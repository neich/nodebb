/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 22);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;//     Backbone.js 1.3.3

//     (c) 2010-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Backbone may be freely distributed under the MIT license.
//     For all details and documentation:
//     http://backbonejs.org

(function (factory) {

  // Establish the root object, `window` (`self`) in the browser, or `global` on the server.
  // We use `self` instead of `window` for `WebWorker` support.
  var root = typeof self == 'object' && self.self === self && self || typeof global == 'object' && global.global === global && global;

  // Set up Backbone appropriately for the environment. Start with AMD.
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1), __webpack_require__(4), exports], __WEBPACK_AMD_DEFINE_RESULT__ = function (_, $, exports) {
      // Export global even in AMD case in case this script is loaded with
      // others that may still expect a global Backbone.
      root.Backbone = factory(root, exports, _, $);
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

    // Next for Node.js or CommonJS. jQuery may not be needed as a module.
  } else if (typeof exports !== 'undefined') {
    var _ = require('underscore'),
        $;
    try {
      $ = require('jquery');
    } catch (e) {}
    factory(root, exports, _, $);

    // Finally, as a browser global.
  } else {
    root.Backbone = factory(root, {}, root._, root.jQuery || root.Zepto || root.ender || root.$);
  }
})(function (root, Backbone, _, $) {

  // Initial Setup
  // -------------

  // Save the previous value of the `Backbone` variable, so that it can be
  // restored later on, if `noConflict` is used.
  var previousBackbone = root.Backbone;

  // Create a local reference to a common array method we'll want to use later.
  var slice = Array.prototype.slice;

  // Current version of the library. Keep in sync with `package.json`.
  Backbone.VERSION = '1.3.3';

  // For Backbone's purposes, jQuery, Zepto, Ender, or My Library (kidding) owns
  // the `$` variable.
  Backbone.$ = $;

  // Runs Backbone.js in *noConflict* mode, returning the `Backbone` variable
  // to its previous owner. Returns a reference to this Backbone object.
  Backbone.noConflict = function () {
    root.Backbone = previousBackbone;
    return this;
  };

  // Turn on `emulateHTTP` to support legacy HTTP servers. Setting this option
  // will fake `"PATCH"`, `"PUT"` and `"DELETE"` requests via the `_method` parameter and
  // set a `X-Http-Method-Override` header.
  Backbone.emulateHTTP = false;

  // Turn on `emulateJSON` to support legacy servers that can't deal with direct
  // `application/json` requests ... this will encode the body as
  // `application/x-www-form-urlencoded` instead and will send the model in a
  // form param named `model`.
  Backbone.emulateJSON = false;

  // Proxy Backbone class methods to Underscore functions, wrapping the model's
  // `attributes` object or collection's `models` array behind the scenes.
  //
  // collection.filter(function(model) { return model.get('age') > 10 });
  // collection.each(this.addView);
  //
  // `Function#apply` can be slow so we use the method's arg count, if we know it.
  var addMethod = function (length, method, attribute) {
    switch (length) {
      case 1:
        return function () {
          return _[method](this[attribute]);
        };
      case 2:
        return function (value) {
          return _[method](this[attribute], value);
        };
      case 3:
        return function (iteratee, context) {
          return _[method](this[attribute], cb(iteratee, this), context);
        };
      case 4:
        return function (iteratee, defaultVal, context) {
          return _[method](this[attribute], cb(iteratee, this), defaultVal, context);
        };
      default:
        return function () {
          var args = slice.call(arguments);
          args.unshift(this[attribute]);
          return _[method].apply(_, args);
        };
    }
  };
  var addUnderscoreMethods = function (Class, methods, attribute) {
    _.each(methods, function (length, method) {
      if (_[method]) Class.prototype[method] = addMethod(length, method, attribute);
    });
  };

  // Support `collection.sortBy('attr')` and `collection.findWhere({id: 1})`.
  var cb = function (iteratee, instance) {
    if (_.isFunction(iteratee)) return iteratee;
    if (_.isObject(iteratee) && !instance._isModel(iteratee)) return modelMatcher(iteratee);
    if (_.isString(iteratee)) return function (model) {
      return model.get(iteratee);
    };
    return iteratee;
  };
  var modelMatcher = function (attrs) {
    var matcher = _.matches(attrs);
    return function (model) {
      return matcher(model.attributes);
    };
  };

  // Backbone.Events
  // ---------------

  // A module that can be mixed in to *any object* in order to provide it with
  // a custom event channel. You may bind a callback to an event with `on` or
  // remove with `off`; `trigger`-ing an event fires all callbacks in
  // succession.
  //
  //     var object = {};
  //     _.extend(object, Backbone.Events);
  //     object.on('expand', function(){ alert('expanded'); });
  //     object.trigger('expand');
  //
  var Events = Backbone.Events = {};

  // Regular expression used to split event strings.
  var eventSplitter = /\s+/;

  // Iterates over the standard `event, callback` (as well as the fancy multiple
  // space-separated events `"change blur", callback` and jQuery-style event
  // maps `{event: callback}`).
  var eventsApi = function (iteratee, events, name, callback, opts) {
    var i = 0,
        names;
    if (name && typeof name === 'object') {
      // Handle event maps.
      if (callback !== void 0 && 'context' in opts && opts.context === void 0) opts.context = callback;
      for (names = _.keys(name); i < names.length; i++) {
        events = eventsApi(iteratee, events, names[i], name[names[i]], opts);
      }
    } else if (name && eventSplitter.test(name)) {
      // Handle space-separated event names by delegating them individually.
      for (names = name.split(eventSplitter); i < names.length; i++) {
        events = iteratee(events, names[i], callback, opts);
      }
    } else {
      // Finally, standard events.
      events = iteratee(events, name, callback, opts);
    }
    return events;
  };

  // Bind an event to a `callback` function. Passing `"all"` will bind
  // the callback to all events fired.
  Events.on = function (name, callback, context) {
    return internalOn(this, name, callback, context);
  };

  // Guard the `listening` argument from the public API.
  var internalOn = function (obj, name, callback, context, listening) {
    obj._events = eventsApi(onApi, obj._events || {}, name, callback, {
      context: context,
      ctx: obj,
      listening: listening
    });

    if (listening) {
      var listeners = obj._listeners || (obj._listeners = {});
      listeners[listening.id] = listening;
    }

    return obj;
  };

  // Inversion-of-control versions of `on`. Tell *this* object to listen to
  // an event in another object... keeping track of what it's listening to
  // for easier unbinding later.
  Events.listenTo = function (obj, name, callback) {
    if (!obj) return this;
    var id = obj._listenId || (obj._listenId = _.uniqueId('l'));
    var listeningTo = this._listeningTo || (this._listeningTo = {});
    var listening = listeningTo[id];

    // This object is not listening to any other events on `obj` yet.
    // Setup the necessary references to track the listening callbacks.
    if (!listening) {
      var thisId = this._listenId || (this._listenId = _.uniqueId('l'));
      listening = listeningTo[id] = { obj: obj, objId: id, id: thisId, listeningTo: listeningTo, count: 0 };
    }

    // Bind callbacks on obj, and keep track of them on listening.
    internalOn(obj, name, callback, this, listening);
    return this;
  };

  // The reducing API that adds a callback to the `events` object.
  var onApi = function (events, name, callback, options) {
    if (callback) {
      var handlers = events[name] || (events[name] = []);
      var context = options.context,
          ctx = options.ctx,
          listening = options.listening;
      if (listening) listening.count++;

      handlers.push({ callback: callback, context: context, ctx: context || ctx, listening: listening });
    }
    return events;
  };

  // Remove one or many callbacks. If `context` is null, removes all
  // callbacks with that function. If `callback` is null, removes all
  // callbacks for the event. If `name` is null, removes all bound
  // callbacks for all events.
  Events.off = function (name, callback, context) {
    if (!this._events) return this;
    this._events = eventsApi(offApi, this._events, name, callback, {
      context: context,
      listeners: this._listeners
    });
    return this;
  };

  // Tell this object to stop listening to either specific events ... or
  // to every object it's currently listening to.
  Events.stopListening = function (obj, name, callback) {
    var listeningTo = this._listeningTo;
    if (!listeningTo) return this;

    var ids = obj ? [obj._listenId] : _.keys(listeningTo);

    for (var i = 0; i < ids.length; i++) {
      var listening = listeningTo[ids[i]];

      // If listening doesn't exist, this object is not currently
      // listening to obj. Break out early.
      if (!listening) break;

      listening.obj.off(name, callback, this);
    }

    return this;
  };

  // The reducing API that removes a callback from the `events` object.
  var offApi = function (events, name, callback, options) {
    if (!events) return;

    var i = 0,
        listening;
    var context = options.context,
        listeners = options.listeners;

    // Delete all events listeners and "drop" events.
    if (!name && !callback && !context) {
      var ids = _.keys(listeners);
      for (; i < ids.length; i++) {
        listening = listeners[ids[i]];
        delete listeners[listening.id];
        delete listening.listeningTo[listening.objId];
      }
      return;
    }

    var names = name ? [name] : _.keys(events);
    for (; i < names.length; i++) {
      name = names[i];
      var handlers = events[name];

      // Bail out if there are no events stored.
      if (!handlers) break;

      // Replace events if there are any remaining.  Otherwise, clean up.
      var remaining = [];
      for (var j = 0; j < handlers.length; j++) {
        var handler = handlers[j];
        if (callback && callback !== handler.callback && callback !== handler.callback._callback || context && context !== handler.context) {
          remaining.push(handler);
        } else {
          listening = handler.listening;
          if (listening && --listening.count === 0) {
            delete listeners[listening.id];
            delete listening.listeningTo[listening.objId];
          }
        }
      }

      // Update tail event if the list has any events.  Otherwise, clean up.
      if (remaining.length) {
        events[name] = remaining;
      } else {
        delete events[name];
      }
    }
    return events;
  };

  // Bind an event to only be triggered a single time. After the first time
  // the callback is invoked, its listener will be removed. If multiple events
  // are passed in using the space-separated syntax, the handler will fire
  // once for each event, not once for a combination of all events.
  Events.once = function (name, callback, context) {
    // Map the event into a `{event: once}` object.
    var events = eventsApi(onceMap, {}, name, callback, _.bind(this.off, this));
    if (typeof name === 'string' && context == null) callback = void 0;
    return this.on(events, callback, context);
  };

  // Inversion-of-control versions of `once`.
  Events.listenToOnce = function (obj, name, callback) {
    // Map the event into a `{event: once}` object.
    var events = eventsApi(onceMap, {}, name, callback, _.bind(this.stopListening, this, obj));
    return this.listenTo(obj, events);
  };

  // Reduces the event callbacks into a map of `{event: onceWrapper}`.
  // `offer` unbinds the `onceWrapper` after it has been called.
  var onceMap = function (map, name, callback, offer) {
    if (callback) {
      var once = map[name] = _.once(function () {
        offer(name, once);
        callback.apply(this, arguments);
      });
      once._callback = callback;
    }
    return map;
  };

  // Trigger one or many events, firing all bound callbacks. Callbacks are
  // passed the same arguments as `trigger` is, apart from the event name
  // (unless you're listening on `"all"`, which will cause your callback to
  // receive the true name of the event as the first argument).
  Events.trigger = function (name) {
    if (!this._events) return this;

    var length = Math.max(0, arguments.length - 1);
    var args = Array(length);
    for (var i = 0; i < length; i++) args[i] = arguments[i + 1];

    eventsApi(triggerApi, this._events, name, void 0, args);
    return this;
  };

  // Handles triggering the appropriate event callbacks.
  var triggerApi = function (objEvents, name, callback, args) {
    if (objEvents) {
      var events = objEvents[name];
      var allEvents = objEvents.all;
      if (events && allEvents) allEvents = allEvents.slice();
      if (events) triggerEvents(events, args);
      if (allEvents) triggerEvents(allEvents, [name].concat(args));
    }
    return objEvents;
  };

  // A difficult-to-believe, but optimized internal dispatch function for
  // triggering events. Tries to keep the usual cases speedy (most internal
  // Backbone events have 3 arguments).
  var triggerEvents = function (events, args) {
    var ev,
        i = -1,
        l = events.length,
        a1 = args[0],
        a2 = args[1],
        a3 = args[2];
    switch (args.length) {
      case 0:
        while (++i < l) (ev = events[i]).callback.call(ev.ctx);return;
      case 1:
        while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1);return;
      case 2:
        while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2);return;
      case 3:
        while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2, a3);return;
      default:
        while (++i < l) (ev = events[i]).callback.apply(ev.ctx, args);return;
    }
  };

  // Aliases for backwards compatibility.
  Events.bind = Events.on;
  Events.unbind = Events.off;

  // Allow the `Backbone` object to serve as a global event bus, for folks who
  // want global "pubsub" in a convenient place.
  _.extend(Backbone, Events);

  // Backbone.Model
  // --------------

  // Backbone **Models** are the basic data object in the framework --
  // frequently representing a row in a table in a database on your server.
  // A discrete chunk of data and a bunch of useful, related methods for
  // performing computations and transformations on that data.

  // Create a new model with the specified attributes. A client id (`cid`)
  // is automatically generated and assigned for you.
  var Model = Backbone.Model = function (attributes, options) {
    var attrs = attributes || {};
    options || (options = {});
    this.cid = _.uniqueId(this.cidPrefix);
    this.attributes = {};
    if (options.collection) this.collection = options.collection;
    if (options.parse) attrs = this.parse(attrs, options) || {};
    var defaults = _.result(this, 'defaults');
    attrs = _.defaults(_.extend({}, defaults, attrs), defaults);
    this.set(attrs, options);
    this.changed = {};
    this.initialize.apply(this, arguments);
  };

  // Attach all inheritable methods to the Model prototype.
  _.extend(Model.prototype, Events, {

    // A hash of attributes whose current and previous value differ.
    changed: null,

    // The value returned during the last failed validation.
    validationError: null,

    // The default name for the JSON `id` attribute is `"id"`. MongoDB and
    // CouchDB users may want to set this to `"_id"`.
    idAttribute: 'id',

    // The prefix is used to create the client id which is used to identify models locally.
    // You may want to override this if you're experiencing name clashes with model ids.
    cidPrefix: 'c',

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function () {},

    // Return a copy of the model's `attributes` object.
    toJSON: function (options) {
      return _.clone(this.attributes);
    },

    // Proxy `Backbone.sync` by default -- but override this if you need
    // custom syncing semantics for *this* particular model.
    sync: function () {
      return Backbone.sync.apply(this, arguments);
    },

    // Get the value of an attribute.
    get: function (attr) {
      return this.attributes[attr];
    },

    // Get the HTML-escaped value of an attribute.
    escape: function (attr) {
      return _.escape(this.get(attr));
    },

    // Returns `true` if the attribute contains a value that is not null
    // or undefined.
    has: function (attr) {
      return this.get(attr) != null;
    },

    // Special-cased proxy to underscore's `_.matches` method.
    matches: function (attrs) {
      return !!_.iteratee(attrs, this)(this.attributes);
    },

    // Set a hash of model attributes on the object, firing `"change"`. This is
    // the core primitive operation of a model, updating the data and notifying
    // anyone who needs to know about the change in state. The heart of the beast.
    set: function (key, val, options) {
      if (key == null) return this;

      // Handle both `"key", value` and `{key: value}` -style arguments.
      var attrs;
      if (typeof key === 'object') {
        attrs = key;
        options = val;
      } else {
        (attrs = {})[key] = val;
      }

      options || (options = {});

      // Run validation.
      if (!this._validate(attrs, options)) return false;

      // Extract attributes and options.
      var unset = options.unset;
      var silent = options.silent;
      var changes = [];
      var changing = this._changing;
      this._changing = true;

      if (!changing) {
        this._previousAttributes = _.clone(this.attributes);
        this.changed = {};
      }

      var current = this.attributes;
      var changed = this.changed;
      var prev = this._previousAttributes;

      // For each `set` attribute, update or delete the current value.
      for (var attr in attrs) {
        val = attrs[attr];
        if (!_.isEqual(current[attr], val)) changes.push(attr);
        if (!_.isEqual(prev[attr], val)) {
          changed[attr] = val;
        } else {
          delete changed[attr];
        }
        unset ? delete current[attr] : current[attr] = val;
      }

      // Update the `id`.
      if (this.idAttribute in attrs) this.id = this.get(this.idAttribute);

      // Trigger all relevant attribute changes.
      if (!silent) {
        if (changes.length) this._pending = options;
        for (var i = 0; i < changes.length; i++) {
          this.trigger('change:' + changes[i], this, current[changes[i]], options);
        }
      }

      // You might be wondering why there's a `while` loop here. Changes can
      // be recursively nested within `"change"` events.
      if (changing) return this;
      if (!silent) {
        while (this._pending) {
          options = this._pending;
          this._pending = false;
          this.trigger('change', this, options);
        }
      }
      this._pending = false;
      this._changing = false;
      return this;
    },

    // Remove an attribute from the model, firing `"change"`. `unset` is a noop
    // if the attribute doesn't exist.
    unset: function (attr, options) {
      return this.set(attr, void 0, _.extend({}, options, { unset: true }));
    },

    // Clear all attributes on the model, firing `"change"`.
    clear: function (options) {
      var attrs = {};
      for (var key in this.attributes) attrs[key] = void 0;
      return this.set(attrs, _.extend({}, options, { unset: true }));
    },

    // Determine if the model has changed since the last `"change"` event.
    // If you specify an attribute name, determine if that attribute has changed.
    hasChanged: function (attr) {
      if (attr == null) return !_.isEmpty(this.changed);
      return _.has(this.changed, attr);
    },

    // Return an object containing all the attributes that have changed, or
    // false if there are no changed attributes. Useful for determining what
    // parts of a view need to be updated and/or what attributes need to be
    // persisted to the server. Unset attributes will be set to undefined.
    // You can also pass an attributes object to diff against the model,
    // determining if there *would be* a change.
    changedAttributes: function (diff) {
      if (!diff) return this.hasChanged() ? _.clone(this.changed) : false;
      var old = this._changing ? this._previousAttributes : this.attributes;
      var changed = {};
      for (var attr in diff) {
        var val = diff[attr];
        if (_.isEqual(old[attr], val)) continue;
        changed[attr] = val;
      }
      return _.size(changed) ? changed : false;
    },

    // Get the previous value of an attribute, recorded at the time the last
    // `"change"` event was fired.
    previous: function (attr) {
      if (attr == null || !this._previousAttributes) return null;
      return this._previousAttributes[attr];
    },

    // Get all of the attributes of the model at the time of the previous
    // `"change"` event.
    previousAttributes: function () {
      return _.clone(this._previousAttributes);
    },

    // Fetch the model from the server, merging the response with the model's
    // local attributes. Any changed attributes will trigger a "change" event.
    fetch: function (options) {
      options = _.extend({ parse: true }, options);
      var model = this;
      var success = options.success;
      options.success = function (resp) {
        var serverAttrs = options.parse ? model.parse(resp, options) : resp;
        if (!model.set(serverAttrs, options)) return false;
        if (success) success.call(options.context, model, resp, options);
        model.trigger('sync', model, resp, options);
      };
      wrapError(this, options);
      return this.sync('read', this, options);
    },

    // Set a hash of model attributes, and sync the model to the server.
    // If the server returns an attributes hash that differs, the model's
    // state will be `set` again.
    save: function (key, val, options) {
      // Handle both `"key", value` and `{key: value}` -style arguments.
      var attrs;
      if (key == null || typeof key === 'object') {
        attrs = key;
        options = val;
      } else {
        (attrs = {})[key] = val;
      }

      options = _.extend({ validate: true, parse: true }, options);
      var wait = options.wait;

      // If we're not waiting and attributes exist, save acts as
      // `set(attr).save(null, opts)` with validation. Otherwise, check if
      // the model will be valid when the attributes, if any, are set.
      if (attrs && !wait) {
        if (!this.set(attrs, options)) return false;
      } else if (!this._validate(attrs, options)) {
        return false;
      }

      // After a successful server-side save, the client is (optionally)
      // updated with the server-side state.
      var model = this;
      var success = options.success;
      var attributes = this.attributes;
      options.success = function (resp) {
        // Ensure attributes are restored during synchronous saves.
        model.attributes = attributes;
        var serverAttrs = options.parse ? model.parse(resp, options) : resp;
        if (wait) serverAttrs = _.extend({}, attrs, serverAttrs);
        if (serverAttrs && !model.set(serverAttrs, options)) return false;
        if (success) success.call(options.context, model, resp, options);
        model.trigger('sync', model, resp, options);
      };
      wrapError(this, options);

      // Set temporary attributes if `{wait: true}` to properly find new ids.
      if (attrs && wait) this.attributes = _.extend({}, attributes, attrs);

      var method = this.isNew() ? 'create' : options.patch ? 'patch' : 'update';
      if (method === 'patch' && !options.attrs) options.attrs = attrs;
      var xhr = this.sync(method, this, options);

      // Restore attributes.
      this.attributes = attributes;

      return xhr;
    },

    // Destroy this model on the server if it was already persisted.
    // Optimistically removes the model from its collection, if it has one.
    // If `wait: true` is passed, waits for the server to respond before removal.
    destroy: function (options) {
      options = options ? _.clone(options) : {};
      var model = this;
      var success = options.success;
      var wait = options.wait;

      var destroy = function () {
        model.stopListening();
        model.trigger('destroy', model, model.collection, options);
      };

      options.success = function (resp) {
        if (wait) destroy();
        if (success) success.call(options.context, model, resp, options);
        if (!model.isNew()) model.trigger('sync', model, resp, options);
      };

      var xhr = false;
      if (this.isNew()) {
        _.defer(options.success);
      } else {
        wrapError(this, options);
        xhr = this.sync('delete', this, options);
      }
      if (!wait) destroy();
      return xhr;
    },

    // Default URL for the model's representation on the server -- if you're
    // using Backbone's restful methods, override this to change the endpoint
    // that will be called.
    url: function () {
      var base = _.result(this, 'urlRoot') || _.result(this.collection, 'url') || urlError();
      if (this.isNew()) return base;
      var id = this.get(this.idAttribute);
      return base.replace(/[^\/]$/, '$&/') + encodeURIComponent(id);
    },

    // **parse** converts a response into the hash of attributes to be `set` on
    // the model. The default implementation is just to pass the response along.
    parse: function (resp, options) {
      return resp;
    },

    // Create a new model with identical attributes to this one.
    clone: function () {
      return new this.constructor(this.attributes);
    },

    // A model is new if it has never been saved to the server, and lacks an id.
    isNew: function () {
      return !this.has(this.idAttribute);
    },

    // Check if the model is currently in a valid state.
    isValid: function (options) {
      return this._validate({}, _.extend({}, options, { validate: true }));
    },

    // Run validation against the next complete set of model attributes,
    // returning `true` if all is well. Otherwise, fire an `"invalid"` event.
    _validate: function (attrs, options) {
      if (!options.validate || !this.validate) return true;
      attrs = _.extend({}, this.attributes, attrs);
      var error = this.validationError = this.validate(attrs, options) || null;
      if (!error) return true;
      this.trigger('invalid', this, error, _.extend(options, { validationError: error }));
      return false;
    }

  });

  // Underscore methods that we want to implement on the Model, mapped to the
  // number of arguments they take.
  var modelMethods = { keys: 1, values: 1, pairs: 1, invert: 1, pick: 0,
    omit: 0, chain: 1, isEmpty: 1 };

  // Mix in each Underscore method as a proxy to `Model#attributes`.
  addUnderscoreMethods(Model, modelMethods, 'attributes');

  // Backbone.Collection
  // -------------------

  // If models tend to represent a single row of data, a Backbone Collection is
  // more analogous to a table full of data ... or a small slice or page of that
  // table, or a collection of rows that belong together for a particular reason
  // -- all of the messages in this particular folder, all of the documents
  // belonging to this particular author, and so on. Collections maintain
  // indexes of their models, both in order, and for lookup by `id`.

  // Create a new **Collection**, perhaps to contain a specific type of `model`.
  // If a `comparator` is specified, the Collection will maintain
  // its models in sort order, as they're added and removed.
  var Collection = Backbone.Collection = function (models, options) {
    options || (options = {});
    if (options.model) this.model = options.model;
    if (options.comparator !== void 0) this.comparator = options.comparator;
    this._reset();
    this.initialize.apply(this, arguments);
    if (models) this.reset(models, _.extend({ silent: true }, options));
  };

  // Default options for `Collection#set`.
  var setOptions = { add: true, remove: true, merge: true };
  var addOptions = { add: true, remove: false };

  // Splices `insert` into `array` at index `at`.
  var splice = function (array, insert, at) {
    at = Math.min(Math.max(at, 0), array.length);
    var tail = Array(array.length - at);
    var length = insert.length;
    var i;
    for (i = 0; i < tail.length; i++) tail[i] = array[i + at];
    for (i = 0; i < length; i++) array[i + at] = insert[i];
    for (i = 0; i < tail.length; i++) array[i + length + at] = tail[i];
  };

  // Define the Collection's inheritable methods.
  _.extend(Collection.prototype, Events, {

    // The default model for a collection is just a **Backbone.Model**.
    // This should be overridden in most cases.
    model: Model,

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function () {},

    // The JSON representation of a Collection is an array of the
    // models' attributes.
    toJSON: function (options) {
      return this.map(function (model) {
        return model.toJSON(options);
      });
    },

    // Proxy `Backbone.sync` by default.
    sync: function () {
      return Backbone.sync.apply(this, arguments);
    },

    // Add a model, or list of models to the set. `models` may be Backbone
    // Models or raw JavaScript objects to be converted to Models, or any
    // combination of the two.
    add: function (models, options) {
      return this.set(models, _.extend({ merge: false }, options, addOptions));
    },

    // Remove a model, or a list of models from the set.
    remove: function (models, options) {
      options = _.extend({}, options);
      var singular = !_.isArray(models);
      models = singular ? [models] : models.slice();
      var removed = this._removeModels(models, options);
      if (!options.silent && removed.length) {
        options.changes = { added: [], merged: [], removed: removed };
        this.trigger('update', this, options);
      }
      return singular ? removed[0] : removed;
    },

    // Update a collection by `set`-ing a new list of models, adding new ones,
    // removing models that are no longer present, and merging models that
    // already exist in the collection, as necessary. Similar to **Model#set**,
    // the core operation for updating the data contained by the collection.
    set: function (models, options) {
      if (models == null) return;

      options = _.extend({}, setOptions, options);
      if (options.parse && !this._isModel(models)) {
        models = this.parse(models, options) || [];
      }

      var singular = !_.isArray(models);
      models = singular ? [models] : models.slice();

      var at = options.at;
      if (at != null) at = +at;
      if (at > this.length) at = this.length;
      if (at < 0) at += this.length + 1;

      var set = [];
      var toAdd = [];
      var toMerge = [];
      var toRemove = [];
      var modelMap = {};

      var add = options.add;
      var merge = options.merge;
      var remove = options.remove;

      var sort = false;
      var sortable = this.comparator && at == null && options.sort !== false;
      var sortAttr = _.isString(this.comparator) ? this.comparator : null;

      // Turn bare objects into model references, and prevent invalid models
      // from being added.
      var model, i;
      for (i = 0; i < models.length; i++) {
        model = models[i];

        // If a duplicate is found, prevent it from being added and
        // optionally merge it into the existing model.
        var existing = this.get(model);
        if (existing) {
          if (merge && model !== existing) {
            var attrs = this._isModel(model) ? model.attributes : model;
            if (options.parse) attrs = existing.parse(attrs, options);
            existing.set(attrs, options);
            toMerge.push(existing);
            if (sortable && !sort) sort = existing.hasChanged(sortAttr);
          }
          if (!modelMap[existing.cid]) {
            modelMap[existing.cid] = true;
            set.push(existing);
          }
          models[i] = existing;

          // If this is a new, valid model, push it to the `toAdd` list.
        } else if (add) {
          model = models[i] = this._prepareModel(model, options);
          if (model) {
            toAdd.push(model);
            this._addReference(model, options);
            modelMap[model.cid] = true;
            set.push(model);
          }
        }
      }

      // Remove stale models.
      if (remove) {
        for (i = 0; i < this.length; i++) {
          model = this.models[i];
          if (!modelMap[model.cid]) toRemove.push(model);
        }
        if (toRemove.length) this._removeModels(toRemove, options);
      }

      // See if sorting is needed, update `length` and splice in new models.
      var orderChanged = false;
      var replace = !sortable && add && remove;
      if (set.length && replace) {
        orderChanged = this.length !== set.length || _.some(this.models, function (m, index) {
          return m !== set[index];
        });
        this.models.length = 0;
        splice(this.models, set, 0);
        this.length = this.models.length;
      } else if (toAdd.length) {
        if (sortable) sort = true;
        splice(this.models, toAdd, at == null ? this.length : at);
        this.length = this.models.length;
      }

      // Silently sort the collection if appropriate.
      if (sort) this.sort({ silent: true });

      // Unless silenced, it's time to fire all appropriate add/sort/update events.
      if (!options.silent) {
        for (i = 0; i < toAdd.length; i++) {
          if (at != null) options.index = at + i;
          model = toAdd[i];
          model.trigger('add', model, this, options);
        }
        if (sort || orderChanged) this.trigger('sort', this, options);
        if (toAdd.length || toRemove.length || toMerge.length) {
          options.changes = {
            added: toAdd,
            removed: toRemove,
            merged: toMerge
          };
          this.trigger('update', this, options);
        }
      }

      // Return the added (or merged) model (or models).
      return singular ? models[0] : models;
    },

    // When you have more items than you want to add or remove individually,
    // you can reset the entire set with a new list of models, without firing
    // any granular `add` or `remove` events. Fires `reset` when finished.
    // Useful for bulk operations and optimizations.
    reset: function (models, options) {
      options = options ? _.clone(options) : {};
      for (var i = 0; i < this.models.length; i++) {
        this._removeReference(this.models[i], options);
      }
      options.previousModels = this.models;
      this._reset();
      models = this.add(models, _.extend({ silent: true }, options));
      if (!options.silent) this.trigger('reset', this, options);
      return models;
    },

    // Add a model to the end of the collection.
    push: function (model, options) {
      return this.add(model, _.extend({ at: this.length }, options));
    },

    // Remove a model from the end of the collection.
    pop: function (options) {
      var model = this.at(this.length - 1);
      return this.remove(model, options);
    },

    // Add a model to the beginning of the collection.
    unshift: function (model, options) {
      return this.add(model, _.extend({ at: 0 }, options));
    },

    // Remove a model from the beginning of the collection.
    shift: function (options) {
      var model = this.at(0);
      return this.remove(model, options);
    },

    // Slice out a sub-array of models from the collection.
    slice: function () {
      return slice.apply(this.models, arguments);
    },

    // Get a model from the set by id, cid, model object with id or cid
    // properties, or an attributes object that is transformed through modelId.
    get: function (obj) {
      if (obj == null) return void 0;
      return this._byId[obj] || this._byId[this.modelId(obj.attributes || obj)] || obj.cid && this._byId[obj.cid];
    },

    // Returns `true` if the model is in the collection.
    has: function (obj) {
      return this.get(obj) != null;
    },

    // Get the model at the given index.
    at: function (index) {
      if (index < 0) index += this.length;
      return this.models[index];
    },

    // Return models with matching attributes. Useful for simple cases of
    // `filter`.
    where: function (attrs, first) {
      return this[first ? 'find' : 'filter'](attrs);
    },

    // Return the first model with matching attributes. Useful for simple cases
    // of `find`.
    findWhere: function (attrs) {
      return this.where(attrs, true);
    },

    // Force the collection to re-sort itself. You don't need to call this under
    // normal circumstances, as the set will maintain sort order as each item
    // is added.
    sort: function (options) {
      var comparator = this.comparator;
      if (!comparator) throw new Error('Cannot sort a set without a comparator');
      options || (options = {});

      var length = comparator.length;
      if (_.isFunction(comparator)) comparator = _.bind(comparator, this);

      // Run sort based on type of `comparator`.
      if (length === 1 || _.isString(comparator)) {
        this.models = this.sortBy(comparator);
      } else {
        this.models.sort(comparator);
      }
      if (!options.silent) this.trigger('sort', this, options);
      return this;
    },

    // Pluck an attribute from each model in the collection.
    pluck: function (attr) {
      return this.map(attr + '');
    },

    // Fetch the default set of models for this collection, resetting the
    // collection when they arrive. If `reset: true` is passed, the response
    // data will be passed through the `reset` method instead of `set`.
    fetch: function (options) {
      options = _.extend({ parse: true }, options);
      var success = options.success;
      var collection = this;
      options.success = function (resp) {
        var method = options.reset ? 'reset' : 'set';
        collection[method](resp, options);
        if (success) success.call(options.context, collection, resp, options);
        collection.trigger('sync', collection, resp, options);
      };
      wrapError(this, options);
      return this.sync('read', this, options);
    },

    // Create a new instance of a model in this collection. Add the model to the
    // collection immediately, unless `wait: true` is passed, in which case we
    // wait for the server to agree.
    create: function (model, options) {
      options = options ? _.clone(options) : {};
      var wait = options.wait;
      model = this._prepareModel(model, options);
      if (!model) return false;
      if (!wait) this.add(model, options);
      var collection = this;
      var success = options.success;
      options.success = function (m, resp, callbackOpts) {
        if (wait) collection.add(m, callbackOpts);
        if (success) success.call(callbackOpts.context, m, resp, callbackOpts);
      };
      model.save(null, options);
      return model;
    },

    // **parse** converts a response into a list of models to be added to the
    // collection. The default implementation is just to pass it through.
    parse: function (resp, options) {
      return resp;
    },

    // Create a new collection with an identical list of models as this one.
    clone: function () {
      return new this.constructor(this.models, {
        model: this.model,
        comparator: this.comparator
      });
    },

    // Define how to uniquely identify models in the collection.
    modelId: function (attrs) {
      return attrs[this.model.prototype.idAttribute || 'id'];
    },

    // Private method to reset all internal state. Called when the collection
    // is first initialized or reset.
    _reset: function () {
      this.length = 0;
      this.models = [];
      this._byId = {};
    },

    // Prepare a hash of attributes (or other model) to be added to this
    // collection.
    _prepareModel: function (attrs, options) {
      if (this._isModel(attrs)) {
        if (!attrs.collection) attrs.collection = this;
        return attrs;
      }
      options = options ? _.clone(options) : {};
      options.collection = this;
      var model = new this.model(attrs, options);
      if (!model.validationError) return model;
      this.trigger('invalid', this, model.validationError, options);
      return false;
    },

    // Internal method called by both remove and set.
    _removeModels: function (models, options) {
      var removed = [];
      for (var i = 0; i < models.length; i++) {
        var model = this.get(models[i]);
        if (!model) continue;

        var index = this.indexOf(model);
        this.models.splice(index, 1);
        this.length--;

        // Remove references before triggering 'remove' event to prevent an
        // infinite loop. #3693
        delete this._byId[model.cid];
        var id = this.modelId(model.attributes);
        if (id != null) delete this._byId[id];

        if (!options.silent) {
          options.index = index;
          model.trigger('remove', model, this, options);
        }

        removed.push(model);
        this._removeReference(model, options);
      }
      return removed;
    },

    // Method for checking whether an object should be considered a model for
    // the purposes of adding to the collection.
    _isModel: function (model) {
      return model instanceof Model;
    },

    // Internal method to create a model's ties to a collection.
    _addReference: function (model, options) {
      this._byId[model.cid] = model;
      var id = this.modelId(model.attributes);
      if (id != null) this._byId[id] = model;
      model.on('all', this._onModelEvent, this);
    },

    // Internal method to sever a model's ties to a collection.
    _removeReference: function (model, options) {
      delete this._byId[model.cid];
      var id = this.modelId(model.attributes);
      if (id != null) delete this._byId[id];
      if (this === model.collection) delete model.collection;
      model.off('all', this._onModelEvent, this);
    },

    // Internal method called every time a model in the set fires an event.
    // Sets need to update their indexes when models change ids. All other
    // events simply proxy through. "add" and "remove" events that originate
    // in other collections are ignored.
    _onModelEvent: function (event, model, collection, options) {
      if (model) {
        if ((event === 'add' || event === 'remove') && collection !== this) return;
        if (event === 'destroy') this.remove(model, options);
        if (event === 'change') {
          var prevId = this.modelId(model.previousAttributes());
          var id = this.modelId(model.attributes);
          if (prevId !== id) {
            if (prevId != null) delete this._byId[prevId];
            if (id != null) this._byId[id] = model;
          }
        }
      }
      this.trigger.apply(this, arguments);
    }

  });

  // Underscore methods that we want to implement on the Collection.
  // 90% of the core usefulness of Backbone Collections is actually implemented
  // right here:
  var collectionMethods = { forEach: 3, each: 3, map: 3, collect: 3, reduce: 0,
    foldl: 0, inject: 0, reduceRight: 0, foldr: 0, find: 3, detect: 3, filter: 3,
    select: 3, reject: 3, every: 3, all: 3, some: 3, any: 3, include: 3, includes: 3,
    contains: 3, invoke: 0, max: 3, min: 3, toArray: 1, size: 1, first: 3,
    head: 3, take: 3, initial: 3, rest: 3, tail: 3, drop: 3, last: 3,
    without: 0, difference: 0, indexOf: 3, shuffle: 1, lastIndexOf: 3,
    isEmpty: 1, chain: 1, sample: 3, partition: 3, groupBy: 3, countBy: 3,
    sortBy: 3, indexBy: 3, findIndex: 3, findLastIndex: 3 };

  // Mix in each Underscore method as a proxy to `Collection#models`.
  addUnderscoreMethods(Collection, collectionMethods, 'models');

  // Backbone.View
  // -------------

  // Backbone Views are almost more convention than they are actual code. A View
  // is simply a JavaScript object that represents a logical chunk of UI in the
  // DOM. This might be a single item, an entire list, a sidebar or panel, or
  // even the surrounding frame which wraps your whole app. Defining a chunk of
  // UI as a **View** allows you to define your DOM events declaratively, without
  // having to worry about render order ... and makes it easy for the view to
  // react to specific changes in the state of your models.

  // Creating a Backbone.View creates its initial element outside of the DOM,
  // if an existing element is not provided...
  var View = Backbone.View = function (options) {
    this.cid = _.uniqueId('view');
    _.extend(this, _.pick(options, viewOptions));
    this._ensureElement();
    this.initialize.apply(this, arguments);
  };

  // Cached regex to split keys for `delegate`.
  var delegateEventSplitter = /^(\S+)\s*(.*)$/;

  // List of view options to be set as properties.
  var viewOptions = ['model', 'collection', 'el', 'id', 'attributes', 'className', 'tagName', 'events'];

  // Set up all inheritable **Backbone.View** properties and methods.
  _.extend(View.prototype, Events, {

    // The default `tagName` of a View's element is `"div"`.
    tagName: 'div',

    // jQuery delegate for element lookup, scoped to DOM elements within the
    // current view. This should be preferred to global lookups where possible.
    $: function (selector) {
      return this.$el.find(selector);
    },

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function () {},

    // **render** is the core function that your view should override, in order
    // to populate its element (`this.el`), with the appropriate HTML. The
    // convention is for **render** to always return `this`.
    render: function () {
      return this;
    },

    // Remove this view by taking the element out of the DOM, and removing any
    // applicable Backbone.Events listeners.
    remove: function () {
      this._removeElement();
      this.stopListening();
      return this;
    },

    // Remove this view's element from the document and all event listeners
    // attached to it. Exposed for subclasses using an alternative DOM
    // manipulation API.
    _removeElement: function () {
      this.$el.remove();
    },

    // Change the view's element (`this.el` property) and re-delegate the
    // view's events on the new element.
    setElement: function (element) {
      this.undelegateEvents();
      this._setElement(element);
      this.delegateEvents();
      return this;
    },

    // Creates the `this.el` and `this.$el` references for this view using the
    // given `el`. `el` can be a CSS selector or an HTML string, a jQuery
    // context or an element. Subclasses can override this to utilize an
    // alternative DOM manipulation API and are only required to set the
    // `this.el` property.
    _setElement: function (el) {
      this.$el = el instanceof Backbone.$ ? el : Backbone.$(el);
      this.el = this.$el[0];
    },

    // Set callbacks, where `this.events` is a hash of
    //
    // *{"event selector": "callback"}*
    //
    //     {
    //       'mousedown .title':  'edit',
    //       'click .button':     'save',
    //       'click .open':       function(e) { ... }
    //     }
    //
    // pairs. Callbacks will be bound to the view, with `this` set properly.
    // Uses event delegation for efficiency.
    // Omitting the selector binds the event to `this.el`.
    delegateEvents: function (events) {
      events || (events = _.result(this, 'events'));
      if (!events) return this;
      this.undelegateEvents();
      for (var key in events) {
        var method = events[key];
        if (!_.isFunction(method)) method = this[method];
        if (!method) continue;
        var match = key.match(delegateEventSplitter);
        this.delegate(match[1], match[2], _.bind(method, this));
      }
      return this;
    },

    // Add a single event listener to the view's element (or a child element
    // using `selector`). This only works for delegate-able events: not `focus`,
    // `blur`, and not `change`, `submit`, and `reset` in Internet Explorer.
    delegate: function (eventName, selector, listener) {
      this.$el.on(eventName + '.delegateEvents' + this.cid, selector, listener);
      return this;
    },

    // Clears all callbacks previously bound to the view by `delegateEvents`.
    // You usually don't need to use this, but may wish to if you have multiple
    // Backbone views attached to the same DOM element.
    undelegateEvents: function () {
      if (this.$el) this.$el.off('.delegateEvents' + this.cid);
      return this;
    },

    // A finer-grained `undelegateEvents` for removing a single delegated event.
    // `selector` and `listener` are both optional.
    undelegate: function (eventName, selector, listener) {
      this.$el.off(eventName + '.delegateEvents' + this.cid, selector, listener);
      return this;
    },

    // Produces a DOM element to be assigned to your view. Exposed for
    // subclasses using an alternative DOM manipulation API.
    _createElement: function (tagName) {
      return document.createElement(tagName);
    },

    // Ensure that the View has a DOM element to render into.
    // If `this.el` is a string, pass it through `$()`, take the first
    // matching element, and re-assign it to `el`. Otherwise, create
    // an element from the `id`, `className` and `tagName` properties.
    _ensureElement: function () {
      if (!this.el) {
        var attrs = _.extend({}, _.result(this, 'attributes'));
        if (this.id) attrs.id = _.result(this, 'id');
        if (this.className) attrs['class'] = _.result(this, 'className');
        this.setElement(this._createElement(_.result(this, 'tagName')));
        this._setAttributes(attrs);
      } else {
        this.setElement(_.result(this, 'el'));
      }
    },

    // Set attributes from a hash on this view's element.  Exposed for
    // subclasses using an alternative DOM manipulation API.
    _setAttributes: function (attributes) {
      this.$el.attr(attributes);
    }

  });

  // Backbone.sync
  // -------------

  // Override this function to change the manner in which Backbone persists
  // models to the server. You will be passed the type of request, and the
  // model in question. By default, makes a RESTful Ajax request
  // to the model's `url()`. Some possible customizations could be:
  //
  // * Use `setTimeout` to batch rapid-fire updates into a single request.
  // * Send up the models as XML instead of JSON.
  // * Persist models via WebSockets instead of Ajax.
  //
  // Turn on `Backbone.emulateHTTP` in order to send `PUT` and `DELETE` requests
  // as `POST`, with a `_method` parameter containing the true HTTP method,
  // as well as all requests with the body as `application/x-www-form-urlencoded`
  // instead of `application/json` with the model in a param named `model`.
  // Useful when interfacing with server-side languages like **PHP** that make
  // it difficult to read the body of `PUT` requests.
  Backbone.sync = function (method, model, options) {
    var type = methodMap[method];

    // Default options, unless specified.
    _.defaults(options || (options = {}), {
      emulateHTTP: Backbone.emulateHTTP,
      emulateJSON: Backbone.emulateJSON
    });

    // Default JSON-request options.
    var params = { type: type, dataType: 'json' };

    // Ensure that we have a URL.
    if (!options.url) {
      params.url = _.result(model, 'url') || urlError();
    }

    // Ensure that we have the appropriate request data.
    if (options.data == null && model && (method === 'create' || method === 'update' || method === 'patch')) {
      params.contentType = 'application/json';
      params.data = JSON.stringify(options.attrs || model.toJSON(options));
    }

    // For older servers, emulate JSON by encoding the request into an HTML-form.
    if (options.emulateJSON) {
      params.contentType = 'application/x-www-form-urlencoded';
      params.data = params.data ? { model: params.data } : {};
    }

    // For older servers, emulate HTTP by mimicking the HTTP method with `_method`
    // And an `X-HTTP-Method-Override` header.
    if (options.emulateHTTP && (type === 'PUT' || type === 'DELETE' || type === 'PATCH')) {
      params.type = 'POST';
      if (options.emulateJSON) params.data._method = type;
      var beforeSend = options.beforeSend;
      options.beforeSend = function (xhr) {
        xhr.setRequestHeader('X-HTTP-Method-Override', type);
        if (beforeSend) return beforeSend.apply(this, arguments);
      };
    }

    // Don't process data on a non-GET request.
    if (params.type !== 'GET' && !options.emulateJSON) {
      params.processData = false;
    }

    // Pass along `textStatus` and `errorThrown` from jQuery.
    var error = options.error;
    options.error = function (xhr, textStatus, errorThrown) {
      options.textStatus = textStatus;
      options.errorThrown = errorThrown;
      if (error) error.call(options.context, xhr, textStatus, errorThrown);
    };

    // Make the request, allowing the user to override any Ajax options.
    var xhr = options.xhr = Backbone.ajax(_.extend(params, options));
    model.trigger('request', model, xhr, options);
    return xhr;
  };

  // Map from CRUD to HTTP for our default `Backbone.sync` implementation.
  var methodMap = {
    'create': 'POST',
    'update': 'PUT',
    'patch': 'PATCH',
    'delete': 'DELETE',
    'read': 'GET'
  };

  // Set the default implementation of `Backbone.ajax` to proxy through to `$`.
  // Override this if you'd like to use a different library.
  Backbone.ajax = function () {
    return Backbone.$.ajax.apply(Backbone.$, arguments);
  };

  // Backbone.Router
  // ---------------

  // Routers map faux-URLs to actions, and fire events when routes are
  // matched. Creating a new one sets its `routes` hash, if not set statically.
  var Router = Backbone.Router = function (options) {
    options || (options = {});
    if (options.routes) this.routes = options.routes;
    this._bindRoutes();
    this.initialize.apply(this, arguments);
  };

  // Cached regular expressions for matching named param parts and splatted
  // parts of route strings.
  var optionalParam = /\((.*?)\)/g;
  var namedParam = /(\(\?)?:\w+/g;
  var splatParam = /\*\w+/g;
  var escapeRegExp = /[\-{}\[\]+?.,\\\^$|#\s]/g;

  // Set up all inheritable **Backbone.Router** properties and methods.
  _.extend(Router.prototype, Events, {

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function () {},

    // Manually bind a single named route to a callback. For example:
    //
    //     this.route('search/:query/p:num', 'search', function(query, num) {
    //       ...
    //     });
    //
    route: function (route, name, callback) {
      if (!_.isRegExp(route)) route = this._routeToRegExp(route);
      if (_.isFunction(name)) {
        callback = name;
        name = '';
      }
      if (!callback) callback = this[name];
      var router = this;
      Backbone.history.route(route, function (fragment) {
        var args = router._extractParameters(route, fragment);
        if (router.execute(callback, args, name) !== false) {
          router.trigger.apply(router, ['route:' + name].concat(args));
          router.trigger('route', name, args);
          Backbone.history.trigger('route', router, name, args);
        }
      });
      return this;
    },

    // Execute a route handler with the provided parameters.  This is an
    // excellent place to do pre-route setup or post-route cleanup.
    execute: function (callback, args, name) {
      if (callback) callback.apply(this, args);
    },

    // Simple proxy to `Backbone.history` to save a fragment into the history.
    navigate: function (fragment, options) {
      Backbone.history.navigate(fragment, options);
      return this;
    },

    // Bind all defined routes to `Backbone.history`. We have to reverse the
    // order of the routes here to support behavior where the most general
    // routes can be defined at the bottom of the route map.
    _bindRoutes: function () {
      if (!this.routes) return;
      this.routes = _.result(this, 'routes');
      var route,
          routes = _.keys(this.routes);
      while ((route = routes.pop()) != null) {
        this.route(route, this.routes[route]);
      }
    },

    // Convert a route string into a regular expression, suitable for matching
    // against the current location hash.
    _routeToRegExp: function (route) {
      route = route.replace(escapeRegExp, '\\$&').replace(optionalParam, '(?:$1)?').replace(namedParam, function (match, optional) {
        return optional ? match : '([^/?]+)';
      }).replace(splatParam, '([^?]*?)');
      return new RegExp('^' + route + '(?:\\?([\\s\\S]*))?$');
    },

    // Given a route, and a URL fragment that it matches, return the array of
    // extracted decoded parameters. Empty or unmatched parameters will be
    // treated as `null` to normalize cross-browser behavior.
    _extractParameters: function (route, fragment) {
      var params = route.exec(fragment).slice(1);
      return _.map(params, function (param, i) {
        // Don't decode the search params.
        if (i === params.length - 1) return param || null;
        return param ? decodeURIComponent(param) : null;
      });
    }

  });

  // Backbone.History
  // ----------------

  // Handles cross-browser history management, based on either
  // [pushState](http://diveintohtml5.info/history.html) and real URLs, or
  // [onhashchange](https://developer.mozilla.org/en-US/docs/DOM/window.onhashchange)
  // and URL fragments. If the browser supports neither (old IE, natch),
  // falls back to polling.
  var History = Backbone.History = function () {
    this.handlers = [];
    this.checkUrl = _.bind(this.checkUrl, this);

    // Ensure that `History` can be used outside of the browser.
    if (typeof window !== 'undefined') {
      this.location = window.location;
      this.history = window.history;
    }
  };

  // Cached regex for stripping a leading hash/slash and trailing space.
  var routeStripper = /^[#\/]|\s+$/g;

  // Cached regex for stripping leading and trailing slashes.
  var rootStripper = /^\/+|\/+$/g;

  // Cached regex for stripping urls of hash.
  var pathStripper = /#.*$/;

  // Has the history handling already been started?
  History.started = false;

  // Set up all inheritable **Backbone.History** properties and methods.
  _.extend(History.prototype, Events, {

    // The default interval to poll for hash changes, if necessary, is
    // twenty times a second.
    interval: 50,

    // Are we at the app root?
    atRoot: function () {
      var path = this.location.pathname.replace(/[^\/]$/, '$&/');
      return path === this.root && !this.getSearch();
    },

    // Does the pathname match the root?
    matchRoot: function () {
      var path = this.decodeFragment(this.location.pathname);
      var rootPath = path.slice(0, this.root.length - 1) + '/';
      return rootPath === this.root;
    },

    // Unicode characters in `location.pathname` are percent encoded so they're
    // decoded for comparison. `%25` should not be decoded since it may be part
    // of an encoded parameter.
    decodeFragment: function (fragment) {
      return decodeURI(fragment.replace(/%25/g, '%2525'));
    },

    // In IE6, the hash fragment and search params are incorrect if the
    // fragment contains `?`.
    getSearch: function () {
      var match = this.location.href.replace(/#.*/, '').match(/\?.+/);
      return match ? match[0] : '';
    },

    // Gets the true hash value. Cannot use location.hash directly due to bug
    // in Firefox where location.hash will always be decoded.
    getHash: function (window) {
      var match = (window || this).location.href.match(/#(.*)$/);
      return match ? match[1] : '';
    },

    // Get the pathname and search params, without the root.
    getPath: function () {
      var path = this.decodeFragment(this.location.pathname + this.getSearch()).slice(this.root.length - 1);
      return path.charAt(0) === '/' ? path.slice(1) : path;
    },

    // Get the cross-browser normalized URL fragment from the path or hash.
    getFragment: function (fragment) {
      if (fragment == null) {
        if (this._usePushState || !this._wantsHashChange) {
          fragment = this.getPath();
        } else {
          fragment = this.getHash();
        }
      }
      return fragment.replace(routeStripper, '');
    },

    // Start the hash change handling, returning `true` if the current URL matches
    // an existing route, and `false` otherwise.
    start: function (options) {
      if (History.started) throw new Error('Backbone.history has already been started');
      History.started = true;

      // Figure out the initial configuration. Do we need an iframe?
      // Is pushState desired ... is it available?
      this.options = _.extend({ root: '/' }, this.options, options);
      this.root = this.options.root;
      this._wantsHashChange = this.options.hashChange !== false;
      this._hasHashChange = 'onhashchange' in window && (document.documentMode === void 0 || document.documentMode > 7);
      this._useHashChange = this._wantsHashChange && this._hasHashChange;
      this._wantsPushState = !!this.options.pushState;
      this._hasPushState = !!(this.history && this.history.pushState);
      this._usePushState = this._wantsPushState && this._hasPushState;
      this.fragment = this.getFragment();

      // Normalize root to always include a leading and trailing slash.
      this.root = ('/' + this.root + '/').replace(rootStripper, '/');

      // Transition from hashChange to pushState or vice versa if both are
      // requested.
      if (this._wantsHashChange && this._wantsPushState) {

        // If we've started off with a route from a `pushState`-enabled
        // browser, but we're currently in a browser that doesn't support it...
        if (!this._hasPushState && !this.atRoot()) {
          var rootPath = this.root.slice(0, -1) || '/';
          this.location.replace(rootPath + '#' + this.getPath());
          // Return immediately as browser will do redirect to new url
          return true;

          // Or if we've started out with a hash-based route, but we're currently
          // in a browser where it could be `pushState`-based instead...
        } else if (this._hasPushState && this.atRoot()) {
          this.navigate(this.getHash(), { replace: true });
        }
      }

      // Proxy an iframe to handle location events if the browser doesn't
      // support the `hashchange` event, HTML5 history, or the user wants
      // `hashChange` but not `pushState`.
      if (!this._hasHashChange && this._wantsHashChange && !this._usePushState) {
        this.iframe = document.createElement('iframe');
        this.iframe.src = 'javascript:0';
        this.iframe.style.display = 'none';
        this.iframe.tabIndex = -1;
        var body = document.body;
        // Using `appendChild` will throw on IE < 9 if the document is not ready.
        var iWindow = body.insertBefore(this.iframe, body.firstChild).contentWindow;
        iWindow.document.open();
        iWindow.document.close();
        iWindow.location.hash = '#' + this.fragment;
      }

      // Add a cross-platform `addEventListener` shim for older browsers.
      var addEventListener = window.addEventListener || function (eventName, listener) {
        return attachEvent('on' + eventName, listener);
      };

      // Depending on whether we're using pushState or hashes, and whether
      // 'onhashchange' is supported, determine how we check the URL state.
      if (this._usePushState) {
        addEventListener('popstate', this.checkUrl, false);
      } else if (this._useHashChange && !this.iframe) {
        addEventListener('hashchange', this.checkUrl, false);
      } else if (this._wantsHashChange) {
        this._checkUrlInterval = setInterval(this.checkUrl, this.interval);
      }

      if (!this.options.silent) return this.loadUrl();
    },

    // Disable Backbone.history, perhaps temporarily. Not useful in a real app,
    // but possibly useful for unit testing Routers.
    stop: function () {
      // Add a cross-platform `removeEventListener` shim for older browsers.
      var removeEventListener = window.removeEventListener || function (eventName, listener) {
        return detachEvent('on' + eventName, listener);
      };

      // Remove window listeners.
      if (this._usePushState) {
        removeEventListener('popstate', this.checkUrl, false);
      } else if (this._useHashChange && !this.iframe) {
        removeEventListener('hashchange', this.checkUrl, false);
      }

      // Clean up the iframe if necessary.
      if (this.iframe) {
        document.body.removeChild(this.iframe);
        this.iframe = null;
      }

      // Some environments will throw when clearing an undefined interval.
      if (this._checkUrlInterval) clearInterval(this._checkUrlInterval);
      History.started = false;
    },

    // Add a route to be tested when the fragment changes. Routes added later
    // may override previous routes.
    route: function (route, callback) {
      this.handlers.unshift({ route: route, callback: callback });
    },

    // Checks the current URL to see if it has changed, and if it has,
    // calls `loadUrl`, normalizing across the hidden iframe.
    checkUrl: function (e) {
      var current = this.getFragment();

      // If the user pressed the back button, the iframe's hash will have
      // changed and we should use that for comparison.
      if (current === this.fragment && this.iframe) {
        current = this.getHash(this.iframe.contentWindow);
      }

      if (current === this.fragment) return false;
      if (this.iframe) this.navigate(current);
      this.loadUrl();
    },

    // Attempt to load the current URL fragment. If a route succeeds with a
    // match, returns `true`. If no defined routes matches the fragment,
    // returns `false`.
    loadUrl: function (fragment) {
      // If the root doesn't match, no routes can match either.
      if (!this.matchRoot()) return false;
      fragment = this.fragment = this.getFragment(fragment);
      return _.some(this.handlers, function (handler) {
        if (handler.route.test(fragment)) {
          handler.callback(fragment);
          return true;
        }
      });
    },

    // Save a fragment into the hash history, or replace the URL state if the
    // 'replace' option is passed. You are responsible for properly URL-encoding
    // the fragment in advance.
    //
    // The options object can contain `trigger: true` if you wish to have the
    // route callback be fired (not usually desirable), or `replace: true`, if
    // you wish to modify the current URL without adding an entry to the history.
    navigate: function (fragment, options) {
      if (!History.started) return false;
      if (!options || options === true) options = { trigger: !!options };

      // Normalize the fragment.
      fragment = this.getFragment(fragment || '');

      // Don't include a trailing slash on the root.
      var rootPath = this.root;
      if (fragment === '' || fragment.charAt(0) === '?') {
        rootPath = rootPath.slice(0, -1) || '/';
      }
      var url = rootPath + fragment;

      // Strip the hash and decode for matching.
      fragment = this.decodeFragment(fragment.replace(pathStripper, ''));

      if (this.fragment === fragment) return;
      this.fragment = fragment;

      // If pushState is available, we use it to set the fragment as a real URL.
      if (this._usePushState) {
        this.history[options.replace ? 'replaceState' : 'pushState']({}, document.title, url);

        // If hash changes haven't been explicitly disabled, update the hash
        // fragment to store history.
      } else if (this._wantsHashChange) {
        this._updateHash(this.location, fragment, options.replace);
        if (this.iframe && fragment !== this.getHash(this.iframe.contentWindow)) {
          var iWindow = this.iframe.contentWindow;

          // Opening and closing the iframe tricks IE7 and earlier to push a
          // history entry on hash-tag change.  When replace is true, we don't
          // want this.
          if (!options.replace) {
            iWindow.document.open();
            iWindow.document.close();
          }

          this._updateHash(iWindow.location, fragment, options.replace);
        }

        // If you've told us that you explicitly don't want fallback hashchange-
        // based history, then `navigate` becomes a page refresh.
      } else {
        return this.location.assign(url);
      }
      if (options.trigger) return this.loadUrl(fragment);
    },

    // Update the hash location, either replacing the current entry, or adding
    // a new one to the browser history.
    _updateHash: function (location, fragment, replace) {
      if (replace) {
        var href = location.href.replace(/(javascript:|#).*$/, '');
        location.replace(href + '#' + fragment);
      } else {
        // Some browsers require that `hash` contains a leading #.
        location.hash = '#' + fragment;
      }
    }

  });

  // Create the default Backbone.history.
  Backbone.history = new History();

  // Helpers
  // -------

  // Helper function to correctly set up the prototype chain for subclasses.
  // Similar to `goog.inherits`, but uses a hash of prototype properties and
  // class properties to be extended.
  var extend = function (protoProps, staticProps) {
    var parent = this;
    var child;

    // The constructor function for the new subclass is either defined by you
    // (the "constructor" property in your `extend` definition), or defaulted
    // by us to simply call the parent constructor.
    if (protoProps && _.has(protoProps, 'constructor')) {
      child = protoProps.constructor;
    } else {
      child = function () {
        return parent.apply(this, arguments);
      };
    }

    // Add static properties to the constructor function, if supplied.
    _.extend(child, parent, staticProps);

    // Set the prototype chain to inherit from `parent`, without calling
    // `parent`'s constructor function and add the prototype properties.
    child.prototype = _.create(parent.prototype, protoProps);
    child.prototype.constructor = child;

    // Set a convenience property in case the parent's prototype is needed
    // later.
    child.__super__ = parent.prototype;

    return child;
  };

  // Set up inheritance for the model, collection, router, view and history.
  Model.extend = Collection.extend = Router.extend = View.extend = History.extend = extend;

  // Throw an error when a URL is needed, and none is supplied.
  var urlError = function () {
    throw new Error('A "url" property or function must be specified');
  };

  // Wrap an optional error callback with a fallback error event.
  var wrapError = function (model, options) {
    var error = options.error;
    options.error = function (resp) {
      if (error) error.call(options.context, model, resp, options);
      model.trigger('error', model, resp, options);
    };
  };

  return Backbone;
});
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(17)))

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;//     Underscore.js 1.8.3
//     http://underscorejs.org
//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.

(function () {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `exports` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype,
      ObjProto = Object.prototype,
      FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var push = ArrayProto.push,
      slice = ArrayProto.slice,
      toString = ObjProto.toString,
      hasOwnProperty = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var nativeIsArray = Array.isArray,
      nativeKeys = Object.keys,
      nativeBind = FuncProto.bind,
      nativeCreate = Object.create;

  // Naked function reference for surrogate-prototype-swapping.
  var Ctor = function () {};

  // Create a safe reference to the Underscore object for use below.
  var _ = function (obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object.
  if (true) {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.8.3';

  // Internal function that returns an efficient (for current engines) version
  // of the passed-in callback, to be repeatedly applied in other Underscore
  // functions.
  var optimizeCb = function (func, context, argCount) {
    if (context === void 0) return func;
    switch (argCount == null ? 3 : argCount) {
      case 1:
        return function (value) {
          return func.call(context, value);
        };
      case 2:
        return function (value, other) {
          return func.call(context, value, other);
        };
      case 3:
        return function (value, index, collection) {
          return func.call(context, value, index, collection);
        };
      case 4:
        return function (accumulator, value, index, collection) {
          return func.call(context, accumulator, value, index, collection);
        };
    }
    return function () {
      return func.apply(context, arguments);
    };
  };

  // A mostly-internal function to generate callbacks that can be applied
  // to each element in a collection, returning the desired result  either
  // identity, an arbitrary callback, a property matcher, or a property accessor.
  var cb = function (value, context, argCount) {
    if (value == null) return _.identity;
    if (_.isFunction(value)) return optimizeCb(value, context, argCount);
    if (_.isObject(value)) return _.matcher(value);
    return _.property(value);
  };
  _.iteratee = function (value, context) {
    return cb(value, context, Infinity);
  };

  // An internal function for creating assigner functions.
  var createAssigner = function (keysFunc, undefinedOnly) {
    return function (obj) {
      var length = arguments.length;
      if (length < 2 || obj == null) return obj;
      for (var index = 1; index < length; index++) {
        var source = arguments[index],
            keys = keysFunc(source),
            l = keys.length;
        for (var i = 0; i < l; i++) {
          var key = keys[i];
          if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];
        }
      }
      return obj;
    };
  };

  // An internal function for creating a new object that inherits from another.
  var baseCreate = function (prototype) {
    if (!_.isObject(prototype)) return {};
    if (nativeCreate) return nativeCreate(prototype);
    Ctor.prototype = prototype;
    var result = new Ctor();
    Ctor.prototype = null;
    return result;
  };

  var property = function (key) {
    return function (obj) {
      return obj == null ? void 0 : obj[key];
    };
  };

  // Helper for collection methods to determine whether a collection
  // should be iterated as an array or as an object
  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
  var getLength = property('length');
  var isArrayLike = function (collection) {
    var length = getLength(collection);
    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
  };

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles raw objects in addition to array-likes. Treats all
  // sparse array-likes as if they were dense.
  _.each = _.forEach = function (obj, iteratee, context) {
    iteratee = optimizeCb(iteratee, context);
    var i, length;
    if (isArrayLike(obj)) {
      for (i = 0, length = obj.length; i < length; i++) {
        iteratee(obj[i], i, obj);
      }
    } else {
      var keys = _.keys(obj);
      for (i = 0, length = keys.length; i < length; i++) {
        iteratee(obj[keys[i]], keys[i], obj);
      }
    }
    return obj;
  };

  // Return the results of applying the iteratee to each element.
  _.map = _.collect = function (obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length,
        results = Array(length);
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      results[index] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
  };

  // Create a reducing function iterating left or right.
  function createReduce(dir) {
    // Optimized iterator function as using arguments.length
    // in the main function will deoptimize the, see #1991.
    function iterator(obj, iteratee, memo, keys, index, length) {
      for (; index >= 0 && index < length; index += dir) {
        var currentKey = keys ? keys[index] : index;
        memo = iteratee(memo, obj[currentKey], currentKey, obj);
      }
      return memo;
    }

    return function (obj, iteratee, memo, context) {
      iteratee = optimizeCb(iteratee, context, 4);
      var keys = !isArrayLike(obj) && _.keys(obj),
          length = (keys || obj).length,
          index = dir > 0 ? 0 : length - 1;
      // Determine the initial value if none is provided.
      if (arguments.length < 3) {
        memo = obj[keys ? keys[index] : index];
        index += dir;
      }
      return iterator(obj, iteratee, memo, keys, index, length);
    };
  }

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`.
  _.reduce = _.foldl = _.inject = createReduce(1);

  // The right-associative version of reduce, also known as `foldr`.
  _.reduceRight = _.foldr = createReduce(-1);

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function (obj, predicate, context) {
    var key;
    if (isArrayLike(obj)) {
      key = _.findIndex(obj, predicate, context);
    } else {
      key = _.findKey(obj, predicate, context);
    }
    if (key !== void 0 && key !== -1) return obj[key];
  };

  // Return all the elements that pass a truth test.
  // Aliased as `select`.
  _.filter = _.select = function (obj, predicate, context) {
    var results = [];
    predicate = cb(predicate, context);
    _.each(obj, function (value, index, list) {
      if (predicate(value, index, list)) results.push(value);
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function (obj, predicate, context) {
    return _.filter(obj, _.negate(cb(predicate)), context);
  };

  // Determine whether all of the elements match a truth test.
  // Aliased as `all`.
  _.every = _.all = function (obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (!predicate(obj[currentKey], currentKey, obj)) return false;
    }
    return true;
  };

  // Determine if at least one element in the object matches a truth test.
  // Aliased as `any`.
  _.some = _.any = function (obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (predicate(obj[currentKey], currentKey, obj)) return true;
    }
    return false;
  };

  // Determine if the array or object contains a given item (using `===`).
  // Aliased as `includes` and `include`.
  _.contains = _.includes = _.include = function (obj, item, fromIndex, guard) {
    if (!isArrayLike(obj)) obj = _.values(obj);
    if (typeof fromIndex != 'number' || guard) fromIndex = 0;
    return _.indexOf(obj, item, fromIndex) >= 0;
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function (obj, method) {
    var args = slice.call(arguments, 2);
    var isFunc = _.isFunction(method);
    return _.map(obj, function (value) {
      var func = isFunc ? method : value[method];
      return func == null ? func : func.apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function (obj, key) {
    return _.map(obj, _.property(key));
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function (obj, attrs) {
    return _.filter(obj, _.matcher(attrs));
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function (obj, attrs) {
    return _.find(obj, _.matcher(attrs));
  };

  // Return the maximum element (or element-based computation).
  _.max = function (obj, iteratee, context) {
    var result = -Infinity,
        lastComputed = -Infinity,
        value,
        computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value > result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function (value, index, list) {
        computed = iteratee(value, index, list);
        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Return the minimum element (or element-based computation).
  _.min = function (obj, iteratee, context) {
    var result = Infinity,
        lastComputed = Infinity,
        value,
        computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value < result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function (value, index, list) {
        computed = iteratee(value, index, list);
        if (computed < lastComputed || computed === Infinity && result === Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Shuffle a collection, using the modern version of the
  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/FisherYates_shuffle).
  _.shuffle = function (obj) {
    var set = isArrayLike(obj) ? obj : _.values(obj);
    var length = set.length;
    var shuffled = Array(length);
    for (var index = 0, rand; index < length; index++) {
      rand = _.random(0, index);
      if (rand !== index) shuffled[index] = shuffled[rand];
      shuffled[rand] = set[index];
    }
    return shuffled;
  };

  // Sample **n** random values from a collection.
  // If **n** is not specified, returns a single random element.
  // The internal `guard` argument allows it to work with `map`.
  _.sample = function (obj, n, guard) {
    if (n == null || guard) {
      if (!isArrayLike(obj)) obj = _.values(obj);
      return obj[_.random(obj.length - 1)];
    }
    return _.shuffle(obj).slice(0, Math.max(0, n));
  };

  // Sort the object's values by a criterion produced by an iteratee.
  _.sortBy = function (obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    return _.pluck(_.map(obj, function (value, index, list) {
      return {
        value: value,
        index: index,
        criteria: iteratee(value, index, list)
      };
    }).sort(function (left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index - right.index;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function (behavior) {
    return function (obj, iteratee, context) {
      var result = {};
      iteratee = cb(iteratee, context);
      _.each(obj, function (value, index) {
        var key = iteratee(value, index, obj);
        behavior(result, value, key);
      });
      return result;
    };
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = group(function (result, value, key) {
    if (_.has(result, key)) result[key].push(value);else result[key] = [value];
  });

  // Indexes the object's values by a criterion, similar to `groupBy`, but for
  // when you know that your index values will be unique.
  _.indexBy = group(function (result, value, key) {
    result[key] = value;
  });

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = group(function (result, value, key) {
    if (_.has(result, key)) result[key]++;else result[key] = 1;
  });

  // Safely create a real, live array from anything iterable.
  _.toArray = function (obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (isArrayLike(obj)) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function (obj) {
    if (obj == null) return 0;
    return isArrayLike(obj) ? obj.length : _.keys(obj).length;
  };

  // Split a collection into two arrays: one whose elements all satisfy the given
  // predicate, and one whose elements all do not satisfy the predicate.
  _.partition = function (obj, predicate, context) {
    predicate = cb(predicate, context);
    var pass = [],
        fail = [];
    _.each(obj, function (value, key, obj) {
      (predicate(value, key, obj) ? pass : fail).push(value);
    });
    return [pass, fail];
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function (array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[0];
    return _.initial(array, array.length - n);
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N.
  _.initial = function (array, n, guard) {
    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array.
  _.last = function (array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[array.length - 1];
    return _.rest(array, Math.max(0, array.length - n));
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array.
  _.rest = _.tail = _.drop = function (array, n, guard) {
    return slice.call(array, n == null || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function (array) {
    return _.filter(array, _.identity);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function (input, shallow, strict, startIndex) {
    var output = [],
        idx = 0;
    for (var i = startIndex || 0, length = getLength(input); i < length; i++) {
      var value = input[i];
      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
        //flatten current level of array or arguments object
        if (!shallow) value = flatten(value, shallow, strict);
        var j = 0,
            len = value.length;
        output.length += len;
        while (j < len) {
          output[idx++] = value[j++];
        }
      } else if (!strict) {
        output[idx++] = value;
      }
    }
    return output;
  };

  // Flatten out an array, either recursively (by default), or just one level.
  _.flatten = function (array, shallow) {
    return flatten(array, shallow, false);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function (array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function (array, isSorted, iteratee, context) {
    if (!_.isBoolean(isSorted)) {
      context = iteratee;
      iteratee = isSorted;
      isSorted = false;
    }
    if (iteratee != null) iteratee = cb(iteratee, context);
    var result = [];
    var seen = [];
    for (var i = 0, length = getLength(array); i < length; i++) {
      var value = array[i],
          computed = iteratee ? iteratee(value, i, array) : value;
      if (isSorted) {
        if (!i || seen !== computed) result.push(value);
        seen = computed;
      } else if (iteratee) {
        if (!_.contains(seen, computed)) {
          seen.push(computed);
          result.push(value);
        }
      } else if (!_.contains(result, value)) {
        result.push(value);
      }
    }
    return result;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function () {
    return _.uniq(flatten(arguments, true, true));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function (array) {
    var result = [];
    var argsLength = arguments.length;
    for (var i = 0, length = getLength(array); i < length; i++) {
      var item = array[i];
      if (_.contains(result, item)) continue;
      for (var j = 1; j < argsLength; j++) {
        if (!_.contains(arguments[j], item)) break;
      }
      if (j === argsLength) result.push(item);
    }
    return result;
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function (array) {
    var rest = flatten(arguments, true, true, 1);
    return _.filter(array, function (value) {
      return !_.contains(rest, value);
    });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function () {
    return _.unzip(arguments);
  };

  // Complement of _.zip. Unzip accepts an array of arrays and groups
  // each array's elements on shared indices
  _.unzip = function (array) {
    var length = array && _.max(array, getLength).length || 0;
    var result = Array(length);

    for (var index = 0; index < length; index++) {
      result[index] = _.pluck(array, index);
    }
    return result;
  };

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values.
  _.object = function (list, values) {
    var result = {};
    for (var i = 0, length = getLength(list); i < length; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // Generator function to create the findIndex and findLastIndex functions
  function createPredicateIndexFinder(dir) {
    return function (array, predicate, context) {
      predicate = cb(predicate, context);
      var length = getLength(array);
      var index = dir > 0 ? 0 : length - 1;
      for (; index >= 0 && index < length; index += dir) {
        if (predicate(array[index], index, array)) return index;
      }
      return -1;
    };
  }

  // Returns the first index on an array-like that passes a predicate test
  _.findIndex = createPredicateIndexFinder(1);
  _.findLastIndex = createPredicateIndexFinder(-1);

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function (array, obj, iteratee, context) {
    iteratee = cb(iteratee, context, 1);
    var value = iteratee(obj);
    var low = 0,
        high = getLength(array);
    while (low < high) {
      var mid = Math.floor((low + high) / 2);
      if (iteratee(array[mid]) < value) low = mid + 1;else high = mid;
    }
    return low;
  };

  // Generator function to create the indexOf and lastIndexOf functions
  function createIndexFinder(dir, predicateFind, sortedIndex) {
    return function (array, item, idx) {
      var i = 0,
          length = getLength(array);
      if (typeof idx == 'number') {
        if (dir > 0) {
          i = idx >= 0 ? idx : Math.max(idx + length, i);
        } else {
          length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
        }
      } else if (sortedIndex && idx && length) {
        idx = sortedIndex(array, item);
        return array[idx] === item ? idx : -1;
      }
      if (item !== item) {
        idx = predicateFind(slice.call(array, i, length), _.isNaN);
        return idx >= 0 ? idx + i : -1;
      }
      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
        if (array[idx] === item) return idx;
      }
      return -1;
    };
  }

  // Return the position of the first occurrence of an item in an array,
  // or -1 if the item is not included in the array.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);
  _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function (start, stop, step) {
    if (stop == null) {
      stop = start || 0;
      start = 0;
    }
    step = step || 1;

    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var range = Array(length);

    for (var idx = 0; idx < length; idx++, start += step) {
      range[idx] = start;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Determines whether to execute a function as a constructor
  // or a normal function with the provided arguments
  var executeBound = function (sourceFunc, boundFunc, context, callingContext, args) {
    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
    var self = baseCreate(sourceFunc.prototype);
    var result = sourceFunc.apply(self, args);
    if (_.isObject(result)) return result;
    return self;
  };

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = function (func, context) {
    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
    var args = slice.call(arguments, 2);
    var bound = function () {
      return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));
    };
    return bound;
  };

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context. _ acts
  // as a placeholder, allowing any combination of arguments to be pre-filled.
  _.partial = function (func) {
    var boundArgs = slice.call(arguments, 1);
    var bound = function () {
      var position = 0,
          length = boundArgs.length;
      var args = Array(length);
      for (var i = 0; i < length; i++) {
        args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];
      }
      while (position < arguments.length) args.push(arguments[position++]);
      return executeBound(func, bound, this, this, args);
    };
    return bound;
  };

  // Bind a number of an object's methods to that object. Remaining arguments
  // are the method names to be bound. Useful for ensuring that all callbacks
  // defined on an object belong to it.
  _.bindAll = function (obj) {
    var i,
        length = arguments.length,
        key;
    if (length <= 1) throw new Error('bindAll must be passed function names');
    for (i = 1; i < length; i++) {
      key = arguments[i];
      obj[key] = _.bind(obj[key], obj);
    }
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function (func, hasher) {
    var memoize = function (key) {
      var cache = memoize.cache;
      var address = '' + (hasher ? hasher.apply(this, arguments) : key);
      if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);
      return cache[address];
    };
    memoize.cache = {};
    return memoize;
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function (func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function () {
      return func.apply(null, args);
    }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = _.partial(_.delay, _, 1);

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.
  _.throttle = function (func, wait, options) {
    var context, args, result;
    var timeout = null;
    var previous = 0;
    if (!options) options = {};
    var later = function () {
      previous = options.leading === false ? 0 : _.now();
      timeout = null;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    };
    return function () {
      var now = _.now();
      if (!previous && options.leading === false) previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0 || remaining > wait) {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }
        previous = now;
        result = func.apply(context, args);
        if (!timeout) context = args = null;
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function (func, wait, immediate) {
    var timeout, args, context, timestamp, result;

    var later = function () {
      var last = _.now() - timestamp;

      if (last < wait && last >= 0) {
        timeout = setTimeout(later, wait - last);
      } else {
        timeout = null;
        if (!immediate) {
          result = func.apply(context, args);
          if (!timeout) context = args = null;
        }
      }
    };

    return function () {
      context = this;
      args = arguments;
      timestamp = _.now();
      var callNow = immediate && !timeout;
      if (!timeout) timeout = setTimeout(later, wait);
      if (callNow) {
        result = func.apply(context, args);
        context = args = null;
      }

      return result;
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function (func, wrapper) {
    return _.partial(wrapper, func);
  };

  // Returns a negated version of the passed-in predicate.
  _.negate = function (predicate) {
    return function () {
      return !predicate.apply(this, arguments);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function () {
    var args = arguments;
    var start = args.length - 1;
    return function () {
      var i = start;
      var result = args[start].apply(this, arguments);
      while (i--) result = args[i].call(this, result);
      return result;
    };
  };

  // Returns a function that will only be executed on and after the Nth call.
  _.after = function (times, func) {
    return function () {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Returns a function that will only be executed up to (but not including) the Nth call.
  _.before = function (times, func) {
    var memo;
    return function () {
      if (--times > 0) {
        memo = func.apply(this, arguments);
      }
      if (times <= 1) func = null;
      return memo;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = _.partial(_.before, 2);

  // Object Functions
  // ----------------

  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
  var hasEnumBug = !{ toString: null }.propertyIsEnumerable('toString');
  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString', 'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

  function collectNonEnumProps(obj, keys) {
    var nonEnumIdx = nonEnumerableProps.length;
    var constructor = obj.constructor;
    var proto = _.isFunction(constructor) && constructor.prototype || ObjProto;

    // Constructor is a special case.
    var prop = 'constructor';
    if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);

    while (nonEnumIdx--) {
      prop = nonEnumerableProps[nonEnumIdx];
      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
        keys.push(prop);
      }
    }
  }

  // Retrieve the names of an object's own properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = function (obj) {
    if (!_.isObject(obj)) return [];
    if (nativeKeys) return nativeKeys(obj);
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve all the property names of an object.
  _.allKeys = function (obj) {
    if (!_.isObject(obj)) return [];
    var keys = [];
    for (var key in obj) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function (obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var values = Array(length);
    for (var i = 0; i < length; i++) {
      values[i] = obj[keys[i]];
    }
    return values;
  };

  // Returns the results of applying the iteratee to each element of the object
  // In contrast to _.map it returns an object
  _.mapObject = function (obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys = _.keys(obj),
        length = keys.length,
        results = {},
        currentKey;
    for (var index = 0; index < length; index++) {
      currentKey = keys[index];
      results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
  };

  // Convert an object into a list of `[key, value]` pairs.
  _.pairs = function (obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var pairs = Array(length);
    for (var i = 0; i < length; i++) {
      pairs[i] = [keys[i], obj[keys[i]]];
    }
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function (obj) {
    var result = {};
    var keys = _.keys(obj);
    for (var i = 0, length = keys.length; i < length; i++) {
      result[obj[keys[i]]] = keys[i];
    }
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function (obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = createAssigner(_.allKeys);

  // Assigns a given object with all the own properties in the passed-in object(s)
  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
  _.extendOwn = _.assign = createAssigner(_.keys);

  // Returns the first key on an object that passes a predicate test
  _.findKey = function (obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = _.keys(obj),
        key;
    for (var i = 0, length = keys.length; i < length; i++) {
      key = keys[i];
      if (predicate(obj[key], key, obj)) return key;
    }
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function (object, oiteratee, context) {
    var result = {},
        obj = object,
        iteratee,
        keys;
    if (obj == null) return result;
    if (_.isFunction(oiteratee)) {
      keys = _.allKeys(obj);
      iteratee = optimizeCb(oiteratee, context);
    } else {
      keys = flatten(arguments, false, false, 1);
      iteratee = function (value, key, obj) {
        return key in obj;
      };
      obj = Object(obj);
    }
    for (var i = 0, length = keys.length; i < length; i++) {
      var key = keys[i];
      var value = obj[key];
      if (iteratee(value, key, obj)) result[key] = value;
    }
    return result;
  };

  // Return a copy of the object without the blacklisted properties.
  _.omit = function (obj, iteratee, context) {
    if (_.isFunction(iteratee)) {
      iteratee = _.negate(iteratee);
    } else {
      var keys = _.map(flatten(arguments, false, false, 1), String);
      iteratee = function (value, key) {
        return !_.contains(keys, key);
      };
    }
    return _.pick(obj, iteratee, context);
  };

  // Fill in a given object with default properties.
  _.defaults = createAssigner(_.allKeys, true);

  // Creates an object that inherits from the given prototype object.
  // If additional properties are provided then they will be added to the
  // created object.
  _.create = function (prototype, props) {
    var result = baseCreate(prototype);
    if (props) _.extendOwn(result, props);
    return result;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function (obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function (obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Returns whether an object has a given set of `key:value` pairs.
  _.isMatch = function (object, attrs) {
    var keys = _.keys(attrs),
        length = keys.length;
    if (object == null) return !length;
    var obj = Object(object);
    for (var i = 0; i < length; i++) {
      var key = keys[i];
      if (attrs[key] !== obj[key] || !(key in obj)) return false;
    }
    return true;
  };

  // Internal recursive comparison function for `isEqual`.
  var eq = function (a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) return a !== 0 || 1 / a === 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className !== toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, regular expressions, dates, and booleans are compared by value.
      case '[object RegExp]':
      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return '' + a === '' + b;
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive.
        // Object(NaN) is equivalent to NaN
        if (+a !== +a) return +b !== +b;
        // An `egal` comparison is performed for other numeric values.
        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a === +b;
    }

    var areArrays = className === '[object Array]';
    if (!areArrays) {
      if (typeof a != 'object' || typeof b != 'object') return false;

      // Objects with different constructors are not equivalent, but `Object`s or `Array`s
      // from different frames are.
      var aCtor = a.constructor,
          bCtor = b.constructor;
      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor && _.isFunction(bCtor) && bCtor instanceof bCtor) && 'constructor' in a && 'constructor' in b) {
        return false;
      }
    }
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.

    // Initializing stack of traversed objects.
    // It's done here since we only need them for objects and arrays comparison.
    aStack = aStack || [];
    bStack = bStack || [];
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] === a) return bStack[length] === b;
    }

    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);

    // Recursively compare objects and arrays.
    if (areArrays) {
      // Compare array lengths to determine if a deep comparison is necessary.
      length = a.length;
      if (length !== b.length) return false;
      // Deep compare the contents, ignoring non-numeric properties.
      while (length--) {
        if (!eq(a[length], b[length], aStack, bStack)) return false;
      }
    } else {
      // Deep compare objects.
      var keys = _.keys(a),
          key;
      length = keys.length;
      // Ensure that both objects contain the same number of properties before comparing deep equality.
      if (_.keys(b).length !== length) return false;
      while (length--) {
        // Deep compare each member
        key = keys[length];
        if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return true;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function (a, b) {
    return eq(a, b);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function (obj) {
    if (obj == null) return true;
    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
    return _.keys(obj).length === 0;
  };

  // Is a given value a DOM element?
  _.isElement = function (obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function (obj) {
    return toString.call(obj) === '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function (obj) {
    var type = typeof obj;
    return type === 'function' || type === 'object' && !!obj;
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError.
  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function (name) {
    _['is' + name] = function (obj) {
      return toString.call(obj) === '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE < 9), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function (obj) {
      return _.has(obj, 'callee');
    };
  }

  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
  // IE 11 (#1621), and in Safari 8 (#1929).
  if (typeof /./ != 'function' && typeof Int8Array != 'object') {
    _.isFunction = function (obj) {
      return typeof obj == 'function' || false;
    };
  }

  // Is a given object a finite number?
  _.isFinite = function (obj) {
    return isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
  _.isNaN = function (obj) {
    return _.isNumber(obj) && obj !== +obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function (obj) {
    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function (obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function (obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function (obj, key) {
    return obj != null && hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function () {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iteratees.
  _.identity = function (value) {
    return value;
  };

  // Predicate-generating functions. Often useful outside of Underscore.
  _.constant = function (value) {
    return function () {
      return value;
    };
  };

  _.noop = function () {};

  _.property = property;

  // Generates a function for a given object that returns a given property.
  _.propertyOf = function (obj) {
    return obj == null ? function () {} : function (key) {
      return obj[key];
    };
  };

  // Returns a predicate for checking whether an object has a given set of
  // `key:value` pairs.
  _.matcher = _.matches = function (attrs) {
    attrs = _.extendOwn({}, attrs);
    return function (obj) {
      return _.isMatch(obj, attrs);
    };
  };

  // Run a function **n** times.
  _.times = function (n, iteratee, context) {
    var accum = Array(Math.max(0, n));
    iteratee = optimizeCb(iteratee, context, 1);
    for (var i = 0; i < n; i++) accum[i] = iteratee(i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function (min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // A (possibly faster) way to get the current timestamp as an integer.
  _.now = Date.now || function () {
    return new Date().getTime();
  };

  // List of HTML entities for escaping.
  var escapeMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#x27;',
    '`': '&#x60;'
  };
  var unescapeMap = _.invert(escapeMap);

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  var createEscaper = function (map) {
    var escaper = function (match) {
      return map[match];
    };
    // Regexes for identifying a key that needs to be escaped
    var source = '(?:' + _.keys(map).join('|') + ')';
    var testRegexp = RegExp(source);
    var replaceRegexp = RegExp(source, 'g');
    return function (string) {
      string = string == null ? '' : '' + string;
      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
    };
  };
  _.escape = createEscaper(escapeMap);
  _.unescape = createEscaper(unescapeMap);

  // If the value of the named `property` is a function then invoke it with the
  // `object` as context; otherwise, return it.
  _.result = function (object, property, fallback) {
    var value = object == null ? void 0 : object[property];
    if (value === void 0) {
      value = fallback;
    }
    return _.isFunction(value) ? value.call(object) : value;
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function (prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate: /<%([\s\S]+?)%>/g,
    interpolate: /<%=([\s\S]+?)%>/g,
    escape: /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'": "'",
    '\\': '\\',
    '\r': 'r',
    '\n': 'n',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escaper = /\\|'|\r|\n|\u2028|\u2029/g;

  var escapeChar = function (match) {
    return '\\' + escapes[match];
  };

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  // NB: `oldSettings` only exists for backwards compatibility.
  _.template = function (text, settings, oldSettings) {
    if (!settings && oldSettings) settings = oldSettings;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = RegExp([(settings.escape || noMatch).source, (settings.interpolate || noMatch).source, (settings.evaluate || noMatch).source].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function (match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset).replace(escaper, escapeChar);
      index = offset + match.length;

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      } else if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      } else if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }

      // Adobe VMs need the match returned to produce the correct offest.
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," + "print=function(){__p+=__j.call(arguments,'');};\n" + source + 'return __p;\n';

    try {
      var render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    var template = function (data) {
      return render.call(this, data, _);
    };

    // Provide the compiled source as a convenience for precompilation.
    var argument = settings.variable || 'obj';
    template.source = 'function(' + argument + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function. Start chaining a wrapped Underscore object.
  _.chain = function (obj) {
    var instance = _(obj);
    instance._chain = true;
    return instance;
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var result = function (instance, obj) {
    return instance._chain ? _(obj).chain() : obj;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function (obj) {
    _.each(_.functions(obj), function (name) {
      var func = _[name] = obj[name];
      _.prototype[name] = function () {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return result(this, func.apply(_, args));
      };
    });
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function (name) {
    var method = ArrayProto[name];
    _.prototype[name] = function () {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
      return result(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  _.each(['concat', 'join', 'slice'], function (name) {
    var method = ArrayProto[name];
    _.prototype[name] = function () {
      return result(this, method.apply(this._wrapped, arguments));
    };
  });

  // Extracts the result from a wrapped and chained object.
  _.prototype.value = function () {
    return this._wrapped;
  };

  // Provide unwrapping proxy for some methods used in engine operations
  // such as arithmetic and JSON stringification.
  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;

  _.prototype.toString = function () {
    return '' + this._wrapped;
  };

  // AMD registration happens at the end for compatibility with AMD loaders
  // that may not enforce next-turn semantics on modules. Even though general
  // practice for AMD registration is to be anonymous, underscore registers
  // as a named module because, like jQuery, it is a base library that is
  // popular enough to be bundled in a third party lib, but not be part of
  // an AMD load request. Those cases could generate an error when an
  // anonymous define() is called outside of a loader request.
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
      return _;
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  }
}).call(this);

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(_, Backbone) {var localStorage = _.extend({}, Backbone.Events);

// Add convenience JSON parse/stringigy functions to Global
localStorage.setItem = function (key, obj) {
  window.localStorage.setItem(key, JSON.stringify(obj));
  localStorage.trigger('localstorage:set:' + key, obj);
};

localStorage.getItem = function (key) {
  var str = window.localStorage.getItem(key);
  if (str) {
    return JSON.parse(str);
  }
};

localStorage.hasItem = function (key) {
  return window.localStorage.hasOwnProperty(key);
};

localStorage.removeItem = function (key) {
  window.localStorage.removeItem(key);
  localStorage.trigger('localstorage:remove:' + key);
};

module.exports = localStorage;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1), __webpack_require__(0)))

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(_, Backbone) {var EventBus = _.extend({}, Backbone.Events);

module.exports = EventBus;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1), __webpack_require__(0)))

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * jQuery JavaScript Library v3.1.1
 * https://jquery.com/
 *
 * Includes Sizzle.js
 * https://sizzlejs.com/
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2016-09-22T22:30Z
 */
(function (global, factory) {

	"use strict";

	if (typeof module === "object" && typeof module.exports === "object") {

		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket #14549 for more info.
		module.exports = global.document ? factory(global, true) : function (w) {
			if (!w.document) {
				throw new Error("jQuery requires a window with a document");
			}
			return factory(w);
		};
	} else {
		factory(global);
	}

	// Pass this if window is not defined yet
})(typeof window !== "undefined" ? window : this, function (window, noGlobal) {

	// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
	// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
	// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
	// enough that all such attempts are guarded in a try block.
	"use strict";

	var arr = [];

	var document = window.document;

	var getProto = Object.getPrototypeOf;

	var slice = arr.slice;

	var concat = arr.concat;

	var push = arr.push;

	var indexOf = arr.indexOf;

	var class2type = {};

	var toString = class2type.toString;

	var hasOwn = class2type.hasOwnProperty;

	var fnToString = hasOwn.toString;

	var ObjectFunctionString = fnToString.call(Object);

	var support = {};

	function DOMEval(code, doc) {
		doc = doc || document;

		var script = doc.createElement("script");

		script.text = code;
		doc.head.appendChild(script).parentNode.removeChild(script);
	}
	/* global Symbol */
	// Defining this global in .eslintrc.json would create a danger of using the global
	// unguarded in another place, it seems safer to define global only for this module


	var version = "3.1.1",


	// Define a local copy of jQuery
	jQuery = function (selector, context) {

		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init(selector, context);
	},


	// Support: Android <=4.0 only
	// Make sure we trim BOM and NBSP
	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,


	// Matches dashed string for camelizing
	rmsPrefix = /^-ms-/,
	    rdashAlpha = /-([a-z])/g,


	// Used by jQuery.camelCase as callback to replace()
	fcamelCase = function (all, letter) {
		return letter.toUpperCase();
	};

	jQuery.fn = jQuery.prototype = {

		// The current version of jQuery being used
		jquery: version,

		constructor: jQuery,

		// The default length of a jQuery object is 0
		length: 0,

		toArray: function () {
			return slice.call(this);
		},

		// Get the Nth element in the matched element set OR
		// Get the whole matched element set as a clean array
		get: function (num) {

			// Return all the elements in a clean array
			if (num == null) {
				return slice.call(this);
			}

			// Return just the one element from the set
			return num < 0 ? this[num + this.length] : this[num];
		},

		// Take an array of elements and push it onto the stack
		// (returning the new matched element set)
		pushStack: function (elems) {

			// Build a new jQuery matched element set
			var ret = jQuery.merge(this.constructor(), elems);

			// Add the old object onto the stack (as a reference)
			ret.prevObject = this;

			// Return the newly-formed element set
			return ret;
		},

		// Execute a callback for every element in the matched set.
		each: function (callback) {
			return jQuery.each(this, callback);
		},

		map: function (callback) {
			return this.pushStack(jQuery.map(this, function (elem, i) {
				return callback.call(elem, i, elem);
			}));
		},

		slice: function () {
			return this.pushStack(slice.apply(this, arguments));
		},

		first: function () {
			return this.eq(0);
		},

		last: function () {
			return this.eq(-1);
		},

		eq: function (i) {
			var len = this.length,
			    j = +i + (i < 0 ? len : 0);
			return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
		},

		end: function () {
			return this.prevObject || this.constructor();
		},

		// For internal use only.
		// Behaves like an Array's method, not like a jQuery method.
		push: push,
		sort: arr.sort,
		splice: arr.splice
	};

	jQuery.extend = jQuery.fn.extend = function () {
		var options,
		    name,
		    src,
		    copy,
		    copyIsArray,
		    clone,
		    target = arguments[0] || {},
		    i = 1,
		    length = arguments.length,
		    deep = false;

		// Handle a deep copy situation
		if (typeof target === "boolean") {
			deep = target;

			// Skip the boolean and the target
			target = arguments[i] || {};
			i++;
		}

		// Handle case when target is a string or something (possible in deep copy)
		if (typeof target !== "object" && !jQuery.isFunction(target)) {
			target = {};
		}

		// Extend jQuery itself if only one argument is passed
		if (i === length) {
			target = this;
			i--;
		}

		for (; i < length; i++) {

			// Only deal with non-null/undefined values
			if ((options = arguments[i]) != null) {

				// Extend the base object
				for (name in options) {
					src = target[name];
					copy = options[name];

					// Prevent never-ending loop
					if (target === copy) {
						continue;
					}

					// Recurse if we're merging plain objects or arrays
					if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) {

						if (copyIsArray) {
							copyIsArray = false;
							clone = src && jQuery.isArray(src) ? src : [];
						} else {
							clone = src && jQuery.isPlainObject(src) ? src : {};
						}

						// Never move original objects, clone them
						target[name] = jQuery.extend(deep, clone, copy);

						// Don't bring in undefined values
					} else if (copy !== undefined) {
						target[name] = copy;
					}
				}
			}
		}

		// Return the modified object
		return target;
	};

	jQuery.extend({

		// Unique for each copy of jQuery on the page
		expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),

		// Assume jQuery is ready without the ready module
		isReady: true,

		error: function (msg) {
			throw new Error(msg);
		},

		noop: function () {},

		isFunction: function (obj) {
			return jQuery.type(obj) === "function";
		},

		isArray: Array.isArray,

		isWindow: function (obj) {
			return obj != null && obj === obj.window;
		},

		isNumeric: function (obj) {

			// As of jQuery 3.0, isNumeric is limited to
			// strings and numbers (primitives or objects)
			// that can be coerced to finite numbers (gh-2662)
			var type = jQuery.type(obj);
			return (type === "number" || type === "string") &&

			// parseFloat NaNs numeric-cast false positives ("")
			// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
			// subtraction forces infinities to NaN
			!isNaN(obj - parseFloat(obj));
		},

		isPlainObject: function (obj) {
			var proto, Ctor;

			// Detect obvious negatives
			// Use toString instead of jQuery.type to catch host objects
			if (!obj || toString.call(obj) !== "[object Object]") {
				return false;
			}

			proto = getProto(obj);

			// Objects with no prototype (e.g., `Object.create( null )`) are plain
			if (!proto) {
				return true;
			}

			// Objects with prototype are plain iff they were constructed by a global Object function
			Ctor = hasOwn.call(proto, "constructor") && proto.constructor;
			return typeof Ctor === "function" && fnToString.call(Ctor) === ObjectFunctionString;
		},

		isEmptyObject: function (obj) {

			/* eslint-disable no-unused-vars */
			// See https://github.com/eslint/eslint/issues/6125
			var name;

			for (name in obj) {
				return false;
			}
			return true;
		},

		type: function (obj) {
			if (obj == null) {
				return obj + "";
			}

			// Support: Android <=2.3 only (functionish RegExp)
			return typeof obj === "object" || typeof obj === "function" ? class2type[toString.call(obj)] || "object" : typeof obj;
		},

		// Evaluates a script in a global context
		globalEval: function (code) {
			DOMEval(code);
		},

		// Convert dashed to camelCase; used by the css and data modules
		// Support: IE <=9 - 11, Edge 12 - 13
		// Microsoft forgot to hump their vendor prefix (#9572)
		camelCase: function (string) {
			return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
		},

		nodeName: function (elem, name) {
			return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
		},

		each: function (obj, callback) {
			var length,
			    i = 0;

			if (isArrayLike(obj)) {
				length = obj.length;
				for (; i < length; i++) {
					if (callback.call(obj[i], i, obj[i]) === false) {
						break;
					}
				}
			} else {
				for (i in obj) {
					if (callback.call(obj[i], i, obj[i]) === false) {
						break;
					}
				}
			}

			return obj;
		},

		// Support: Android <=4.0 only
		trim: function (text) {
			return text == null ? "" : (text + "").replace(rtrim, "");
		},

		// results is for internal usage only
		makeArray: function (arr, results) {
			var ret = results || [];

			if (arr != null) {
				if (isArrayLike(Object(arr))) {
					jQuery.merge(ret, typeof arr === "string" ? [arr] : arr);
				} else {
					push.call(ret, arr);
				}
			}

			return ret;
		},

		inArray: function (elem, arr, i) {
			return arr == null ? -1 : indexOf.call(arr, elem, i);
		},

		// Support: Android <=4.0 only, PhantomJS 1 only
		// push.apply(_, arraylike) throws on ancient WebKit
		merge: function (first, second) {
			var len = +second.length,
			    j = 0,
			    i = first.length;

			for (; j < len; j++) {
				first[i++] = second[j];
			}

			first.length = i;

			return first;
		},

		grep: function (elems, callback, invert) {
			var callbackInverse,
			    matches = [],
			    i = 0,
			    length = elems.length,
			    callbackExpect = !invert;

			// Go through the array, only saving the items
			// that pass the validator function
			for (; i < length; i++) {
				callbackInverse = !callback(elems[i], i);
				if (callbackInverse !== callbackExpect) {
					matches.push(elems[i]);
				}
			}

			return matches;
		},

		// arg is for internal usage only
		map: function (elems, callback, arg) {
			var length,
			    value,
			    i = 0,
			    ret = [];

			// Go through the array, translating each of the items to their new values
			if (isArrayLike(elems)) {
				length = elems.length;
				for (; i < length; i++) {
					value = callback(elems[i], i, arg);

					if (value != null) {
						ret.push(value);
					}
				}

				// Go through every key on the object,
			} else {
				for (i in elems) {
					value = callback(elems[i], i, arg);

					if (value != null) {
						ret.push(value);
					}
				}
			}

			// Flatten any nested arrays
			return concat.apply([], ret);
		},

		// A global GUID counter for objects
		guid: 1,

		// Bind a function to a context, optionally partially applying any
		// arguments.
		proxy: function (fn, context) {
			var tmp, args, proxy;

			if (typeof context === "string") {
				tmp = fn[context];
				context = fn;
				fn = tmp;
			}

			// Quick check to determine if target is callable, in the spec
			// this throws a TypeError, but we will just return undefined.
			if (!jQuery.isFunction(fn)) {
				return undefined;
			}

			// Simulated bind
			args = slice.call(arguments, 2);
			proxy = function () {
				return fn.apply(context || this, args.concat(slice.call(arguments)));
			};

			// Set the guid of unique handler to the same of original handler, so it can be removed
			proxy.guid = fn.guid = fn.guid || jQuery.guid++;

			return proxy;
		},

		now: Date.now,

		// jQuery.support is not used in Core but other projects attach their
		// properties to it so it needs to exist.
		support: support
	});

	if (typeof Symbol === "function") {
		jQuery.fn[Symbol.iterator] = arr[Symbol.iterator];
	}

	// Populate the class2type map
	jQuery.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function (i, name) {
		class2type["[object " + name + "]"] = name.toLowerCase();
	});

	function isArrayLike(obj) {

		// Support: real iOS 8.2 only (not reproducible in simulator)
		// `in` check used to prevent JIT error (gh-2145)
		// hasOwn isn't used here due to false negatives
		// regarding Nodelist length in IE
		var length = !!obj && "length" in obj && obj.length,
		    type = jQuery.type(obj);

		if (type === "function" || jQuery.isWindow(obj)) {
			return false;
		}

		return type === "array" || length === 0 || typeof length === "number" && length > 0 && length - 1 in obj;
	}
	var Sizzle =
	/*!
  * Sizzle CSS Selector Engine v2.3.3
  * https://sizzlejs.com/
  *
  * Copyright jQuery Foundation and other contributors
  * Released under the MIT license
  * http://jquery.org/license
  *
  * Date: 2016-08-08
  */
	function (window) {

		var i,
		    support,
		    Expr,
		    getText,
		    isXML,
		    tokenize,
		    compile,
		    select,
		    outermostContext,
		    sortInput,
		    hasDuplicate,


		// Local document vars
		setDocument,
		    document,
		    docElem,
		    documentIsHTML,
		    rbuggyQSA,
		    rbuggyMatches,
		    matches,
		    contains,


		// Instance-specific data
		expando = "sizzle" + 1 * new Date(),
		    preferredDoc = window.document,
		    dirruns = 0,
		    done = 0,
		    classCache = createCache(),
		    tokenCache = createCache(),
		    compilerCache = createCache(),
		    sortOrder = function (a, b) {
			if (a === b) {
				hasDuplicate = true;
			}
			return 0;
		},


		// Instance methods
		hasOwn = {}.hasOwnProperty,
		    arr = [],
		    pop = arr.pop,
		    push_native = arr.push,
		    push = arr.push,
		    slice = arr.slice,

		// Use a stripped-down indexOf as it's faster than native
		// https://jsperf.com/thor-indexof-vs-for/5
		indexOf = function (list, elem) {
			var i = 0,
			    len = list.length;
			for (; i < len; i++) {
				if (list[i] === elem) {
					return i;
				}
			}
			return -1;
		},
		    booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",


		// Regular expressions

		// http://www.w3.org/TR/css3-selectors/#whitespace
		whitespace = "[\\x20\\t\\r\\n\\f]",


		// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
		identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",


		// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
		attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +
		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace + "*\\]",
		    pseudos = ":(" + identifier + ")(?:\\((" +
		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
		// 3. anything else (capture 2)
		".*" + ")\\)|)",


		// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
		rwhitespace = new RegExp(whitespace + "+", "g"),
		    rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"),
		    rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"),
		    rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"),
		    rattributeQuotes = new RegExp("=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g"),
		    rpseudo = new RegExp(pseudos),
		    ridentifier = new RegExp("^" + identifier + "$"),
		    matchExpr = {
			"ID": new RegExp("^#(" + identifier + ")"),
			"CLASS": new RegExp("^\\.(" + identifier + ")"),
			"TAG": new RegExp("^(" + identifier + "|[*])"),
			"ATTR": new RegExp("^" + attributes),
			"PSEUDO": new RegExp("^" + pseudos),
			"CHILD": new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
			"bool": new RegExp("^(?:" + booleans + ")$", "i"),
			// For use in libraries implementing .is()
			// We use this for POS matching in `select`
			"needsContext": new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
		},
		    rinputs = /^(?:input|select|textarea|button)$/i,
		    rheader = /^h\d$/i,
		    rnative = /^[^{]+\{\s*\[native \w/,


		// Easily-parseable/retrievable ID or TAG or CLASS selectors
		rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
		    rsibling = /[+~]/,


		// CSS escapes
		// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
		runescape = new RegExp("\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig"),
		    funescape = function (_, escaped, escapedWhitespace) {
			var high = "0x" + escaped - 0x10000;
			// NaN means non-codepoint
			// Support: Firefox<24
			// Workaround erroneous numeric interpretation of +"0x"
			return high !== high || escapedWhitespace ? escaped : high < 0 ?
			// BMP codepoint
			String.fromCharCode(high + 0x10000) :
			// Supplemental Plane codepoint (surrogate pair)
			String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);
		},


		// CSS string/identifier serialization
		// https://drafts.csswg.org/cssom/#common-serializing-idioms
		rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
		    fcssescape = function (ch, asCodePoint) {
			if (asCodePoint) {

				// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
				if (ch === "\0") {
					return "\uFFFD";
				}

				// Control characters and (dependent upon position) numbers get escaped as code points
				return ch.slice(0, -1) + "\\" + ch.charCodeAt(ch.length - 1).toString(16) + " ";
			}

			// Other potentially-special ASCII characters get backslash-escaped
			return "\\" + ch;
		},


		// Used for iframes
		// See setDocument()
		// Removing the function wrapper causes a "Permission Denied"
		// error in IE
		unloadHandler = function () {
			setDocument();
		},
		    disabledAncestor = addCombinator(function (elem) {
			return elem.disabled === true && ("form" in elem || "label" in elem);
		}, { dir: "parentNode", next: "legend" });

		// Optimize for push.apply( _, NodeList )
		try {
			push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes);
			// Support: Android<4.0
			// Detect silently failing push.apply
			arr[preferredDoc.childNodes.length].nodeType;
		} catch (e) {
			push = { apply: arr.length ?

				// Leverage slice if possible
				function (target, els) {
					push_native.apply(target, slice.call(els));
				} :

				// Support: IE<9
				// Otherwise append directly
				function (target, els) {
					var j = target.length,
					    i = 0;
					// Can't trust NodeList.length
					while (target[j++] = els[i++]) {}
					target.length = j - 1;
				}
			};
		}

		function Sizzle(selector, context, results, seed) {
			var m,
			    i,
			    elem,
			    nid,
			    match,
			    groups,
			    newSelector,
			    newContext = context && context.ownerDocument,


			// nodeType defaults to 9, since context defaults to document
			nodeType = context ? context.nodeType : 9;

			results = results || [];

			// Return early from calls with invalid selector or context
			if (typeof selector !== "string" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {

				return results;
			}

			// Try to shortcut find operations (as opposed to filters) in HTML documents
			if (!seed) {

				if ((context ? context.ownerDocument || context : preferredDoc) !== document) {
					setDocument(context);
				}
				context = context || document;

				if (documentIsHTML) {

					// If the selector is sufficiently simple, try using a "get*By*" DOM method
					// (excepting DocumentFragment context, where the methods don't exist)
					if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {

						// ID selector
						if (m = match[1]) {

							// Document context
							if (nodeType === 9) {
								if (elem = context.getElementById(m)) {

									// Support: IE, Opera, Webkit
									// TODO: identify versions
									// getElementById can match elements by name instead of ID
									if (elem.id === m) {
										results.push(elem);
										return results;
									}
								} else {
									return results;
								}

								// Element context
							} else {

								// Support: IE, Opera, Webkit
								// TODO: identify versions
								// getElementById can match elements by name instead of ID
								if (newContext && (elem = newContext.getElementById(m)) && contains(context, elem) && elem.id === m) {

									results.push(elem);
									return results;
								}
							}

							// Type selector
						} else if (match[2]) {
							push.apply(results, context.getElementsByTagName(selector));
							return results;

							// Class selector
						} else if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) {

							push.apply(results, context.getElementsByClassName(m));
							return results;
						}
					}

					// Take advantage of querySelectorAll
					if (support.qsa && !compilerCache[selector + " "] && (!rbuggyQSA || !rbuggyQSA.test(selector))) {

						if (nodeType !== 1) {
							newContext = context;
							newSelector = selector;

							// qSA looks outside Element context, which is not what we want
							// Thanks to Andrew Dupont for this workaround technique
							// Support: IE <=8
							// Exclude object elements
						} else if (context.nodeName.toLowerCase() !== "object") {

							// Capture the context ID, setting it first if necessary
							if (nid = context.getAttribute("id")) {
								nid = nid.replace(rcssescape, fcssescape);
							} else {
								context.setAttribute("id", nid = expando);
							}

							// Prefix every selector in the list
							groups = tokenize(selector);
							i = groups.length;
							while (i--) {
								groups[i] = "#" + nid + " " + toSelector(groups[i]);
							}
							newSelector = groups.join(",");

							// Expand context for sibling selectors
							newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
						}

						if (newSelector) {
							try {
								push.apply(results, newContext.querySelectorAll(newSelector));
								return results;
							} catch (qsaError) {} finally {
								if (nid === expando) {
									context.removeAttribute("id");
								}
							}
						}
					}
				}
			}

			// All others
			return select(selector.replace(rtrim, "$1"), context, results, seed);
		}

		/**
   * Create key-value caches of limited size
   * @returns {function(string, object)} Returns the Object data after storing it on itself with
   *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
   *	deleting the oldest entry
   */
		function createCache() {
			var keys = [];

			function cache(key, value) {
				// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
				if (keys.push(key + " ") > Expr.cacheLength) {
					// Only keep the most recent entries
					delete cache[keys.shift()];
				}
				return cache[key + " "] = value;
			}
			return cache;
		}

		/**
   * Mark a function for special use by Sizzle
   * @param {Function} fn The function to mark
   */
		function markFunction(fn) {
			fn[expando] = true;
			return fn;
		}

		/**
   * Support testing using an element
   * @param {Function} fn Passed the created element and returns a boolean result
   */
		function assert(fn) {
			var el = document.createElement("fieldset");

			try {
				return !!fn(el);
			} catch (e) {
				return false;
			} finally {
				// Remove from its parent by default
				if (el.parentNode) {
					el.parentNode.removeChild(el);
				}
				// release memory in IE
				el = null;
			}
		}

		/**
   * Adds the same handler for all of the specified attrs
   * @param {String} attrs Pipe-separated list of attributes
   * @param {Function} handler The method that will be applied
   */
		function addHandle(attrs, handler) {
			var arr = attrs.split("|"),
			    i = arr.length;

			while (i--) {
				Expr.attrHandle[arr[i]] = handler;
			}
		}

		/**
   * Checks document order of two siblings
   * @param {Element} a
   * @param {Element} b
   * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
   */
		function siblingCheck(a, b) {
			var cur = b && a,
			    diff = cur && a.nodeType === 1 && b.nodeType === 1 && a.sourceIndex - b.sourceIndex;

			// Use IE sourceIndex if available on both nodes
			if (diff) {
				return diff;
			}

			// Check if b follows a
			if (cur) {
				while (cur = cur.nextSibling) {
					if (cur === b) {
						return -1;
					}
				}
			}

			return a ? 1 : -1;
		}

		/**
   * Returns a function to use in pseudos for input types
   * @param {String} type
   */
		function createInputPseudo(type) {
			return function (elem) {
				var name = elem.nodeName.toLowerCase();
				return name === "input" && elem.type === type;
			};
		}

		/**
   * Returns a function to use in pseudos for buttons
   * @param {String} type
   */
		function createButtonPseudo(type) {
			return function (elem) {
				var name = elem.nodeName.toLowerCase();
				return (name === "input" || name === "button") && elem.type === type;
			};
		}

		/**
   * Returns a function to use in pseudos for :enabled/:disabled
   * @param {Boolean} disabled true for :disabled; false for :enabled
   */
		function createDisabledPseudo(disabled) {

			// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
			return function (elem) {

				// Only certain elements can match :enabled or :disabled
				// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
				// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
				if ("form" in elem) {

					// Check for inherited disabledness on relevant non-disabled elements:
					// * listed form-associated elements in a disabled fieldset
					//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
					//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
					// * option elements in a disabled optgroup
					//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
					// All such elements have a "form" property.
					if (elem.parentNode && elem.disabled === false) {

						// Option elements defer to a parent optgroup if present
						if ("label" in elem) {
							if ("label" in elem.parentNode) {
								return elem.parentNode.disabled === disabled;
							} else {
								return elem.disabled === disabled;
							}
						}

						// Support: IE 6 - 11
						// Use the isDisabled shortcut property to check for disabled fieldset ancestors
						return elem.isDisabled === disabled ||

						// Where there is no isDisabled, check manually
						/* jshint -W018 */
						elem.isDisabled !== !disabled && disabledAncestor(elem) === disabled;
					}

					return elem.disabled === disabled;

					// Try to winnow out elements that can't be disabled before trusting the disabled property.
					// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
					// even exist on them, let alone have a boolean value.
				} else if ("label" in elem) {
					return elem.disabled === disabled;
				}

				// Remaining elements are neither :enabled nor :disabled
				return false;
			};
		}

		/**
   * Returns a function to use in pseudos for positionals
   * @param {Function} fn
   */
		function createPositionalPseudo(fn) {
			return markFunction(function (argument) {
				argument = +argument;
				return markFunction(function (seed, matches) {
					var j,
					    matchIndexes = fn([], seed.length, argument),
					    i = matchIndexes.length;

					// Match elements found at the specified indexes
					while (i--) {
						if (seed[j = matchIndexes[i]]) {
							seed[j] = !(matches[j] = seed[j]);
						}
					}
				});
			});
		}

		/**
   * Checks a node for validity as a Sizzle context
   * @param {Element|Object=} context
   * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
   */
		function testContext(context) {
			return context && typeof context.getElementsByTagName !== "undefined" && context;
		}

		// Expose support vars for convenience
		support = Sizzle.support = {};

		/**
   * Detects XML nodes
   * @param {Element|Object} elem An element or a document
   * @returns {Boolean} True iff elem is a non-HTML XML node
   */
		isXML = Sizzle.isXML = function (elem) {
			// documentElement is verified for cases where it doesn't yet exist
			// (such as loading iframes in IE - #4833)
			var documentElement = elem && (elem.ownerDocument || elem).documentElement;
			return documentElement ? documentElement.nodeName !== "HTML" : false;
		};

		/**
   * Sets document-related variables once based on the current document
   * @param {Element|Object} [doc] An element or document object to use to set the document
   * @returns {Object} Returns the current document
   */
		setDocument = Sizzle.setDocument = function (node) {
			var hasCompare,
			    subWindow,
			    doc = node ? node.ownerDocument || node : preferredDoc;

			// Return early if doc is invalid or already selected
			if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {
				return document;
			}

			// Update global variables
			document = doc;
			docElem = document.documentElement;
			documentIsHTML = !isXML(document);

			// Support: IE 9-11, Edge
			// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
			if (preferredDoc !== document && (subWindow = document.defaultView) && subWindow.top !== subWindow) {

				// Support: IE 11, Edge
				if (subWindow.addEventListener) {
					subWindow.addEventListener("unload", unloadHandler, false);

					// Support: IE 9 - 10 only
				} else if (subWindow.attachEvent) {
					subWindow.attachEvent("onunload", unloadHandler);
				}
			}

			/* Attributes
   ---------------------------------------------------------------------- */

			// Support: IE<8
			// Verify that getAttribute really returns attributes and not properties
			// (excepting IE8 booleans)
			support.attributes = assert(function (el) {
				el.className = "i";
				return !el.getAttribute("className");
			});

			/* getElement(s)By*
   ---------------------------------------------------------------------- */

			// Check if getElementsByTagName("*") returns only elements
			support.getElementsByTagName = assert(function (el) {
				el.appendChild(document.createComment(""));
				return !el.getElementsByTagName("*").length;
			});

			// Support: IE<9
			support.getElementsByClassName = rnative.test(document.getElementsByClassName);

			// Support: IE<10
			// Check if getElementById returns elements by name
			// The broken getElementById methods don't pick up programmatically-set names,
			// so use a roundabout getElementsByName test
			support.getById = assert(function (el) {
				docElem.appendChild(el).id = expando;
				return !document.getElementsByName || !document.getElementsByName(expando).length;
			});

			// ID filter and find
			if (support.getById) {
				Expr.filter["ID"] = function (id) {
					var attrId = id.replace(runescape, funescape);
					return function (elem) {
						return elem.getAttribute("id") === attrId;
					};
				};
				Expr.find["ID"] = function (id, context) {
					if (typeof context.getElementById !== "undefined" && documentIsHTML) {
						var elem = context.getElementById(id);
						return elem ? [elem] : [];
					}
				};
			} else {
				Expr.filter["ID"] = function (id) {
					var attrId = id.replace(runescape, funescape);
					return function (elem) {
						var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
						return node && node.value === attrId;
					};
				};

				// Support: IE 6 - 7 only
				// getElementById is not reliable as a find shortcut
				Expr.find["ID"] = function (id, context) {
					if (typeof context.getElementById !== "undefined" && documentIsHTML) {
						var node,
						    i,
						    elems,
						    elem = context.getElementById(id);

						if (elem) {

							// Verify the id attribute
							node = elem.getAttributeNode("id");
							if (node && node.value === id) {
								return [elem];
							}

							// Fall back on getElementsByName
							elems = context.getElementsByName(id);
							i = 0;
							while (elem = elems[i++]) {
								node = elem.getAttributeNode("id");
								if (node && node.value === id) {
									return [elem];
								}
							}
						}

						return [];
					}
				};
			}

			// Tag
			Expr.find["TAG"] = support.getElementsByTagName ? function (tag, context) {
				if (typeof context.getElementsByTagName !== "undefined") {
					return context.getElementsByTagName(tag);

					// DocumentFragment nodes don't have gEBTN
				} else if (support.qsa) {
					return context.querySelectorAll(tag);
				}
			} : function (tag, context) {
				var elem,
				    tmp = [],
				    i = 0,

				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
				results = context.getElementsByTagName(tag);

				// Filter out possible comments
				if (tag === "*") {
					while (elem = results[i++]) {
						if (elem.nodeType === 1) {
							tmp.push(elem);
						}
					}

					return tmp;
				}
				return results;
			};

			// Class
			Expr.find["CLASS"] = support.getElementsByClassName && function (className, context) {
				if (typeof context.getElementsByClassName !== "undefined" && documentIsHTML) {
					return context.getElementsByClassName(className);
				}
			};

			/* QSA/matchesSelector
   ---------------------------------------------------------------------- */

			// QSA and matchesSelector support

			// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
			rbuggyMatches = [];

			// qSa(:focus) reports false when true (Chrome 21)
			// We allow this because of a bug in IE8/9 that throws an error
			// whenever `document.activeElement` is accessed on an iframe
			// So, we allow :focus to pass through QSA all the time to avoid the IE error
			// See https://bugs.jquery.com/ticket/13378
			rbuggyQSA = [];

			if (support.qsa = rnative.test(document.querySelectorAll)) {
				// Build QSA regex
				// Regex strategy adopted from Diego Perini
				assert(function (el) {
					// Select is set to empty string on purpose
					// This is to test IE's treatment of not explicitly
					// setting a boolean content attribute,
					// since its presence should be enough
					// https://bugs.jquery.com/ticket/12359
					docElem.appendChild(el).innerHTML = "<a id='" + expando + "'></a>" + "<select id='" + expando + "-\r\\' msallowcapture=''>" + "<option selected=''></option></select>";

					// Support: IE8, Opera 11-12.16
					// Nothing should be selected when empty strings follow ^= or $= or *=
					// The test attribute must be unknown in Opera but "safe" for WinRT
					// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
					if (el.querySelectorAll("[msallowcapture^='']").length) {
						rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")");
					}

					// Support: IE8
					// Boolean attributes and "value" are not treated correctly
					if (!el.querySelectorAll("[selected]").length) {
						rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
					}

					// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
					if (!el.querySelectorAll("[id~=" + expando + "-]").length) {
						rbuggyQSA.push("~=");
					}

					// Webkit/Opera - :checked should return selected option elements
					// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
					// IE8 throws error here and will not see later tests
					if (!el.querySelectorAll(":checked").length) {
						rbuggyQSA.push(":checked");
					}

					// Support: Safari 8+, iOS 8+
					// https://bugs.webkit.org/show_bug.cgi?id=136851
					// In-page `selector#id sibling-combinator selector` fails
					if (!el.querySelectorAll("a#" + expando + "+*").length) {
						rbuggyQSA.push(".#.+[+~]");
					}
				});

				assert(function (el) {
					el.innerHTML = "<a href='' disabled='disabled'></a>" + "<select disabled='disabled'><option/></select>";

					// Support: Windows 8 Native Apps
					// The type and name attributes are restricted during .innerHTML assignment
					var input = document.createElement("input");
					input.setAttribute("type", "hidden");
					el.appendChild(input).setAttribute("name", "D");

					// Support: IE8
					// Enforce case-sensitivity of name attribute
					if (el.querySelectorAll("[name=d]").length) {
						rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=");
					}

					// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
					// IE8 throws error here and will not see later tests
					if (el.querySelectorAll(":enabled").length !== 2) {
						rbuggyQSA.push(":enabled", ":disabled");
					}

					// Support: IE9-11+
					// IE's :disabled selector does not pick up the children of disabled fieldsets
					docElem.appendChild(el).disabled = true;
					if (el.querySelectorAll(":disabled").length !== 2) {
						rbuggyQSA.push(":enabled", ":disabled");
					}

					// Opera 10-11 does not throw on post-comma invalid pseudos
					el.querySelectorAll("*,:x");
					rbuggyQSA.push(",.*:");
				});
			}

			if (support.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {

				assert(function (el) {
					// Check to see if it's possible to do matchesSelector
					// on a disconnected node (IE 9)
					support.disconnectedMatch = matches.call(el, "*");

					// This should fail with an exception
					// Gecko does not error, returns false instead
					matches.call(el, "[s!='']:x");
					rbuggyMatches.push("!=", pseudos);
				});
			}

			rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
			rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));

			/* Contains
   ---------------------------------------------------------------------- */
			hasCompare = rnative.test(docElem.compareDocumentPosition);

			// Element contains another
			// Purposefully self-exclusive
			// As in, an element does not contain itself
			contains = hasCompare || rnative.test(docElem.contains) ? function (a, b) {
				var adown = a.nodeType === 9 ? a.documentElement : a,
				    bup = b && b.parentNode;
				return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
			} : function (a, b) {
				if (b) {
					while (b = b.parentNode) {
						if (b === a) {
							return true;
						}
					}
				}
				return false;
			};

			/* Sorting
   ---------------------------------------------------------------------- */

			// Document order sorting
			sortOrder = hasCompare ? function (a, b) {

				// Flag for duplicate removal
				if (a === b) {
					hasDuplicate = true;
					return 0;
				}

				// Sort on method existence if only one input has compareDocumentPosition
				var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
				if (compare) {
					return compare;
				}

				// Calculate position if both inputs belong to the same document
				compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) :

				// Otherwise we know they are disconnected
				1;

				// Disconnected nodes
				if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {

					// Choose the first element that is related to our preferred document
					if (a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) {
						return -1;
					}
					if (b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) {
						return 1;
					}

					// Maintain original order
					return sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;
				}

				return compare & 4 ? -1 : 1;
			} : function (a, b) {
				// Exit early if the nodes are identical
				if (a === b) {
					hasDuplicate = true;
					return 0;
				}

				var cur,
				    i = 0,
				    aup = a.parentNode,
				    bup = b.parentNode,
				    ap = [a],
				    bp = [b];

				// Parentless nodes are either documents or disconnected
				if (!aup || !bup) {
					return a === document ? -1 : b === document ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;

					// If the nodes are siblings, we can do a quick check
				} else if (aup === bup) {
					return siblingCheck(a, b);
				}

				// Otherwise we need full lists of their ancestors for comparison
				cur = a;
				while (cur = cur.parentNode) {
					ap.unshift(cur);
				}
				cur = b;
				while (cur = cur.parentNode) {
					bp.unshift(cur);
				}

				// Walk down the tree looking for a discrepancy
				while (ap[i] === bp[i]) {
					i++;
				}

				return i ?
				// Do a sibling check if the nodes have a common ancestor
				siblingCheck(ap[i], bp[i]) :

				// Otherwise nodes in our document sort first
				ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;
			};

			return document;
		};

		Sizzle.matches = function (expr, elements) {
			return Sizzle(expr, null, null, elements);
		};

		Sizzle.matchesSelector = function (elem, expr) {
			// Set document vars if needed
			if ((elem.ownerDocument || elem) !== document) {
				setDocument(elem);
			}

			// Make sure that attribute selectors are quoted
			expr = expr.replace(rattributeQuotes, "='$1']");

			if (support.matchesSelector && documentIsHTML && !compilerCache[expr + " "] && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {

				try {
					var ret = matches.call(elem, expr);

					// IE 9's matchesSelector returns false on disconnected nodes
					if (ret || support.disconnectedMatch ||
					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11) {
						return ret;
					}
				} catch (e) {}
			}

			return Sizzle(expr, document, null, [elem]).length > 0;
		};

		Sizzle.contains = function (context, elem) {
			// Set document vars if needed
			if ((context.ownerDocument || context) !== document) {
				setDocument(context);
			}
			return contains(context, elem);
		};

		Sizzle.attr = function (elem, name) {
			// Set document vars if needed
			if ((elem.ownerDocument || elem) !== document) {
				setDocument(elem);
			}

			var fn = Expr.attrHandle[name.toLowerCase()],

			// Don't get fooled by Object.prototype properties (jQuery #13807)
			val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;

			return val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
		};

		Sizzle.escape = function (sel) {
			return (sel + "").replace(rcssescape, fcssescape);
		};

		Sizzle.error = function (msg) {
			throw new Error("Syntax error, unrecognized expression: " + msg);
		};

		/**
   * Document sorting and removing duplicates
   * @param {ArrayLike} results
   */
		Sizzle.uniqueSort = function (results) {
			var elem,
			    duplicates = [],
			    j = 0,
			    i = 0;

			// Unless we *know* we can detect duplicates, assume their presence
			hasDuplicate = !support.detectDuplicates;
			sortInput = !support.sortStable && results.slice(0);
			results.sort(sortOrder);

			if (hasDuplicate) {
				while (elem = results[i++]) {
					if (elem === results[i]) {
						j = duplicates.push(i);
					}
				}
				while (j--) {
					results.splice(duplicates[j], 1);
				}
			}

			// Clear input after sorting to release objects
			// See https://github.com/jquery/sizzle/pull/225
			sortInput = null;

			return results;
		};

		/**
   * Utility function for retrieving the text value of an array of DOM nodes
   * @param {Array|Element} elem
   */
		getText = Sizzle.getText = function (elem) {
			var node,
			    ret = "",
			    i = 0,
			    nodeType = elem.nodeType;

			if (!nodeType) {
				// If no nodeType, this is expected to be an array
				while (node = elem[i++]) {
					// Do not traverse comment nodes
					ret += getText(node);
				}
			} else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
				// Use textContent for elements
				// innerText usage removed for consistency of new lines (jQuery #11153)
				if (typeof elem.textContent === "string") {
					return elem.textContent;
				} else {
					// Traverse its children
					for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
						ret += getText(elem);
					}
				}
			} else if (nodeType === 3 || nodeType === 4) {
				return elem.nodeValue;
			}
			// Do not include comment or processing instruction nodes

			return ret;
		};

		Expr = Sizzle.selectors = {

			// Can be adjusted by the user
			cacheLength: 50,

			createPseudo: markFunction,

			match: matchExpr,

			attrHandle: {},

			find: {},

			relative: {
				">": { dir: "parentNode", first: true },
				" ": { dir: "parentNode" },
				"+": { dir: "previousSibling", first: true },
				"~": { dir: "previousSibling" }
			},

			preFilter: {
				"ATTR": function (match) {
					match[1] = match[1].replace(runescape, funescape);

					// Move the given value to match[3] whether quoted or unquoted
					match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);

					if (match[2] === "~=") {
						match[3] = " " + match[3] + " ";
					}

					return match.slice(0, 4);
				},

				"CHILD": function (match) {
					/* matches from matchExpr["CHILD"]
     	1 type (only|nth|...)
     	2 what (child|of-type)
     	3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
     	4 xn-component of xn+y argument ([+-]?\d*n|)
     	5 sign of xn-component
     	6 x of xn-component
     	7 sign of y-component
     	8 y of y-component
     */
					match[1] = match[1].toLowerCase();

					if (match[1].slice(0, 3) === "nth") {
						// nth-* requires argument
						if (!match[3]) {
							Sizzle.error(match[0]);
						}

						// numeric x and y parameters for Expr.filter.CHILD
						// remember that false/true cast respectively to 0/1
						match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
						match[5] = +(match[7] + match[8] || match[3] === "odd");

						// other types prohibit arguments
					} else if (match[3]) {
						Sizzle.error(match[0]);
					}

					return match;
				},

				"PSEUDO": function (match) {
					var excess,
					    unquoted = !match[6] && match[2];

					if (matchExpr["CHILD"].test(match[0])) {
						return null;
					}

					// Accept quoted arguments as-is
					if (match[3]) {
						match[2] = match[4] || match[5] || "";

						// Strip excess characters from unquoted arguments
					} else if (unquoted && rpseudo.test(unquoted) && (
					// Get excess from tokenize (recursively)
					excess = tokenize(unquoted, true)) && (
					// advance to the next closing parenthesis
					excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {

						// excess is a negative index
						match[0] = match[0].slice(0, excess);
						match[2] = unquoted.slice(0, excess);
					}

					// Return only captures needed by the pseudo filter method (type and argument)
					return match.slice(0, 3);
				}
			},

			filter: {

				"TAG": function (nodeNameSelector) {
					var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
					return nodeNameSelector === "*" ? function () {
						return true;
					} : function (elem) {
						return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
					};
				},

				"CLASS": function (className) {
					var pattern = classCache[className + " "];

					return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function (elem) {
						return pattern.test(typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "");
					});
				},

				"ATTR": function (name, operator, check) {
					return function (elem) {
						var result = Sizzle.attr(elem, name);

						if (result == null) {
							return operator === "!=";
						}
						if (!operator) {
							return true;
						}

						result += "";

						return operator === "=" ? result === check : operator === "!=" ? result !== check : operator === "^=" ? check && result.indexOf(check) === 0 : operator === "*=" ? check && result.indexOf(check) > -1 : operator === "$=" ? check && result.slice(-check.length) === check : operator === "~=" ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1 : operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" : false;
					};
				},

				"CHILD": function (type, what, argument, first, last) {
					var simple = type.slice(0, 3) !== "nth",
					    forward = type.slice(-4) !== "last",
					    ofType = what === "of-type";

					return first === 1 && last === 0 ?

					// Shortcut for :nth-*(n)
					function (elem) {
						return !!elem.parentNode;
					} : function (elem, context, xml) {
						var cache,
						    uniqueCache,
						    outerCache,
						    node,
						    nodeIndex,
						    start,
						    dir = simple !== forward ? "nextSibling" : "previousSibling",
						    parent = elem.parentNode,
						    name = ofType && elem.nodeName.toLowerCase(),
						    useCache = !xml && !ofType,
						    diff = false;

						if (parent) {

							// :(first|last|only)-(child|of-type)
							if (simple) {
								while (dir) {
									node = elem;
									while (node = node[dir]) {
										if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {

											return false;
										}
									}
									// Reverse direction for :only-* (if we haven't yet done so)
									start = dir = type === "only" && !start && "nextSibling";
								}
								return true;
							}

							start = [forward ? parent.firstChild : parent.lastChild];

							// non-xml :nth-child(...) stores cache data on `parent`
							if (forward && useCache) {

								// Seek `elem` from a previously-cached index

								// ...in a gzip-friendly way
								node = parent;
								outerCache = node[expando] || (node[expando] = {});

								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});

								cache = uniqueCache[type] || [];
								nodeIndex = cache[0] === dirruns && cache[1];
								diff = nodeIndex && cache[2];
								node = nodeIndex && parent.childNodes[nodeIndex];

								while (node = ++nodeIndex && node && node[dir] || (

								// Fallback to seeking `elem` from the start
								diff = nodeIndex = 0) || start.pop()) {

									// When found, cache indexes on `parent` and break
									if (node.nodeType === 1 && ++diff && node === elem) {
										uniqueCache[type] = [dirruns, nodeIndex, diff];
										break;
									}
								}
							} else {
								// Use previously-cached element index if available
								if (useCache) {
									// ...in a gzip-friendly way
									node = elem;
									outerCache = node[expando] || (node[expando] = {});

									// Support: IE <9 only
									// Defend against cloned attroperties (jQuery gh-1709)
									uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});

									cache = uniqueCache[type] || [];
									nodeIndex = cache[0] === dirruns && cache[1];
									diff = nodeIndex;
								}

								// xml :nth-child(...)
								// or :nth-last-child(...) or :nth(-last)?-of-type(...)
								if (diff === false) {
									// Use the same loop as above to seek `elem` from the start
									while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {

										if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {

											// Cache the index of each encountered element
											if (useCache) {
												outerCache = node[expando] || (node[expando] = {});

												// Support: IE <9 only
												// Defend against cloned attroperties (jQuery gh-1709)
												uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});

												uniqueCache[type] = [dirruns, diff];
											}

											if (node === elem) {
												break;
											}
										}
									}
								}
							}

							// Incorporate the offset, then check against cycle size
							diff -= last;
							return diff === first || diff % first === 0 && diff / first >= 0;
						}
					};
				},

				"PSEUDO": function (pseudo, argument) {
					// pseudo-class names are case-insensitive
					// http://www.w3.org/TR/selectors/#pseudo-classes
					// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
					// Remember that setFilters inherits from pseudos
					var args,
					    fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error("unsupported pseudo: " + pseudo);

					// The user may use createPseudo to indicate that
					// arguments are needed to create the filter function
					// just as Sizzle does
					if (fn[expando]) {
						return fn(argument);
					}

					// But maintain support for old signatures
					if (fn.length > 1) {
						args = [pseudo, pseudo, "", argument];
						return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function (seed, matches) {
							var idx,
							    matched = fn(seed, argument),
							    i = matched.length;
							while (i--) {
								idx = indexOf(seed, matched[i]);
								seed[idx] = !(matches[idx] = matched[i]);
							}
						}) : function (elem) {
							return fn(elem, 0, args);
						};
					}

					return fn;
				}
			},

			pseudos: {
				// Potentially complex pseudos
				"not": markFunction(function (selector) {
					// Trim the selector passed to compile
					// to avoid treating leading and trailing
					// spaces as combinators
					var input = [],
					    results = [],
					    matcher = compile(selector.replace(rtrim, "$1"));

					return matcher[expando] ? markFunction(function (seed, matches, context, xml) {
						var elem,
						    unmatched = matcher(seed, null, xml, []),
						    i = seed.length;

						// Match elements unmatched by `matcher`
						while (i--) {
							if (elem = unmatched[i]) {
								seed[i] = !(matches[i] = elem);
							}
						}
					}) : function (elem, context, xml) {
						input[0] = elem;
						matcher(input, null, xml, results);
						// Don't keep the element (issue #299)
						input[0] = null;
						return !results.pop();
					};
				}),

				"has": markFunction(function (selector) {
					return function (elem) {
						return Sizzle(selector, elem).length > 0;
					};
				}),

				"contains": markFunction(function (text) {
					text = text.replace(runescape, funescape);
					return function (elem) {
						return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
					};
				}),

				// "Whether an element is represented by a :lang() selector
				// is based solely on the element's language value
				// being equal to the identifier C,
				// or beginning with the identifier C immediately followed by "-".
				// The matching of C against the element's language value is performed case-insensitively.
				// The identifier C does not have to be a valid language name."
				// http://www.w3.org/TR/selectors/#lang-pseudo
				"lang": markFunction(function (lang) {
					// lang value must be a valid identifier
					if (!ridentifier.test(lang || "")) {
						Sizzle.error("unsupported lang: " + lang);
					}
					lang = lang.replace(runescape, funescape).toLowerCase();
					return function (elem) {
						var elemLang;
						do {
							if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang")) {

								elemLang = elemLang.toLowerCase();
								return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
							}
						} while ((elem = elem.parentNode) && elem.nodeType === 1);
						return false;
					};
				}),

				// Miscellaneous
				"target": function (elem) {
					var hash = window.location && window.location.hash;
					return hash && hash.slice(1) === elem.id;
				},

				"root": function (elem) {
					return elem === docElem;
				},

				"focus": function (elem) {
					return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
				},

				// Boolean properties
				"enabled": createDisabledPseudo(false),
				"disabled": createDisabledPseudo(true),

				"checked": function (elem) {
					// In CSS3, :checked should return both checked and selected elements
					// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
					var nodeName = elem.nodeName.toLowerCase();
					return nodeName === "input" && !!elem.checked || nodeName === "option" && !!elem.selected;
				},

				"selected": function (elem) {
					// Accessing this property makes selected-by-default
					// options in Safari work properly
					if (elem.parentNode) {
						elem.parentNode.selectedIndex;
					}

					return elem.selected === true;
				},

				// Contents
				"empty": function (elem) {
					// http://www.w3.org/TR/selectors/#empty-pseudo
					// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
					//   but not by others (comment: 8; processing instruction: 7; etc.)
					// nodeType < 6 works because attributes (2) do not appear as children
					for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
						if (elem.nodeType < 6) {
							return false;
						}
					}
					return true;
				},

				"parent": function (elem) {
					return !Expr.pseudos["empty"](elem);
				},

				// Element/input types
				"header": function (elem) {
					return rheader.test(elem.nodeName);
				},

				"input": function (elem) {
					return rinputs.test(elem.nodeName);
				},

				"button": function (elem) {
					var name = elem.nodeName.toLowerCase();
					return name === "input" && elem.type === "button" || name === "button";
				},

				"text": function (elem) {
					var attr;
					return elem.nodeName.toLowerCase() === "input" && elem.type === "text" && (

					// Support: IE<8
					// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
					(attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
				},

				// Position-in-collection
				"first": createPositionalPseudo(function () {
					return [0];
				}),

				"last": createPositionalPseudo(function (matchIndexes, length) {
					return [length - 1];
				}),

				"eq": createPositionalPseudo(function (matchIndexes, length, argument) {
					return [argument < 0 ? argument + length : argument];
				}),

				"even": createPositionalPseudo(function (matchIndexes, length) {
					var i = 0;
					for (; i < length; i += 2) {
						matchIndexes.push(i);
					}
					return matchIndexes;
				}),

				"odd": createPositionalPseudo(function (matchIndexes, length) {
					var i = 1;
					for (; i < length; i += 2) {
						matchIndexes.push(i);
					}
					return matchIndexes;
				}),

				"lt": createPositionalPseudo(function (matchIndexes, length, argument) {
					var i = argument < 0 ? argument + length : argument;
					for (; --i >= 0;) {
						matchIndexes.push(i);
					}
					return matchIndexes;
				}),

				"gt": createPositionalPseudo(function (matchIndexes, length, argument) {
					var i = argument < 0 ? argument + length : argument;
					for (; ++i < length;) {
						matchIndexes.push(i);
					}
					return matchIndexes;
				})
			}
		};

		Expr.pseudos["nth"] = Expr.pseudos["eq"];

		// Add button/input type pseudos
		for (i in { radio: true, checkbox: true, file: true, password: true, image: true }) {
			Expr.pseudos[i] = createInputPseudo(i);
		}
		for (i in { submit: true, reset: true }) {
			Expr.pseudos[i] = createButtonPseudo(i);
		}

		// Easy API for creating new setFilters
		function setFilters() {}
		setFilters.prototype = Expr.filters = Expr.pseudos;
		Expr.setFilters = new setFilters();

		tokenize = Sizzle.tokenize = function (selector, parseOnly) {
			var matched,
			    match,
			    tokens,
			    type,
			    soFar,
			    groups,
			    preFilters,
			    cached = tokenCache[selector + " "];

			if (cached) {
				return parseOnly ? 0 : cached.slice(0);
			}

			soFar = selector;
			groups = [];
			preFilters = Expr.preFilter;

			while (soFar) {

				// Comma and first run
				if (!matched || (match = rcomma.exec(soFar))) {
					if (match) {
						// Don't consume trailing commas as valid
						soFar = soFar.slice(match[0].length) || soFar;
					}
					groups.push(tokens = []);
				}

				matched = false;

				// Combinators
				if (match = rcombinators.exec(soFar)) {
					matched = match.shift();
					tokens.push({
						value: matched,
						// Cast descendant combinators to space
						type: match[0].replace(rtrim, " ")
					});
					soFar = soFar.slice(matched.length);
				}

				// Filters
				for (type in Expr.filter) {
					if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
						matched = match.shift();
						tokens.push({
							value: matched,
							type: type,
							matches: match
						});
						soFar = soFar.slice(matched.length);
					}
				}

				if (!matched) {
					break;
				}
			}

			// Return the length of the invalid excess
			// if we're just parsing
			// Otherwise, throw an error or return tokens
			return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) :
			// Cache the tokens
			tokenCache(selector, groups).slice(0);
		};

		function toSelector(tokens) {
			var i = 0,
			    len = tokens.length,
			    selector = "";
			for (; i < len; i++) {
				selector += tokens[i].value;
			}
			return selector;
		}

		function addCombinator(matcher, combinator, base) {
			var dir = combinator.dir,
			    skip = combinator.next,
			    key = skip || dir,
			    checkNonElements = base && key === "parentNode",
			    doneName = done++;

			return combinator.first ?
			// Check against closest ancestor/preceding element
			function (elem, context, xml) {
				while (elem = elem[dir]) {
					if (elem.nodeType === 1 || checkNonElements) {
						return matcher(elem, context, xml);
					}
				}
				return false;
			} :

			// Check against all ancestor/preceding elements
			function (elem, context, xml) {
				var oldCache,
				    uniqueCache,
				    outerCache,
				    newCache = [dirruns, doneName];

				// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
				if (xml) {
					while (elem = elem[dir]) {
						if (elem.nodeType === 1 || checkNonElements) {
							if (matcher(elem, context, xml)) {
								return true;
							}
						}
					}
				} else {
					while (elem = elem[dir]) {
						if (elem.nodeType === 1 || checkNonElements) {
							outerCache = elem[expando] || (elem[expando] = {});

							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {});

							if (skip && skip === elem.nodeName.toLowerCase()) {
								elem = elem[dir] || elem;
							} else if ((oldCache = uniqueCache[key]) && oldCache[0] === dirruns && oldCache[1] === doneName) {

								// Assign to newCache so results back-propagate to previous elements
								return newCache[2] = oldCache[2];
							} else {
								// Reuse newcache so results back-propagate to previous elements
								uniqueCache[key] = newCache;

								// A match means we're done; a fail means we have to keep checking
								if (newCache[2] = matcher(elem, context, xml)) {
									return true;
								}
							}
						}
					}
				}
				return false;
			};
		}

		function elementMatcher(matchers) {
			return matchers.length > 1 ? function (elem, context, xml) {
				var i = matchers.length;
				while (i--) {
					if (!matchers[i](elem, context, xml)) {
						return false;
					}
				}
				return true;
			} : matchers[0];
		}

		function multipleContexts(selector, contexts, results) {
			var i = 0,
			    len = contexts.length;
			for (; i < len; i++) {
				Sizzle(selector, contexts[i], results);
			}
			return results;
		}

		function condense(unmatched, map, filter, context, xml) {
			var elem,
			    newUnmatched = [],
			    i = 0,
			    len = unmatched.length,
			    mapped = map != null;

			for (; i < len; i++) {
				if (elem = unmatched[i]) {
					if (!filter || filter(elem, context, xml)) {
						newUnmatched.push(elem);
						if (mapped) {
							map.push(i);
						}
					}
				}
			}

			return newUnmatched;
		}

		function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
			if (postFilter && !postFilter[expando]) {
				postFilter = setMatcher(postFilter);
			}
			if (postFinder && !postFinder[expando]) {
				postFinder = setMatcher(postFinder, postSelector);
			}
			return markFunction(function (seed, results, context, xml) {
				var temp,
				    i,
				    elem,
				    preMap = [],
				    postMap = [],
				    preexisting = results.length,


				// Get initial elements from seed or context
				elems = seed || multipleContexts(selector || "*", context.nodeType ? [context] : context, []),


				// Prefilter to get matcher input, preserving a map for seed-results synchronization
				matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems,
				    matcherOut = matcher ?
				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || (seed ? preFilter : preexisting || postFilter) ?

				// ...intermediate processing is necessary
				[] :

				// ...otherwise use results directly
				results : matcherIn;

				// Find primary matches
				if (matcher) {
					matcher(matcherIn, matcherOut, context, xml);
				}

				// Apply postFilter
				if (postFilter) {
					temp = condense(matcherOut, postMap);
					postFilter(temp, [], context, xml);

					// Un-match failing elements by moving them back to matcherIn
					i = temp.length;
					while (i--) {
						if (elem = temp[i]) {
							matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
						}
					}
				}

				if (seed) {
					if (postFinder || preFilter) {
						if (postFinder) {
							// Get the final matcherOut by condensing this intermediate into postFinder contexts
							temp = [];
							i = matcherOut.length;
							while (i--) {
								if (elem = matcherOut[i]) {
									// Restore matcherIn since elem is not yet a final match
									temp.push(matcherIn[i] = elem);
								}
							}
							postFinder(null, matcherOut = [], temp, xml);
						}

						// Move matched elements from seed to results to keep them synchronized
						i = matcherOut.length;
						while (i--) {
							if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {

								seed[temp] = !(results[temp] = elem);
							}
						}
					}

					// Add elements to results, through postFinder if defined
				} else {
					matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);
					if (postFinder) {
						postFinder(null, results, matcherOut, xml);
					} else {
						push.apply(results, matcherOut);
					}
				}
			});
		}

		function matcherFromTokens(tokens) {
			var checkContext,
			    matcher,
			    j,
			    len = tokens.length,
			    leadingRelative = Expr.relative[tokens[0].type],
			    implicitRelative = leadingRelative || Expr.relative[" "],
			    i = leadingRelative ? 1 : 0,


			// The foundational matcher ensures that elements are reachable from top-level context(s)
			matchContext = addCombinator(function (elem) {
				return elem === checkContext;
			}, implicitRelative, true),
			    matchAnyContext = addCombinator(function (elem) {
				return indexOf(checkContext, elem) > -1;
			}, implicitRelative, true),
			    matchers = [function (elem, context, xml) {
				var ret = !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
				// Avoid hanging onto element (issue #299)
				checkContext = null;
				return ret;
			}];

			for (; i < len; i++) {
				if (matcher = Expr.relative[tokens[i].type]) {
					matchers = [addCombinator(elementMatcher(matchers), matcher)];
				} else {
					matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);

					// Return special upon seeing a positional matcher
					if (matcher[expando]) {
						// Find the next relative operator (if any) for proper handling
						j = ++i;
						for (; j < len; j++) {
							if (Expr.relative[tokens[j].type]) {
								break;
							}
						}
						return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(
						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice(0, i - 1).concat({ value: tokens[i - 2].type === " " ? "*" : "" })).replace(rtrim, "$1"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));
					}
					matchers.push(matcher);
				}
			}

			return elementMatcher(matchers);
		}

		function matcherFromGroupMatchers(elementMatchers, setMatchers) {
			var bySet = setMatchers.length > 0,
			    byElement = elementMatchers.length > 0,
			    superMatcher = function (seed, context, xml, results, outermost) {
				var elem,
				    j,
				    matcher,
				    matchedCount = 0,
				    i = "0",
				    unmatched = seed && [],
				    setMatched = [],
				    contextBackup = outermostContext,

				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find["TAG"]("*", outermost),

				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1,
				    len = elems.length;

				if (outermost) {
					outermostContext = context === document || context || outermost;
				}

				// Add elements passing elementMatchers directly to results
				// Support: IE<9, Safari
				// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
				for (; i !== len && (elem = elems[i]) != null; i++) {
					if (byElement && elem) {
						j = 0;
						if (!context && elem.ownerDocument !== document) {
							setDocument(elem);
							xml = !documentIsHTML;
						}
						while (matcher = elementMatchers[j++]) {
							if (matcher(elem, context || document, xml)) {
								results.push(elem);
								break;
							}
						}
						if (outermost) {
							dirruns = dirrunsUnique;
						}
					}

					// Track unmatched elements for set filters
					if (bySet) {
						// They will have gone through all possible matchers
						if (elem = !matcher && elem) {
							matchedCount--;
						}

						// Lengthen the array for every element, matched or not
						if (seed) {
							unmatched.push(elem);
						}
					}
				}

				// `i` is now the count of elements visited above, and adding it to `matchedCount`
				// makes the latter nonnegative.
				matchedCount += i;

				// Apply set filters to unmatched elements
				// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
				// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
				// no element matchers and no seed.
				// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
				// case, which will result in a "00" `matchedCount` that differs from `i` but is also
				// numerically zero.
				if (bySet && i !== matchedCount) {
					j = 0;
					while (matcher = setMatchers[j++]) {
						matcher(unmatched, setMatched, context, xml);
					}

					if (seed) {
						// Reintegrate element matches to eliminate the need for sorting
						if (matchedCount > 0) {
							while (i--) {
								if (!(unmatched[i] || setMatched[i])) {
									setMatched[i] = pop.call(results);
								}
							}
						}

						// Discard index placeholder values to get only actual matches
						setMatched = condense(setMatched);
					}

					// Add matches to results
					push.apply(results, setMatched);

					// Seedless set matches succeeding multiple successful matchers stipulate sorting
					if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {

						Sizzle.uniqueSort(results);
					}
				}

				// Override manipulation of globals by nested matchers
				if (outermost) {
					dirruns = dirrunsUnique;
					outermostContext = contextBackup;
				}

				return unmatched;
			};

			return bySet ? markFunction(superMatcher) : superMatcher;
		}

		compile = Sizzle.compile = function (selector, match /* Internal Use Only */) {
			var i,
			    setMatchers = [],
			    elementMatchers = [],
			    cached = compilerCache[selector + " "];

			if (!cached) {
				// Generate a function of recursive functions that can be used to check each element
				if (!match) {
					match = tokenize(selector);
				}
				i = match.length;
				while (i--) {
					cached = matcherFromTokens(match[i]);
					if (cached[expando]) {
						setMatchers.push(cached);
					} else {
						elementMatchers.push(cached);
					}
				}

				// Cache the compiled function
				cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));

				// Save selector and tokenization
				cached.selector = selector;
			}
			return cached;
		};

		/**
   * A low-level selection function that works with Sizzle's compiled
   *  selector functions
   * @param {String|Function} selector A selector or a pre-compiled
   *  selector function built with Sizzle.compile
   * @param {Element} context
   * @param {Array} [results]
   * @param {Array} [seed] A set of elements to match against
   */
		select = Sizzle.select = function (selector, context, results, seed) {
			var i,
			    tokens,
			    token,
			    type,
			    find,
			    compiled = typeof selector === "function" && selector,
			    match = !seed && tokenize(selector = compiled.selector || selector);

			results = results || [];

			// Try to minimize operations if there is only one selector in the list and no seed
			// (the latter of which guarantees us context)
			if (match.length === 1) {

				// Reduce context if the leading compound selector is an ID
				tokens = match[0] = match[0].slice(0);
				if (tokens.length > 2 && (token = tokens[0]).type === "ID" && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {

					context = (Expr.find["ID"](token.matches[0].replace(runescape, funescape), context) || [])[0];
					if (!context) {
						return results;

						// Precompiled matchers will still verify ancestry, so step up a level
					} else if (compiled) {
						context = context.parentNode;
					}

					selector = selector.slice(tokens.shift().value.length);
				}

				// Fetch a seed set for right-to-left matching
				i = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;
				while (i--) {
					token = tokens[i];

					// Abort if we hit a combinator
					if (Expr.relative[type = token.type]) {
						break;
					}
					if (find = Expr.find[type]) {
						// Search, expanding context for leading sibling combinators
						if (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context)) {

							// If seed is empty or no tokens remain, we can return early
							tokens.splice(i, 1);
							selector = seed.length && toSelector(tokens);
							if (!selector) {
								push.apply(results, seed);
								return results;
							}

							break;
						}
					}
				}
			}

			// Compile and execute a filtering function if one is not provided
			// Provide `match` to avoid retokenization if we modified the selector above
			(compiled || compile(selector, match))(seed, context, !documentIsHTML, results, !context || rsibling.test(selector) && testContext(context.parentNode) || context);
			return results;
		};

		// One-time assignments

		// Sort stability
		support.sortStable = expando.split("").sort(sortOrder).join("") === expando;

		// Support: Chrome 14-35+
		// Always assume duplicates if they aren't passed to the comparison function
		support.detectDuplicates = !!hasDuplicate;

		// Initialize against the default document
		setDocument();

		// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
		// Detached nodes confoundingly follow *each other*
		support.sortDetached = assert(function (el) {
			// Should return 1, but returns 4 (following)
			return el.compareDocumentPosition(document.createElement("fieldset")) & 1;
		});

		// Support: IE<8
		// Prevent attribute/property "interpolation"
		// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
		if (!assert(function (el) {
			el.innerHTML = "<a href='#'></a>";
			return el.firstChild.getAttribute("href") === "#";
		})) {
			addHandle("type|href|height|width", function (elem, name, isXML) {
				if (!isXML) {
					return elem.getAttribute(name, name.toLowerCase() === "type" ? 1 : 2);
				}
			});
		}

		// Support: IE<9
		// Use defaultValue in place of getAttribute("value")
		if (!support.attributes || !assert(function (el) {
			el.innerHTML = "<input/>";
			el.firstChild.setAttribute("value", "");
			return el.firstChild.getAttribute("value") === "";
		})) {
			addHandle("value", function (elem, name, isXML) {
				if (!isXML && elem.nodeName.toLowerCase() === "input") {
					return elem.defaultValue;
				}
			});
		}

		// Support: IE<9
		// Use getAttributeNode to fetch booleans when getAttribute lies
		if (!assert(function (el) {
			return el.getAttribute("disabled") == null;
		})) {
			addHandle(booleans, function (elem, name, isXML) {
				var val;
				if (!isXML) {
					return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
				}
			});
		}

		return Sizzle;
	}(window);

	jQuery.find = Sizzle;
	jQuery.expr = Sizzle.selectors;

	// Deprecated
	jQuery.expr[":"] = jQuery.expr.pseudos;
	jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
	jQuery.text = Sizzle.getText;
	jQuery.isXMLDoc = Sizzle.isXML;
	jQuery.contains = Sizzle.contains;
	jQuery.escapeSelector = Sizzle.escape;

	var dir = function (elem, dir, until) {
		var matched = [],
		    truncate = until !== undefined;

		while ((elem = elem[dir]) && elem.nodeType !== 9) {
			if (elem.nodeType === 1) {
				if (truncate && jQuery(elem).is(until)) {
					break;
				}
				matched.push(elem);
			}
		}
		return matched;
	};

	var siblings = function (n, elem) {
		var matched = [];

		for (; n; n = n.nextSibling) {
			if (n.nodeType === 1 && n !== elem) {
				matched.push(n);
			}
		}

		return matched;
	};

	var rneedsContext = jQuery.expr.match.needsContext;

	var rsingleTag = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;

	var risSimple = /^.[^:#\[\.,]*$/;

	// Implement the identical functionality for filter and not
	function winnow(elements, qualifier, not) {
		if (jQuery.isFunction(qualifier)) {
			return jQuery.grep(elements, function (elem, i) {
				return !!qualifier.call(elem, i, elem) !== not;
			});
		}

		// Single element
		if (qualifier.nodeType) {
			return jQuery.grep(elements, function (elem) {
				return elem === qualifier !== not;
			});
		}

		// Arraylike of elements (jQuery, arguments, Array)
		if (typeof qualifier !== "string") {
			return jQuery.grep(elements, function (elem) {
				return indexOf.call(qualifier, elem) > -1 !== not;
			});
		}

		// Simple selector that can be filtered directly, removing non-Elements
		if (risSimple.test(qualifier)) {
			return jQuery.filter(qualifier, elements, not);
		}

		// Complex selector, compare the two sets, removing non-Elements
		qualifier = jQuery.filter(qualifier, elements);
		return jQuery.grep(elements, function (elem) {
			return indexOf.call(qualifier, elem) > -1 !== not && elem.nodeType === 1;
		});
	}

	jQuery.filter = function (expr, elems, not) {
		var elem = elems[0];

		if (not) {
			expr = ":not(" + expr + ")";
		}

		if (elems.length === 1 && elem.nodeType === 1) {
			return jQuery.find.matchesSelector(elem, expr) ? [elem] : [];
		}

		return jQuery.find.matches(expr, jQuery.grep(elems, function (elem) {
			return elem.nodeType === 1;
		}));
	};

	jQuery.fn.extend({
		find: function (selector) {
			var i,
			    ret,
			    len = this.length,
			    self = this;

			if (typeof selector !== "string") {
				return this.pushStack(jQuery(selector).filter(function () {
					for (i = 0; i < len; i++) {
						if (jQuery.contains(self[i], this)) {
							return true;
						}
					}
				}));
			}

			ret = this.pushStack([]);

			for (i = 0; i < len; i++) {
				jQuery.find(selector, self[i], ret);
			}

			return len > 1 ? jQuery.uniqueSort(ret) : ret;
		},
		filter: function (selector) {
			return this.pushStack(winnow(this, selector || [], false));
		},
		not: function (selector) {
			return this.pushStack(winnow(this, selector || [], true));
		},
		is: function (selector) {
			return !!winnow(this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test(selector) ? jQuery(selector) : selector || [], false).length;
		}
	});

	// Initialize a jQuery object


	// A central reference to the root jQuery(document)
	var rootjQuery,


	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	// Shortcut simple #id case for speed
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,
	    init = jQuery.fn.init = function (selector, context, root) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if (!selector) {
			return this;
		}

		// Method init() accepts an alternate rootjQuery
		// so migrate can support jQuery.sub (gh-2101)
		root = root || rootjQuery;

		// Handle HTML strings
		if (typeof selector === "string") {
			if (selector[0] === "<" && selector[selector.length - 1] === ">" && selector.length >= 3) {

				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [null, selector, null];
			} else {
				match = rquickExpr.exec(selector);
			}

			// Match html or make sure no context is specified for #id
			if (match && (match[1] || !context)) {

				// HANDLE: $(html) -> $(array)
				if (match[1]) {
					context = context instanceof jQuery ? context[0] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true));

					// HANDLE: $(html, props)
					if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
						for (match in context) {

							// Properties of context are called as methods if possible
							if (jQuery.isFunction(this[match])) {
								this[match](context[match]);

								// ...and otherwise set as attributes
							} else {
								this.attr(match, context[match]);
							}
						}
					}

					return this;

					// HANDLE: $(#id)
				} else {
					elem = document.getElementById(match[2]);

					if (elem) {

						// Inject the element directly into the jQuery object
						this[0] = elem;
						this.length = 1;
					}
					return this;
				}

				// HANDLE: $(expr, $(...))
			} else if (!context || context.jquery) {
				return (context || root).find(selector);

				// HANDLE: $(expr, context)
				// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor(context).find(selector);
			}

			// HANDLE: $(DOMElement)
		} else if (selector.nodeType) {
			this[0] = selector;
			this.length = 1;
			return this;

			// HANDLE: $(function)
			// Shortcut for document ready
		} else if (jQuery.isFunction(selector)) {
			return root.ready !== undefined ? root.ready(selector) :

			// Execute immediately if ready is not present
			selector(jQuery);
		}

		return jQuery.makeArray(selector, this);
	};

	// Give the init function the jQuery prototype for later instantiation
	init.prototype = jQuery.fn;

	// Initialize central reference
	rootjQuery = jQuery(document);

	var rparentsprev = /^(?:parents|prev(?:Until|All))/,


	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

	jQuery.fn.extend({
		has: function (target) {
			var targets = jQuery(target, this),
			    l = targets.length;

			return this.filter(function () {
				var i = 0;
				for (; i < l; i++) {
					if (jQuery.contains(this, targets[i])) {
						return true;
					}
				}
			});
		},

		closest: function (selectors, context) {
			var cur,
			    i = 0,
			    l = this.length,
			    matched = [],
			    targets = typeof selectors !== "string" && jQuery(selectors);

			// Positional selectors never match, since there's no _selection_ context
			if (!rneedsContext.test(selectors)) {
				for (; i < l; i++) {
					for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {

						// Always skip document fragments
						if (cur.nodeType < 11 && (targets ? targets.index(cur) > -1 :

						// Don't pass non-elements to Sizzle
						cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {

							matched.push(cur);
							break;
						}
					}
				}
			}

			return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched);
		},

		// Determine the position of an element within the set
		index: function (elem) {

			// No argument, return index in parent
			if (!elem) {
				return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
			}

			// Index in selector
			if (typeof elem === "string") {
				return indexOf.call(jQuery(elem), this[0]);
			}

			// Locate the position of the desired element
			return indexOf.call(this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[0] : elem);
		},

		add: function (selector, context) {
			return this.pushStack(jQuery.uniqueSort(jQuery.merge(this.get(), jQuery(selector, context))));
		},

		addBack: function (selector) {
			return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
		}
	});

	function sibling(cur, dir) {
		while ((cur = cur[dir]) && cur.nodeType !== 1) {}
		return cur;
	}

	jQuery.each({
		parent: function (elem) {
			var parent = elem.parentNode;
			return parent && parent.nodeType !== 11 ? parent : null;
		},
		parents: function (elem) {
			return dir(elem, "parentNode");
		},
		parentsUntil: function (elem, i, until) {
			return dir(elem, "parentNode", until);
		},
		next: function (elem) {
			return sibling(elem, "nextSibling");
		},
		prev: function (elem) {
			return sibling(elem, "previousSibling");
		},
		nextAll: function (elem) {
			return dir(elem, "nextSibling");
		},
		prevAll: function (elem) {
			return dir(elem, "previousSibling");
		},
		nextUntil: function (elem, i, until) {
			return dir(elem, "nextSibling", until);
		},
		prevUntil: function (elem, i, until) {
			return dir(elem, "previousSibling", until);
		},
		siblings: function (elem) {
			return siblings((elem.parentNode || {}).firstChild, elem);
		},
		children: function (elem) {
			return siblings(elem.firstChild);
		},
		contents: function (elem) {
			return elem.contentDocument || jQuery.merge([], elem.childNodes);
		}
	}, function (name, fn) {
		jQuery.fn[name] = function (until, selector) {
			var matched = jQuery.map(this, fn, until);

			if (name.slice(-5) !== "Until") {
				selector = until;
			}

			if (selector && typeof selector === "string") {
				matched = jQuery.filter(selector, matched);
			}

			if (this.length > 1) {

				// Remove duplicates
				if (!guaranteedUnique[name]) {
					jQuery.uniqueSort(matched);
				}

				// Reverse order for parents* and prev-derivatives
				if (rparentsprev.test(name)) {
					matched.reverse();
				}
			}

			return this.pushStack(matched);
		};
	});
	var rnothtmlwhite = /[^\x20\t\r\n\f]+/g;

	// Convert String-formatted options into Object-formatted ones
	function createOptions(options) {
		var object = {};
		jQuery.each(options.match(rnothtmlwhite) || [], function (_, flag) {
			object[flag] = true;
		});
		return object;
	}

	/*
  * Create a callback list using the following parameters:
  *
  *	options: an optional list of space-separated options that will change how
  *			the callback list behaves or a more traditional option object
  *
  * By default a callback list will act like an event callback list and can be
  * "fired" multiple times.
  *
  * Possible options:
  *
  *	once:			will ensure the callback list can only be fired once (like a Deferred)
  *
  *	memory:			will keep track of previous values and will call any callback added
  *					after the list has been fired right away with the latest "memorized"
  *					values (like a Deferred)
  *
  *	unique:			will ensure a callback can only be added once (no duplicate in the list)
  *
  *	stopOnFalse:	interrupt callings when a callback returns false
  *
  */
	jQuery.Callbacks = function (options) {

		// Convert options from String-formatted to Object-formatted if needed
		// (we check in cache first)
		options = typeof options === "string" ? createOptions(options) : jQuery.extend({}, options);

		var // Flag to know if list is currently firing
		firing,


		// Last fire value for non-forgettable lists
		memory,


		// Flag to know if list was already fired
		fired,


		// Flag to prevent firing
		locked,


		// Actual callback list
		list = [],


		// Queue of execution data for repeatable lists
		queue = [],


		// Index of currently firing callback (modified by add/remove as needed)
		firingIndex = -1,


		// Fire callbacks
		fire = function () {

			// Enforce single-firing
			locked = options.once;

			// Execute callbacks for all pending executions,
			// respecting firingIndex overrides and runtime changes
			fired = firing = true;
			for (; queue.length; firingIndex = -1) {
				memory = queue.shift();
				while (++firingIndex < list.length) {

					// Run callback and check for early termination
					if (list[firingIndex].apply(memory[0], memory[1]) === false && options.stopOnFalse) {

						// Jump to end and forget the data so .add doesn't re-fire
						firingIndex = list.length;
						memory = false;
					}
				}
			}

			// Forget the data if we're done with it
			if (!options.memory) {
				memory = false;
			}

			firing = false;

			// Clean up if we're done firing for good
			if (locked) {

				// Keep an empty list if we have data for future add calls
				if (memory) {
					list = [];

					// Otherwise, this object is spent
				} else {
					list = "";
				}
			}
		},


		// Actual Callbacks object
		self = {

			// Add a callback or a collection of callbacks to the list
			add: function () {
				if (list) {

					// If we have memory from a past run, we should fire after adding
					if (memory && !firing) {
						firingIndex = list.length - 1;
						queue.push(memory);
					}

					(function add(args) {
						jQuery.each(args, function (_, arg) {
							if (jQuery.isFunction(arg)) {
								if (!options.unique || !self.has(arg)) {
									list.push(arg);
								}
							} else if (arg && arg.length && jQuery.type(arg) !== "string") {

								// Inspect recursively
								add(arg);
							}
						});
					})(arguments);

					if (memory && !firing) {
						fire();
					}
				}
				return this;
			},

			// Remove a callback from the list
			remove: function () {
				jQuery.each(arguments, function (_, arg) {
					var index;
					while ((index = jQuery.inArray(arg, list, index)) > -1) {
						list.splice(index, 1);

						// Handle firing indexes
						if (index <= firingIndex) {
							firingIndex--;
						}
					}
				});
				return this;
			},

			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function (fn) {
				return fn ? jQuery.inArray(fn, list) > -1 : list.length > 0;
			},

			// Remove all callbacks from the list
			empty: function () {
				if (list) {
					list = [];
				}
				return this;
			},

			// Disable .fire and .add
			// Abort any current/pending executions
			// Clear all callbacks and values
			disable: function () {
				locked = queue = [];
				list = memory = "";
				return this;
			},
			disabled: function () {
				return !list;
			},

			// Disable .fire
			// Also disable .add unless we have memory (since it would have no effect)
			// Abort any pending executions
			lock: function () {
				locked = queue = [];
				if (!memory && !firing) {
					list = memory = "";
				}
				return this;
			},
			locked: function () {
				return !!locked;
			},

			// Call all callbacks with the given context and arguments
			fireWith: function (context, args) {
				if (!locked) {
					args = args || [];
					args = [context, args.slice ? args.slice() : args];
					queue.push(args);
					if (!firing) {
						fire();
					}
				}
				return this;
			},

			// Call all the callbacks with the given arguments
			fire: function () {
				self.fireWith(this, arguments);
				return this;
			},

			// To know if the callbacks have already been called at least once
			fired: function () {
				return !!fired;
			}
		};

		return self;
	};

	function Identity(v) {
		return v;
	}
	function Thrower(ex) {
		throw ex;
	}

	function adoptValue(value, resolve, reject) {
		var method;

		try {

			// Check for promise aspect first to privilege synchronous behavior
			if (value && jQuery.isFunction(method = value.promise)) {
				method.call(value).done(resolve).fail(reject);

				// Other thenables
			} else if (value && jQuery.isFunction(method = value.then)) {
				method.call(value, resolve, reject);

				// Other non-thenables
			} else {

				// Support: Android 4.0 only
				// Strict mode functions invoked without .call/.apply get global-object context
				resolve.call(undefined, value);
			}

			// For Promises/A+, convert exceptions into rejections
			// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
			// Deferred#then to conditionally suppress rejection.
		} catch (value) {

			// Support: Android 4.0 only
			// Strict mode functions invoked without .call/.apply get global-object context
			reject.call(undefined, value);
		}
	}

	jQuery.extend({

		Deferred: function (func) {
			var tuples = [

			// action, add listener, callbacks,
			// ... .then handlers, argument index, [final state]
			["notify", "progress", jQuery.Callbacks("memory"), jQuery.Callbacks("memory"), 2], ["resolve", "done", jQuery.Callbacks("once memory"), jQuery.Callbacks("once memory"), 0, "resolved"], ["reject", "fail", jQuery.Callbacks("once memory"), jQuery.Callbacks("once memory"), 1, "rejected"]],
			    state = "pending",
			    promise = {
				state: function () {
					return state;
				},
				always: function () {
					deferred.done(arguments).fail(arguments);
					return this;
				},
				"catch": function (fn) {
					return promise.then(null, fn);
				},

				// Keep pipe for back-compat
				pipe: function () /* fnDone, fnFail, fnProgress */{
					var fns = arguments;

					return jQuery.Deferred(function (newDefer) {
						jQuery.each(tuples, function (i, tuple) {

							// Map tuples (progress, done, fail) to arguments (done, fail, progress)
							var fn = jQuery.isFunction(fns[tuple[4]]) && fns[tuple[4]];

							// deferred.progress(function() { bind to newDefer or newDefer.notify })
							// deferred.done(function() { bind to newDefer or newDefer.resolve })
							// deferred.fail(function() { bind to newDefer or newDefer.reject })
							deferred[tuple[1]](function () {
								var returned = fn && fn.apply(this, arguments);
								if (returned && jQuery.isFunction(returned.promise)) {
									returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject);
								} else {
									newDefer[tuple[0] + "With"](this, fn ? [returned] : arguments);
								}
							});
						});
						fns = null;
					}).promise();
				},
				then: function (onFulfilled, onRejected, onProgress) {
					var maxDepth = 0;
					function resolve(depth, deferred, handler, special) {
						return function () {
							var that = this,
							    args = arguments,
							    mightThrow = function () {
								var returned, then;

								// Support: Promises/A+ section 2.3.3.3.3
								// https://promisesaplus.com/#point-59
								// Ignore double-resolution attempts
								if (depth < maxDepth) {
									return;
								}

								returned = handler.apply(that, args);

								// Support: Promises/A+ section 2.3.1
								// https://promisesaplus.com/#point-48
								if (returned === deferred.promise()) {
									throw new TypeError("Thenable self-resolution");
								}

								// Support: Promises/A+ sections 2.3.3.1, 3.5
								// https://promisesaplus.com/#point-54
								// https://promisesaplus.com/#point-75
								// Retrieve `then` only once
								then = returned && (

								// Support: Promises/A+ section 2.3.4
								// https://promisesaplus.com/#point-64
								// Only check objects and functions for thenability
								typeof returned === "object" || typeof returned === "function") && returned.then;

								// Handle a returned thenable
								if (jQuery.isFunction(then)) {

									// Special processors (notify) just wait for resolution
									if (special) {
										then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special));

										// Normal processors (resolve) also hook into progress
									} else {

										// ...and disregard older resolution values
										maxDepth++;

										then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special), resolve(maxDepth, deferred, Identity, deferred.notifyWith));
									}

									// Handle all other returned values
								} else {

									// Only substitute handlers pass on context
									// and multiple values (non-spec behavior)
									if (handler !== Identity) {
										that = undefined;
										args = [returned];
									}

									// Process the value(s)
									// Default process is resolve
									(special || deferred.resolveWith)(that, args);
								}
							},


							// Only normal processors (resolve) catch and reject exceptions
							process = special ? mightThrow : function () {
								try {
									mightThrow();
								} catch (e) {

									if (jQuery.Deferred.exceptionHook) {
										jQuery.Deferred.exceptionHook(e, process.stackTrace);
									}

									// Support: Promises/A+ section 2.3.3.3.4.1
									// https://promisesaplus.com/#point-61
									// Ignore post-resolution exceptions
									if (depth + 1 >= maxDepth) {

										// Only substitute handlers pass on context
										// and multiple values (non-spec behavior)
										if (handler !== Thrower) {
											that = undefined;
											args = [e];
										}

										deferred.rejectWith(that, args);
									}
								}
							};

							// Support: Promises/A+ section 2.3.3.3.1
							// https://promisesaplus.com/#point-57
							// Re-resolve promises immediately to dodge false rejection from
							// subsequent errors
							if (depth) {
								process();
							} else {

								// Call an optional hook to record the stack, in case of exception
								// since it's otherwise lost when execution goes async
								if (jQuery.Deferred.getStackHook) {
									process.stackTrace = jQuery.Deferred.getStackHook();
								}
								window.setTimeout(process);
							}
						};
					}

					return jQuery.Deferred(function (newDefer) {

						// progress_handlers.add( ... )
						tuples[0][3].add(resolve(0, newDefer, jQuery.isFunction(onProgress) ? onProgress : Identity, newDefer.notifyWith));

						// fulfilled_handlers.add( ... )
						tuples[1][3].add(resolve(0, newDefer, jQuery.isFunction(onFulfilled) ? onFulfilled : Identity));

						// rejected_handlers.add( ... )
						tuples[2][3].add(resolve(0, newDefer, jQuery.isFunction(onRejected) ? onRejected : Thrower));
					}).promise();
				},

				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function (obj) {
					return obj != null ? jQuery.extend(obj, promise) : promise;
				}
			},
			    deferred = {};

			// Add list-specific methods
			jQuery.each(tuples, function (i, tuple) {
				var list = tuple[2],
				    stateString = tuple[5];

				// promise.progress = list.add
				// promise.done = list.add
				// promise.fail = list.add
				promise[tuple[1]] = list.add;

				// Handle state
				if (stateString) {
					list.add(function () {

						// state = "resolved" (i.e., fulfilled)
						// state = "rejected"
						state = stateString;
					},

					// rejected_callbacks.disable
					// fulfilled_callbacks.disable
					tuples[3 - i][2].disable,

					// progress_callbacks.lock
					tuples[0][2].lock);
				}

				// progress_handlers.fire
				// fulfilled_handlers.fire
				// rejected_handlers.fire
				list.add(tuple[3].fire);

				// deferred.notify = function() { deferred.notifyWith(...) }
				// deferred.resolve = function() { deferred.resolveWith(...) }
				// deferred.reject = function() { deferred.rejectWith(...) }
				deferred[tuple[0]] = function () {
					deferred[tuple[0] + "With"](this === deferred ? undefined : this, arguments);
					return this;
				};

				// deferred.notifyWith = list.fireWith
				// deferred.resolveWith = list.fireWith
				// deferred.rejectWith = list.fireWith
				deferred[tuple[0] + "With"] = list.fireWith;
			});

			// Make the deferred a promise
			promise.promise(deferred);

			// Call given func if any
			if (func) {
				func.call(deferred, deferred);
			}

			// All done!
			return deferred;
		},

		// Deferred helper
		when: function (singleValue) {
			var

			// count of uncompleted subordinates
			remaining = arguments.length,


			// count of unprocessed arguments
			i = remaining,


			// subordinate fulfillment data
			resolveContexts = Array(i),
			    resolveValues = slice.call(arguments),


			// the master Deferred
			master = jQuery.Deferred(),


			// subordinate callback factory
			updateFunc = function (i) {
				return function (value) {
					resolveContexts[i] = this;
					resolveValues[i] = arguments.length > 1 ? slice.call(arguments) : value;
					if (! --remaining) {
						master.resolveWith(resolveContexts, resolveValues);
					}
				};
			};

			// Single- and empty arguments are adopted like Promise.resolve
			if (remaining <= 1) {
				adoptValue(singleValue, master.done(updateFunc(i)).resolve, master.reject);

				// Use .then() to unwrap secondary thenables (cf. gh-3000)
				if (master.state() === "pending" || jQuery.isFunction(resolveValues[i] && resolveValues[i].then)) {

					return master.then();
				}
			}

			// Multiple arguments are aggregated like Promise.all array elements
			while (i--) {
				adoptValue(resolveValues[i], updateFunc(i), master.reject);
			}

			return master.promise();
		}
	});

	// These usually indicate a programmer mistake during development,
	// warn about them ASAP rather than swallowing them by default.
	var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

	jQuery.Deferred.exceptionHook = function (error, stack) {

		// Support: IE 8 - 9 only
		// Console exists when dev tools are open, which can happen at any time
		if (window.console && window.console.warn && error && rerrorNames.test(error.name)) {
			window.console.warn("jQuery.Deferred exception: " + error.message, error.stack, stack);
		}
	};

	jQuery.readyException = function (error) {
		window.setTimeout(function () {
			throw error;
		});
	};

	// The deferred used on DOM ready
	var readyList = jQuery.Deferred();

	jQuery.fn.ready = function (fn) {

		readyList.then(fn)

		// Wrap jQuery.readyException in a function so that the lookup
		// happens at the time of error handling instead of callback
		// registration.
		.catch(function (error) {
			jQuery.readyException(error);
		});

		return this;
	};

	jQuery.extend({

		// Is the DOM ready to be used? Set to true once it occurs.
		isReady: false,

		// A counter to track how many items to wait for before
		// the ready event fires. See #6781
		readyWait: 1,

		// Hold (or release) the ready event
		holdReady: function (hold) {
			if (hold) {
				jQuery.readyWait++;
			} else {
				jQuery.ready(true);
			}
		},

		// Handle when the DOM is ready
		ready: function (wait) {

			// Abort if there are pending holds or we're already ready
			if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
				return;
			}

			// Remember that the DOM is ready
			jQuery.isReady = true;

			// If a normal DOM Ready event fired, decrement, and wait if need be
			if (wait !== true && --jQuery.readyWait > 0) {
				return;
			}

			// If there are functions bound, to execute
			readyList.resolveWith(document, [jQuery]);
		}
	});

	jQuery.ready.then = readyList.then;

	// The ready event handler and self cleanup method
	function completed() {
		document.removeEventListener("DOMContentLoaded", completed);
		window.removeEventListener("load", completed);
		jQuery.ready();
	}

	// Catch cases where $(document).ready() is called
	// after the browser event has already occurred.
	// Support: IE <=9 - 10 only
	// Older IE sometimes signals "interactive" too soon
	if (document.readyState === "complete" || document.readyState !== "loading" && !document.documentElement.doScroll) {

		// Handle it asynchronously to allow scripts the opportunity to delay ready
		window.setTimeout(jQuery.ready);
	} else {

		// Use the handy event callback
		document.addEventListener("DOMContentLoaded", completed);

		// A fallback to window.onload, that will always work
		window.addEventListener("load", completed);
	}

	// Multifunctional method to get and set values of a collection
	// The value/s can optionally be executed if it's a function
	var access = function (elems, fn, key, value, chainable, emptyGet, raw) {
		var i = 0,
		    len = elems.length,
		    bulk = key == null;

		// Sets many values
		if (jQuery.type(key) === "object") {
			chainable = true;
			for (i in key) {
				access(elems, fn, i, key[i], true, emptyGet, raw);
			}

			// Sets one value
		} else if (value !== undefined) {
			chainable = true;

			if (!jQuery.isFunction(value)) {
				raw = true;
			}

			if (bulk) {

				// Bulk operations run against the entire set
				if (raw) {
					fn.call(elems, value);
					fn = null;

					// ...except when executing function values
				} else {
					bulk = fn;
					fn = function (elem, key, value) {
						return bulk.call(jQuery(elem), value);
					};
				}
			}

			if (fn) {
				for (; i < len; i++) {
					fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
				}
			}
		}

		if (chainable) {
			return elems;
		}

		// Gets
		if (bulk) {
			return fn.call(elems);
		}

		return len ? fn(elems[0], key) : emptyGet;
	};
	var acceptData = function (owner) {

		// Accepts only:
		//  - Node
		//    - Node.ELEMENT_NODE
		//    - Node.DOCUMENT_NODE
		//  - Object
		//    - Any
		return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;
	};

	function Data() {
		this.expando = jQuery.expando + Data.uid++;
	}

	Data.uid = 1;

	Data.prototype = {

		cache: function (owner) {

			// Check if the owner object already has a cache
			var value = owner[this.expando];

			// If not, create one
			if (!value) {
				value = {};

				// We can accept data for non-element nodes in modern browsers,
				// but we should not, see #8335.
				// Always return an empty object.
				if (acceptData(owner)) {

					// If it is a node unlikely to be stringify-ed or looped over
					// use plain assignment
					if (owner.nodeType) {
						owner[this.expando] = value;

						// Otherwise secure it in a non-enumerable property
						// configurable must be true to allow the property to be
						// deleted when data is removed
					} else {
						Object.defineProperty(owner, this.expando, {
							value: value,
							configurable: true
						});
					}
				}
			}

			return value;
		},
		set: function (owner, data, value) {
			var prop,
			    cache = this.cache(owner);

			// Handle: [ owner, key, value ] args
			// Always use camelCase key (gh-2257)
			if (typeof data === "string") {
				cache[jQuery.camelCase(data)] = value;

				// Handle: [ owner, { properties } ] args
			} else {

				// Copy the properties one-by-one to the cache object
				for (prop in data) {
					cache[jQuery.camelCase(prop)] = data[prop];
				}
			}
			return cache;
		},
		get: function (owner, key) {
			return key === undefined ? this.cache(owner) :

			// Always use camelCase key (gh-2257)
			owner[this.expando] && owner[this.expando][jQuery.camelCase(key)];
		},
		access: function (owner, key, value) {

			// In cases where either:
			//
			//   1. No key was specified
			//   2. A string key was specified, but no value provided
			//
			// Take the "read" path and allow the get method to determine
			// which value to return, respectively either:
			//
			//   1. The entire cache object
			//   2. The data stored at the key
			//
			if (key === undefined || key && typeof key === "string" && value === undefined) {

				return this.get(owner, key);
			}

			// When the key is not a string, or both a key and value
			// are specified, set or extend (existing objects) with either:
			//
			//   1. An object of properties
			//   2. A key and value
			//
			this.set(owner, key, value);

			// Since the "set" path can have two possible entry points
			// return the expected data based on which path was taken[*]
			return value !== undefined ? value : key;
		},
		remove: function (owner, key) {
			var i,
			    cache = owner[this.expando];

			if (cache === undefined) {
				return;
			}

			if (key !== undefined) {

				// Support array or space separated string of keys
				if (jQuery.isArray(key)) {

					// If key is an array of keys...
					// We always set camelCase keys, so remove that.
					key = key.map(jQuery.camelCase);
				} else {
					key = jQuery.camelCase(key);

					// If a key with the spaces exists, use it.
					// Otherwise, create an array by matching non-whitespace
					key = key in cache ? [key] : key.match(rnothtmlwhite) || [];
				}

				i = key.length;

				while (i--) {
					delete cache[key[i]];
				}
			}

			// Remove the expando if there's no more data
			if (key === undefined || jQuery.isEmptyObject(cache)) {

				// Support: Chrome <=35 - 45
				// Webkit & Blink performance suffers when deleting properties
				// from DOM nodes, so set to undefined instead
				// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
				if (owner.nodeType) {
					owner[this.expando] = undefined;
				} else {
					delete owner[this.expando];
				}
			}
		},
		hasData: function (owner) {
			var cache = owner[this.expando];
			return cache !== undefined && !jQuery.isEmptyObject(cache);
		}
	};
	var dataPriv = new Data();

	var dataUser = new Data();

	//	Implementation Summary
	//
	//	1. Enforce API surface and semantic compatibility with 1.9.x branch
	//	2. Improve the module's maintainability by reducing the storage
	//		paths to a single mechanism.
	//	3. Use the same single mechanism to support "private" and "user" data.
	//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
	//	5. Avoid exposing implementation details on user objects (eg. expando properties)
	//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

	var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	    rmultiDash = /[A-Z]/g;

	function getData(data) {
		if (data === "true") {
			return true;
		}

		if (data === "false") {
			return false;
		}

		if (data === "null") {
			return null;
		}

		// Only convert to a number if it doesn't change the string
		if (data === +data + "") {
			return +data;
		}

		if (rbrace.test(data)) {
			return JSON.parse(data);
		}

		return data;
	}

	function dataAttr(elem, key, data) {
		var name;

		// If nothing was found internally, try to fetch any
		// data from the HTML5 data-* attribute
		if (data === undefined && elem.nodeType === 1) {
			name = "data-" + key.replace(rmultiDash, "-$&").toLowerCase();
			data = elem.getAttribute(name);

			if (typeof data === "string") {
				try {
					data = getData(data);
				} catch (e) {}

				// Make sure we set the data so it isn't changed later
				dataUser.set(elem, key, data);
			} else {
				data = undefined;
			}
		}
		return data;
	}

	jQuery.extend({
		hasData: function (elem) {
			return dataUser.hasData(elem) || dataPriv.hasData(elem);
		},

		data: function (elem, name, data) {
			return dataUser.access(elem, name, data);
		},

		removeData: function (elem, name) {
			dataUser.remove(elem, name);
		},

		// TODO: Now that all calls to _data and _removeData have been replaced
		// with direct calls to dataPriv methods, these can be deprecated.
		_data: function (elem, name, data) {
			return dataPriv.access(elem, name, data);
		},

		_removeData: function (elem, name) {
			dataPriv.remove(elem, name);
		}
	});

	jQuery.fn.extend({
		data: function (key, value) {
			var i,
			    name,
			    data,
			    elem = this[0],
			    attrs = elem && elem.attributes;

			// Gets all values
			if (key === undefined) {
				if (this.length) {
					data = dataUser.get(elem);

					if (elem.nodeType === 1 && !dataPriv.get(elem, "hasDataAttrs")) {
						i = attrs.length;
						while (i--) {

							// Support: IE 11 only
							// The attrs elements can be null (#14894)
							if (attrs[i]) {
								name = attrs[i].name;
								if (name.indexOf("data-") === 0) {
									name = jQuery.camelCase(name.slice(5));
									dataAttr(elem, name, data[name]);
								}
							}
						}
						dataPriv.set(elem, "hasDataAttrs", true);
					}
				}

				return data;
			}

			// Sets multiple values
			if (typeof key === "object") {
				return this.each(function () {
					dataUser.set(this, key);
				});
			}

			return access(this, function (value) {
				var data;

				// The calling jQuery object (element matches) is not empty
				// (and therefore has an element appears at this[ 0 ]) and the
				// `value` parameter was not undefined. An empty jQuery object
				// will result in `undefined` for elem = this[ 0 ] which will
				// throw an exception if an attempt to read a data cache is made.
				if (elem && value === undefined) {

					// Attempt to get data from the cache
					// The key will always be camelCased in Data
					data = dataUser.get(elem, key);
					if (data !== undefined) {
						return data;
					}

					// Attempt to "discover" the data in
					// HTML5 custom data-* attrs
					data = dataAttr(elem, key);
					if (data !== undefined) {
						return data;
					}

					// We tried really hard, but the data doesn't exist.
					return;
				}

				// Set the data...
				this.each(function () {

					// We always store the camelCased key
					dataUser.set(this, key, value);
				});
			}, null, value, arguments.length > 1, null, true);
		},

		removeData: function (key) {
			return this.each(function () {
				dataUser.remove(this, key);
			});
		}
	});

	jQuery.extend({
		queue: function (elem, type, data) {
			var queue;

			if (elem) {
				type = (type || "fx") + "queue";
				queue = dataPriv.get(elem, type);

				// Speed up dequeue by getting out quickly if this is just a lookup
				if (data) {
					if (!queue || jQuery.isArray(data)) {
						queue = dataPriv.access(elem, type, jQuery.makeArray(data));
					} else {
						queue.push(data);
					}
				}
				return queue || [];
			}
		},

		dequeue: function (elem, type) {
			type = type || "fx";

			var queue = jQuery.queue(elem, type),
			    startLength = queue.length,
			    fn = queue.shift(),
			    hooks = jQuery._queueHooks(elem, type),
			    next = function () {
				jQuery.dequeue(elem, type);
			};

			// If the fx queue is dequeued, always remove the progress sentinel
			if (fn === "inprogress") {
				fn = queue.shift();
				startLength--;
			}

			if (fn) {

				// Add a progress sentinel to prevent the fx queue from being
				// automatically dequeued
				if (type === "fx") {
					queue.unshift("inprogress");
				}

				// Clear up the last queue stop function
				delete hooks.stop;
				fn.call(elem, next, hooks);
			}

			if (!startLength && hooks) {
				hooks.empty.fire();
			}
		},

		// Not public - generate a queueHooks object, or return the current one
		_queueHooks: function (elem, type) {
			var key = type + "queueHooks";
			return dataPriv.get(elem, key) || dataPriv.access(elem, key, {
				empty: jQuery.Callbacks("once memory").add(function () {
					dataPriv.remove(elem, [type + "queue", key]);
				})
			});
		}
	});

	jQuery.fn.extend({
		queue: function (type, data) {
			var setter = 2;

			if (typeof type !== "string") {
				data = type;
				type = "fx";
				setter--;
			}

			if (arguments.length < setter) {
				return jQuery.queue(this[0], type);
			}

			return data === undefined ? this : this.each(function () {
				var queue = jQuery.queue(this, type, data);

				// Ensure a hooks for this queue
				jQuery._queueHooks(this, type);

				if (type === "fx" && queue[0] !== "inprogress") {
					jQuery.dequeue(this, type);
				}
			});
		},
		dequeue: function (type) {
			return this.each(function () {
				jQuery.dequeue(this, type);
			});
		},
		clearQueue: function (type) {
			return this.queue(type || "fx", []);
		},

		// Get a promise resolved when queues of a certain type
		// are emptied (fx is the type by default)
		promise: function (type, obj) {
			var tmp,
			    count = 1,
			    defer = jQuery.Deferred(),
			    elements = this,
			    i = this.length,
			    resolve = function () {
				if (! --count) {
					defer.resolveWith(elements, [elements]);
				}
			};

			if (typeof type !== "string") {
				obj = type;
				type = undefined;
			}
			type = type || "fx";

			while (i--) {
				tmp = dataPriv.get(elements[i], type + "queueHooks");
				if (tmp && tmp.empty) {
					count++;
					tmp.empty.add(resolve);
				}
			}
			resolve();
			return defer.promise(obj);
		}
	});
	var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;

	var rcssNum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i");

	var cssExpand = ["Top", "Right", "Bottom", "Left"];

	var isHiddenWithinTree = function (elem, el) {

		// isHiddenWithinTree might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;

		// Inline style trumps all
		return elem.style.display === "none" || elem.style.display === "" &&

		// Otherwise, check computed style
		// Support: Firefox <=43 - 45
		// Disconnected elements can have computed display: none, so first confirm that elem is
		// in the document.
		jQuery.contains(elem.ownerDocument, elem) && jQuery.css(elem, "display") === "none";
	};

	var swap = function (elem, options, callback, args) {
		var ret,
		    name,
		    old = {};

		// Remember the old values, and insert the new ones
		for (name in options) {
			old[name] = elem.style[name];
			elem.style[name] = options[name];
		}

		ret = callback.apply(elem, args || []);

		// Revert the old values
		for (name in options) {
			elem.style[name] = old[name];
		}

		return ret;
	};

	function adjustCSS(elem, prop, valueParts, tween) {
		var adjusted,
		    scale = 1,
		    maxIterations = 20,
		    currentValue = tween ? function () {
			return tween.cur();
		} : function () {
			return jQuery.css(elem, prop, "");
		},
		    initial = currentValue(),
		    unit = valueParts && valueParts[3] || (jQuery.cssNumber[prop] ? "" : "px"),


		// Starting value computation is required for potential unit mismatches
		initialInUnit = (jQuery.cssNumber[prop] || unit !== "px" && +initial) && rcssNum.exec(jQuery.css(elem, prop));

		if (initialInUnit && initialInUnit[3] !== unit) {

			// Trust units reported by jQuery.css
			unit = unit || initialInUnit[3];

			// Make sure we update the tween properties later on
			valueParts = valueParts || [];

			// Iteratively approximate from a nonzero starting point
			initialInUnit = +initial || 1;

			do {

				// If previous iteration zeroed out, double until we get *something*.
				// Use string for doubling so we don't accidentally see scale as unchanged below
				scale = scale || ".5";

				// Adjust and apply
				initialInUnit = initialInUnit / scale;
				jQuery.style(elem, prop, initialInUnit + unit);

				// Update scale, tolerating zero or NaN from tween.cur()
				// Break the loop if scale is unchanged or perfect, or if we've just had enough.
			} while (scale !== (scale = currentValue() / initial) && scale !== 1 && --maxIterations);
		}

		if (valueParts) {
			initialInUnit = +initialInUnit || +initial || 0;

			// Apply relative offset (+=/-=) if specified
			adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2];
			if (tween) {
				tween.unit = unit;
				tween.start = initialInUnit;
				tween.end = adjusted;
			}
		}
		return adjusted;
	}

	var defaultDisplayMap = {};

	function getDefaultDisplay(elem) {
		var temp,
		    doc = elem.ownerDocument,
		    nodeName = elem.nodeName,
		    display = defaultDisplayMap[nodeName];

		if (display) {
			return display;
		}

		temp = doc.body.appendChild(doc.createElement(nodeName));
		display = jQuery.css(temp, "display");

		temp.parentNode.removeChild(temp);

		if (display === "none") {
			display = "block";
		}
		defaultDisplayMap[nodeName] = display;

		return display;
	}

	function showHide(elements, show) {
		var display,
		    elem,
		    values = [],
		    index = 0,
		    length = elements.length;

		// Determine new display value for elements that need to change
		for (; index < length; index++) {
			elem = elements[index];
			if (!elem.style) {
				continue;
			}

			display = elem.style.display;
			if (show) {

				// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
				// check is required in this first loop unless we have a nonempty display value (either
				// inline or about-to-be-restored)
				if (display === "none") {
					values[index] = dataPriv.get(elem, "display") || null;
					if (!values[index]) {
						elem.style.display = "";
					}
				}
				if (elem.style.display === "" && isHiddenWithinTree(elem)) {
					values[index] = getDefaultDisplay(elem);
				}
			} else {
				if (display !== "none") {
					values[index] = "none";

					// Remember what we're overwriting
					dataPriv.set(elem, "display", display);
				}
			}
		}

		// Set the display of the elements in a second loop to avoid constant reflow
		for (index = 0; index < length; index++) {
			if (values[index] != null) {
				elements[index].style.display = values[index];
			}
		}

		return elements;
	}

	jQuery.fn.extend({
		show: function () {
			return showHide(this, true);
		},
		hide: function () {
			return showHide(this);
		},
		toggle: function (state) {
			if (typeof state === "boolean") {
				return state ? this.show() : this.hide();
			}

			return this.each(function () {
				if (isHiddenWithinTree(this)) {
					jQuery(this).show();
				} else {
					jQuery(this).hide();
				}
			});
		}
	});
	var rcheckableType = /^(?:checkbox|radio)$/i;

	var rtagName = /<([a-z][^\/\0>\x20\t\r\n\f]+)/i;

	var rscriptType = /^$|\/(?:java|ecma)script/i;

	// We have to close these tags to support XHTML (#13200)
	var wrapMap = {

		// Support: IE <=9 only
		option: [1, "<select multiple='multiple'>", "</select>"],

		// XHTML parsers do not magically insert elements in the
		// same way that tag soup parsers do. So we cannot shorten
		// this by omitting <tbody> or other required elements.
		thead: [1, "<table>", "</table>"],
		col: [2, "<table><colgroup>", "</colgroup></table>"],
		tr: [2, "<table><tbody>", "</tbody></table>"],
		td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],

		_default: [0, "", ""]
	};

	// Support: IE <=9 only
	wrapMap.optgroup = wrapMap.option;

	wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
	wrapMap.th = wrapMap.td;

	function getAll(context, tag) {

		// Support: IE <=9 - 11 only
		// Use typeof to avoid zero-argument method invocation on host objects (#15151)
		var ret;

		if (typeof context.getElementsByTagName !== "undefined") {
			ret = context.getElementsByTagName(tag || "*");
		} else if (typeof context.querySelectorAll !== "undefined") {
			ret = context.querySelectorAll(tag || "*");
		} else {
			ret = [];
		}

		if (tag === undefined || tag && jQuery.nodeName(context, tag)) {
			return jQuery.merge([context], ret);
		}

		return ret;
	}

	// Mark scripts as having already been evaluated
	function setGlobalEval(elems, refElements) {
		var i = 0,
		    l = elems.length;

		for (; i < l; i++) {
			dataPriv.set(elems[i], "globalEval", !refElements || dataPriv.get(refElements[i], "globalEval"));
		}
	}

	var rhtml = /<|&#?\w+;/;

	function buildFragment(elems, context, scripts, selection, ignored) {
		var elem,
		    tmp,
		    tag,
		    wrap,
		    contains,
		    j,
		    fragment = context.createDocumentFragment(),
		    nodes = [],
		    i = 0,
		    l = elems.length;

		for (; i < l; i++) {
			elem = elems[i];

			if (elem || elem === 0) {

				// Add nodes directly
				if (jQuery.type(elem) === "object") {

					// Support: Android <=4.0 only, PhantomJS 1 only
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge(nodes, elem.nodeType ? [elem] : elem);

					// Convert non-html into a text node
				} else if (!rhtml.test(elem)) {
					nodes.push(context.createTextNode(elem));

					// Convert html into DOM nodes
				} else {
					tmp = tmp || fragment.appendChild(context.createElement("div"));

					// Deserialize a standard representation
					tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
					wrap = wrapMap[tag] || wrapMap._default;
					tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2];

					// Descend through wrappers to the right content
					j = wrap[0];
					while (j--) {
						tmp = tmp.lastChild;
					}

					// Support: Android <=4.0 only, PhantomJS 1 only
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge(nodes, tmp.childNodes);

					// Remember the top-level container
					tmp = fragment.firstChild;

					// Ensure the created nodes are orphaned (#12392)
					tmp.textContent = "";
				}
			}
		}

		// Remove wrapper from fragment
		fragment.textContent = "";

		i = 0;
		while (elem = nodes[i++]) {

			// Skip elements already in the context collection (trac-4087)
			if (selection && jQuery.inArray(elem, selection) > -1) {
				if (ignored) {
					ignored.push(elem);
				}
				continue;
			}

			contains = jQuery.contains(elem.ownerDocument, elem);

			// Append to fragment
			tmp = getAll(fragment.appendChild(elem), "script");

			// Preserve script evaluation history
			if (contains) {
				setGlobalEval(tmp);
			}

			// Capture executables
			if (scripts) {
				j = 0;
				while (elem = tmp[j++]) {
					if (rscriptType.test(elem.type || "")) {
						scripts.push(elem);
					}
				}
			}
		}

		return fragment;
	}

	(function () {
		var fragment = document.createDocumentFragment(),
		    div = fragment.appendChild(document.createElement("div")),
		    input = document.createElement("input");

		// Support: Android 4.0 - 4.3 only
		// Check state lost if the name is set (#11217)
		// Support: Windows Web Apps (WWA)
		// `name` and `type` must use .setAttribute for WWA (#14901)
		input.setAttribute("type", "radio");
		input.setAttribute("checked", "checked");
		input.setAttribute("name", "t");

		div.appendChild(input);

		// Support: Android <=4.1 only
		// Older WebKit doesn't clone checked state correctly in fragments
		support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;

		// Support: IE <=11 only
		// Make sure textarea (and checkbox) defaultValue is properly cloned
		div.innerHTML = "<textarea>x</textarea>";
		support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
	})();
	var documentElement = document.documentElement;

	var rkeyEvent = /^key/,
	    rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
	    rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

	function returnTrue() {
		return true;
	}

	function returnFalse() {
		return false;
	}

	// Support: IE <=9 only
	// See #13393 for more info
	function safeActiveElement() {
		try {
			return document.activeElement;
		} catch (err) {}
	}

	function on(elem, types, selector, data, fn, one) {
		var origFn, type;

		// Types can be a map of types/handlers
		if (typeof types === "object") {

			// ( types-Object, selector, data )
			if (typeof selector !== "string") {

				// ( types-Object, data )
				data = data || selector;
				selector = undefined;
			}
			for (type in types) {
				on(elem, type, selector, data, types[type], one);
			}
			return elem;
		}

		if (data == null && fn == null) {

			// ( types, fn )
			fn = selector;
			data = selector = undefined;
		} else if (fn == null) {
			if (typeof selector === "string") {

				// ( types, selector, fn )
				fn = data;
				data = undefined;
			} else {

				// ( types, data, fn )
				fn = data;
				data = selector;
				selector = undefined;
			}
		}
		if (fn === false) {
			fn = returnFalse;
		} else if (!fn) {
			return elem;
		}

		if (one === 1) {
			origFn = fn;
			fn = function (event) {

				// Can use an empty set, since event contains the info
				jQuery().off(event);
				return origFn.apply(this, arguments);
			};

			// Use same guid so caller can remove using origFn
			fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
		}
		return elem.each(function () {
			jQuery.event.add(this, types, fn, data, selector);
		});
	}

	/*
  * Helper functions for managing events -- not part of the public interface.
  * Props to Dean Edwards' addEvent library for many of the ideas.
  */
	jQuery.event = {

		global: {},

		add: function (elem, types, handler, data, selector) {

			var handleObjIn,
			    eventHandle,
			    tmp,
			    events,
			    t,
			    handleObj,
			    special,
			    handlers,
			    type,
			    namespaces,
			    origType,
			    elemData = dataPriv.get(elem);

			// Don't attach events to noData or text/comment nodes (but allow plain objects)
			if (!elemData) {
				return;
			}

			// Caller can pass in an object of custom data in lieu of the handler
			if (handler.handler) {
				handleObjIn = handler;
				handler = handleObjIn.handler;
				selector = handleObjIn.selector;
			}

			// Ensure that invalid selectors throw exceptions at attach time
			// Evaluate against documentElement in case elem is a non-element node (e.g., document)
			if (selector) {
				jQuery.find.matchesSelector(documentElement, selector);
			}

			// Make sure that the handler has a unique ID, used to find/remove it later
			if (!handler.guid) {
				handler.guid = jQuery.guid++;
			}

			// Init the element's event structure and main handler, if this is the first
			if (!(events = elemData.events)) {
				events = elemData.events = {};
			}
			if (!(eventHandle = elemData.handle)) {
				eventHandle = elemData.handle = function (e) {

					// Discard the second event of a jQuery.event.trigger() and
					// when an event is called after a page has unloaded
					return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : undefined;
				};
			}

			// Handle multiple events separated by a space
			types = (types || "").match(rnothtmlwhite) || [""];
			t = types.length;
			while (t--) {
				tmp = rtypenamespace.exec(types[t]) || [];
				type = origType = tmp[1];
				namespaces = (tmp[2] || "").split(".").sort();

				// There *must* be a type, no attaching namespace-only handlers
				if (!type) {
					continue;
				}

				// If event changes its type, use the special event handlers for the changed type
				special = jQuery.event.special[type] || {};

				// If selector defined, determine special event api type, otherwise given type
				type = (selector ? special.delegateType : special.bindType) || type;

				// Update special based on newly reset type
				special = jQuery.event.special[type] || {};

				// handleObj is passed to all event handlers
				handleObj = jQuery.extend({
					type: type,
					origType: origType,
					data: data,
					handler: handler,
					guid: handler.guid,
					selector: selector,
					needsContext: selector && jQuery.expr.match.needsContext.test(selector),
					namespace: namespaces.join(".")
				}, handleObjIn);

				// Init the event handler queue if we're the first
				if (!(handlers = events[type])) {
					handlers = events[type] = [];
					handlers.delegateCount = 0;

					// Only use addEventListener if the special events handler returns false
					if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {

						if (elem.addEventListener) {
							elem.addEventListener(type, eventHandle);
						}
					}
				}

				if (special.add) {
					special.add.call(elem, handleObj);

					if (!handleObj.handler.guid) {
						handleObj.handler.guid = handler.guid;
					}
				}

				// Add to the element's handler list, delegates in front
				if (selector) {
					handlers.splice(handlers.delegateCount++, 0, handleObj);
				} else {
					handlers.push(handleObj);
				}

				// Keep track of which events have ever been used, for event optimization
				jQuery.event.global[type] = true;
			}
		},

		// Detach an event or set of events from an element
		remove: function (elem, types, handler, selector, mappedTypes) {

			var j,
			    origCount,
			    tmp,
			    events,
			    t,
			    handleObj,
			    special,
			    handlers,
			    type,
			    namespaces,
			    origType,
			    elemData = dataPriv.hasData(elem) && dataPriv.get(elem);

			if (!elemData || !(events = elemData.events)) {
				return;
			}

			// Once for each type.namespace in types; type may be omitted
			types = (types || "").match(rnothtmlwhite) || [""];
			t = types.length;
			while (t--) {
				tmp = rtypenamespace.exec(types[t]) || [];
				type = origType = tmp[1];
				namespaces = (tmp[2] || "").split(".").sort();

				// Unbind all events (on this namespace, if provided) for the element
				if (!type) {
					for (type in events) {
						jQuery.event.remove(elem, type + types[t], handler, selector, true);
					}
					continue;
				}

				special = jQuery.event.special[type] || {};
				type = (selector ? special.delegateType : special.bindType) || type;
				handlers = events[type] || [];
				tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");

				// Remove matching events
				origCount = j = handlers.length;
				while (j--) {
					handleObj = handlers[j];

					if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
						handlers.splice(j, 1);

						if (handleObj.selector) {
							handlers.delegateCount--;
						}
						if (special.remove) {
							special.remove.call(elem, handleObj);
						}
					}
				}

				// Remove generic event handler if we removed something and no more handlers exist
				// (avoids potential for endless recursion during removal of special event handlers)
				if (origCount && !handlers.length) {
					if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {

						jQuery.removeEvent(elem, type, elemData.handle);
					}

					delete events[type];
				}
			}

			// Remove data and the expando if it's no longer used
			if (jQuery.isEmptyObject(events)) {
				dataPriv.remove(elem, "handle events");
			}
		},

		dispatch: function (nativeEvent) {

			// Make a writable jQuery.Event from the native event object
			var event = jQuery.event.fix(nativeEvent);

			var i,
			    j,
			    ret,
			    matched,
			    handleObj,
			    handlerQueue,
			    args = new Array(arguments.length),
			    handlers = (dataPriv.get(this, "events") || {})[event.type] || [],
			    special = jQuery.event.special[event.type] || {};

			// Use the fix-ed jQuery.Event rather than the (read-only) native event
			args[0] = event;

			for (i = 1; i < arguments.length; i++) {
				args[i] = arguments[i];
			}

			event.delegateTarget = this;

			// Call the preDispatch hook for the mapped type, and let it bail if desired
			if (special.preDispatch && special.preDispatch.call(this, event) === false) {
				return;
			}

			// Determine handlers
			handlerQueue = jQuery.event.handlers.call(this, event, handlers);

			// Run delegates first; they may want to stop propagation beneath us
			i = 0;
			while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
				event.currentTarget = matched.elem;

				j = 0;
				while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {

					// Triggered event must either 1) have no namespace, or 2) have namespace(s)
					// a subset or equal to those in the bound event (both can have no namespace).
					if (!event.rnamespace || event.rnamespace.test(handleObj.namespace)) {

						event.handleObj = handleObj;
						event.data = handleObj.data;

						ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);

						if (ret !== undefined) {
							if ((event.result = ret) === false) {
								event.preventDefault();
								event.stopPropagation();
							}
						}
					}
				}
			}

			// Call the postDispatch hook for the mapped type
			if (special.postDispatch) {
				special.postDispatch.call(this, event);
			}

			return event.result;
		},

		handlers: function (event, handlers) {
			var i,
			    handleObj,
			    sel,
			    matchedHandlers,
			    matchedSelectors,
			    handlerQueue = [],
			    delegateCount = handlers.delegateCount,
			    cur = event.target;

			// Find delegate handlers
			if (delegateCount &&

			// Support: IE <=9
			// Black-hole SVG <use> instance trees (trac-13180)
			cur.nodeType &&

			// Support: Firefox <=42
			// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
			// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
			// Support: IE 11 only
			// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
			!(event.type === "click" && event.button >= 1)) {

				for (; cur !== this; cur = cur.parentNode || this) {

					// Don't check non-elements (#13208)
					// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
					if (cur.nodeType === 1 && !(event.type === "click" && cur.disabled === true)) {
						matchedHandlers = [];
						matchedSelectors = {};
						for (i = 0; i < delegateCount; i++) {
							handleObj = handlers[i];

							// Don't conflict with Object.prototype properties (#13203)
							sel = handleObj.selector + " ";

							if (matchedSelectors[sel] === undefined) {
								matchedSelectors[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) > -1 : jQuery.find(sel, this, null, [cur]).length;
							}
							if (matchedSelectors[sel]) {
								matchedHandlers.push(handleObj);
							}
						}
						if (matchedHandlers.length) {
							handlerQueue.push({ elem: cur, handlers: matchedHandlers });
						}
					}
				}
			}

			// Add the remaining (directly-bound) handlers
			cur = this;
			if (delegateCount < handlers.length) {
				handlerQueue.push({ elem: cur, handlers: handlers.slice(delegateCount) });
			}

			return handlerQueue;
		},

		addProp: function (name, hook) {
			Object.defineProperty(jQuery.Event.prototype, name, {
				enumerable: true,
				configurable: true,

				get: jQuery.isFunction(hook) ? function () {
					if (this.originalEvent) {
						return hook(this.originalEvent);
					}
				} : function () {
					if (this.originalEvent) {
						return this.originalEvent[name];
					}
				},

				set: function (value) {
					Object.defineProperty(this, name, {
						enumerable: true,
						configurable: true,
						writable: true,
						value: value
					});
				}
			});
		},

		fix: function (originalEvent) {
			return originalEvent[jQuery.expando] ? originalEvent : new jQuery.Event(originalEvent);
		},

		special: {
			load: {

				// Prevent triggered image.load events from bubbling to window.load
				noBubble: true
			},
			focus: {

				// Fire native event if possible so blur/focus sequence is correct
				trigger: function () {
					if (this !== safeActiveElement() && this.focus) {
						this.focus();
						return false;
					}
				},
				delegateType: "focusin"
			},
			blur: {
				trigger: function () {
					if (this === safeActiveElement() && this.blur) {
						this.blur();
						return false;
					}
				},
				delegateType: "focusout"
			},
			click: {

				// For checkbox, fire native event so checked state will be right
				trigger: function () {
					if (this.type === "checkbox" && this.click && jQuery.nodeName(this, "input")) {
						this.click();
						return false;
					}
				},

				// For cross-browser consistency, don't fire native .click() on links
				_default: function (event) {
					return jQuery.nodeName(event.target, "a");
				}
			},

			beforeunload: {
				postDispatch: function (event) {

					// Support: Firefox 20+
					// Firefox doesn't alert if the returnValue field is not set.
					if (event.result !== undefined && event.originalEvent) {
						event.originalEvent.returnValue = event.result;
					}
				}
			}
		}
	};

	jQuery.removeEvent = function (elem, type, handle) {

		// This "if" is needed for plain objects
		if (elem.removeEventListener) {
			elem.removeEventListener(type, handle);
		}
	};

	jQuery.Event = function (src, props) {

		// Allow instantiation without the 'new' keyword
		if (!(this instanceof jQuery.Event)) {
			return new jQuery.Event(src, props);
		}

		// Event object
		if (src && src.type) {
			this.originalEvent = src;
			this.type = src.type;

			// Events bubbling up the document may have been marked as prevented
			// by a handler lower down the tree; reflect the correct value.
			this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === undefined &&

			// Support: Android <=2.3 only
			src.returnValue === false ? returnTrue : returnFalse;

			// Create target properties
			// Support: Safari <=6 - 7 only
			// Target should not be a text node (#504, #13143)
			this.target = src.target && src.target.nodeType === 3 ? src.target.parentNode : src.target;

			this.currentTarget = src.currentTarget;
			this.relatedTarget = src.relatedTarget;

			// Event type
		} else {
			this.type = src;
		}

		// Put explicitly provided properties onto the event object
		if (props) {
			jQuery.extend(this, props);
		}

		// Create a timestamp if incoming event doesn't have one
		this.timeStamp = src && src.timeStamp || jQuery.now();

		// Mark it as fixed
		this[jQuery.expando] = true;
	};

	// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
	// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
	jQuery.Event.prototype = {
		constructor: jQuery.Event,
		isDefaultPrevented: returnFalse,
		isPropagationStopped: returnFalse,
		isImmediatePropagationStopped: returnFalse,
		isSimulated: false,

		preventDefault: function () {
			var e = this.originalEvent;

			this.isDefaultPrevented = returnTrue;

			if (e && !this.isSimulated) {
				e.preventDefault();
			}
		},
		stopPropagation: function () {
			var e = this.originalEvent;

			this.isPropagationStopped = returnTrue;

			if (e && !this.isSimulated) {
				e.stopPropagation();
			}
		},
		stopImmediatePropagation: function () {
			var e = this.originalEvent;

			this.isImmediatePropagationStopped = returnTrue;

			if (e && !this.isSimulated) {
				e.stopImmediatePropagation();
			}

			this.stopPropagation();
		}
	};

	// Includes all common event props including KeyEvent and MouseEvent specific props
	jQuery.each({
		altKey: true,
		bubbles: true,
		cancelable: true,
		changedTouches: true,
		ctrlKey: true,
		detail: true,
		eventPhase: true,
		metaKey: true,
		pageX: true,
		pageY: true,
		shiftKey: true,
		view: true,
		"char": true,
		charCode: true,
		key: true,
		keyCode: true,
		button: true,
		buttons: true,
		clientX: true,
		clientY: true,
		offsetX: true,
		offsetY: true,
		pointerId: true,
		pointerType: true,
		screenX: true,
		screenY: true,
		targetTouches: true,
		toElement: true,
		touches: true,

		which: function (event) {
			var button = event.button;

			// Add which for key events
			if (event.which == null && rkeyEvent.test(event.type)) {
				return event.charCode != null ? event.charCode : event.keyCode;
			}

			// Add which for click: 1 === left; 2 === middle; 3 === right
			if (!event.which && button !== undefined && rmouseEvent.test(event.type)) {
				if (button & 1) {
					return 1;
				}

				if (button & 2) {
					return 3;
				}

				if (button & 4) {
					return 2;
				}

				return 0;
			}

			return event.which;
		}
	}, jQuery.event.addProp);

	// Create mouseenter/leave events using mouseover/out and event-time checks
	// so that event delegation works in jQuery.
	// Do the same for pointerenter/pointerleave and pointerover/pointerout
	//
	// Support: Safari 7 only
	// Safari sends mouseenter too often; see:
	// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
	// for the description of the bug (it existed in older Chrome versions as well).
	jQuery.each({
		mouseenter: "mouseover",
		mouseleave: "mouseout",
		pointerenter: "pointerover",
		pointerleave: "pointerout"
	}, function (orig, fix) {
		jQuery.event.special[orig] = {
			delegateType: fix,
			bindType: fix,

			handle: function (event) {
				var ret,
				    target = this,
				    related = event.relatedTarget,
				    handleObj = event.handleObj;

				// For mouseenter/leave call the handler if related is outside the target.
				// NB: No relatedTarget if the mouse left/entered the browser window
				if (!related || related !== target && !jQuery.contains(target, related)) {
					event.type = handleObj.origType;
					ret = handleObj.handler.apply(this, arguments);
					event.type = fix;
				}
				return ret;
			}
		};
	});

	jQuery.fn.extend({

		on: function (types, selector, data, fn) {
			return on(this, types, selector, data, fn);
		},
		one: function (types, selector, data, fn) {
			return on(this, types, selector, data, fn, 1);
		},
		off: function (types, selector, fn) {
			var handleObj, type;
			if (types && types.preventDefault && types.handleObj) {

				// ( event )  dispatched jQuery.Event
				handleObj = types.handleObj;
				jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);
				return this;
			}
			if (typeof types === "object") {

				// ( types-object [, selector] )
				for (type in types) {
					this.off(type, selector, types[type]);
				}
				return this;
			}
			if (selector === false || typeof selector === "function") {

				// ( types [, fn] )
				fn = selector;
				selector = undefined;
			}
			if (fn === false) {
				fn = returnFalse;
			}
			return this.each(function () {
				jQuery.event.remove(this, types, fn, selector);
			});
		}
	});

	var

	/* eslint-disable max-len */

	// See https://github.com/eslint/eslint/issues/3229
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,


	/* eslint-enable */

	// Support: IE <=10 - 11, Edge 12 - 13
	// In IE/Edge using regex groups here causes severe slowdowns.
	// See https://connect.microsoft.com/IE/feedback/details/1736512/
	rnoInnerhtml = /<script|<style|<link/i,


	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	    rscriptTypeMasked = /^true\/(.*)/,
	    rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

	function manipulationTarget(elem, content) {
		if (jQuery.nodeName(elem, "table") && jQuery.nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr")) {

			return elem.getElementsByTagName("tbody")[0] || elem;
		}

		return elem;
	}

	// Replace/restore the type attribute of script elements for safe DOM manipulation
	function disableScript(elem) {
		elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
		return elem;
	}
	function restoreScript(elem) {
		var match = rscriptTypeMasked.exec(elem.type);

		if (match) {
			elem.type = match[1];
		} else {
			elem.removeAttribute("type");
		}

		return elem;
	}

	function cloneCopyEvent(src, dest) {
		var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

		if (dest.nodeType !== 1) {
			return;
		}

		// 1. Copy private data: events, handlers, etc.
		if (dataPriv.hasData(src)) {
			pdataOld = dataPriv.access(src);
			pdataCur = dataPriv.set(dest, pdataOld);
			events = pdataOld.events;

			if (events) {
				delete pdataCur.handle;
				pdataCur.events = {};

				for (type in events) {
					for (i = 0, l = events[type].length; i < l; i++) {
						jQuery.event.add(dest, type, events[type][i]);
					}
				}
			}
		}

		// 2. Copy user data
		if (dataUser.hasData(src)) {
			udataOld = dataUser.access(src);
			udataCur = jQuery.extend({}, udataOld);

			dataUser.set(dest, udataCur);
		}
	}

	// Fix IE bugs, see support tests
	function fixInput(src, dest) {
		var nodeName = dest.nodeName.toLowerCase();

		// Fails to persist the checked state of a cloned checkbox or radio button.
		if (nodeName === "input" && rcheckableType.test(src.type)) {
			dest.checked = src.checked;

			// Fails to return the selected option to the default selected state when cloning options
		} else if (nodeName === "input" || nodeName === "textarea") {
			dest.defaultValue = src.defaultValue;
		}
	}

	function domManip(collection, args, callback, ignored) {

		// Flatten any nested arrays
		args = concat.apply([], args);

		var fragment,
		    first,
		    scripts,
		    hasScripts,
		    node,
		    doc,
		    i = 0,
		    l = collection.length,
		    iNoClone = l - 1,
		    value = args[0],
		    isFunction = jQuery.isFunction(value);

		// We can't cloneNode fragments that contain checked, in WebKit
		if (isFunction || l > 1 && typeof value === "string" && !support.checkClone && rchecked.test(value)) {
			return collection.each(function (index) {
				var self = collection.eq(index);
				if (isFunction) {
					args[0] = value.call(this, index, self.html());
				}
				domManip(self, args, callback, ignored);
			});
		}

		if (l) {
			fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);
			first = fragment.firstChild;

			if (fragment.childNodes.length === 1) {
				fragment = first;
			}

			// Require either new content or an interest in ignored elements to invoke the callback
			if (first || ignored) {
				scripts = jQuery.map(getAll(fragment, "script"), disableScript);
				hasScripts = scripts.length;

				// Use the original fragment for the last item
				// instead of the first because it can end up
				// being emptied incorrectly in certain situations (#8070).
				for (; i < l; i++) {
					node = fragment;

					if (i !== iNoClone) {
						node = jQuery.clone(node, true, true);

						// Keep references to cloned scripts for later restoration
						if (hasScripts) {

							// Support: Android <=4.0 only, PhantomJS 1 only
							// push.apply(_, arraylike) throws on ancient WebKit
							jQuery.merge(scripts, getAll(node, "script"));
						}
					}

					callback.call(collection[i], node, i);
				}

				if (hasScripts) {
					doc = scripts[scripts.length - 1].ownerDocument;

					// Reenable scripts
					jQuery.map(scripts, restoreScript);

					// Evaluate executable scripts on first document insertion
					for (i = 0; i < hasScripts; i++) {
						node = scripts[i];
						if (rscriptType.test(node.type || "") && !dataPriv.access(node, "globalEval") && jQuery.contains(doc, node)) {

							if (node.src) {

								// Optional AJAX dependency, but won't run scripts if not present
								if (jQuery._evalUrl) {
									jQuery._evalUrl(node.src);
								}
							} else {
								DOMEval(node.textContent.replace(rcleanScript, ""), doc);
							}
						}
					}
				}
			}
		}

		return collection;
	}

	function remove(elem, selector, keepData) {
		var node,
		    nodes = selector ? jQuery.filter(selector, elem) : elem,
		    i = 0;

		for (; (node = nodes[i]) != null; i++) {
			if (!keepData && node.nodeType === 1) {
				jQuery.cleanData(getAll(node));
			}

			if (node.parentNode) {
				if (keepData && jQuery.contains(node.ownerDocument, node)) {
					setGlobalEval(getAll(node, "script"));
				}
				node.parentNode.removeChild(node);
			}
		}

		return elem;
	}

	jQuery.extend({
		htmlPrefilter: function (html) {
			return html.replace(rxhtmlTag, "<$1></$2>");
		},

		clone: function (elem, dataAndEvents, deepDataAndEvents) {
			var i,
			    l,
			    srcElements,
			    destElements,
			    clone = elem.cloneNode(true),
			    inPage = jQuery.contains(elem.ownerDocument, elem);

			// Fix IE cloning issues
			if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {

				// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
				destElements = getAll(clone);
				srcElements = getAll(elem);

				for (i = 0, l = srcElements.length; i < l; i++) {
					fixInput(srcElements[i], destElements[i]);
				}
			}

			// Copy the events from the original to the clone
			if (dataAndEvents) {
				if (deepDataAndEvents) {
					srcElements = srcElements || getAll(elem);
					destElements = destElements || getAll(clone);

					for (i = 0, l = srcElements.length; i < l; i++) {
						cloneCopyEvent(srcElements[i], destElements[i]);
					}
				} else {
					cloneCopyEvent(elem, clone);
				}
			}

			// Preserve script evaluation history
			destElements = getAll(clone, "script");
			if (destElements.length > 0) {
				setGlobalEval(destElements, !inPage && getAll(elem, "script"));
			}

			// Return the cloned set
			return clone;
		},

		cleanData: function (elems) {
			var data,
			    elem,
			    type,
			    special = jQuery.event.special,
			    i = 0;

			for (; (elem = elems[i]) !== undefined; i++) {
				if (acceptData(elem)) {
					if (data = elem[dataPriv.expando]) {
						if (data.events) {
							for (type in data.events) {
								if (special[type]) {
									jQuery.event.remove(elem, type);

									// This is a shortcut to avoid jQuery.event.remove's overhead
								} else {
									jQuery.removeEvent(elem, type, data.handle);
								}
							}
						}

						// Support: Chrome <=35 - 45+
						// Assign undefined instead of using delete, see Data#remove
						elem[dataPriv.expando] = undefined;
					}
					if (elem[dataUser.expando]) {

						// Support: Chrome <=35 - 45+
						// Assign undefined instead of using delete, see Data#remove
						elem[dataUser.expando] = undefined;
					}
				}
			}
		}
	});

	jQuery.fn.extend({
		detach: function (selector) {
			return remove(this, selector, true);
		},

		remove: function (selector) {
			return remove(this, selector);
		},

		text: function (value) {
			return access(this, function (value) {
				return value === undefined ? jQuery.text(this) : this.empty().each(function () {
					if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
						this.textContent = value;
					}
				});
			}, null, value, arguments.length);
		},

		append: function () {
			return domManip(this, arguments, function (elem) {
				if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
					var target = manipulationTarget(this, elem);
					target.appendChild(elem);
				}
			});
		},

		prepend: function () {
			return domManip(this, arguments, function (elem) {
				if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
					var target = manipulationTarget(this, elem);
					target.insertBefore(elem, target.firstChild);
				}
			});
		},

		before: function () {
			return domManip(this, arguments, function (elem) {
				if (this.parentNode) {
					this.parentNode.insertBefore(elem, this);
				}
			});
		},

		after: function () {
			return domManip(this, arguments, function (elem) {
				if (this.parentNode) {
					this.parentNode.insertBefore(elem, this.nextSibling);
				}
			});
		},

		empty: function () {
			var elem,
			    i = 0;

			for (; (elem = this[i]) != null; i++) {
				if (elem.nodeType === 1) {

					// Prevent memory leaks
					jQuery.cleanData(getAll(elem, false));

					// Remove any remaining nodes
					elem.textContent = "";
				}
			}

			return this;
		},

		clone: function (dataAndEvents, deepDataAndEvents) {
			dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
			deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

			return this.map(function () {
				return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
			});
		},

		html: function (value) {
			return access(this, function (value) {
				var elem = this[0] || {},
				    i = 0,
				    l = this.length;

				if (value === undefined && elem.nodeType === 1) {
					return elem.innerHTML;
				}

				// See if we can take a shortcut and just use innerHTML
				if (typeof value === "string" && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || ["", ""])[1].toLowerCase()]) {

					value = jQuery.htmlPrefilter(value);

					try {
						for (; i < l; i++) {
							elem = this[i] || {};

							// Remove element nodes and prevent memory leaks
							if (elem.nodeType === 1) {
								jQuery.cleanData(getAll(elem, false));
								elem.innerHTML = value;
							}
						}

						elem = 0;

						// If using innerHTML throws an exception, use the fallback method
					} catch (e) {}
				}

				if (elem) {
					this.empty().append(value);
				}
			}, null, value, arguments.length);
		},

		replaceWith: function () {
			var ignored = [];

			// Make the changes, replacing each non-ignored context element with the new content
			return domManip(this, arguments, function (elem) {
				var parent = this.parentNode;

				if (jQuery.inArray(this, ignored) < 0) {
					jQuery.cleanData(getAll(this));
					if (parent) {
						parent.replaceChild(elem, this);
					}
				}

				// Force callback invocation
			}, ignored);
		}
	});

	jQuery.each({
		appendTo: "append",
		prependTo: "prepend",
		insertBefore: "before",
		insertAfter: "after",
		replaceAll: "replaceWith"
	}, function (name, original) {
		jQuery.fn[name] = function (selector) {
			var elems,
			    ret = [],
			    insert = jQuery(selector),
			    last = insert.length - 1,
			    i = 0;

			for (; i <= last; i++) {
				elems = i === last ? this : this.clone(true);
				jQuery(insert[i])[original](elems);

				// Support: Android <=4.0 only, PhantomJS 1 only
				// .get() because push.apply(_, arraylike) throws on ancient WebKit
				push.apply(ret, elems.get());
			}

			return this.pushStack(ret);
		};
	});
	var rmargin = /^margin/;

	var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");

	var getStyles = function (elem) {

		// Support: IE <=11 only, Firefox <=30 (#15098, #14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		var view = elem.ownerDocument.defaultView;

		if (!view || !view.opener) {
			view = window;
		}

		return view.getComputedStyle(elem);
	};

	(function () {

		// Executing both pixelPosition & boxSizingReliable tests require only one layout
		// so they're executed at the same time to save the second computation.
		function computeStyleTests() {

			// This is a singleton, we need to execute it only once
			if (!div) {
				return;
			}

			div.style.cssText = "box-sizing:border-box;" + "position:relative;display:block;" + "margin:auto;border:1px;padding:1px;" + "top:1%;width:50%";
			div.innerHTML = "";
			documentElement.appendChild(container);

			var divStyle = window.getComputedStyle(div);
			pixelPositionVal = divStyle.top !== "1%";

			// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
			reliableMarginLeftVal = divStyle.marginLeft === "2px";
			boxSizingReliableVal = divStyle.width === "4px";

			// Support: Android 4.0 - 4.3 only
			// Some styles come back with percentage values, even though they shouldn't
			div.style.marginRight = "50%";
			pixelMarginRightVal = divStyle.marginRight === "4px";

			documentElement.removeChild(container);

			// Nullify the div so it wouldn't be stored in the memory and
			// it will also be a sign that checks already performed
			div = null;
		}

		var pixelPositionVal,
		    boxSizingReliableVal,
		    pixelMarginRightVal,
		    reliableMarginLeftVal,
		    container = document.createElement("div"),
		    div = document.createElement("div");

		// Finish early in limited (non-browser) environments
		if (!div.style) {
			return;
		}

		// Support: IE <=9 - 11 only
		// Style of cloned element affects source element cloned (#8908)
		div.style.backgroundClip = "content-box";
		div.cloneNode(true).style.backgroundClip = "";
		support.clearCloneStyle = div.style.backgroundClip === "content-box";

		container.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;" + "padding:0;margin-top:1px;position:absolute";
		container.appendChild(div);

		jQuery.extend(support, {
			pixelPosition: function () {
				computeStyleTests();
				return pixelPositionVal;
			},
			boxSizingReliable: function () {
				computeStyleTests();
				return boxSizingReliableVal;
			},
			pixelMarginRight: function () {
				computeStyleTests();
				return pixelMarginRightVal;
			},
			reliableMarginLeft: function () {
				computeStyleTests();
				return reliableMarginLeftVal;
			}
		});
	})();

	function curCSS(elem, name, computed) {
		var width,
		    minWidth,
		    maxWidth,
		    ret,
		    style = elem.style;

		computed = computed || getStyles(elem);

		// Support: IE <=9 only
		// getPropertyValue is only needed for .css('filter') (#12537)
		if (computed) {
			ret = computed.getPropertyValue(name) || computed[name];

			if (ret === "" && !jQuery.contains(elem.ownerDocument, elem)) {
				ret = jQuery.style(elem, name);
			}

			// A tribute to the "awesome hack by Dean Edwards"
			// Android Browser returns percentage for some values,
			// but width seems to be reliably pixels.
			// This is against the CSSOM draft spec:
			// https://drafts.csswg.org/cssom/#resolved-values
			if (!support.pixelMarginRight() && rnumnonpx.test(ret) && rmargin.test(name)) {

				// Remember the original values
				width = style.width;
				minWidth = style.minWidth;
				maxWidth = style.maxWidth;

				// Put in the new values to get a computed value out
				style.minWidth = style.maxWidth = style.width = ret;
				ret = computed.width;

				// Revert the changed values
				style.width = width;
				style.minWidth = minWidth;
				style.maxWidth = maxWidth;
			}
		}

		return ret !== undefined ?

		// Support: IE <=9 - 11 only
		// IE returns zIndex value as an integer.
		ret + "" : ret;
	}

	function addGetHookIf(conditionFn, hookFn) {

		// Define the hook, we'll check on the first run if it's really needed.
		return {
			get: function () {
				if (conditionFn()) {

					// Hook not needed (or it's not possible to use it due
					// to missing dependency), remove it.
					delete this.get;
					return;
				}

				// Hook needed; redefine it so that the support test is not executed again.
				return (this.get = hookFn).apply(this, arguments);
			}
		};
	}

	var

	// Swappable if display is none or starts with table
	// except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	    cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	    cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	},
	    cssPrefixes = ["Webkit", "Moz", "ms"],
	    emptyStyle = document.createElement("div").style;

	// Return a css property mapped to a potentially vendor prefixed property
	function vendorPropName(name) {

		// Shortcut for names that are not vendor prefixed
		if (name in emptyStyle) {
			return name;
		}

		// Check for vendor prefixed names
		var capName = name[0].toUpperCase() + name.slice(1),
		    i = cssPrefixes.length;

		while (i--) {
			name = cssPrefixes[i] + capName;
			if (name in emptyStyle) {
				return name;
			}
		}
	}

	function setPositiveNumber(elem, value, subtract) {

		// Any relative (+/-) values have already been
		// normalized at this point
		var matches = rcssNum.exec(value);
		return matches ?

		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || "px") : value;
	}

	function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {
		var i,
		    val = 0;

		// If we already have the right measurement, avoid augmentation
		if (extra === (isBorderBox ? "border" : "content")) {
			i = 4;

			// Otherwise initialize for horizontal or vertical properties
		} else {
			i = name === "width" ? 1 : 0;
		}

		for (; i < 4; i += 2) {

			// Both box models exclude margin, so add it if we want it
			if (extra === "margin") {
				val += jQuery.css(elem, extra + cssExpand[i], true, styles);
			}

			if (isBorderBox) {

				// border-box includes padding, so remove it if we want content
				if (extra === "content") {
					val -= jQuery.css(elem, "padding" + cssExpand[i], true, styles);
				}

				// At this point, extra isn't border nor margin, so remove border
				if (extra !== "margin") {
					val -= jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
				}
			} else {

				// At this point, extra isn't content, so add padding
				val += jQuery.css(elem, "padding" + cssExpand[i], true, styles);

				// At this point, extra isn't content nor padding, so add border
				if (extra !== "padding") {
					val += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
				}
			}
		}

		return val;
	}

	function getWidthOrHeight(elem, name, extra) {

		// Start with offset property, which is equivalent to the border-box value
		var val,
		    valueIsBorderBox = true,
		    styles = getStyles(elem),
		    isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box";

		// Support: IE <=11 only
		// Running getBoundingClientRect on a disconnected node
		// in IE throws an error.
		if (elem.getClientRects().length) {
			val = elem.getBoundingClientRect()[name];
		}

		// Some non-html elements return undefined for offsetWidth, so check for null/undefined
		// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
		// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
		if (val <= 0 || val == null) {

			// Fall back to computed then uncomputed css if necessary
			val = curCSS(elem, name, styles);
			if (val < 0 || val == null) {
				val = elem.style[name];
			}

			// Computed unit is not pixels. Stop here and return.
			if (rnumnonpx.test(val)) {
				return val;
			}

			// Check for style in case a browser which returns unreliable values
			// for getComputedStyle silently falls back to the reliable elem.style
			valueIsBorderBox = isBorderBox && (support.boxSizingReliable() || val === elem.style[name]);

			// Normalize "", auto, and prepare for extra
			val = parseFloat(val) || 0;
		}

		// Use the active box-sizing model to add/subtract irrelevant styles
		return val + augmentWidthOrHeight(elem, name, extra || (isBorderBox ? "border" : "content"), valueIsBorderBox, styles) + "px";
	}

	jQuery.extend({

		// Add in style property hooks for overriding the default
		// behavior of getting and setting a style property
		cssHooks: {
			opacity: {
				get: function (elem, computed) {
					if (computed) {

						// We should always get a number back from opacity
						var ret = curCSS(elem, "opacity");
						return ret === "" ? "1" : ret;
					}
				}
			}
		},

		// Don't automatically add "px" to these possibly-unitless properties
		cssNumber: {
			"animationIterationCount": true,
			"columnCount": true,
			"fillOpacity": true,
			"flexGrow": true,
			"flexShrink": true,
			"fontWeight": true,
			"lineHeight": true,
			"opacity": true,
			"order": true,
			"orphans": true,
			"widows": true,
			"zIndex": true,
			"zoom": true
		},

		// Add in properties whose names you wish to fix before
		// setting or getting the value
		cssProps: {
			"float": "cssFloat"
		},

		// Get and set the style property on a DOM Node
		style: function (elem, name, value, extra) {

			// Don't set styles on text and comment nodes
			if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
				return;
			}

			// Make sure that we're working with the right name
			var ret,
			    type,
			    hooks,
			    origName = jQuery.camelCase(name),
			    style = elem.style;

			name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(origName) || origName);

			// Gets hook for the prefixed version, then unprefixed version
			hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];

			// Check if we're setting a value
			if (value !== undefined) {
				type = typeof value;

				// Convert "+=" or "-=" to relative numbers (#7345)
				if (type === "string" && (ret = rcssNum.exec(value)) && ret[1]) {
					value = adjustCSS(elem, name, ret);

					// Fixes bug #9237
					type = "number";
				}

				// Make sure that null and NaN values aren't set (#7116)
				if (value == null || value !== value) {
					return;
				}

				// If a number was passed in, add the unit (except for certain CSS properties)
				if (type === "number") {
					value += ret && ret[3] || (jQuery.cssNumber[origName] ? "" : "px");
				}

				// background-* props affect original clone's values
				if (!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) {
					style[name] = "inherit";
				}

				// If a hook was provided, use that value, otherwise just set the specified value
				if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {

					style[name] = value;
				}
			} else {

				// If a hook was provided get the non-computed value from there
				if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {

					return ret;
				}

				// Otherwise just get the value from the style object
				return style[name];
			}
		},

		css: function (elem, name, extra, styles) {
			var val,
			    num,
			    hooks,
			    origName = jQuery.camelCase(name);

			// Make sure that we're working with the right name
			name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(origName) || origName);

			// Try prefixed name followed by the unprefixed name
			hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];

			// If a hook was provided get the computed value from there
			if (hooks && "get" in hooks) {
				val = hooks.get(elem, true, extra);
			}

			// Otherwise, if a way to get the computed value exists, use that
			if (val === undefined) {
				val = curCSS(elem, name, styles);
			}

			// Convert "normal" to computed value
			if (val === "normal" && name in cssNormalTransform) {
				val = cssNormalTransform[name];
			}

			// Make numeric if forced or a qualifier was provided and val looks numeric
			if (extra === "" || extra) {
				num = parseFloat(val);
				return extra === true || isFinite(num) ? num || 0 : val;
			}
			return val;
		}
	});

	jQuery.each(["height", "width"], function (i, name) {
		jQuery.cssHooks[name] = {
			get: function (elem, computed, extra) {
				if (computed) {

					// Certain elements can have dimension info if we invisibly show them
					// but it must have a current display style that would benefit
					return rdisplayswap.test(jQuery.css(elem, "display")) && (

					// Support: Safari 8+
					// Table columns in Safari have non-zero offsetWidth & zero
					// getBoundingClientRect().width unless display is changed.
					// Support: IE <=11 only
					// Running getBoundingClientRect on a disconnected node
					// in IE throws an error.
					!elem.getClientRects().length || !elem.getBoundingClientRect().width) ? swap(elem, cssShow, function () {
						return getWidthOrHeight(elem, name, extra);
					}) : getWidthOrHeight(elem, name, extra);
				}
			},

			set: function (elem, value, extra) {
				var matches,
				    styles = extra && getStyles(elem),
				    subtract = extra && augmentWidthOrHeight(elem, name, extra, jQuery.css(elem, "boxSizing", false, styles) === "border-box", styles);

				// Convert to pixels if value adjustment is needed
				if (subtract && (matches = rcssNum.exec(value)) && (matches[3] || "px") !== "px") {

					elem.style[name] = value;
					value = jQuery.css(elem, name);
				}

				return setPositiveNumber(elem, value, subtract);
			}
		};
	});

	jQuery.cssHooks.marginLeft = addGetHookIf(support.reliableMarginLeft, function (elem, computed) {
		if (computed) {
			return (parseFloat(curCSS(elem, "marginLeft")) || elem.getBoundingClientRect().left - swap(elem, { marginLeft: 0 }, function () {
				return elem.getBoundingClientRect().left;
			})) + "px";
		}
	});

	// These hooks are used by animate to expand properties
	jQuery.each({
		margin: "",
		padding: "",
		border: "Width"
	}, function (prefix, suffix) {
		jQuery.cssHooks[prefix + suffix] = {
			expand: function (value) {
				var i = 0,
				    expanded = {},


				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split(" ") : [value];

				for (; i < 4; i++) {
					expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
				}

				return expanded;
			}
		};

		if (!rmargin.test(prefix)) {
			jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
		}
	});

	jQuery.fn.extend({
		css: function (name, value) {
			return access(this, function (elem, name, value) {
				var styles,
				    len,
				    map = {},
				    i = 0;

				if (jQuery.isArray(name)) {
					styles = getStyles(elem);
					len = name.length;

					for (; i < len; i++) {
						map[name[i]] = jQuery.css(elem, name[i], false, styles);
					}

					return map;
				}

				return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);
			}, name, value, arguments.length > 1);
		}
	});

	function Tween(elem, options, prop, end, easing) {
		return new Tween.prototype.init(elem, options, prop, end, easing);
	}
	jQuery.Tween = Tween;

	Tween.prototype = {
		constructor: Tween,
		init: function (elem, options, prop, end, easing, unit) {
			this.elem = elem;
			this.prop = prop;
			this.easing = easing || jQuery.easing._default;
			this.options = options;
			this.start = this.now = this.cur();
			this.end = end;
			this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px");
		},
		cur: function () {
			var hooks = Tween.propHooks[this.prop];

			return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
		},
		run: function (percent) {
			var eased,
			    hooks = Tween.propHooks[this.prop];

			if (this.options.duration) {
				this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);
			} else {
				this.pos = eased = percent;
			}
			this.now = (this.end - this.start) * eased + this.start;

			if (this.options.step) {
				this.options.step.call(this.elem, this.now, this);
			}

			if (hooks && hooks.set) {
				hooks.set(this);
			} else {
				Tween.propHooks._default.set(this);
			}
			return this;
		}
	};

	Tween.prototype.init.prototype = Tween.prototype;

	Tween.propHooks = {
		_default: {
			get: function (tween) {
				var result;

				// Use a property on the element directly when it is not a DOM element,
				// or when there is no matching style property that exists.
				if (tween.elem.nodeType !== 1 || tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) {
					return tween.elem[tween.prop];
				}

				// Passing an empty string as a 3rd parameter to .css will automatically
				// attempt a parseFloat and fallback to a string if the parse fails.
				// Simple values such as "10px" are parsed to Float;
				// complex values such as "rotate(1rad)" are returned as-is.
				result = jQuery.css(tween.elem, tween.prop, "");

				// Empty strings, null, undefined and "auto" are converted to 0.
				return !result || result === "auto" ? 0 : result;
			},
			set: function (tween) {

				// Use step hook for back compat.
				// Use cssHook if its there.
				// Use .style if available and use plain properties where available.
				if (jQuery.fx.step[tween.prop]) {
					jQuery.fx.step[tween.prop](tween);
				} else if (tween.elem.nodeType === 1 && (tween.elem.style[jQuery.cssProps[tween.prop]] != null || jQuery.cssHooks[tween.prop])) {
					jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
				} else {
					tween.elem[tween.prop] = tween.now;
				}
			}
		}
	};

	// Support: IE <=9 only
	// Panic based approach to setting things on disconnected nodes
	Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
		set: function (tween) {
			if (tween.elem.nodeType && tween.elem.parentNode) {
				tween.elem[tween.prop] = tween.now;
			}
		}
	};

	jQuery.easing = {
		linear: function (p) {
			return p;
		},
		swing: function (p) {
			return 0.5 - Math.cos(p * Math.PI) / 2;
		},
		_default: "swing"
	};

	jQuery.fx = Tween.prototype.init;

	// Back compat <1.8 extension point
	jQuery.fx.step = {};

	var fxNow,
	    timerId,
	    rfxtypes = /^(?:toggle|show|hide)$/,
	    rrun = /queueHooks$/;

	function raf() {
		if (timerId) {
			window.requestAnimationFrame(raf);
			jQuery.fx.tick();
		}
	}

	// Animations created synchronously will run synchronously
	function createFxNow() {
		window.setTimeout(function () {
			fxNow = undefined;
		});
		return fxNow = jQuery.now();
	}

	// Generate parameters to create a standard animation
	function genFx(type, includeWidth) {
		var which,
		    i = 0,
		    attrs = { height: type };

		// If we include width, step value is 1 to do all cssExpand values,
		// otherwise step value is 2 to skip over Left and Right
		includeWidth = includeWidth ? 1 : 0;
		for (; i < 4; i += 2 - includeWidth) {
			which = cssExpand[i];
			attrs["margin" + which] = attrs["padding" + which] = type;
		}

		if (includeWidth) {
			attrs.opacity = attrs.width = type;
		}

		return attrs;
	}

	function createTween(value, prop, animation) {
		var tween,
		    collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners["*"]),
		    index = 0,
		    length = collection.length;
		for (; index < length; index++) {
			if (tween = collection[index].call(animation, prop, value)) {

				// We're done with this property
				return tween;
			}
		}
	}

	function defaultPrefilter(elem, props, opts) {
		var prop,
		    value,
		    toggle,
		    hooks,
		    oldfire,
		    propTween,
		    restoreDisplay,
		    display,
		    isBox = "width" in props || "height" in props,
		    anim = this,
		    orig = {},
		    style = elem.style,
		    hidden = elem.nodeType && isHiddenWithinTree(elem),
		    dataShow = dataPriv.get(elem, "fxshow");

		// Queue-skipping animations hijack the fx hooks
		if (!opts.queue) {
			hooks = jQuery._queueHooks(elem, "fx");
			if (hooks.unqueued == null) {
				hooks.unqueued = 0;
				oldfire = hooks.empty.fire;
				hooks.empty.fire = function () {
					if (!hooks.unqueued) {
						oldfire();
					}
				};
			}
			hooks.unqueued++;

			anim.always(function () {

				// Ensure the complete handler is called before this completes
				anim.always(function () {
					hooks.unqueued--;
					if (!jQuery.queue(elem, "fx").length) {
						hooks.empty.fire();
					}
				});
			});
		}

		// Detect show/hide animations
		for (prop in props) {
			value = props[prop];
			if (rfxtypes.test(value)) {
				delete props[prop];
				toggle = toggle || value === "toggle";
				if (value === (hidden ? "hide" : "show")) {

					// Pretend to be hidden if this is a "show" and
					// there is still data from a stopped show/hide
					if (value === "show" && dataShow && dataShow[prop] !== undefined) {
						hidden = true;

						// Ignore all other no-op show/hide data
					} else {
						continue;
					}
				}
				orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);
			}
		}

		// Bail out if this is a no-op like .hide().hide()
		propTween = !jQuery.isEmptyObject(props);
		if (!propTween && jQuery.isEmptyObject(orig)) {
			return;
		}

		// Restrict "overflow" and "display" styles during box animations
		if (isBox && elem.nodeType === 1) {

			// Support: IE <=9 - 11, Edge 12 - 13
			// Record all 3 overflow attributes because IE does not infer the shorthand
			// from identically-valued overflowX and overflowY
			opts.overflow = [style.overflow, style.overflowX, style.overflowY];

			// Identify a display type, preferring old show/hide data over the CSS cascade
			restoreDisplay = dataShow && dataShow.display;
			if (restoreDisplay == null) {
				restoreDisplay = dataPriv.get(elem, "display");
			}
			display = jQuery.css(elem, "display");
			if (display === "none") {
				if (restoreDisplay) {
					display = restoreDisplay;
				} else {

					// Get nonempty value(s) by temporarily forcing visibility
					showHide([elem], true);
					restoreDisplay = elem.style.display || restoreDisplay;
					display = jQuery.css(elem, "display");
					showHide([elem]);
				}
			}

			// Animate inline elements as inline-block
			if (display === "inline" || display === "inline-block" && restoreDisplay != null) {
				if (jQuery.css(elem, "float") === "none") {

					// Restore the original display value at the end of pure show/hide animations
					if (!propTween) {
						anim.done(function () {
							style.display = restoreDisplay;
						});
						if (restoreDisplay == null) {
							display = style.display;
							restoreDisplay = display === "none" ? "" : display;
						}
					}
					style.display = "inline-block";
				}
			}
		}

		if (opts.overflow) {
			style.overflow = "hidden";
			anim.always(function () {
				style.overflow = opts.overflow[0];
				style.overflowX = opts.overflow[1];
				style.overflowY = opts.overflow[2];
			});
		}

		// Implement show/hide animations
		propTween = false;
		for (prop in orig) {

			// General show/hide setup for this element animation
			if (!propTween) {
				if (dataShow) {
					if ("hidden" in dataShow) {
						hidden = dataShow.hidden;
					}
				} else {
					dataShow = dataPriv.access(elem, "fxshow", { display: restoreDisplay });
				}

				// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
				if (toggle) {
					dataShow.hidden = !hidden;
				}

				// Show elements before animating them
				if (hidden) {
					showHide([elem], true);
				}

				/* eslint-disable no-loop-func */

				anim.done(function () {

					/* eslint-enable no-loop-func */

					// The final step of a "hide" animation is actually hiding the element
					if (!hidden) {
						showHide([elem]);
					}
					dataPriv.remove(elem, "fxshow");
					for (prop in orig) {
						jQuery.style(elem, prop, orig[prop]);
					}
				});
			}

			// Per-property setup
			propTween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
			if (!(prop in dataShow)) {
				dataShow[prop] = propTween.start;
				if (hidden) {
					propTween.end = propTween.start;
					propTween.start = 0;
				}
			}
		}
	}

	function propFilter(props, specialEasing) {
		var index, name, easing, value, hooks;

		// camelCase, specialEasing and expand cssHook pass
		for (index in props) {
			name = jQuery.camelCase(index);
			easing = specialEasing[name];
			value = props[index];
			if (jQuery.isArray(value)) {
				easing = value[1];
				value = props[index] = value[0];
			}

			if (index !== name) {
				props[name] = value;
				delete props[index];
			}

			hooks = jQuery.cssHooks[name];
			if (hooks && "expand" in hooks) {
				value = hooks.expand(value);
				delete props[name];

				// Not quite $.extend, this won't overwrite existing keys.
				// Reusing 'index' because we have the correct "name"
				for (index in value) {
					if (!(index in props)) {
						props[index] = value[index];
						specialEasing[index] = easing;
					}
				}
			} else {
				specialEasing[name] = easing;
			}
		}
	}

	function Animation(elem, properties, options) {
		var result,
		    stopped,
		    index = 0,
		    length = Animation.prefilters.length,
		    deferred = jQuery.Deferred().always(function () {

			// Don't match elem in the :animated selector
			delete tick.elem;
		}),
		    tick = function () {
			if (stopped) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
			    remaining = Math.max(0, animation.startTime + animation.duration - currentTime),


			// Support: Android 2.3 only
			// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
			temp = remaining / animation.duration || 0,
			    percent = 1 - temp,
			    index = 0,
			    length = animation.tweens.length;

			for (; index < length; index++) {
				animation.tweens[index].run(percent);
			}

			deferred.notifyWith(elem, [animation, percent, remaining]);

			if (percent < 1 && length) {
				return remaining;
			} else {
				deferred.resolveWith(elem, [animation]);
				return false;
			}
		},
		    animation = deferred.promise({
			elem: elem,
			props: jQuery.extend({}, properties),
			opts: jQuery.extend(true, {
				specialEasing: {},
				easing: jQuery.easing._default
			}, options),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function (prop, end) {
				var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
				animation.tweens.push(tween);
				return tween;
			},
			stop: function (gotoEnd) {
				var index = 0,


				// If we are going to the end, we want to run all the tweens
				// otherwise we skip this part
				length = gotoEnd ? animation.tweens.length : 0;
				if (stopped) {
					return this;
				}
				stopped = true;
				for (; index < length; index++) {
					animation.tweens[index].run(1);
				}

				// Resolve when we played the last frame; otherwise, reject
				if (gotoEnd) {
					deferred.notifyWith(elem, [animation, 1, 0]);
					deferred.resolveWith(elem, [animation, gotoEnd]);
				} else {
					deferred.rejectWith(elem, [animation, gotoEnd]);
				}
				return this;
			}
		}),
		    props = animation.props;

		propFilter(props, animation.opts.specialEasing);

		for (; index < length; index++) {
			result = Animation.prefilters[index].call(animation, elem, props, animation.opts);
			if (result) {
				if (jQuery.isFunction(result.stop)) {
					jQuery._queueHooks(animation.elem, animation.opts.queue).stop = jQuery.proxy(result.stop, result);
				}
				return result;
			}
		}

		jQuery.map(props, createTween, animation);

		if (jQuery.isFunction(animation.opts.start)) {
			animation.opts.start.call(elem, animation);
		}

		jQuery.fx.timer(jQuery.extend(tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		}));

		// attach callbacks from options
		return animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
	}

	jQuery.Animation = jQuery.extend(Animation, {

		tweeners: {
			"*": [function (prop, value) {
				var tween = this.createTween(prop, value);
				adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);
				return tween;
			}]
		},

		tweener: function (props, callback) {
			if (jQuery.isFunction(props)) {
				callback = props;
				props = ["*"];
			} else {
				props = props.match(rnothtmlwhite);
			}

			var prop,
			    index = 0,
			    length = props.length;

			for (; index < length; index++) {
				prop = props[index];
				Animation.tweeners[prop] = Animation.tweeners[prop] || [];
				Animation.tweeners[prop].unshift(callback);
			}
		},

		prefilters: [defaultPrefilter],

		prefilter: function (callback, prepend) {
			if (prepend) {
				Animation.prefilters.unshift(callback);
			} else {
				Animation.prefilters.push(callback);
			}
		}
	});

	jQuery.speed = function (speed, easing, fn) {
		var opt = speed && typeof speed === "object" ? jQuery.extend({}, speed) : {
			complete: fn || !fn && easing || jQuery.isFunction(speed) && speed,
			duration: speed,
			easing: fn && easing || easing && !jQuery.isFunction(easing) && easing
		};

		// Go to the end state if fx are off or if document is hidden
		if (jQuery.fx.off || document.hidden) {
			opt.duration = 0;
		} else {
			if (typeof opt.duration !== "number") {
				if (opt.duration in jQuery.fx.speeds) {
					opt.duration = jQuery.fx.speeds[opt.duration];
				} else {
					opt.duration = jQuery.fx.speeds._default;
				}
			}
		}

		// Normalize opt.queue - true/undefined/null -> "fx"
		if (opt.queue == null || opt.queue === true) {
			opt.queue = "fx";
		}

		// Queueing
		opt.old = opt.complete;

		opt.complete = function () {
			if (jQuery.isFunction(opt.old)) {
				opt.old.call(this);
			}

			if (opt.queue) {
				jQuery.dequeue(this, opt.queue);
			}
		};

		return opt;
	};

	jQuery.fn.extend({
		fadeTo: function (speed, to, easing, callback) {

			// Show any hidden elements after setting opacity to 0
			return this.filter(isHiddenWithinTree).css("opacity", 0).show()

			// Animate to the value specified
			.end().animate({ opacity: to }, speed, easing, callback);
		},
		animate: function (prop, speed, easing, callback) {
			var empty = jQuery.isEmptyObject(prop),
			    optall = jQuery.speed(speed, easing, callback),
			    doAnimation = function () {

				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation(this, jQuery.extend({}, prop), optall);

				// Empty animations, or finishing resolves immediately
				if (empty || dataPriv.get(this, "finish")) {
					anim.stop(true);
				}
			};
			doAnimation.finish = doAnimation;

			return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
		},
		stop: function (type, clearQueue, gotoEnd) {
			var stopQueue = function (hooks) {
				var stop = hooks.stop;
				delete hooks.stop;
				stop(gotoEnd);
			};

			if (typeof type !== "string") {
				gotoEnd = clearQueue;
				clearQueue = type;
				type = undefined;
			}
			if (clearQueue && type !== false) {
				this.queue(type || "fx", []);
			}

			return this.each(function () {
				var dequeue = true,
				    index = type != null && type + "queueHooks",
				    timers = jQuery.timers,
				    data = dataPriv.get(this);

				if (index) {
					if (data[index] && data[index].stop) {
						stopQueue(data[index]);
					}
				} else {
					for (index in data) {
						if (data[index] && data[index].stop && rrun.test(index)) {
							stopQueue(data[index]);
						}
					}
				}

				for (index = timers.length; index--;) {
					if (timers[index].elem === this && (type == null || timers[index].queue === type)) {

						timers[index].anim.stop(gotoEnd);
						dequeue = false;
						timers.splice(index, 1);
					}
				}

				// Start the next in the queue if the last step wasn't forced.
				// Timers currently will call their complete callbacks, which
				// will dequeue but only if they were gotoEnd.
				if (dequeue || !gotoEnd) {
					jQuery.dequeue(this, type);
				}
			});
		},
		finish: function (type) {
			if (type !== false) {
				type = type || "fx";
			}
			return this.each(function () {
				var index,
				    data = dataPriv.get(this),
				    queue = data[type + "queue"],
				    hooks = data[type + "queueHooks"],
				    timers = jQuery.timers,
				    length = queue ? queue.length : 0;

				// Enable finishing flag on private data
				data.finish = true;

				// Empty the queue first
				jQuery.queue(this, type, []);

				if (hooks && hooks.stop) {
					hooks.stop.call(this, true);
				}

				// Look for any active animations, and finish them
				for (index = timers.length; index--;) {
					if (timers[index].elem === this && timers[index].queue === type) {
						timers[index].anim.stop(true);
						timers.splice(index, 1);
					}
				}

				// Look for any animations in the old queue and finish them
				for (index = 0; index < length; index++) {
					if (queue[index] && queue[index].finish) {
						queue[index].finish.call(this);
					}
				}

				// Turn off finishing flag
				delete data.finish;
			});
		}
	});

	jQuery.each(["toggle", "show", "hide"], function (i, name) {
		var cssFn = jQuery.fn[name];
		jQuery.fn[name] = function (speed, easing, callback) {
			return speed == null || typeof speed === "boolean" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
		};
	});

	// Generate shortcuts for custom animations
	jQuery.each({
		slideDown: genFx("show"),
		slideUp: genFx("hide"),
		slideToggle: genFx("toggle"),
		fadeIn: { opacity: "show" },
		fadeOut: { opacity: "hide" },
		fadeToggle: { opacity: "toggle" }
	}, function (name, props) {
		jQuery.fn[name] = function (speed, easing, callback) {
			return this.animate(props, speed, easing, callback);
		};
	});

	jQuery.timers = [];
	jQuery.fx.tick = function () {
		var timer,
		    i = 0,
		    timers = jQuery.timers;

		fxNow = jQuery.now();

		for (; i < timers.length; i++) {
			timer = timers[i];

			// Checks the timer has not already been removed
			if (!timer() && timers[i] === timer) {
				timers.splice(i--, 1);
			}
		}

		if (!timers.length) {
			jQuery.fx.stop();
		}
		fxNow = undefined;
	};

	jQuery.fx.timer = function (timer) {
		jQuery.timers.push(timer);
		if (timer()) {
			jQuery.fx.start();
		} else {
			jQuery.timers.pop();
		}
	};

	jQuery.fx.interval = 13;
	jQuery.fx.start = function () {
		if (!timerId) {
			timerId = window.requestAnimationFrame ? window.requestAnimationFrame(raf) : window.setInterval(jQuery.fx.tick, jQuery.fx.interval);
		}
	};

	jQuery.fx.stop = function () {
		if (window.cancelAnimationFrame) {
			window.cancelAnimationFrame(timerId);
		} else {
			window.clearInterval(timerId);
		}

		timerId = null;
	};

	jQuery.fx.speeds = {
		slow: 600,
		fast: 200,

		// Default speed
		_default: 400
	};

	// Based off of the plugin by Clint Helfers, with permission.
	// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
	jQuery.fn.delay = function (time, type) {
		time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
		type = type || "fx";

		return this.queue(type, function (next, hooks) {
			var timeout = window.setTimeout(next, time);
			hooks.stop = function () {
				window.clearTimeout(timeout);
			};
		});
	};

	(function () {
		var input = document.createElement("input"),
		    select = document.createElement("select"),
		    opt = select.appendChild(document.createElement("option"));

		input.type = "checkbox";

		// Support: Android <=4.3 only
		// Default value for a checkbox should be "on"
		support.checkOn = input.value !== "";

		// Support: IE <=11 only
		// Must access selectedIndex to make default options select
		support.optSelected = opt.selected;

		// Support: IE <=11 only
		// An input loses its value after becoming a radio
		input = document.createElement("input");
		input.value = "t";
		input.type = "radio";
		support.radioValue = input.value === "t";
	})();

	var boolHook,
	    attrHandle = jQuery.expr.attrHandle;

	jQuery.fn.extend({
		attr: function (name, value) {
			return access(this, jQuery.attr, name, value, arguments.length > 1);
		},

		removeAttr: function (name) {
			return this.each(function () {
				jQuery.removeAttr(this, name);
			});
		}
	});

	jQuery.extend({
		attr: function (elem, name, value) {
			var ret,
			    hooks,
			    nType = elem.nodeType;

			// Don't get/set attributes on text, comment and attribute nodes
			if (nType === 3 || nType === 8 || nType === 2) {
				return;
			}

			// Fallback to prop when attributes are not supported
			if (typeof elem.getAttribute === "undefined") {
				return jQuery.prop(elem, name, value);
			}

			// Attribute hooks are determined by the lowercase version
			// Grab necessary hook if one is defined
			if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
				hooks = jQuery.attrHooks[name.toLowerCase()] || (jQuery.expr.match.bool.test(name) ? boolHook : undefined);
			}

			if (value !== undefined) {
				if (value === null) {
					jQuery.removeAttr(elem, name);
					return;
				}

				if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
					return ret;
				}

				elem.setAttribute(name, value + "");
				return value;
			}

			if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
				return ret;
			}

			ret = jQuery.find.attr(elem, name);

			// Non-existent attributes return null, we normalize to undefined
			return ret == null ? undefined : ret;
		},

		attrHooks: {
			type: {
				set: function (elem, value) {
					if (!support.radioValue && value === "radio" && jQuery.nodeName(elem, "input")) {
						var val = elem.value;
						elem.setAttribute("type", value);
						if (val) {
							elem.value = val;
						}
						return value;
					}
				}
			}
		},

		removeAttr: function (elem, value) {
			var name,
			    i = 0,


			// Attribute names can contain non-HTML whitespace characters
			// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
			attrNames = value && value.match(rnothtmlwhite);

			if (attrNames && elem.nodeType === 1) {
				while (name = attrNames[i++]) {
					elem.removeAttribute(name);
				}
			}
		}
	});

	// Hooks for boolean attributes
	boolHook = {
		set: function (elem, value, name) {
			if (value === false) {

				// Remove boolean attributes when set to false
				jQuery.removeAttr(elem, name);
			} else {
				elem.setAttribute(name, name);
			}
			return name;
		}
	};

	jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function (i, name) {
		var getter = attrHandle[name] || jQuery.find.attr;

		attrHandle[name] = function (elem, name, isXML) {
			var ret,
			    handle,
			    lowercaseName = name.toLowerCase();

			if (!isXML) {

				// Avoid an infinite loop by temporarily removing this function from the getter
				handle = attrHandle[lowercaseName];
				attrHandle[lowercaseName] = ret;
				ret = getter(elem, name, isXML) != null ? lowercaseName : null;
				attrHandle[lowercaseName] = handle;
			}
			return ret;
		};
	});

	var rfocusable = /^(?:input|select|textarea|button)$/i,
	    rclickable = /^(?:a|area)$/i;

	jQuery.fn.extend({
		prop: function (name, value) {
			return access(this, jQuery.prop, name, value, arguments.length > 1);
		},

		removeProp: function (name) {
			return this.each(function () {
				delete this[jQuery.propFix[name] || name];
			});
		}
	});

	jQuery.extend({
		prop: function (elem, name, value) {
			var ret,
			    hooks,
			    nType = elem.nodeType;

			// Don't get/set properties on text, comment and attribute nodes
			if (nType === 3 || nType === 8 || nType === 2) {
				return;
			}

			if (nType !== 1 || !jQuery.isXMLDoc(elem)) {

				// Fix name and attach hooks
				name = jQuery.propFix[name] || name;
				hooks = jQuery.propHooks[name];
			}

			if (value !== undefined) {
				if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
					return ret;
				}

				return elem[name] = value;
			}

			if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
				return ret;
			}

			return elem[name];
		},

		propHooks: {
			tabIndex: {
				get: function (elem) {

					// Support: IE <=9 - 11 only
					// elem.tabIndex doesn't always return the
					// correct value when it hasn't been explicitly set
					// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
					// Use proper attribute retrieval(#12072)
					var tabindex = jQuery.find.attr(elem, "tabindex");

					if (tabindex) {
						return parseInt(tabindex, 10);
					}

					if (rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href) {
						return 0;
					}

					return -1;
				}
			}
		},

		propFix: {
			"for": "htmlFor",
			"class": "className"
		}
	});

	// Support: IE <=11 only
	// Accessing the selectedIndex property
	// forces the browser to respect setting selected
	// on the option
	// The getter ensures a default option is selected
	// when in an optgroup
	// eslint rule "no-unused-expressions" is disabled for this code
	// since it considers such accessions noop
	if (!support.optSelected) {
		jQuery.propHooks.selected = {
			get: function (elem) {

				/* eslint no-unused-expressions: "off" */

				var parent = elem.parentNode;
				if (parent && parent.parentNode) {
					parent.parentNode.selectedIndex;
				}
				return null;
			},
			set: function (elem) {

				/* eslint no-unused-expressions: "off" */

				var parent = elem.parentNode;
				if (parent) {
					parent.selectedIndex;

					if (parent.parentNode) {
						parent.parentNode.selectedIndex;
					}
				}
			}
		};
	}

	jQuery.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function () {
		jQuery.propFix[this.toLowerCase()] = this;
	});

	// Strip and collapse whitespace according to HTML spec
	// https://html.spec.whatwg.org/multipage/infrastructure.html#strip-and-collapse-whitespace
	function stripAndCollapse(value) {
		var tokens = value.match(rnothtmlwhite) || [];
		return tokens.join(" ");
	}

	function getClass(elem) {
		return elem.getAttribute && elem.getAttribute("class") || "";
	}

	jQuery.fn.extend({
		addClass: function (value) {
			var classes,
			    elem,
			    cur,
			    curValue,
			    clazz,
			    j,
			    finalValue,
			    i = 0;

			if (jQuery.isFunction(value)) {
				return this.each(function (j) {
					jQuery(this).addClass(value.call(this, j, getClass(this)));
				});
			}

			if (typeof value === "string" && value) {
				classes = value.match(rnothtmlwhite) || [];

				while (elem = this[i++]) {
					curValue = getClass(elem);
					cur = elem.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";

					if (cur) {
						j = 0;
						while (clazz = classes[j++]) {
							if (cur.indexOf(" " + clazz + " ") < 0) {
								cur += clazz + " ";
							}
						}

						// Only assign if different to avoid unneeded rendering.
						finalValue = stripAndCollapse(cur);
						if (curValue !== finalValue) {
							elem.setAttribute("class", finalValue);
						}
					}
				}
			}

			return this;
		},

		removeClass: function (value) {
			var classes,
			    elem,
			    cur,
			    curValue,
			    clazz,
			    j,
			    finalValue,
			    i = 0;

			if (jQuery.isFunction(value)) {
				return this.each(function (j) {
					jQuery(this).removeClass(value.call(this, j, getClass(this)));
				});
			}

			if (!arguments.length) {
				return this.attr("class", "");
			}

			if (typeof value === "string" && value) {
				classes = value.match(rnothtmlwhite) || [];

				while (elem = this[i++]) {
					curValue = getClass(elem);

					// This expression is here for better compressibility (see addClass)
					cur = elem.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";

					if (cur) {
						j = 0;
						while (clazz = classes[j++]) {

							// Remove *all* instances
							while (cur.indexOf(" " + clazz + " ") > -1) {
								cur = cur.replace(" " + clazz + " ", " ");
							}
						}

						// Only assign if different to avoid unneeded rendering.
						finalValue = stripAndCollapse(cur);
						if (curValue !== finalValue) {
							elem.setAttribute("class", finalValue);
						}
					}
				}
			}

			return this;
		},

		toggleClass: function (value, stateVal) {
			var type = typeof value;

			if (typeof stateVal === "boolean" && type === "string") {
				return stateVal ? this.addClass(value) : this.removeClass(value);
			}

			if (jQuery.isFunction(value)) {
				return this.each(function (i) {
					jQuery(this).toggleClass(value.call(this, i, getClass(this), stateVal), stateVal);
				});
			}

			return this.each(function () {
				var className, i, self, classNames;

				if (type === "string") {

					// Toggle individual class names
					i = 0;
					self = jQuery(this);
					classNames = value.match(rnothtmlwhite) || [];

					while (className = classNames[i++]) {

						// Check each className given, space separated list
						if (self.hasClass(className)) {
							self.removeClass(className);
						} else {
							self.addClass(className);
						}
					}

					// Toggle whole class name
				} else if (value === undefined || type === "boolean") {
					className = getClass(this);
					if (className) {

						// Store className if set
						dataPriv.set(this, "__className__", className);
					}

					// If the element has a class name or if we're passed `false`,
					// then remove the whole classname (if there was one, the above saved it).
					// Otherwise bring back whatever was previously saved (if anything),
					// falling back to the empty string if nothing was stored.
					if (this.setAttribute) {
						this.setAttribute("class", className || value === false ? "" : dataPriv.get(this, "__className__") || "");
					}
				}
			});
		},

		hasClass: function (selector) {
			var className,
			    elem,
			    i = 0;

			className = " " + selector + " ";
			while (elem = this[i++]) {
				if (elem.nodeType === 1 && (" " + stripAndCollapse(getClass(elem)) + " ").indexOf(className) > -1) {
					return true;
				}
			}

			return false;
		}
	});

	var rreturn = /\r/g;

	jQuery.fn.extend({
		val: function (value) {
			var hooks,
			    ret,
			    isFunction,
			    elem = this[0];

			if (!arguments.length) {
				if (elem) {
					hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];

					if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== undefined) {
						return ret;
					}

					ret = elem.value;

					// Handle most common string cases
					if (typeof ret === "string") {
						return ret.replace(rreturn, "");
					}

					// Handle cases where value is null/undef or number
					return ret == null ? "" : ret;
				}

				return;
			}

			isFunction = jQuery.isFunction(value);

			return this.each(function (i) {
				var val;

				if (this.nodeType !== 1) {
					return;
				}

				if (isFunction) {
					val = value.call(this, i, jQuery(this).val());
				} else {
					val = value;
				}

				// Treat null/undefined as ""; convert numbers to string
				if (val == null) {
					val = "";
				} else if (typeof val === "number") {
					val += "";
				} else if (jQuery.isArray(val)) {
					val = jQuery.map(val, function (value) {
						return value == null ? "" : value + "";
					});
				}

				hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];

				// If set returns undefined, fall back to normal setting
				if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === undefined) {
					this.value = val;
				}
			});
		}
	});

	jQuery.extend({
		valHooks: {
			option: {
				get: function (elem) {

					var val = jQuery.find.attr(elem, "value");
					return val != null ? val :

					// Support: IE <=10 - 11 only
					// option.text throws exceptions (#14686, #14858)
					// Strip and collapse whitespace
					// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
					stripAndCollapse(jQuery.text(elem));
				}
			},
			select: {
				get: function (elem) {
					var value,
					    option,
					    i,
					    options = elem.options,
					    index = elem.selectedIndex,
					    one = elem.type === "select-one",
					    values = one ? null : [],
					    max = one ? index + 1 : options.length;

					if (index < 0) {
						i = max;
					} else {
						i = one ? index : 0;
					}

					// Loop through all the selected options
					for (; i < max; i++) {
						option = options[i];

						// Support: IE <=9 only
						// IE8-9 doesn't update selected after form reset (#2551)
						if ((option.selected || i === index) &&

						// Don't return options that are disabled or in a disabled optgroup
						!option.disabled && (!option.parentNode.disabled || !jQuery.nodeName(option.parentNode, "optgroup"))) {

							// Get the specific value for the option
							value = jQuery(option).val();

							// We don't need an array for one selects
							if (one) {
								return value;
							}

							// Multi-Selects return an array
							values.push(value);
						}
					}

					return values;
				},

				set: function (elem, value) {
					var optionSet,
					    option,
					    options = elem.options,
					    values = jQuery.makeArray(value),
					    i = options.length;

					while (i--) {
						option = options[i];

						/* eslint-disable no-cond-assign */

						if (option.selected = jQuery.inArray(jQuery.valHooks.option.get(option), values) > -1) {
							optionSet = true;
						}

						/* eslint-enable no-cond-assign */
					}

					// Force browsers to behave consistently when non-matching value is set
					if (!optionSet) {
						elem.selectedIndex = -1;
					}
					return values;
				}
			}
		}
	});

	// Radios and checkboxes getter/setter
	jQuery.each(["radio", "checkbox"], function () {
		jQuery.valHooks[this] = {
			set: function (elem, value) {
				if (jQuery.isArray(value)) {
					return elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1;
				}
			}
		};
		if (!support.checkOn) {
			jQuery.valHooks[this].get = function (elem) {
				return elem.getAttribute("value") === null ? "on" : elem.value;
			};
		}
	});

	// Return jQuery for attributes-only inclusion


	var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;

	jQuery.extend(jQuery.event, {

		trigger: function (event, data, elem, onlyHandlers) {

			var i,
			    cur,
			    tmp,
			    bubbleType,
			    ontype,
			    handle,
			    special,
			    eventPath = [elem || document],
			    type = hasOwn.call(event, "type") ? event.type : event,
			    namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];

			cur = tmp = elem = elem || document;

			// Don't do events on text and comment nodes
			if (elem.nodeType === 3 || elem.nodeType === 8) {
				return;
			}

			// focus/blur morphs to focusin/out; ensure we're not firing them right now
			if (rfocusMorph.test(type + jQuery.event.triggered)) {
				return;
			}

			if (type.indexOf(".") > -1) {

				// Namespaced trigger; create a regexp to match event type in handle()
				namespaces = type.split(".");
				type = namespaces.shift();
				namespaces.sort();
			}
			ontype = type.indexOf(":") < 0 && "on" + type;

			// Caller can pass in a jQuery.Event object, Object, or just an event type string
			event = event[jQuery.expando] ? event : new jQuery.Event(type, typeof event === "object" && event);

			// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
			event.isTrigger = onlyHandlers ? 2 : 3;
			event.namespace = namespaces.join(".");
			event.rnamespace = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null;

			// Clean up the event in case it is being reused
			event.result = undefined;
			if (!event.target) {
				event.target = elem;
			}

			// Clone any incoming data and prepend the event, creating the handler arg list
			data = data == null ? [event] : jQuery.makeArray(data, [event]);

			// Allow special events to draw outside the lines
			special = jQuery.event.special[type] || {};
			if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
				return;
			}

			// Determine event propagation path in advance, per W3C events spec (#9951)
			// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
			if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {

				bubbleType = special.delegateType || type;
				if (!rfocusMorph.test(bubbleType + type)) {
					cur = cur.parentNode;
				}
				for (; cur; cur = cur.parentNode) {
					eventPath.push(cur);
					tmp = cur;
				}

				// Only add window if we got to document (e.g., not plain obj or detached DOM)
				if (tmp === (elem.ownerDocument || document)) {
					eventPath.push(tmp.defaultView || tmp.parentWindow || window);
				}
			}

			// Fire handlers on the event path
			i = 0;
			while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {

				event.type = i > 1 ? bubbleType : special.bindType || type;

				// jQuery handler
				handle = (dataPriv.get(cur, "events") || {})[event.type] && dataPriv.get(cur, "handle");
				if (handle) {
					handle.apply(cur, data);
				}

				// Native handler
				handle = ontype && cur[ontype];
				if (handle && handle.apply && acceptData(cur)) {
					event.result = handle.apply(cur, data);
					if (event.result === false) {
						event.preventDefault();
					}
				}
			}
			event.type = type;

			// If nobody prevented the default action, do it now
			if (!onlyHandlers && !event.isDefaultPrevented()) {

				if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && acceptData(elem)) {

					// Call a native DOM method on the target with the same name as the event.
					// Don't do default actions on window, that's where global variables be (#6170)
					if (ontype && jQuery.isFunction(elem[type]) && !jQuery.isWindow(elem)) {

						// Don't re-trigger an onFOO event when we call its FOO() method
						tmp = elem[ontype];

						if (tmp) {
							elem[ontype] = null;
						}

						// Prevent re-triggering of the same event, since we already bubbled it above
						jQuery.event.triggered = type;
						elem[type]();
						jQuery.event.triggered = undefined;

						if (tmp) {
							elem[ontype] = tmp;
						}
					}
				}
			}

			return event.result;
		},

		// Piggyback on a donor event to simulate a different one
		// Used only for `focus(in | out)` events
		simulate: function (type, elem, event) {
			var e = jQuery.extend(new jQuery.Event(), event, {
				type: type,
				isSimulated: true
			});

			jQuery.event.trigger(e, null, elem);
		}

	});

	jQuery.fn.extend({

		trigger: function (type, data) {
			return this.each(function () {
				jQuery.event.trigger(type, data, this);
			});
		},
		triggerHandler: function (type, data) {
			var elem = this[0];
			if (elem) {
				return jQuery.event.trigger(type, data, elem, true);
			}
		}
	});

	jQuery.each(("blur focus focusin focusout resize scroll click dblclick " + "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " + "change select submit keydown keypress keyup contextmenu").split(" "), function (i, name) {

		// Handle event binding
		jQuery.fn[name] = function (data, fn) {
			return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
		};
	});

	jQuery.fn.extend({
		hover: function (fnOver, fnOut) {
			return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
		}
	});

	support.focusin = "onfocusin" in window;

	// Support: Firefox <=44
	// Firefox doesn't have focus(in | out) events
	// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
	//
	// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
	// focus(in | out) events fire after focus & blur events,
	// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
	// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
	if (!support.focusin) {
		jQuery.each({ focus: "focusin", blur: "focusout" }, function (orig, fix) {

			// Attach a single capturing handler on the document while someone wants focusin/focusout
			var handler = function (event) {
				jQuery.event.simulate(fix, event.target, jQuery.event.fix(event));
			};

			jQuery.event.special[fix] = {
				setup: function () {
					var doc = this.ownerDocument || this,
					    attaches = dataPriv.access(doc, fix);

					if (!attaches) {
						doc.addEventListener(orig, handler, true);
					}
					dataPriv.access(doc, fix, (attaches || 0) + 1);
				},
				teardown: function () {
					var doc = this.ownerDocument || this,
					    attaches = dataPriv.access(doc, fix) - 1;

					if (!attaches) {
						doc.removeEventListener(orig, handler, true);
						dataPriv.remove(doc, fix);
					} else {
						dataPriv.access(doc, fix, attaches);
					}
				}
			};
		});
	}
	var location = window.location;

	var nonce = jQuery.now();

	var rquery = /\?/;

	// Cross-browser xml parsing
	jQuery.parseXML = function (data) {
		var xml;
		if (!data || typeof data !== "string") {
			return null;
		}

		// Support: IE 9 - 11 only
		// IE throws on parseFromString with invalid input.
		try {
			xml = new window.DOMParser().parseFromString(data, "text/xml");
		} catch (e) {
			xml = undefined;
		}

		if (!xml || xml.getElementsByTagName("parsererror").length) {
			jQuery.error("Invalid XML: " + data);
		}
		return xml;
	};

	var rbracket = /\[\]$/,
	    rCRLF = /\r?\n/g,
	    rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	    rsubmittable = /^(?:input|select|textarea|keygen)/i;

	function buildParams(prefix, obj, traditional, add) {
		var name;

		if (jQuery.isArray(obj)) {

			// Serialize array item.
			jQuery.each(obj, function (i, v) {
				if (traditional || rbracket.test(prefix)) {

					// Treat each array item as a scalar.
					add(prefix, v);
				} else {

					// Item is non-scalar (array or object), encode its numeric index.
					buildParams(prefix + "[" + (typeof v === "object" && v != null ? i : "") + "]", v, traditional, add);
				}
			});
		} else if (!traditional && jQuery.type(obj) === "object") {

			// Serialize object item.
			for (name in obj) {
				buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
			}
		} else {

			// Serialize scalar item.
			add(prefix, obj);
		}
	}

	// Serialize an array of form elements or a set of
	// key/values into a query string
	jQuery.param = function (a, traditional) {
		var prefix,
		    s = [],
		    add = function (key, valueOrFunction) {

			// If value is a function, invoke it and use its return value
			var value = jQuery.isFunction(valueOrFunction) ? valueOrFunction() : valueOrFunction;

			s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value == null ? "" : value);
		};

		// If an array was passed in, assume that it is an array of form elements.
		if (jQuery.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) {

			// Serialize the form elements
			jQuery.each(a, function () {
				add(this.name, this.value);
			});
		} else {

			// If traditional, encode the "old" way (the way 1.3.2 or older
			// did it), otherwise encode params recursively.
			for (prefix in a) {
				buildParams(prefix, a[prefix], traditional, add);
			}
		}

		// Return the resulting serialization
		return s.join("&");
	};

	jQuery.fn.extend({
		serialize: function () {
			return jQuery.param(this.serializeArray());
		},
		serializeArray: function () {
			return this.map(function () {

				// Can add propHook for "elements" to filter or add form elements
				var elements = jQuery.prop(this, "elements");
				return elements ? jQuery.makeArray(elements) : this;
			}).filter(function () {
				var type = this.type;

				// Use .is( ":disabled" ) so that fieldset[disabled] works
				return this.name && !jQuery(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
			}).map(function (i, elem) {
				var val = jQuery(this).val();

				if (val == null) {
					return null;
				}

				if (jQuery.isArray(val)) {
					return jQuery.map(val, function (val) {
						return { name: elem.name, value: val.replace(rCRLF, "\r\n") };
					});
				}

				return { name: elem.name, value: val.replace(rCRLF, "\r\n") };
			}).get();
		}
	});

	var r20 = /%20/g,
	    rhash = /#.*$/,
	    rantiCache = /([?&])_=[^&]*/,
	    rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,


	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	    rnoContent = /^(?:GET|HEAD)$/,
	    rprotocol = /^\/\//,


	/* Prefilters
  * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
  * 2) These are called:
  *    - BEFORE asking for a transport
  *    - AFTER param serialization (s.data is a string if s.processData is true)
  * 3) key is the dataType
  * 4) the catchall symbol "*" can be used
  * 5) execution will start with transport dataType and THEN continue down to "*" if needed
  */
	prefilters = {},


	/* Transports bindings
  * 1) key is the dataType
  * 2) the catchall symbol "*" can be used
  * 3) selection will start with transport dataType and THEN go to "*" if needed
  */
	transports = {},


	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat("*"),


	// Anchor tag for parsing the document origin
	originAnchor = document.createElement("a");
	originAnchor.href = location.href;

	// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
	function addToPrefiltersOrTransports(structure) {

		// dataTypeExpression is optional and defaults to "*"
		return function (dataTypeExpression, func) {

			if (typeof dataTypeExpression !== "string") {
				func = dataTypeExpression;
				dataTypeExpression = "*";
			}

			var dataType,
			    i = 0,
			    dataTypes = dataTypeExpression.toLowerCase().match(rnothtmlwhite) || [];

			if (jQuery.isFunction(func)) {

				// For each dataType in the dataTypeExpression
				while (dataType = dataTypes[i++]) {

					// Prepend if requested
					if (dataType[0] === "+") {
						dataType = dataType.slice(1) || "*";
						(structure[dataType] = structure[dataType] || []).unshift(func);

						// Otherwise append
					} else {
						(structure[dataType] = structure[dataType] || []).push(func);
					}
				}
			}
		};
	}

	// Base inspection function for prefilters and transports
	function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {

		var inspected = {},
		    seekingTransport = structure === transports;

		function inspect(dataType) {
			var selected;
			inspected[dataType] = true;
			jQuery.each(structure[dataType] || [], function (_, prefilterOrFactory) {
				var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
				if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {

					options.dataTypes.unshift(dataTypeOrTransport);
					inspect(dataTypeOrTransport);
					return false;
				} else if (seekingTransport) {
					return !(selected = dataTypeOrTransport);
				}
			});
			return selected;
		}

		return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
	}

	// A special extend for ajax options
	// that takes "flat" options (not to be deep extended)
	// Fixes #9887
	function ajaxExtend(target, src) {
		var key,
		    deep,
		    flatOptions = jQuery.ajaxSettings.flatOptions || {};

		for (key in src) {
			if (src[key] !== undefined) {
				(flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];
			}
		}
		if (deep) {
			jQuery.extend(true, target, deep);
		}

		return target;
	}

	/* Handles responses to an ajax request:
  * - finds the right dataType (mediates between content-type and expected dataType)
  * - returns the corresponding response
  */
	function ajaxHandleResponses(s, jqXHR, responses) {

		var ct,
		    type,
		    finalDataType,
		    firstDataType,
		    contents = s.contents,
		    dataTypes = s.dataTypes;

		// Remove auto dataType and get content-type in the process
		while (dataTypes[0] === "*") {
			dataTypes.shift();
			if (ct === undefined) {
				ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
			}
		}

		// Check if we're dealing with a known content-type
		if (ct) {
			for (type in contents) {
				if (contents[type] && contents[type].test(ct)) {
					dataTypes.unshift(type);
					break;
				}
			}
		}

		// Check to see if we have a response for the expected dataType
		if (dataTypes[0] in responses) {
			finalDataType = dataTypes[0];
		} else {

			// Try convertible dataTypes
			for (type in responses) {
				if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
					finalDataType = type;
					break;
				}
				if (!firstDataType) {
					firstDataType = type;
				}
			}

			// Or just use first one
			finalDataType = finalDataType || firstDataType;
		}

		// If we found a dataType
		// We add the dataType to the list if needed
		// and return the corresponding response
		if (finalDataType) {
			if (finalDataType !== dataTypes[0]) {
				dataTypes.unshift(finalDataType);
			}
			return responses[finalDataType];
		}
	}

	/* Chain conversions given the request and the original response
  * Also sets the responseXXX fields on the jqXHR instance
  */
	function ajaxConvert(s, response, jqXHR, isSuccess) {
		var conv2,
		    current,
		    conv,
		    tmp,
		    prev,
		    converters = {},


		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

		// Create converters map with lowercased keys
		if (dataTypes[1]) {
			for (conv in s.converters) {
				converters[conv.toLowerCase()] = s.converters[conv];
			}
		}

		current = dataTypes.shift();

		// Convert to each sequential dataType
		while (current) {

			if (s.responseFields[current]) {
				jqXHR[s.responseFields[current]] = response;
			}

			// Apply the dataFilter if provided
			if (!prev && isSuccess && s.dataFilter) {
				response = s.dataFilter(response, s.dataType);
			}

			prev = current;
			current = dataTypes.shift();

			if (current) {

				// There's only work to do if current dataType is non-auto
				if (current === "*") {

					current = prev;

					// Convert response if prev dataType is non-auto and differs from current
				} else if (prev !== "*" && prev !== current) {

					// Seek a direct converter
					conv = converters[prev + " " + current] || converters["* " + current];

					// If none found, seek a pair
					if (!conv) {
						for (conv2 in converters) {

							// If conv2 outputs current
							tmp = conv2.split(" ");
							if (tmp[1] === current) {

								// If prev can be converted to accepted input
								conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];
								if (conv) {

									// Condense equivalence converters
									if (conv === true) {
										conv = converters[conv2];

										// Otherwise, insert the intermediate dataType
									} else if (converters[conv2] !== true) {
										current = tmp[0];
										dataTypes.unshift(tmp[1]);
									}
									break;
								}
							}
						}
					}

					// Apply converter (if not an equivalence)
					if (conv !== true) {

						// Unless errors are allowed to bubble, catch and return them
						if (conv && s.throws) {
							response = conv(response);
						} else {
							try {
								response = conv(response);
							} catch (e) {
								return {
									state: "parsererror",
									error: conv ? e : "No conversion from " + prev + " to " + current
								};
							}
						}
					}
				}
			}
		}

		return { state: "success", data: response };
	}

	jQuery.extend({

		// Counter for holding the number of active queries
		active: 0,

		// Last-Modified header cache for next request
		lastModified: {},
		etag: {},

		ajaxSettings: {
			url: location.href,
			type: "GET",
			isLocal: rlocalProtocol.test(location.protocol),
			global: true,
			processData: true,
			async: true,
			contentType: "application/x-www-form-urlencoded; charset=UTF-8",

			/*
   timeout: 0,
   data: null,
   dataType: null,
   username: null,
   password: null,
   cache: null,
   throws: false,
   traditional: false,
   headers: {},
   */

			accepts: {
				"*": allTypes,
				text: "text/plain",
				html: "text/html",
				xml: "application/xml, text/xml",
				json: "application/json, text/javascript"
			},

			contents: {
				xml: /\bxml\b/,
				html: /\bhtml/,
				json: /\bjson\b/
			},

			responseFields: {
				xml: "responseXML",
				text: "responseText",
				json: "responseJSON"
			},

			// Data converters
			// Keys separate source (or catchall "*") and destination types with a single space
			converters: {

				// Convert anything to text
				"* text": String,

				// Text to html (true = no transformation)
				"text html": true,

				// Evaluate text as a json expression
				"text json": JSON.parse,

				// Parse text as xml
				"text xml": jQuery.parseXML
			},

			// For options that shouldn't be deep extended:
			// you can add your own custom options here if
			// and when you create one that shouldn't be
			// deep extended (see ajaxExtend)
			flatOptions: {
				url: true,
				context: true
			}
		},

		// Creates a full fledged settings object into target
		// with both ajaxSettings and settings fields.
		// If target is omitted, writes into ajaxSettings.
		ajaxSetup: function (target, settings) {
			return settings ?

			// Building a settings object
			ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) :

			// Extending ajaxSettings
			ajaxExtend(jQuery.ajaxSettings, target);
		},

		ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
		ajaxTransport: addToPrefiltersOrTransports(transports),

		// Main method
		ajax: function (url, options) {

			// If url is an object, simulate pre-1.5 signature
			if (typeof url === "object") {
				options = url;
				url = undefined;
			}

			// Force options to be an object
			options = options || {};

			var transport,


			// URL without anti-cache param
			cacheURL,


			// Response headers
			responseHeadersString,
			    responseHeaders,


			// timeout handle
			timeoutTimer,


			// Url cleanup var
			urlAnchor,


			// Request state (becomes false upon send and true upon completion)
			completed,


			// To know if global events are to be dispatched
			fireGlobals,


			// Loop variable
			i,


			// uncached part of the url
			uncached,


			// Create the final options object
			s = jQuery.ajaxSetup({}, options),


			// Callbacks context
			callbackContext = s.context || s,


			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event,


			// Deferreds
			deferred = jQuery.Deferred(),
			    completeDeferred = jQuery.Callbacks("once memory"),


			// Status-dependent callbacks
			statusCode = s.statusCode || {},


			// Headers (they are sent all at once)
			requestHeaders = {},
			    requestHeadersNames = {},


			// Default abort message
			strAbort = "canceled",


			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function (key) {
					var match;
					if (completed) {
						if (!responseHeaders) {
							responseHeaders = {};
							while (match = rheaders.exec(responseHeadersString)) {
								responseHeaders[match[1].toLowerCase()] = match[2];
							}
						}
						match = responseHeaders[key.toLowerCase()];
					}
					return match == null ? null : match;
				},

				// Raw string
				getAllResponseHeaders: function () {
					return completed ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function (name, value) {
					if (completed == null) {
						name = requestHeadersNames[name.toLowerCase()] = requestHeadersNames[name.toLowerCase()] || name;
						requestHeaders[name] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function (type) {
					if (completed == null) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function (map) {
					var code;
					if (map) {
						if (completed) {

							// Execute the appropriate callbacks
							jqXHR.always(map[jqXHR.status]);
						} else {

							// Lazy-add the new callbacks in a way that preserves old ones
							for (code in map) {
								statusCode[code] = [statusCode[code], map[code]];
							}
						}
					}
					return this;
				},

				// Cancel the request
				abort: function (statusText) {
					var finalText = statusText || strAbort;
					if (transport) {
						transport.abort(finalText);
					}
					done(0, finalText);
					return this;
				}
			};

			// Attach deferreds
			deferred.promise(jqXHR);

			// Add protocol if not provided (prefilters might expect it)
			// Handle falsy url in the settings object (#10093: consistency with old signature)
			// We also use the url parameter if available
			s.url = ((url || s.url || location.href) + "").replace(rprotocol, location.protocol + "//");

			// Alias method option to type as per ticket #12004
			s.type = options.method || options.type || s.method || s.type;

			// Extract dataTypes list
			s.dataTypes = (s.dataType || "*").toLowerCase().match(rnothtmlwhite) || [""];

			// A cross-domain request is in order when the origin doesn't match the current origin.
			if (s.crossDomain == null) {
				urlAnchor = document.createElement("a");

				// Support: IE <=8 - 11, Edge 12 - 13
				// IE throws exception on accessing the href property if url is malformed,
				// e.g. http://example.com:80x/
				try {
					urlAnchor.href = s.url;

					// Support: IE <=8 - 11 only
					// Anchor's host property isn't correctly set when s.url is relative
					urlAnchor.href = urlAnchor.href;
					s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !== urlAnchor.protocol + "//" + urlAnchor.host;
				} catch (e) {

					// If there is an error parsing the URL, assume it is crossDomain,
					// it can be rejected by the transport if it is invalid
					s.crossDomain = true;
				}
			}

			// Convert data if not already a string
			if (s.data && s.processData && typeof s.data !== "string") {
				s.data = jQuery.param(s.data, s.traditional);
			}

			// Apply prefilters
			inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);

			// If request was aborted inside a prefilter, stop there
			if (completed) {
				return jqXHR;
			}

			// We can fire global events as of now if asked to
			// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
			fireGlobals = jQuery.event && s.global;

			// Watch for a new set of requests
			if (fireGlobals && jQuery.active++ === 0) {
				jQuery.event.trigger("ajaxStart");
			}

			// Uppercase the type
			s.type = s.type.toUpperCase();

			// Determine if request has content
			s.hasContent = !rnoContent.test(s.type);

			// Save the URL in case we're toying with the If-Modified-Since
			// and/or If-None-Match header later on
			// Remove hash to simplify url manipulation
			cacheURL = s.url.replace(rhash, "");

			// More options handling for requests with no content
			if (!s.hasContent) {

				// Remember the hash so we can put it back
				uncached = s.url.slice(cacheURL.length);

				// If data is available, append data to url
				if (s.data) {
					cacheURL += (rquery.test(cacheURL) ? "&" : "?") + s.data;

					// #9682: remove data so that it's not used in an eventual retry
					delete s.data;
				}

				// Add or update anti-cache param if needed
				if (s.cache === false) {
					cacheURL = cacheURL.replace(rantiCache, "$1");
					uncached = (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce++ + uncached;
				}

				// Put hash and anti-cache on the URL that will be requested (gh-1732)
				s.url = cacheURL + uncached;

				// Change '%20' to '+' if this is encoded form body content (gh-2658)
			} else if (s.data && s.processData && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0) {
				s.data = s.data.replace(r20, "+");
			}

			// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
			if (s.ifModified) {
				if (jQuery.lastModified[cacheURL]) {
					jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]);
				}
				if (jQuery.etag[cacheURL]) {
					jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL]);
				}
			}

			// Set the correct header, if data is being sent
			if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
				jqXHR.setRequestHeader("Content-Type", s.contentType);
			}

			// Set the Accepts header for the server, depending on the dataType
			jqXHR.setRequestHeader("Accept", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]);

			// Check for headers option
			for (i in s.headers) {
				jqXHR.setRequestHeader(i, s.headers[i]);
			}

			// Allow custom headers/mimetypes and early abort
			if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || completed)) {

				// Abort if not done already and return
				return jqXHR.abort();
			}

			// Aborting is no longer a cancellation
			strAbort = "abort";

			// Install callbacks on deferreds
			completeDeferred.add(s.complete);
			jqXHR.done(s.success);
			jqXHR.fail(s.error);

			// Get transport
			transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);

			// If no transport, we auto-abort
			if (!transport) {
				done(-1, "No Transport");
			} else {
				jqXHR.readyState = 1;

				// Send global event
				if (fireGlobals) {
					globalEventContext.trigger("ajaxSend", [jqXHR, s]);
				}

				// If request was aborted inside ajaxSend, stop there
				if (completed) {
					return jqXHR;
				}

				// Timeout
				if (s.async && s.timeout > 0) {
					timeoutTimer = window.setTimeout(function () {
						jqXHR.abort("timeout");
					}, s.timeout);
				}

				try {
					completed = false;
					transport.send(requestHeaders, done);
				} catch (e) {

					// Rethrow post-completion exceptions
					if (completed) {
						throw e;
					}

					// Propagate others as results
					done(-1, e);
				}
			}

			// Callback for when everything is done
			function done(status, nativeStatusText, responses, headers) {
				var isSuccess,
				    success,
				    error,
				    response,
				    modified,
				    statusText = nativeStatusText;

				// Ignore repeat invocations
				if (completed) {
					return;
				}

				completed = true;

				// Clear timeout if it exists
				if (timeoutTimer) {
					window.clearTimeout(timeoutTimer);
				}

				// Dereference transport for early garbage collection
				// (no matter how long the jqXHR object will be used)
				transport = undefined;

				// Cache response headers
				responseHeadersString = headers || "";

				// Set readyState
				jqXHR.readyState = status > 0 ? 4 : 0;

				// Determine if successful
				isSuccess = status >= 200 && status < 300 || status === 304;

				// Get response data
				if (responses) {
					response = ajaxHandleResponses(s, jqXHR, responses);
				}

				// Convert no matter what (that way responseXXX fields are always set)
				response = ajaxConvert(s, response, jqXHR, isSuccess);

				// If successful, handle type chaining
				if (isSuccess) {

					// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
					if (s.ifModified) {
						modified = jqXHR.getResponseHeader("Last-Modified");
						if (modified) {
							jQuery.lastModified[cacheURL] = modified;
						}
						modified = jqXHR.getResponseHeader("etag");
						if (modified) {
							jQuery.etag[cacheURL] = modified;
						}
					}

					// if no content
					if (status === 204 || s.type === "HEAD") {
						statusText = "nocontent";

						// if not modified
					} else if (status === 304) {
						statusText = "notmodified";

						// If we have data, let's convert it
					} else {
						statusText = response.state;
						success = response.data;
						error = response.error;
						isSuccess = !error;
					}
				} else {

					// Extract error from statusText and normalize for non-aborts
					error = statusText;
					if (status || !statusText) {
						statusText = "error";
						if (status < 0) {
							status = 0;
						}
					}
				}

				// Set data for the fake xhr object
				jqXHR.status = status;
				jqXHR.statusText = (nativeStatusText || statusText) + "";

				// Success/Error
				if (isSuccess) {
					deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
				} else {
					deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
				}

				// Status-dependent callbacks
				jqXHR.statusCode(statusCode);
				statusCode = undefined;

				if (fireGlobals) {
					globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError", [jqXHR, s, isSuccess ? success : error]);
				}

				// Complete
				completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);

				if (fireGlobals) {
					globalEventContext.trigger("ajaxComplete", [jqXHR, s]);

					// Handle the global AJAX counter
					if (! --jQuery.active) {
						jQuery.event.trigger("ajaxStop");
					}
				}
			}

			return jqXHR;
		},

		getJSON: function (url, data, callback) {
			return jQuery.get(url, data, callback, "json");
		},

		getScript: function (url, callback) {
			return jQuery.get(url, undefined, callback, "script");
		}
	});

	jQuery.each(["get", "post"], function (i, method) {
		jQuery[method] = function (url, data, callback, type) {

			// Shift arguments if data argument was omitted
			if (jQuery.isFunction(data)) {
				type = type || callback;
				callback = data;
				data = undefined;
			}

			// The url can be an options object (which then must have .url)
			return jQuery.ajax(jQuery.extend({
				url: url,
				type: method,
				dataType: type,
				data: data,
				success: callback
			}, jQuery.isPlainObject(url) && url));
		};
	});

	jQuery._evalUrl = function (url) {
		return jQuery.ajax({
			url: url,

			// Make this explicit, since user can override this through ajaxSetup (#11264)
			type: "GET",
			dataType: "script",
			cache: true,
			async: false,
			global: false,
			"throws": true
		});
	};

	jQuery.fn.extend({
		wrapAll: function (html) {
			var wrap;

			if (this[0]) {
				if (jQuery.isFunction(html)) {
					html = html.call(this[0]);
				}

				// The elements to wrap the target around
				wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);

				if (this[0].parentNode) {
					wrap.insertBefore(this[0]);
				}

				wrap.map(function () {
					var elem = this;

					while (elem.firstElementChild) {
						elem = elem.firstElementChild;
					}

					return elem;
				}).append(this);
			}

			return this;
		},

		wrapInner: function (html) {
			if (jQuery.isFunction(html)) {
				return this.each(function (i) {
					jQuery(this).wrapInner(html.call(this, i));
				});
			}

			return this.each(function () {
				var self = jQuery(this),
				    contents = self.contents();

				if (contents.length) {
					contents.wrapAll(html);
				} else {
					self.append(html);
				}
			});
		},

		wrap: function (html) {
			var isFunction = jQuery.isFunction(html);

			return this.each(function (i) {
				jQuery(this).wrapAll(isFunction ? html.call(this, i) : html);
			});
		},

		unwrap: function (selector) {
			this.parent(selector).not("body").each(function () {
				jQuery(this).replaceWith(this.childNodes);
			});
			return this;
		}
	});

	jQuery.expr.pseudos.hidden = function (elem) {
		return !jQuery.expr.pseudos.visible(elem);
	};
	jQuery.expr.pseudos.visible = function (elem) {
		return !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length);
	};

	jQuery.ajaxSettings.xhr = function () {
		try {
			return new window.XMLHttpRequest();
		} catch (e) {}
	};

	var xhrSuccessStatus = {

		// File protocol always yields status code 0, assume 200
		0: 200,

		// Support: IE <=9 only
		// #1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	    xhrSupported = jQuery.ajaxSettings.xhr();

	support.cors = !!xhrSupported && "withCredentials" in xhrSupported;
	support.ajax = xhrSupported = !!xhrSupported;

	jQuery.ajaxTransport(function (options) {
		var callback, errorCallback;

		// Cross domain only allowed if supported through XMLHttpRequest
		if (support.cors || xhrSupported && !options.crossDomain) {
			return {
				send: function (headers, complete) {
					var i,
					    xhr = options.xhr();

					xhr.open(options.type, options.url, options.async, options.username, options.password);

					// Apply custom fields if provided
					if (options.xhrFields) {
						for (i in options.xhrFields) {
							xhr[i] = options.xhrFields[i];
						}
					}

					// Override mime type if needed
					if (options.mimeType && xhr.overrideMimeType) {
						xhr.overrideMimeType(options.mimeType);
					}

					// X-Requested-With header
					// For cross-domain requests, seeing as conditions for a preflight are
					// akin to a jigsaw puzzle, we simply never set it to be sure.
					// (it can always be set on a per-request basis or even using ajaxSetup)
					// For same-domain requests, won't change header if already provided.
					if (!options.crossDomain && !headers["X-Requested-With"]) {
						headers["X-Requested-With"] = "XMLHttpRequest";
					}

					// Set headers
					for (i in headers) {
						xhr.setRequestHeader(i, headers[i]);
					}

					// Callback
					callback = function (type) {
						return function () {
							if (callback) {
								callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.onreadystatechange = null;

								if (type === "abort") {
									xhr.abort();
								} else if (type === "error") {

									// Support: IE <=9 only
									// On a manual native abort, IE9 throws
									// errors on any property access that is not readyState
									if (typeof xhr.status !== "number") {
										complete(0, "error");
									} else {
										complete(

										// File: protocol always yields status 0; see #8605, #14207
										xhr.status, xhr.statusText);
									}
								} else {
									complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText,

									// Support: IE <=9 only
									// IE9 has no XHR2 but throws on binary (trac-11426)
									// For XHR2 non-text, let the caller handle it (gh-2498)
									(xhr.responseType || "text") !== "text" || typeof xhr.responseText !== "string" ? { binary: xhr.response } : { text: xhr.responseText }, xhr.getAllResponseHeaders());
								}
							}
						};
					};

					// Listen to events
					xhr.onload = callback();
					errorCallback = xhr.onerror = callback("error");

					// Support: IE 9 only
					// Use onreadystatechange to replace onabort
					// to handle uncaught aborts
					if (xhr.onabort !== undefined) {
						xhr.onabort = errorCallback;
					} else {
						xhr.onreadystatechange = function () {

							// Check readyState before timeout as it changes
							if (xhr.readyState === 4) {

								// Allow onerror to be called first,
								// but that will not handle a native abort
								// Also, save errorCallback to a variable
								// as xhr.onerror cannot be accessed
								window.setTimeout(function () {
									if (callback) {
										errorCallback();
									}
								});
							}
						};
					}

					// Create the abort callback
					callback = callback("abort");

					try {

						// Do send the request (this may raise an exception)
						xhr.send(options.hasContent && options.data || null);
					} catch (e) {

						// #14683: Only rethrow if this hasn't been notified as an error yet
						if (callback) {
							throw e;
						}
					}
				},

				abort: function () {
					if (callback) {
						callback();
					}
				}
			};
		}
	});

	// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
	jQuery.ajaxPrefilter(function (s) {
		if (s.crossDomain) {
			s.contents.script = false;
		}
	});

	// Install script dataType
	jQuery.ajaxSetup({
		accepts: {
			script: "text/javascript, application/javascript, " + "application/ecmascript, application/x-ecmascript"
		},
		contents: {
			script: /\b(?:java|ecma)script\b/
		},
		converters: {
			"text script": function (text) {
				jQuery.globalEval(text);
				return text;
			}
		}
	});

	// Handle cache's special case and crossDomain
	jQuery.ajaxPrefilter("script", function (s) {
		if (s.cache === undefined) {
			s.cache = false;
		}
		if (s.crossDomain) {
			s.type = "GET";
		}
	});

	// Bind script tag hack transport
	jQuery.ajaxTransport("script", function (s) {

		// This transport only deals with cross domain requests
		if (s.crossDomain) {
			var script, callback;
			return {
				send: function (_, complete) {
					script = jQuery("<script>").prop({
						charset: s.scriptCharset,
						src: s.url
					}).on("load error", callback = function (evt) {
						script.remove();
						callback = null;
						if (evt) {
							complete(evt.type === "error" ? 404 : 200, evt.type);
						}
					});

					// Use native DOM manipulation to avoid our domManip AJAX trickery
					document.head.appendChild(script[0]);
				},
				abort: function () {
					if (callback) {
						callback();
					}
				}
			};
		}
	});

	var oldCallbacks = [],
	    rjsonp = /(=)\?(?=&|$)|\?\?/;

	// Default jsonp settings
	jQuery.ajaxSetup({
		jsonp: "callback",
		jsonpCallback: function () {
			var callback = oldCallbacks.pop() || jQuery.expando + "_" + nonce++;
			this[callback] = true;
			return callback;
		}
	});

	// Detect, normalize options and install callbacks for jsonp requests
	jQuery.ajaxPrefilter("json jsonp", function (s, originalSettings, jqXHR) {

		var callbackName,
		    overwritten,
		    responseContainer,
		    jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? "url" : typeof s.data === "string" && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0 && rjsonp.test(s.data) && "data");

		// Handle iff the expected data type is "jsonp" or we have a parameter to set
		if (jsonProp || s.dataTypes[0] === "jsonp") {

			// Get callback name, remembering preexisting value associated with it
			callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;

			// Insert callback into url or form data
			if (jsonProp) {
				s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
			} else if (s.jsonp !== false) {
				s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName;
			}

			// Use data converter to retrieve json after script execution
			s.converters["script json"] = function () {
				if (!responseContainer) {
					jQuery.error(callbackName + " was not called");
				}
				return responseContainer[0];
			};

			// Force json dataType
			s.dataTypes[0] = "json";

			// Install callback
			overwritten = window[callbackName];
			window[callbackName] = function () {
				responseContainer = arguments;
			};

			// Clean-up function (fires after converters)
			jqXHR.always(function () {

				// If previous value didn't exist - remove it
				if (overwritten === undefined) {
					jQuery(window).removeProp(callbackName);

					// Otherwise restore preexisting value
				} else {
					window[callbackName] = overwritten;
				}

				// Save back as free
				if (s[callbackName]) {

					// Make sure that re-using the options doesn't screw things around
					s.jsonpCallback = originalSettings.jsonpCallback;

					// Save the callback name for future use
					oldCallbacks.push(callbackName);
				}

				// Call if it was a function and we have a response
				if (responseContainer && jQuery.isFunction(overwritten)) {
					overwritten(responseContainer[0]);
				}

				responseContainer = overwritten = undefined;
			});

			// Delegate to script
			return "script";
		}
	});

	// Support: Safari 8 only
	// In Safari 8 documents created via document.implementation.createHTMLDocument
	// collapse sibling forms: the second one becomes a child of the first one.
	// Because of that, this security measure has to be disabled in Safari 8.
	// https://bugs.webkit.org/show_bug.cgi?id=137337
	support.createHTMLDocument = function () {
		var body = document.implementation.createHTMLDocument("").body;
		body.innerHTML = "<form></form><form></form>";
		return body.childNodes.length === 2;
	}();

	// Argument "data" should be string of html
	// context (optional): If specified, the fragment will be created in this context,
	// defaults to document
	// keepScripts (optional): If true, will include scripts passed in the html string
	jQuery.parseHTML = function (data, context, keepScripts) {
		if (typeof data !== "string") {
			return [];
		}
		if (typeof context === "boolean") {
			keepScripts = context;
			context = false;
		}

		var base, parsed, scripts;

		if (!context) {

			// Stop scripts or inline event handlers from being executed immediately
			// by using document.implementation
			if (support.createHTMLDocument) {
				context = document.implementation.createHTMLDocument("");

				// Set the base href for the created document
				// so any parsed elements with URLs
				// are based on the document's URL (gh-2965)
				base = context.createElement("base");
				base.href = document.location.href;
				context.head.appendChild(base);
			} else {
				context = document;
			}
		}

		parsed = rsingleTag.exec(data);
		scripts = !keepScripts && [];

		// Single tag
		if (parsed) {
			return [context.createElement(parsed[1])];
		}

		parsed = buildFragment([data], context, scripts);

		if (scripts && scripts.length) {
			jQuery(scripts).remove();
		}

		return jQuery.merge([], parsed.childNodes);
	};

	/**
  * Load a url into a page
  */
	jQuery.fn.load = function (url, params, callback) {
		var selector,
		    type,
		    response,
		    self = this,
		    off = url.indexOf(" ");

		if (off > -1) {
			selector = stripAndCollapse(url.slice(off));
			url = url.slice(0, off);
		}

		// If it's a function
		if (jQuery.isFunction(params)) {

			// We assume that it's the callback
			callback = params;
			params = undefined;

			// Otherwise, build a param string
		} else if (params && typeof params === "object") {
			type = "POST";
		}

		// If we have elements to modify, make the request
		if (self.length > 0) {
			jQuery.ajax({
				url: url,

				// If "type" variable is undefined, then "GET" method will be used.
				// Make value of this field explicit since
				// user can override it through ajaxSetup method
				type: type || "GET",
				dataType: "html",
				data: params
			}).done(function (responseText) {

				// Save response for use in complete callback
				response = arguments;

				self.html(selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector) :

				// Otherwise use the full result
				responseText);

				// If the request succeeds, this function gets "data", "status", "jqXHR"
				// but they are ignored because response was set above.
				// If it fails, this function gets "jqXHR", "status", "error"
			}).always(callback && function (jqXHR, status) {
				self.each(function () {
					callback.apply(this, response || [jqXHR.responseText, status, jqXHR]);
				});
			});
		}

		return this;
	};

	// Attach a bunch of functions for handling common AJAX events
	jQuery.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function (i, type) {
		jQuery.fn[type] = function (fn) {
			return this.on(type, fn);
		};
	});

	jQuery.expr.pseudos.animated = function (elem) {
		return jQuery.grep(jQuery.timers, function (fn) {
			return elem === fn.elem;
		}).length;
	};

	/**
  * Gets a window from an element
  */
	function getWindow(elem) {
		return jQuery.isWindow(elem) ? elem : elem.nodeType === 9 && elem.defaultView;
	}

	jQuery.offset = {
		setOffset: function (elem, options, i) {
			var curPosition,
			    curLeft,
			    curCSSTop,
			    curTop,
			    curOffset,
			    curCSSLeft,
			    calculatePosition,
			    position = jQuery.css(elem, "position"),
			    curElem = jQuery(elem),
			    props = {};

			// Set position first, in-case top/left are set even on static elem
			if (position === "static") {
				elem.style.position = "relative";
			}

			curOffset = curElem.offset();
			curCSSTop = jQuery.css(elem, "top");
			curCSSLeft = jQuery.css(elem, "left");
			calculatePosition = (position === "absolute" || position === "fixed") && (curCSSTop + curCSSLeft).indexOf("auto") > -1;

			// Need to be able to calculate position if either
			// top or left is auto and position is either absolute or fixed
			if (calculatePosition) {
				curPosition = curElem.position();
				curTop = curPosition.top;
				curLeft = curPosition.left;
			} else {
				curTop = parseFloat(curCSSTop) || 0;
				curLeft = parseFloat(curCSSLeft) || 0;
			}

			if (jQuery.isFunction(options)) {

				// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
				options = options.call(elem, i, jQuery.extend({}, curOffset));
			}

			if (options.top != null) {
				props.top = options.top - curOffset.top + curTop;
			}
			if (options.left != null) {
				props.left = options.left - curOffset.left + curLeft;
			}

			if ("using" in options) {
				options.using.call(elem, props);
			} else {
				curElem.css(props);
			}
		}
	};

	jQuery.fn.extend({
		offset: function (options) {

			// Preserve chaining for setter
			if (arguments.length) {
				return options === undefined ? this : this.each(function (i) {
					jQuery.offset.setOffset(this, options, i);
				});
			}

			var docElem,
			    win,
			    rect,
			    doc,
			    elem = this[0];

			if (!elem) {
				return;
			}

			// Support: IE <=11 only
			// Running getBoundingClientRect on a
			// disconnected node in IE throws an error
			if (!elem.getClientRects().length) {
				return { top: 0, left: 0 };
			}

			rect = elem.getBoundingClientRect();

			// Make sure element is not hidden (display: none)
			if (rect.width || rect.height) {
				doc = elem.ownerDocument;
				win = getWindow(doc);
				docElem = doc.documentElement;

				return {
					top: rect.top + win.pageYOffset - docElem.clientTop,
					left: rect.left + win.pageXOffset - docElem.clientLeft
				};
			}

			// Return zeros for disconnected and hidden elements (gh-2310)
			return rect;
		},

		position: function () {
			if (!this[0]) {
				return;
			}

			var offsetParent,
			    offset,
			    elem = this[0],
			    parentOffset = { top: 0, left: 0 };

			// Fixed elements are offset from window (parentOffset = {top:0, left: 0},
			// because it is its only offset parent
			if (jQuery.css(elem, "position") === "fixed") {

				// Assume getBoundingClientRect is there when computed position is fixed
				offset = elem.getBoundingClientRect();
			} else {

				// Get *real* offsetParent
				offsetParent = this.offsetParent();

				// Get correct offsets
				offset = this.offset();
				if (!jQuery.nodeName(offsetParent[0], "html")) {
					parentOffset = offsetParent.offset();
				}

				// Add offsetParent borders
				parentOffset = {
					top: parentOffset.top + jQuery.css(offsetParent[0], "borderTopWidth", true),
					left: parentOffset.left + jQuery.css(offsetParent[0], "borderLeftWidth", true)
				};
			}

			// Subtract parent offsets and element margins
			return {
				top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", true),
				left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", true)
			};
		},

		// This method will return documentElement in the following cases:
		// 1) For the element inside the iframe without offsetParent, this method will return
		//    documentElement of the parent window
		// 2) For the hidden or detached element
		// 3) For body or html element, i.e. in case of the html node - it will return itself
		//
		// but those exceptions were never presented as a real life use-cases
		// and might be considered as more preferable results.
		//
		// This logic, however, is not guaranteed and can change at any point in the future
		offsetParent: function () {
			return this.map(function () {
				var offsetParent = this.offsetParent;

				while (offsetParent && jQuery.css(offsetParent, "position") === "static") {
					offsetParent = offsetParent.offsetParent;
				}

				return offsetParent || documentElement;
			});
		}
	});

	// Create scrollLeft and scrollTop methods
	jQuery.each({ scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function (method, prop) {
		var top = "pageYOffset" === prop;

		jQuery.fn[method] = function (val) {
			return access(this, function (elem, method, val) {
				var win = getWindow(elem);

				if (val === undefined) {
					return win ? win[prop] : elem[method];
				}

				if (win) {
					win.scrollTo(!top ? val : win.pageXOffset, top ? val : win.pageYOffset);
				} else {
					elem[method] = val;
				}
			}, method, val, arguments.length);
		};
	});

	// Support: Safari <=7 - 9.1, Chrome <=37 - 49
	// Add the top/left cssHooks using jQuery.fn.position
	// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
	// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
	// getComputedStyle returns percent when specified for top/left/bottom/right;
	// rather than make the css module depend on the offset module, just check for it here
	jQuery.each(["top", "left"], function (i, prop) {
		jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function (elem, computed) {
			if (computed) {
				computed = curCSS(elem, prop);

				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + "px" : computed;
			}
		});
	});

	// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
	jQuery.each({ Height: "height", Width: "width" }, function (name, type) {
		jQuery.each({ padding: "inner" + name, content: type, "": "outer" + name }, function (defaultExtra, funcName) {

			// Margin is only for outerHeight, outerWidth
			jQuery.fn[funcName] = function (margin, value) {
				var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"),
				    extra = defaultExtra || (margin === true || value === true ? "margin" : "border");

				return access(this, function (elem, type, value) {
					var doc;

					if (jQuery.isWindow(elem)) {

						// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
						return funcName.indexOf("outer") === 0 ? elem["inner" + name] : elem.document.documentElement["client" + name];
					}

					// Get document width or height
					if (elem.nodeType === 9) {
						doc = elem.documentElement;

						// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
						// whichever is greatest
						return Math.max(elem.body["scroll" + name], doc["scroll" + name], elem.body["offset" + name], doc["offset" + name], doc["client" + name]);
					}

					return value === undefined ?

					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css(elem, type, extra) :

					// Set width or height on the element
					jQuery.style(elem, type, value, extra);
				}, type, chainable ? margin : undefined, chainable);
			};
		});
	});

	jQuery.fn.extend({

		bind: function (types, data, fn) {
			return this.on(types, null, data, fn);
		},
		unbind: function (types, fn) {
			return this.off(types, null, fn);
		},

		delegate: function (selector, types, data, fn) {
			return this.on(types, selector, data, fn);
		},
		undelegate: function (selector, types, fn) {

			// ( namespace ) or ( selector, types [, fn] )
			return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn);
		}
	});

	jQuery.parseJSON = JSON.parse;

	// Register as a named AMD module, since jQuery can be concatenated with other
	// files that may use define, but not via a proper concatenation script that
	// understands anonymous AMD modules. A named AMD is safest and most robust
	// way to register. Lowercase jquery is used because AMD module names are
	// derived from file names, and jQuery is normally delivered in a lowercase
	// file name. Do this after creating the global so that if an AMD module wants
	// to call noConflict to hide this version of jQuery, it will work.

	// Note that for maximum portability, libraries that are not jQuery should
	// declare themselves as anonymous modules, and avoid setting a global if an
	// AMD loader is present. jQuery is a special case. For more information, see
	// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

	if (true) {
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
			return jQuery;
		}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}

	var

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,


	// Map over the $ in case of overwrite
	_$ = window.$;

	jQuery.noConflict = function (deep) {
		if (window.$ === jQuery) {
			window.$ = _$;
		}

		if (deep && window.jQuery === jQuery) {
			window.jQuery = _jQuery;
		}

		return jQuery;
	};

	// Expose jQuery and $ identifiers, even in AMD
	// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
	// and CommonJS for browser emulators (#13566)
	if (!noGlobal) {
		window.jQuery = window.$ = jQuery;
	}

	return jQuery;
});

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

var Presenter = __webpack_require__(9);

var App = { Presenter };

App.init = function () {
  this.Presenter.init();
};

module.exports = App;

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Backbone) {var OrderModel = __webpack_require__(7);

var OrderCollection = Backbone.Collection.extend({
  model: OrderModel,
  url: "/api/users/self/orders"
});

module.exports = OrderCollection;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Backbone) {var OrderModel = Backbone.Model.extend({
  urlRoot: "/api/orders"
});
// Return the model for the module
module.exports = OrderModel;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function($) {var localStorage = __webpack_require__(2);
var EventBus = __webpack_require__(3);

var Api = {};

Api.login = function (data) {
  return $.ajax({
    url: '/api/users/login',
    dataType: 'json',
    type: 'post',
    contentType: 'application/json',
    data: JSON.stringify(data),
    processData: false
  });
};

Api.signup = function (data) {
  return $.ajax({
    url: '/api/users',
    dataType: 'json',
    type: 'post',
    contentType: 'application/json',
    data: JSON.stringify(data),
    processData: false
  });
};

Api.init = function () {

  // Login

  EventBus.on('api:login', function (username, password) {
    Api.login({ username: username, password: password }).then(EventBus.trigger.bind(EventBus, 'api:login:successful')).catch(EventBus.trigger.bind(EventBus, 'api:login:error')).done();
  });

  EventBus.on('api:login:successful', function (user) {
    localStorage.setItem('user', user);
    EventBus.trigger('ui:showHome');
  });

  EventBus.on('api:login:error', EventBus.trigger.bind(EventBus, 'ui:showError'));

  // Signup

  EventBus.on('api:signup', function (data) {
    Api.signup(data).then(EventBus.trigger.bind(EventBus, 'api:signup:successful')).catch(EventBus.trigger.bind(EventBus, 'api:signup:error')).done();
  });

  EventBus.on('api:signup:successful', function (user) {
    EventBus.trigger('ui:showHome');
  });

  EventBus.on('api:signup:error', EventBus.trigger.bind(EventBus, 'ui:showError'));
};

module.exports = Api;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {


var Presenters = {};

var Ui = __webpack_require__(12);
var Router = __webpack_require__(11);
var Login = __webpack_require__(10);
var Api = __webpack_require__(8);

Presenters.init = function () {
  Ui.init();
  Login.init();
  Api.init();
  Router.init();
};

module.exports = Presenters;

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

var EventBus = __webpack_require__(3);

var Login = {};

Login.init = function () {

  EventBus.on('view:login:request', EventBus.trigger.bind(EventBus, 'api:login'));

  EventBus.on('view:signup:request', EventBus.trigger.bind(EventBus, 'api:signup'));
};

module.exports = Login;

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Backbone) {var EventBus = __webpack_require__(3);
var localStorage = __webpack_require__(2);

var Router = {};

Router.init = function () {
  var AppRouter = Backbone.Router.extend({
    routes: {
      // Define some URL routes
      '': 'home',
      'signup': 'signup',
      'login': 'home',
      'orders': 'showOrders',

      // Default
      '*actions': 'defaultAction'
    },

    home: function () {
      EventBus.trigger('ui:showHome');
    },

    signup: function () {
      EventBus.trigger('ui:switch:signup');
    },

    showOrders: function () {
      EventBus.trigger('ui:switch:orders');
    }
  });

  new AppRouter();

  Backbone.history.start();
};

module.exports = Router;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function($) {var EventBus = __webpack_require__(3);
var localStorage = __webpack_require__(2);
var CollectionOrder = __webpack_require__(6);
var UserLogin = __webpack_require__(15);
var UserSignup = __webpack_require__(16);
var HeaderView = __webpack_require__(13);
var OrdersView = __webpack_require__(14);

var Ui = {};

// Views that can be rendered at #content
var loginView = new UserLogin({ eventBus: EventBus });
var signupView = new UserSignup({ eventBus: EventBus });

var orderList = new CollectionOrder({ eventBus: EventBus });
var ordersView = new OrdersView({ collection: orderList, eventBus: EventBus });

var $content = $('#content');

var headerView = new HeaderView({ el: '#header', eventBus: EventBus });

Ui.switchContent = function (widget) {

  var args = Array.prototype.slice.call(arguments);
  args.shift();
  switch (widget) {
    case 'login':
      {
        $content.html(loginView.render.apply(loginView, args).el);
        loginView.delegateEvents();
        break;
      }
    case 'signup':
      {
        $content.html(signupView.render.apply(signupView, args).el);
        signupView.delegateEvents();
        break;
      }
    case 'orders':
      {
        orderList.fetch({
          success: function () {
            $content.html(ordersView.render.apply(ordersView, args).el);
            ordersView.delegateEvents();
          },
          error: Ui.error
        });
        break;
      }
  }
};

Ui.init = function () {
  headerView.setUserData(localStorage.getItem('user'));
  Ui.showHome();
};

Ui.showHome = function () {
  if (localStorage.hasItem('user')) {
    Ui.switchContent('orders');
  } else {
    Ui.switchContent('login');
  }
};

Ui.showSignup = function () {
  Ui.switchContent('signup');
};

Ui.showOrders = function () {
  orderList.fetch({
    success: Ui.switchContent.bind(Ui, 'orders'),
    error: Ui.error
  });
};

// This always receive a JSON object with a standard API error
Ui.error = function (err) {
  if (err.message) alert("Error: " + err.message);else if (err.responseJSON) {
    if (err.responseJSON.message) alert("Error: " + err.responseJSON.message);else if (err.responseJSON.error) alert("Error: " + err.responseJSON.error.message);
  }
};

EventBus.on('ui:showHome', Ui.showHome);
EventBus.on('ui:showError', Ui.error);
EventBus.on('ui:switch:signup', Ui.showSignup);
EventBus.on('ui:switch:orders', Ui.showOrders);

module.exports = Ui;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Backbone, _) {var t_header = __webpack_require__(18);

var userData = {};

var Header = Backbone.View.extend({

  initialize: function (params) {
    this.template = _.template(t_header);
    params.eventBus.on('localstorage:set:user', this.setUserData.bind(this));
  },

  render: function () {
    this.$el.html(this.template({ user: userData }));
    return this;
  },

  setUserData: function (user) {
    userData = user;
    this.render();
  }

});

module.exports = Header;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0), __webpack_require__(1)))

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Backbone, _) {var tl_order = __webpack_require__(19);

var OrderListView = Backbone.View.extend({

  initialize: function (eventBus) {
    this.eventBus = eventBus;
    this.template = _.template(tl_order);
  },

  className: 'container',

  render: function () {
    this.$el.html(this.template({ orders: this.collection }));
    return this;
  }

});

module.exports = OrderListView;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0), __webpack_require__(1)))

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Backbone, _) {var t_login = __webpack_require__(20);

var UserLogin = Backbone.View.extend({

  initialize: function (params) {
    this.eventBus = params.eventBus;
  },

  template: _.template(t_login),

  className: 'container',

  events: {
    'click #btn-login': 'submit'
  },

  submit: function () {
    this.eventBus.trigger('view:login:request', this.$('#login-username').val(), this.$('#login-password').val());
  },

  render: function () {
    this.$el.html(this.template());
    return this;
  }

});

module.exports = UserLogin;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0), __webpack_require__(1)))

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Backbone, _) {var t_signup = __webpack_require__(21);

var UserSignup = Backbone.View.extend({

  className: 'container',

  template: _.template(t_signup),

  initialize: function (params) {
    this.eventBus = params.eventBus;
  },

  events: {
    'click #btn-signup': 'submit'
  },

  submit: function () {
    var data = {
      username: this.$('[name=username]').val(),
      email: this.$('[name=email]').val(),
      password: this.$('[name=passwd]').val()
    };
    this.eventBus.trigger('view:signup:request', data);
  },

  render: function () {
    this.$el.html(this.template());
    return this;
  }
});

module.exports = UserSignup;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0), __webpack_require__(1)))

/***/ }),
/* 17 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = function () {
	return this;
}();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1, eval)("this");
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;

/***/ }),
/* 18 */
/***/ (function(module, exports) {

module.exports = "<div class=\"navbar-header\">\n    <button type=\"button\" class=\"navbar-toggle\" data-toggle=\"collapse\" data-target=\".navbar-collapse\">\n        <span class=\"sr-only\">Toggle navigation</span>\n        <span class=\"icon-bar\"></span>\n        <span class=\"icon-bar\"></span>\n        <span class=\"icon-bar\"></span>\n    </button>\n</div>\n<div class=\"navbar-collapse collapse\">\n    <ul class=\"nav navbar-nav\">\n        <li class=\"active\"><a href=\"#\">Home</a></li>\n        <% if (user && user.username) { %>\n        <li><a href=\"#orders\">Orders</a></li>\n        <% } %>\n    </ul>\n    <ul class=\"nav navbar-nav navbar-right\">\n        <% if (user && user.username) { %>\n        <li><a href='#profile'><%= user.username %></a></li>\n        <% } %>\n    </ul>\n</div>"

/***/ }),
/* 19 */
/***/ (function(module, exports) {

module.exports = "<div class=\"row\">\n    <div class=\"col-md-6\">\n        <div class=\"panel panel-primary\">\n            <div class=\"panel-heading\">\n                <span class=\"glyphicon glyphicon-list\"></span>Sortable Lists\n                <div class=\"pull-right action-buttons\">\n                    <div class=\"btn-group pull-right\">\n                        <button type=\"button\" class=\"btn btn-default btn-xs dropdown-toggle\" data-toggle=\"dropdown\">\n                            <span class=\"glyphicon glyphicon-cog\" style=\"margin-right: 0px;\"></span>\n                        </button>\n                        <ul class=\"dropdown-menu slidedown\">\n                            <li><a href=\"http://www.jquery2dotnet.com\"><span class=\"glyphicon glyphicon-pencil\"></span>Edit</a>\n                            </li>\n                            <li><a href=\"http://www.jquery2dotnet.com\"><span class=\"glyphicon glyphicon-trash\"></span>Delete</a>\n                            </li>\n                            <li><a href=\"http://www.jquery2dotnet.com\"><span class=\"glyphicon glyphicon-flag\"></span>Flag</a>\n                            </li>\n                        </ul>\n                    </div>\n                </div>\n            </div>\n            <div class=\"panel-body\">\n                <ul class=\"list-group\">\n                    <% orders.each(function(o) { %>\n                    <li class=\"list-group-item\">\n                        <span>Id: <%= o.get('id') %>, description: <%= o.get('description') %>\n                        </span>\n                    </li>\n                    <% }); %>\n                </ul>\n            </div>\n            <div class=\"panel-footer\">\n                <div class=\"row\">\n                    <div class=\"col-md-6\">\n                        <h6>\n                            Total Count <span class=\"label label-info\"><%= orders.length %></span></h6>\n                    </div>\n                </div>\n            </div>\n        </div>\n    </div>\n</div>\n"

/***/ }),
/* 20 */
/***/ (function(module, exports) {

module.exports = "    <div id=\"loginbox\" style=\"margin-top:50px;\" class=\"mainbox col-md-6 col-md-offset-3 col-sm-8 col-sm-offset-2\">\n        <div class=\"panel panel-info\" >\n            <div class=\"panel-heading\">\n                <div class=\"panel-title\">Sign In</div>\n                <div style=\"float:right; font-size: 80%; position: relative; top:-10px\"><a href=\"#\">Forgot password?</a></div>\n            </div>\n\n            <div style=\"padding-top:30px\" class=\"panel-body\" >\n\n                <div style=\"display:none\" id=\"login-alert\" class=\"alert alert-danger col-sm-12\"></div>\n\n                <div id=\"loginform\" class=\"form-horizontal\" role=\"form\">\n\n                    <div style=\"margin-bottom: 25px\" class=\"input-group\">\n                        <span class=\"input-group-addon\"><i class=\"glyphicon glyphicon-user\"></i></span>\n                        <input id=\"login-username\" type=\"text\" class=\"form-control\" name=\"username\" value=\"\" placeholder=\"username or email\">\n                    </div>\n\n                    <div style=\"margin-bottom: 25px\" class=\"input-group\">\n                        <span class=\"input-group-addon\"><i class=\"glyphicon glyphicon-lock\"></i></span>\n                        <input id=\"login-password\" type=\"password\" class=\"form-control\" name=\"password\" placeholder=\"password\">\n                    </div>\n\n                    <div class=\"input-group\">\n                        <div class=\"checkbox\">\n                            <label>\n                                <input id=\"login-remember\" type=\"checkbox\" name=\"remember\" value=\"1\"> Remember me\n                            </label>\n                        </div>\n                    </div>\n\n                    <div style=\"margin-top:10px\" class=\"form-group\">\n                        <!-- Button -->\n\n                        <div class=\"col-sm-12 controls\">\n                            <button id=\"btn-login\" class=\"btn btn-success\">Login  </button>\n                            <button id=\"btn-fblogin\" class=\"btn btn-primary\">Login with Facebook</button>\n\n                        </div>\n                    </div>\n\n                    <div class=\"form-group\">\n                        <div class=\"col-md-12 control\">\n                            <div style=\"border-top: 1px solid#888; padding-top:15px; font-size:85%\" >\n                                Don't have an account!\n                                <a href=\"#signup\">\n                                    Sign Up Here\n                                </a>\n                            </div>\n                        </div>\n                    </div>\n                </div>\n\n\n            </div>\n        </div>\n    </div>\n"

/***/ }),
/* 21 */
/***/ (function(module, exports) {

module.exports = "<div id=\"signupbox\" margin-top:50px\"\n     class=\"mainbox col-md-6 col-md-offset-3 col-sm-8 col-sm-offset-2\">\n    <div class=\"panel panel-info\">\n        <div class=\"panel-heading\">\n            <div class=\"panel-title\">Sign Up</div>\n            <div style=\"float:right; font-size: 85%; position: relative; top:-10px\"><a id=\"signinlink\" href=\"#login\">Sign\n                In</a></div>\n        </div>\n        <div class=\"panel-body\">\n            <div id=\"signupform\" class=\"form-horizontal\" role=\"form\">\n\n                <div id=\"signupalert\" style=\"display:none\" class=\"alert alert-danger\">\n                    <p>Error:</p>\n                    <span></span>\n                </div>\n\n                <div class=\"form-group\">\n                    <label for=\"username\" class=\"col-md-3 control-label\">Username</label>\n\n                    <div class=\"col-md-9\">\n                        <input type=\"text\" class=\"form-control\" name=\"username\" placeholder=\"First Name\">\n                    </div>\n                </div>\n\n                <div class=\"form-group\">\n                    <label for=\"email\" class=\"col-md-3 control-label\">Email</label>\n\n                    <div class=\"col-md-9\">\n                        <input type=\"text\" class=\"form-control\" name=\"email\" placeholder=\"Email Address\">\n                    </div>\n                </div>\n\n                <div class=\"form-group\">\n                    <label for=\"password\" class=\"col-md-3 control-label\">Password</label>\n\n                    <div class=\"col-md-9\">\n                        <input type=\"password\" class=\"form-control\" name=\"passwd\" placeholder=\"Password\">\n                    </div>\n                </div>\n\n                <div class=\"form-group\">\n                    <!-- Button -->\n                    <div class=\"col-md-offset-3 col-md-9\">\n                        <button id=\"btn-signup\" type=\"button\" class=\"btn btn-info\"><i class=\"icon-hand-right\"></i> &nbsp\n                            Sign Up\n                        </button>\n                        <span style=\"margin-left:8px;\">or</span>\n                    </div>\n                </div>\n\n                <div style=\"border-top: 1px solid #999; padding-top:20px\" class=\"form-group\">\n\n                    <div class=\"col-md-offset-3 col-md-9\">\n                        <button id=\"btn-fbsignup\" type=\"button\" class=\"btn btn-primary\"><i class=\"icon-facebook\"></i> \n                            Sign Up with Facebook\n                        </button>\n                    </div>\n\n                </div>\n\n\n            </div>\n        </div>\n    </div>\n\n\n</div>\n"

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

var localStorage = __webpack_require__(2);
var App = __webpack_require__(5);

// WARNING: this deletes any previously user
// THIS SHOULD NOT GO INTO PRODUCTION
localStorage.removeItem('user');

App.init();

/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgMDZmNTIwZDIwNmQ2ZDYxMjc3NmMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWNrYm9uZS9iYWNrYm9uZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3VuZGVyc2NvcmUvdW5kZXJzY29yZS5qcyIsIndlYnBhY2s6Ly8vLi9qcy9sb2NhbFN0b3JhZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vanMvZXZlbnRCdXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9qcXVlcnkvZGlzdC9qcXVlcnkuanMiLCJ3ZWJwYWNrOi8vLy4vanMvYXBwLmpzIiwid2VicGFjazovLy8uL2pzL2NvbGxlY3Rpb25zL2Nfb3JkZXJzLmpzIiwid2VicGFjazovLy8uL2pzL21vZGVscy9tX29yZGVyLmpzIiwid2VicGFjazovLy8uL2pzL3ByZXNlbnRlcnMvYXBpLmpzIiwid2VicGFjazovLy8uL2pzL3ByZXNlbnRlcnMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vanMvcHJlc2VudGVycy9sb2dpbi5qcyIsIndlYnBhY2s6Ly8vLi9qcy9wcmVzZW50ZXJzL3JvdXRlci5qcyIsIndlYnBhY2s6Ly8vLi9qcy9wcmVzZW50ZXJzL3VpLmpzIiwid2VicGFjazovLy8uL2pzL3ZpZXdzL2hlYWRlci5qcyIsIndlYnBhY2s6Ly8vLi9qcy92aWV3cy9vcmRlci92bF9vcmRlcnMuanMiLCJ3ZWJwYWNrOi8vLy4vanMvdmlld3MvdXNlci92X2xvZ2luLmpzIiwid2VicGFjazovLy8uL2pzL3ZpZXdzL3VzZXIvdl9zaWdudXAuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qcyIsIndlYnBhY2s6Ly8vLi90ZW1wbGF0ZXMvaGVhZGVyLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vdGVtcGxhdGVzL29yZGVyL3RsX29yZGVyLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vdGVtcGxhdGVzL3VzZXIvbG9naW4uaHRtbCIsIndlYnBhY2s6Ly8vLi90ZW1wbGF0ZXMvdXNlci9zaWdudXAuaHRtbCIsIndlYnBhY2s6Ly8vLi9qcy9tYWluLmpzIl0sIm5hbWVzIjpbImZhY3RvcnkiLCJyb290Iiwic2VsZiIsImdsb2JhbCIsImRlZmluZSIsIl8iLCIkIiwiZXhwb3J0cyIsIkJhY2tib25lIiwicmVxdWlyZSIsImUiLCJqUXVlcnkiLCJaZXB0byIsImVuZGVyIiwicHJldmlvdXNCYWNrYm9uZSIsInNsaWNlIiwiQXJyYXkiLCJwcm90b3R5cGUiLCJWRVJTSU9OIiwibm9Db25mbGljdCIsImVtdWxhdGVIVFRQIiwiZW11bGF0ZUpTT04iLCJhZGRNZXRob2QiLCJsZW5ndGgiLCJtZXRob2QiLCJhdHRyaWJ1dGUiLCJ2YWx1ZSIsIml0ZXJhdGVlIiwiY29udGV4dCIsImNiIiwiZGVmYXVsdFZhbCIsImFyZ3MiLCJjYWxsIiwiYXJndW1lbnRzIiwidW5zaGlmdCIsImFwcGx5IiwiYWRkVW5kZXJzY29yZU1ldGhvZHMiLCJDbGFzcyIsIm1ldGhvZHMiLCJlYWNoIiwiaW5zdGFuY2UiLCJpc0Z1bmN0aW9uIiwiaXNPYmplY3QiLCJfaXNNb2RlbCIsIm1vZGVsTWF0Y2hlciIsImlzU3RyaW5nIiwibW9kZWwiLCJnZXQiLCJhdHRycyIsIm1hdGNoZXIiLCJtYXRjaGVzIiwiYXR0cmlidXRlcyIsIkV2ZW50cyIsImV2ZW50U3BsaXR0ZXIiLCJldmVudHNBcGkiLCJldmVudHMiLCJuYW1lIiwiY2FsbGJhY2siLCJvcHRzIiwiaSIsIm5hbWVzIiwia2V5cyIsInRlc3QiLCJzcGxpdCIsIm9uIiwiaW50ZXJuYWxPbiIsIm9iaiIsImxpc3RlbmluZyIsIl9ldmVudHMiLCJvbkFwaSIsImN0eCIsImxpc3RlbmVycyIsIl9saXN0ZW5lcnMiLCJpZCIsImxpc3RlblRvIiwiX2xpc3RlbklkIiwidW5pcXVlSWQiLCJsaXN0ZW5pbmdUbyIsIl9saXN0ZW5pbmdUbyIsInRoaXNJZCIsIm9iaklkIiwiY291bnQiLCJvcHRpb25zIiwiaGFuZGxlcnMiLCJwdXNoIiwib2ZmIiwib2ZmQXBpIiwic3RvcExpc3RlbmluZyIsImlkcyIsInJlbWFpbmluZyIsImoiLCJoYW5kbGVyIiwiX2NhbGxiYWNrIiwib25jZSIsIm9uY2VNYXAiLCJiaW5kIiwibGlzdGVuVG9PbmNlIiwibWFwIiwib2ZmZXIiLCJ0cmlnZ2VyIiwiTWF0aCIsIm1heCIsInRyaWdnZXJBcGkiLCJvYmpFdmVudHMiLCJhbGxFdmVudHMiLCJhbGwiLCJ0cmlnZ2VyRXZlbnRzIiwiY29uY2F0IiwiZXYiLCJsIiwiYTEiLCJhMiIsImEzIiwidW5iaW5kIiwiZXh0ZW5kIiwiTW9kZWwiLCJjaWQiLCJjaWRQcmVmaXgiLCJjb2xsZWN0aW9uIiwicGFyc2UiLCJkZWZhdWx0cyIsInJlc3VsdCIsInNldCIsImNoYW5nZWQiLCJpbml0aWFsaXplIiwidmFsaWRhdGlvbkVycm9yIiwiaWRBdHRyaWJ1dGUiLCJ0b0pTT04iLCJjbG9uZSIsInN5bmMiLCJhdHRyIiwiZXNjYXBlIiwiaGFzIiwia2V5IiwidmFsIiwiX3ZhbGlkYXRlIiwidW5zZXQiLCJzaWxlbnQiLCJjaGFuZ2VzIiwiY2hhbmdpbmciLCJfY2hhbmdpbmciLCJfcHJldmlvdXNBdHRyaWJ1dGVzIiwiY3VycmVudCIsInByZXYiLCJpc0VxdWFsIiwiX3BlbmRpbmciLCJjbGVhciIsImhhc0NoYW5nZWQiLCJpc0VtcHR5IiwiY2hhbmdlZEF0dHJpYnV0ZXMiLCJkaWZmIiwib2xkIiwic2l6ZSIsInByZXZpb3VzIiwicHJldmlvdXNBdHRyaWJ1dGVzIiwiZmV0Y2giLCJzdWNjZXNzIiwicmVzcCIsInNlcnZlckF0dHJzIiwid3JhcEVycm9yIiwic2F2ZSIsInZhbGlkYXRlIiwid2FpdCIsImlzTmV3IiwicGF0Y2giLCJ4aHIiLCJkZXN0cm95IiwiZGVmZXIiLCJ1cmwiLCJiYXNlIiwidXJsRXJyb3IiLCJyZXBsYWNlIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiY29uc3RydWN0b3IiLCJpc1ZhbGlkIiwiZXJyb3IiLCJtb2RlbE1ldGhvZHMiLCJ2YWx1ZXMiLCJwYWlycyIsImludmVydCIsInBpY2siLCJvbWl0IiwiY2hhaW4iLCJDb2xsZWN0aW9uIiwibW9kZWxzIiwiY29tcGFyYXRvciIsIl9yZXNldCIsInJlc2V0Iiwic2V0T3B0aW9ucyIsImFkZCIsInJlbW92ZSIsIm1lcmdlIiwiYWRkT3B0aW9ucyIsInNwbGljZSIsImFycmF5IiwiaW5zZXJ0IiwiYXQiLCJtaW4iLCJ0YWlsIiwic2luZ3VsYXIiLCJpc0FycmF5IiwicmVtb3ZlZCIsIl9yZW1vdmVNb2RlbHMiLCJhZGRlZCIsIm1lcmdlZCIsInRvQWRkIiwidG9NZXJnZSIsInRvUmVtb3ZlIiwibW9kZWxNYXAiLCJzb3J0Iiwic29ydGFibGUiLCJzb3J0QXR0ciIsImV4aXN0aW5nIiwiX3ByZXBhcmVNb2RlbCIsIl9hZGRSZWZlcmVuY2UiLCJvcmRlckNoYW5nZWQiLCJzb21lIiwibSIsImluZGV4IiwiX3JlbW92ZVJlZmVyZW5jZSIsInByZXZpb3VzTW9kZWxzIiwicG9wIiwic2hpZnQiLCJfYnlJZCIsIm1vZGVsSWQiLCJ3aGVyZSIsImZpcnN0IiwiZmluZFdoZXJlIiwiRXJyb3IiLCJzb3J0QnkiLCJwbHVjayIsImNyZWF0ZSIsImNhbGxiYWNrT3B0cyIsImluZGV4T2YiLCJfb25Nb2RlbEV2ZW50IiwiZXZlbnQiLCJwcmV2SWQiLCJjb2xsZWN0aW9uTWV0aG9kcyIsImZvckVhY2giLCJjb2xsZWN0IiwicmVkdWNlIiwiZm9sZGwiLCJpbmplY3QiLCJyZWR1Y2VSaWdodCIsImZvbGRyIiwiZmluZCIsImRldGVjdCIsImZpbHRlciIsInNlbGVjdCIsInJlamVjdCIsImV2ZXJ5IiwiYW55IiwiaW5jbHVkZSIsImluY2x1ZGVzIiwiY29udGFpbnMiLCJpbnZva2UiLCJ0b0FycmF5IiwiaGVhZCIsInRha2UiLCJpbml0aWFsIiwicmVzdCIsImRyb3AiLCJsYXN0Iiwid2l0aG91dCIsImRpZmZlcmVuY2UiLCJzaHVmZmxlIiwibGFzdEluZGV4T2YiLCJzYW1wbGUiLCJwYXJ0aXRpb24iLCJncm91cEJ5IiwiY291bnRCeSIsImluZGV4QnkiLCJmaW5kSW5kZXgiLCJmaW5kTGFzdEluZGV4IiwiVmlldyIsInZpZXdPcHRpb25zIiwiX2Vuc3VyZUVsZW1lbnQiLCJkZWxlZ2F0ZUV2ZW50U3BsaXR0ZXIiLCJ0YWdOYW1lIiwic2VsZWN0b3IiLCIkZWwiLCJyZW5kZXIiLCJfcmVtb3ZlRWxlbWVudCIsInNldEVsZW1lbnQiLCJlbGVtZW50IiwidW5kZWxlZ2F0ZUV2ZW50cyIsIl9zZXRFbGVtZW50IiwiZGVsZWdhdGVFdmVudHMiLCJlbCIsIm1hdGNoIiwiZGVsZWdhdGUiLCJldmVudE5hbWUiLCJsaXN0ZW5lciIsInVuZGVsZWdhdGUiLCJfY3JlYXRlRWxlbWVudCIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImNsYXNzTmFtZSIsIl9zZXRBdHRyaWJ1dGVzIiwidHlwZSIsIm1ldGhvZE1hcCIsInBhcmFtcyIsImRhdGFUeXBlIiwiZGF0YSIsImNvbnRlbnRUeXBlIiwiSlNPTiIsInN0cmluZ2lmeSIsIl9tZXRob2QiLCJiZWZvcmVTZW5kIiwic2V0UmVxdWVzdEhlYWRlciIsInByb2Nlc3NEYXRhIiwidGV4dFN0YXR1cyIsImVycm9yVGhyb3duIiwiYWpheCIsIlJvdXRlciIsInJvdXRlcyIsIl9iaW5kUm91dGVzIiwib3B0aW9uYWxQYXJhbSIsIm5hbWVkUGFyYW0iLCJzcGxhdFBhcmFtIiwiZXNjYXBlUmVnRXhwIiwicm91dGUiLCJpc1JlZ0V4cCIsIl9yb3V0ZVRvUmVnRXhwIiwicm91dGVyIiwiaGlzdG9yeSIsImZyYWdtZW50IiwiX2V4dHJhY3RQYXJhbWV0ZXJzIiwiZXhlY3V0ZSIsIm5hdmlnYXRlIiwib3B0aW9uYWwiLCJSZWdFeHAiLCJleGVjIiwicGFyYW0iLCJkZWNvZGVVUklDb21wb25lbnQiLCJIaXN0b3J5IiwiY2hlY2tVcmwiLCJ3aW5kb3ciLCJsb2NhdGlvbiIsInJvdXRlU3RyaXBwZXIiLCJyb290U3RyaXBwZXIiLCJwYXRoU3RyaXBwZXIiLCJzdGFydGVkIiwiaW50ZXJ2YWwiLCJhdFJvb3QiLCJwYXRoIiwicGF0aG5hbWUiLCJnZXRTZWFyY2giLCJtYXRjaFJvb3QiLCJkZWNvZGVGcmFnbWVudCIsInJvb3RQYXRoIiwiZGVjb2RlVVJJIiwiaHJlZiIsImdldEhhc2giLCJnZXRQYXRoIiwiY2hhckF0IiwiZ2V0RnJhZ21lbnQiLCJfdXNlUHVzaFN0YXRlIiwiX3dhbnRzSGFzaENoYW5nZSIsInN0YXJ0IiwiaGFzaENoYW5nZSIsIl9oYXNIYXNoQ2hhbmdlIiwiZG9jdW1lbnRNb2RlIiwiX3VzZUhhc2hDaGFuZ2UiLCJfd2FudHNQdXNoU3RhdGUiLCJwdXNoU3RhdGUiLCJfaGFzUHVzaFN0YXRlIiwiaWZyYW1lIiwic3JjIiwic3R5bGUiLCJkaXNwbGF5IiwidGFiSW5kZXgiLCJib2R5IiwiaVdpbmRvdyIsImluc2VydEJlZm9yZSIsImZpcnN0Q2hpbGQiLCJjb250ZW50V2luZG93Iiwib3BlbiIsImNsb3NlIiwiaGFzaCIsImFkZEV2ZW50TGlzdGVuZXIiLCJhdHRhY2hFdmVudCIsIl9jaGVja1VybEludGVydmFsIiwic2V0SW50ZXJ2YWwiLCJsb2FkVXJsIiwic3RvcCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJkZXRhY2hFdmVudCIsInJlbW92ZUNoaWxkIiwiY2xlYXJJbnRlcnZhbCIsInRpdGxlIiwiX3VwZGF0ZUhhc2giLCJhc3NpZ24iLCJwcm90b1Byb3BzIiwic3RhdGljUHJvcHMiLCJwYXJlbnQiLCJjaGlsZCIsIl9fc3VwZXJfXyIsInByZXZpb3VzVW5kZXJzY29yZSIsIkFycmF5UHJvdG8iLCJPYmpQcm90byIsIk9iamVjdCIsIkZ1bmNQcm90byIsIkZ1bmN0aW9uIiwidG9TdHJpbmciLCJoYXNPd25Qcm9wZXJ0eSIsIm5hdGl2ZUlzQXJyYXkiLCJuYXRpdmVLZXlzIiwibmF0aXZlQmluZCIsIm5hdGl2ZUNyZWF0ZSIsIkN0b3IiLCJfd3JhcHBlZCIsIm1vZHVsZSIsIm9wdGltaXplQ2IiLCJmdW5jIiwiYXJnQ291bnQiLCJvdGhlciIsImFjY3VtdWxhdG9yIiwiaWRlbnRpdHkiLCJwcm9wZXJ0eSIsIkluZmluaXR5IiwiY3JlYXRlQXNzaWduZXIiLCJrZXlzRnVuYyIsInVuZGVmaW5lZE9ubHkiLCJzb3VyY2UiLCJiYXNlQ3JlYXRlIiwiTUFYX0FSUkFZX0lOREVYIiwicG93IiwiZ2V0TGVuZ3RoIiwiaXNBcnJheUxpa2UiLCJyZXN1bHRzIiwiY3VycmVudEtleSIsImNyZWF0ZVJlZHVjZSIsImRpciIsIml0ZXJhdG9yIiwibWVtbyIsInByZWRpY2F0ZSIsImZpbmRLZXkiLCJsaXN0IiwibmVnYXRlIiwiaXRlbSIsImZyb21JbmRleCIsImd1YXJkIiwiaXNGdW5jIiwibGFzdENvbXB1dGVkIiwiY29tcHV0ZWQiLCJzaHVmZmxlZCIsInJhbmQiLCJyYW5kb20iLCJuIiwiY3JpdGVyaWEiLCJsZWZ0IiwicmlnaHQiLCJhIiwiYiIsImdyb3VwIiwiYmVoYXZpb3IiLCJwYXNzIiwiZmFpbCIsImNvbXBhY3QiLCJmbGF0dGVuIiwiaW5wdXQiLCJzaGFsbG93Iiwic3RyaWN0Iiwic3RhcnRJbmRleCIsIm91dHB1dCIsImlkeCIsImlzQXJndW1lbnRzIiwibGVuIiwidW5pcSIsInVuaXF1ZSIsImlzU29ydGVkIiwiaXNCb29sZWFuIiwic2VlbiIsInVuaW9uIiwiaW50ZXJzZWN0aW9uIiwiYXJnc0xlbmd0aCIsInppcCIsInVuemlwIiwib2JqZWN0IiwiY3JlYXRlUHJlZGljYXRlSW5kZXhGaW5kZXIiLCJzb3J0ZWRJbmRleCIsImxvdyIsImhpZ2giLCJtaWQiLCJmbG9vciIsImNyZWF0ZUluZGV4RmluZGVyIiwicHJlZGljYXRlRmluZCIsImlzTmFOIiwicmFuZ2UiLCJzdGVwIiwiY2VpbCIsImV4ZWN1dGVCb3VuZCIsInNvdXJjZUZ1bmMiLCJib3VuZEZ1bmMiLCJjYWxsaW5nQ29udGV4dCIsIlR5cGVFcnJvciIsImJvdW5kIiwicGFydGlhbCIsImJvdW5kQXJncyIsInBvc2l0aW9uIiwiYmluZEFsbCIsIm1lbW9pemUiLCJoYXNoZXIiLCJjYWNoZSIsImFkZHJlc3MiLCJkZWxheSIsInNldFRpbWVvdXQiLCJ0aHJvdHRsZSIsInRpbWVvdXQiLCJsYXRlciIsImxlYWRpbmciLCJub3ciLCJjbGVhclRpbWVvdXQiLCJ0cmFpbGluZyIsImRlYm91bmNlIiwiaW1tZWRpYXRlIiwidGltZXN0YW1wIiwiY2FsbE5vdyIsIndyYXAiLCJ3cmFwcGVyIiwiY29tcG9zZSIsImFmdGVyIiwidGltZXMiLCJiZWZvcmUiLCJoYXNFbnVtQnVnIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJub25FbnVtZXJhYmxlUHJvcHMiLCJjb2xsZWN0Tm9uRW51bVByb3BzIiwibm9uRW51bUlkeCIsInByb3RvIiwicHJvcCIsImFsbEtleXMiLCJtYXBPYmplY3QiLCJmdW5jdGlvbnMiLCJleHRlbmRPd24iLCJvaXRlcmF0ZWUiLCJTdHJpbmciLCJwcm9wcyIsInRhcCIsImludGVyY2VwdG9yIiwiaXNNYXRjaCIsImVxIiwiYVN0YWNrIiwiYlN0YWNrIiwiYXJlQXJyYXlzIiwiYUN0b3IiLCJiQ3RvciIsImlzRWxlbWVudCIsIm5vZGVUeXBlIiwiSW50OEFycmF5IiwiaXNGaW5pdGUiLCJwYXJzZUZsb2F0IiwiaXNOdW1iZXIiLCJpc051bGwiLCJpc1VuZGVmaW5lZCIsImNvbnN0YW50Iiwibm9vcCIsInByb3BlcnR5T2YiLCJhY2N1bSIsIkRhdGUiLCJnZXRUaW1lIiwiZXNjYXBlTWFwIiwidW5lc2NhcGVNYXAiLCJjcmVhdGVFc2NhcGVyIiwiZXNjYXBlciIsImpvaW4iLCJ0ZXN0UmVnZXhwIiwicmVwbGFjZVJlZ2V4cCIsInN0cmluZyIsInVuZXNjYXBlIiwiZmFsbGJhY2siLCJpZENvdW50ZXIiLCJwcmVmaXgiLCJ0ZW1wbGF0ZVNldHRpbmdzIiwiZXZhbHVhdGUiLCJpbnRlcnBvbGF0ZSIsIm5vTWF0Y2giLCJlc2NhcGVzIiwiZXNjYXBlQ2hhciIsInRlbXBsYXRlIiwidGV4dCIsInNldHRpbmdzIiwib2xkU2V0dGluZ3MiLCJvZmZzZXQiLCJ2YXJpYWJsZSIsImFyZ3VtZW50IiwiX2NoYWluIiwibWl4aW4iLCJ2YWx1ZU9mIiwibG9jYWxTdG9yYWdlIiwic2V0SXRlbSIsImdldEl0ZW0iLCJzdHIiLCJoYXNJdGVtIiwicmVtb3ZlSXRlbSIsIkV2ZW50QnVzIiwidyIsIm5vR2xvYmFsIiwiYXJyIiwiZ2V0UHJvdG8iLCJnZXRQcm90b3R5cGVPZiIsImNsYXNzMnR5cGUiLCJoYXNPd24iLCJmblRvU3RyaW5nIiwiT2JqZWN0RnVuY3Rpb25TdHJpbmciLCJzdXBwb3J0IiwiRE9NRXZhbCIsImNvZGUiLCJkb2MiLCJzY3JpcHQiLCJhcHBlbmRDaGlsZCIsInBhcmVudE5vZGUiLCJ2ZXJzaW9uIiwiZm4iLCJpbml0IiwicnRyaW0iLCJybXNQcmVmaXgiLCJyZGFzaEFscGhhIiwiZmNhbWVsQ2FzZSIsImxldHRlciIsInRvVXBwZXJDYXNlIiwianF1ZXJ5IiwibnVtIiwicHVzaFN0YWNrIiwiZWxlbXMiLCJyZXQiLCJwcmV2T2JqZWN0IiwiZWxlbSIsImVuZCIsImNvcHkiLCJjb3B5SXNBcnJheSIsInRhcmdldCIsImRlZXAiLCJpc1BsYWluT2JqZWN0IiwidW5kZWZpbmVkIiwiZXhwYW5kbyIsImlzUmVhZHkiLCJtc2ciLCJpc1dpbmRvdyIsImlzTnVtZXJpYyIsImlzRW1wdHlPYmplY3QiLCJnbG9iYWxFdmFsIiwiY2FtZWxDYXNlIiwibm9kZU5hbWUiLCJ0b0xvd2VyQ2FzZSIsInRyaW0iLCJtYWtlQXJyYXkiLCJpbkFycmF5Iiwic2Vjb25kIiwiZ3JlcCIsImNhbGxiYWNrSW52ZXJzZSIsImNhbGxiYWNrRXhwZWN0IiwiYXJnIiwiZ3VpZCIsInByb3h5IiwidG1wIiwiU3ltYm9sIiwiU2l6emxlIiwiRXhwciIsImdldFRleHQiLCJpc1hNTCIsInRva2VuaXplIiwiY29tcGlsZSIsIm91dGVybW9zdENvbnRleHQiLCJzb3J0SW5wdXQiLCJoYXNEdXBsaWNhdGUiLCJzZXREb2N1bWVudCIsImRvY0VsZW0iLCJkb2N1bWVudElzSFRNTCIsInJidWdneVFTQSIsInJidWdneU1hdGNoZXMiLCJwcmVmZXJyZWREb2MiLCJkaXJydW5zIiwiZG9uZSIsImNsYXNzQ2FjaGUiLCJjcmVhdGVDYWNoZSIsInRva2VuQ2FjaGUiLCJjb21waWxlckNhY2hlIiwic29ydE9yZGVyIiwicHVzaF9uYXRpdmUiLCJib29sZWFucyIsIndoaXRlc3BhY2UiLCJpZGVudGlmaWVyIiwicHNldWRvcyIsInJ3aGl0ZXNwYWNlIiwicmNvbW1hIiwicmNvbWJpbmF0b3JzIiwicmF0dHJpYnV0ZVF1b3RlcyIsInJwc2V1ZG8iLCJyaWRlbnRpZmllciIsIm1hdGNoRXhwciIsInJpbnB1dHMiLCJyaGVhZGVyIiwicm5hdGl2ZSIsInJxdWlja0V4cHIiLCJyc2libGluZyIsInJ1bmVzY2FwZSIsImZ1bmVzY2FwZSIsImVzY2FwZWQiLCJlc2NhcGVkV2hpdGVzcGFjZSIsImZyb21DaGFyQ29kZSIsInJjc3Nlc2NhcGUiLCJmY3NzZXNjYXBlIiwiY2giLCJhc0NvZGVQb2ludCIsImNoYXJDb2RlQXQiLCJ1bmxvYWRIYW5kbGVyIiwiZGlzYWJsZWRBbmNlc3RvciIsImFkZENvbWJpbmF0b3IiLCJkaXNhYmxlZCIsIm5leHQiLCJjaGlsZE5vZGVzIiwiZWxzIiwic2VlZCIsIm5pZCIsImdyb3VwcyIsIm5ld1NlbGVjdG9yIiwibmV3Q29udGV4dCIsIm93bmVyRG9jdW1lbnQiLCJnZXRFbGVtZW50QnlJZCIsImdldEVsZW1lbnRzQnlUYWdOYW1lIiwiZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSIsInFzYSIsImdldEF0dHJpYnV0ZSIsInNldEF0dHJpYnV0ZSIsInRvU2VsZWN0b3IiLCJ0ZXN0Q29udGV4dCIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJxc2FFcnJvciIsInJlbW92ZUF0dHJpYnV0ZSIsImNhY2hlTGVuZ3RoIiwibWFya0Z1bmN0aW9uIiwiYXNzZXJ0IiwiYWRkSGFuZGxlIiwiYXR0ckhhbmRsZSIsInNpYmxpbmdDaGVjayIsImN1ciIsInNvdXJjZUluZGV4IiwibmV4dFNpYmxpbmciLCJjcmVhdGVJbnB1dFBzZXVkbyIsImNyZWF0ZUJ1dHRvblBzZXVkbyIsImNyZWF0ZURpc2FibGVkUHNldWRvIiwiaXNEaXNhYmxlZCIsImNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8iLCJtYXRjaEluZGV4ZXMiLCJkb2N1bWVudEVsZW1lbnQiLCJub2RlIiwiaGFzQ29tcGFyZSIsInN1YldpbmRvdyIsImRlZmF1bHRWaWV3IiwidG9wIiwiY3JlYXRlQ29tbWVudCIsImdldEJ5SWQiLCJnZXRFbGVtZW50c0J5TmFtZSIsImF0dHJJZCIsImdldEF0dHJpYnV0ZU5vZGUiLCJ0YWciLCJpbm5lckhUTUwiLCJtYXRjaGVzU2VsZWN0b3IiLCJ3ZWJraXRNYXRjaGVzU2VsZWN0b3IiLCJtb3pNYXRjaGVzU2VsZWN0b3IiLCJvTWF0Y2hlc1NlbGVjdG9yIiwibXNNYXRjaGVzU2VsZWN0b3IiLCJkaXNjb25uZWN0ZWRNYXRjaCIsImNvbXBhcmVEb2N1bWVudFBvc2l0aW9uIiwiYWRvd24iLCJidXAiLCJjb21wYXJlIiwic29ydERldGFjaGVkIiwiYXVwIiwiYXAiLCJicCIsImV4cHIiLCJlbGVtZW50cyIsInNwZWNpZmllZCIsInNlbCIsInVuaXF1ZVNvcnQiLCJkdXBsaWNhdGVzIiwiZGV0ZWN0RHVwbGljYXRlcyIsInNvcnRTdGFibGUiLCJ0ZXh0Q29udGVudCIsIm5vZGVWYWx1ZSIsInNlbGVjdG9ycyIsImNyZWF0ZVBzZXVkbyIsInJlbGF0aXZlIiwicHJlRmlsdGVyIiwiZXhjZXNzIiwidW5xdW90ZWQiLCJub2RlTmFtZVNlbGVjdG9yIiwicGF0dGVybiIsIm9wZXJhdG9yIiwiY2hlY2siLCJ3aGF0Iiwic2ltcGxlIiwiZm9yd2FyZCIsIm9mVHlwZSIsInhtbCIsInVuaXF1ZUNhY2hlIiwib3V0ZXJDYWNoZSIsIm5vZGVJbmRleCIsInVzZUNhY2hlIiwibGFzdENoaWxkIiwidW5pcXVlSUQiLCJwc2V1ZG8iLCJzZXRGaWx0ZXJzIiwibWF0Y2hlZCIsInVubWF0Y2hlZCIsImlubmVyVGV4dCIsImxhbmciLCJlbGVtTGFuZyIsImFjdGl2ZUVsZW1lbnQiLCJoYXNGb2N1cyIsImNoZWNrZWQiLCJzZWxlY3RlZCIsInNlbGVjdGVkSW5kZXgiLCJyYWRpbyIsImNoZWNrYm94IiwiZmlsZSIsInBhc3N3b3JkIiwiaW1hZ2UiLCJzdWJtaXQiLCJmaWx0ZXJzIiwicGFyc2VPbmx5IiwidG9rZW5zIiwic29GYXIiLCJwcmVGaWx0ZXJzIiwiY2FjaGVkIiwiY29tYmluYXRvciIsInNraXAiLCJjaGVja05vbkVsZW1lbnRzIiwiZG9uZU5hbWUiLCJvbGRDYWNoZSIsIm5ld0NhY2hlIiwiZWxlbWVudE1hdGNoZXIiLCJtYXRjaGVycyIsIm11bHRpcGxlQ29udGV4dHMiLCJjb250ZXh0cyIsImNvbmRlbnNlIiwibmV3VW5tYXRjaGVkIiwibWFwcGVkIiwic2V0TWF0Y2hlciIsInBvc3RGaWx0ZXIiLCJwb3N0RmluZGVyIiwicG9zdFNlbGVjdG9yIiwidGVtcCIsInByZU1hcCIsInBvc3RNYXAiLCJwcmVleGlzdGluZyIsIm1hdGNoZXJJbiIsIm1hdGNoZXJPdXQiLCJtYXRjaGVyRnJvbVRva2VucyIsImNoZWNrQ29udGV4dCIsImxlYWRpbmdSZWxhdGl2ZSIsImltcGxpY2l0UmVsYXRpdmUiLCJtYXRjaENvbnRleHQiLCJtYXRjaEFueUNvbnRleHQiLCJtYXRjaGVyRnJvbUdyb3VwTWF0Y2hlcnMiLCJlbGVtZW50TWF0Y2hlcnMiLCJzZXRNYXRjaGVycyIsImJ5U2V0IiwiYnlFbGVtZW50Iiwic3VwZXJNYXRjaGVyIiwib3V0ZXJtb3N0IiwibWF0Y2hlZENvdW50Iiwic2V0TWF0Y2hlZCIsImNvbnRleHRCYWNrdXAiLCJkaXJydW5zVW5pcXVlIiwidG9rZW4iLCJjb21waWxlZCIsImRlZmF1bHRWYWx1ZSIsImlzWE1MRG9jIiwiZXNjYXBlU2VsZWN0b3IiLCJ1bnRpbCIsInRydW5jYXRlIiwiaXMiLCJzaWJsaW5ncyIsInJuZWVkc0NvbnRleHQiLCJuZWVkc0NvbnRleHQiLCJyc2luZ2xlVGFnIiwicmlzU2ltcGxlIiwid2lubm93IiwicXVhbGlmaWVyIiwibm90Iiwicm9vdGpRdWVyeSIsInBhcnNlSFRNTCIsInJlYWR5IiwicnBhcmVudHNwcmV2IiwiZ3VhcmFudGVlZFVuaXF1ZSIsImNoaWxkcmVuIiwiY29udGVudHMiLCJ0YXJnZXRzIiwiY2xvc2VzdCIsInByZXZBbGwiLCJhZGRCYWNrIiwic2libGluZyIsInBhcmVudHMiLCJwYXJlbnRzVW50aWwiLCJuZXh0QWxsIiwibmV4dFVudGlsIiwicHJldlVudGlsIiwiY29udGVudERvY3VtZW50IiwicmV2ZXJzZSIsInJub3RodG1sd2hpdGUiLCJjcmVhdGVPcHRpb25zIiwiZmxhZyIsIkNhbGxiYWNrcyIsImZpcmluZyIsIm1lbW9yeSIsImZpcmVkIiwibG9ja2VkIiwicXVldWUiLCJmaXJpbmdJbmRleCIsImZpcmUiLCJzdG9wT25GYWxzZSIsImVtcHR5IiwiZGlzYWJsZSIsImxvY2siLCJmaXJlV2l0aCIsIklkZW50aXR5IiwidiIsIlRocm93ZXIiLCJleCIsImFkb3B0VmFsdWUiLCJyZXNvbHZlIiwicHJvbWlzZSIsInRoZW4iLCJEZWZlcnJlZCIsInR1cGxlcyIsInN0YXRlIiwiYWx3YXlzIiwiZGVmZXJyZWQiLCJwaXBlIiwiZm5zIiwibmV3RGVmZXIiLCJ0dXBsZSIsInJldHVybmVkIiwicHJvZ3Jlc3MiLCJub3RpZnkiLCJvbkZ1bGZpbGxlZCIsIm9uUmVqZWN0ZWQiLCJvblByb2dyZXNzIiwibWF4RGVwdGgiLCJkZXB0aCIsInNwZWNpYWwiLCJ0aGF0IiwibWlnaHRUaHJvdyIsIm5vdGlmeVdpdGgiLCJyZXNvbHZlV2l0aCIsInByb2Nlc3MiLCJleGNlcHRpb25Ib29rIiwic3RhY2tUcmFjZSIsInJlamVjdFdpdGgiLCJnZXRTdGFja0hvb2siLCJzdGF0ZVN0cmluZyIsIndoZW4iLCJzaW5nbGVWYWx1ZSIsInJlc29sdmVDb250ZXh0cyIsInJlc29sdmVWYWx1ZXMiLCJtYXN0ZXIiLCJ1cGRhdGVGdW5jIiwicmVycm9yTmFtZXMiLCJzdGFjayIsImNvbnNvbGUiLCJ3YXJuIiwibWVzc2FnZSIsInJlYWR5RXhjZXB0aW9uIiwicmVhZHlMaXN0IiwiY2F0Y2giLCJyZWFkeVdhaXQiLCJob2xkUmVhZHkiLCJob2xkIiwiY29tcGxldGVkIiwicmVhZHlTdGF0ZSIsImRvU2Nyb2xsIiwiYWNjZXNzIiwiY2hhaW5hYmxlIiwiZW1wdHlHZXQiLCJyYXciLCJidWxrIiwiYWNjZXB0RGF0YSIsIm93bmVyIiwiRGF0YSIsInVpZCIsImRlZmluZVByb3BlcnR5IiwiY29uZmlndXJhYmxlIiwiaGFzRGF0YSIsImRhdGFQcml2IiwiZGF0YVVzZXIiLCJyYnJhY2UiLCJybXVsdGlEYXNoIiwiZ2V0RGF0YSIsImRhdGFBdHRyIiwicmVtb3ZlRGF0YSIsIl9kYXRhIiwiX3JlbW92ZURhdGEiLCJkZXF1ZXVlIiwic3RhcnRMZW5ndGgiLCJob29rcyIsIl9xdWV1ZUhvb2tzIiwic2V0dGVyIiwiY2xlYXJRdWV1ZSIsInBudW0iLCJyY3NzTnVtIiwiY3NzRXhwYW5kIiwiaXNIaWRkZW5XaXRoaW5UcmVlIiwiY3NzIiwic3dhcCIsImFkanVzdENTUyIsInZhbHVlUGFydHMiLCJ0d2VlbiIsImFkanVzdGVkIiwic2NhbGUiLCJtYXhJdGVyYXRpb25zIiwiY3VycmVudFZhbHVlIiwidW5pdCIsImNzc051bWJlciIsImluaXRpYWxJblVuaXQiLCJkZWZhdWx0RGlzcGxheU1hcCIsImdldERlZmF1bHREaXNwbGF5Iiwic2hvd0hpZGUiLCJzaG93IiwiaGlkZSIsInRvZ2dsZSIsInJjaGVja2FibGVUeXBlIiwicnRhZ05hbWUiLCJyc2NyaXB0VHlwZSIsIndyYXBNYXAiLCJvcHRpb24iLCJ0aGVhZCIsImNvbCIsInRyIiwidGQiLCJfZGVmYXVsdCIsIm9wdGdyb3VwIiwidGJvZHkiLCJ0Zm9vdCIsImNvbGdyb3VwIiwiY2FwdGlvbiIsInRoIiwiZ2V0QWxsIiwic2V0R2xvYmFsRXZhbCIsInJlZkVsZW1lbnRzIiwicmh0bWwiLCJidWlsZEZyYWdtZW50Iiwic2NyaXB0cyIsInNlbGVjdGlvbiIsImlnbm9yZWQiLCJjcmVhdGVEb2N1bWVudEZyYWdtZW50Iiwibm9kZXMiLCJjcmVhdGVUZXh0Tm9kZSIsImh0bWxQcmVmaWx0ZXIiLCJkaXYiLCJjaGVja0Nsb25lIiwiY2xvbmVOb2RlIiwibm9DbG9uZUNoZWNrZWQiLCJya2V5RXZlbnQiLCJybW91c2VFdmVudCIsInJ0eXBlbmFtZXNwYWNlIiwicmV0dXJuVHJ1ZSIsInJldHVybkZhbHNlIiwic2FmZUFjdGl2ZUVsZW1lbnQiLCJlcnIiLCJ0eXBlcyIsIm9uZSIsIm9yaWdGbiIsImhhbmRsZU9iakluIiwiZXZlbnRIYW5kbGUiLCJ0IiwiaGFuZGxlT2JqIiwibmFtZXNwYWNlcyIsIm9yaWdUeXBlIiwiZWxlbURhdGEiLCJoYW5kbGUiLCJ0cmlnZ2VyZWQiLCJkaXNwYXRjaCIsImRlbGVnYXRlVHlwZSIsImJpbmRUeXBlIiwibmFtZXNwYWNlIiwiZGVsZWdhdGVDb3VudCIsInNldHVwIiwibWFwcGVkVHlwZXMiLCJvcmlnQ291bnQiLCJ0ZWFyZG93biIsInJlbW92ZUV2ZW50IiwibmF0aXZlRXZlbnQiLCJmaXgiLCJoYW5kbGVyUXVldWUiLCJkZWxlZ2F0ZVRhcmdldCIsInByZURpc3BhdGNoIiwiaXNQcm9wYWdhdGlvblN0b3BwZWQiLCJjdXJyZW50VGFyZ2V0IiwiaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQiLCJybmFtZXNwYWNlIiwicHJldmVudERlZmF1bHQiLCJzdG9wUHJvcGFnYXRpb24iLCJwb3N0RGlzcGF0Y2giLCJtYXRjaGVkSGFuZGxlcnMiLCJtYXRjaGVkU2VsZWN0b3JzIiwiYnV0dG9uIiwiYWRkUHJvcCIsImhvb2siLCJFdmVudCIsImVudW1lcmFibGUiLCJvcmlnaW5hbEV2ZW50Iiwid3JpdGFibGUiLCJsb2FkIiwibm9CdWJibGUiLCJmb2N1cyIsImJsdXIiLCJjbGljayIsImJlZm9yZXVubG9hZCIsInJldHVyblZhbHVlIiwiaXNEZWZhdWx0UHJldmVudGVkIiwiZGVmYXVsdFByZXZlbnRlZCIsInJlbGF0ZWRUYXJnZXQiLCJ0aW1lU3RhbXAiLCJpc1NpbXVsYXRlZCIsInN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiIsImFsdEtleSIsImJ1YmJsZXMiLCJjYW5jZWxhYmxlIiwiY2hhbmdlZFRvdWNoZXMiLCJjdHJsS2V5IiwiZGV0YWlsIiwiZXZlbnRQaGFzZSIsIm1ldGFLZXkiLCJwYWdlWCIsInBhZ2VZIiwic2hpZnRLZXkiLCJ2aWV3IiwiY2hhckNvZGUiLCJrZXlDb2RlIiwiYnV0dG9ucyIsImNsaWVudFgiLCJjbGllbnRZIiwib2Zmc2V0WCIsIm9mZnNldFkiLCJwb2ludGVySWQiLCJwb2ludGVyVHlwZSIsInNjcmVlblgiLCJzY3JlZW5ZIiwidGFyZ2V0VG91Y2hlcyIsInRvRWxlbWVudCIsInRvdWNoZXMiLCJ3aGljaCIsIm1vdXNlZW50ZXIiLCJtb3VzZWxlYXZlIiwicG9pbnRlcmVudGVyIiwicG9pbnRlcmxlYXZlIiwib3JpZyIsInJlbGF0ZWQiLCJyeGh0bWxUYWciLCJybm9Jbm5lcmh0bWwiLCJyY2hlY2tlZCIsInJzY3JpcHRUeXBlTWFza2VkIiwicmNsZWFuU2NyaXB0IiwibWFuaXB1bGF0aW9uVGFyZ2V0IiwiY29udGVudCIsImRpc2FibGVTY3JpcHQiLCJyZXN0b3JlU2NyaXB0IiwiY2xvbmVDb3B5RXZlbnQiLCJkZXN0IiwicGRhdGFPbGQiLCJwZGF0YUN1ciIsInVkYXRhT2xkIiwidWRhdGFDdXIiLCJmaXhJbnB1dCIsImRvbU1hbmlwIiwiaGFzU2NyaXB0cyIsImlOb0Nsb25lIiwiaHRtbCIsIl9ldmFsVXJsIiwia2VlcERhdGEiLCJjbGVhbkRhdGEiLCJkYXRhQW5kRXZlbnRzIiwiZGVlcERhdGFBbmRFdmVudHMiLCJzcmNFbGVtZW50cyIsImRlc3RFbGVtZW50cyIsImluUGFnZSIsImRldGFjaCIsImFwcGVuZCIsInByZXBlbmQiLCJyZXBsYWNlV2l0aCIsInJlcGxhY2VDaGlsZCIsImFwcGVuZFRvIiwicHJlcGVuZFRvIiwiaW5zZXJ0QWZ0ZXIiLCJyZXBsYWNlQWxsIiwib3JpZ2luYWwiLCJybWFyZ2luIiwicm51bW5vbnB4IiwiZ2V0U3R5bGVzIiwib3BlbmVyIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImNvbXB1dGVTdHlsZVRlc3RzIiwiY3NzVGV4dCIsImNvbnRhaW5lciIsImRpdlN0eWxlIiwicGl4ZWxQb3NpdGlvblZhbCIsInJlbGlhYmxlTWFyZ2luTGVmdFZhbCIsIm1hcmdpbkxlZnQiLCJib3hTaXppbmdSZWxpYWJsZVZhbCIsIndpZHRoIiwibWFyZ2luUmlnaHQiLCJwaXhlbE1hcmdpblJpZ2h0VmFsIiwiYmFja2dyb3VuZENsaXAiLCJjbGVhckNsb25lU3R5bGUiLCJwaXhlbFBvc2l0aW9uIiwiYm94U2l6aW5nUmVsaWFibGUiLCJwaXhlbE1hcmdpblJpZ2h0IiwicmVsaWFibGVNYXJnaW5MZWZ0IiwiY3VyQ1NTIiwibWluV2lkdGgiLCJtYXhXaWR0aCIsImdldFByb3BlcnR5VmFsdWUiLCJhZGRHZXRIb29rSWYiLCJjb25kaXRpb25GbiIsImhvb2tGbiIsInJkaXNwbGF5c3dhcCIsImNzc1Nob3ciLCJ2aXNpYmlsaXR5IiwiY3NzTm9ybWFsVHJhbnNmb3JtIiwibGV0dGVyU3BhY2luZyIsImZvbnRXZWlnaHQiLCJjc3NQcmVmaXhlcyIsImVtcHR5U3R5bGUiLCJ2ZW5kb3JQcm9wTmFtZSIsImNhcE5hbWUiLCJzZXRQb3NpdGl2ZU51bWJlciIsInN1YnRyYWN0IiwiYXVnbWVudFdpZHRoT3JIZWlnaHQiLCJleHRyYSIsImlzQm9yZGVyQm94Iiwic3R5bGVzIiwiZ2V0V2lkdGhPckhlaWdodCIsInZhbHVlSXNCb3JkZXJCb3giLCJnZXRDbGllbnRSZWN0cyIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImNzc0hvb2tzIiwib3BhY2l0eSIsImNzc1Byb3BzIiwib3JpZ05hbWUiLCJtYXJnaW4iLCJwYWRkaW5nIiwiYm9yZGVyIiwic3VmZml4IiwiZXhwYW5kIiwiZXhwYW5kZWQiLCJwYXJ0cyIsIlR3ZWVuIiwiZWFzaW5nIiwicHJvcEhvb2tzIiwicnVuIiwicGVyY2VudCIsImVhc2VkIiwiZHVyYXRpb24iLCJwb3MiLCJmeCIsInNjcm9sbFRvcCIsInNjcm9sbExlZnQiLCJsaW5lYXIiLCJwIiwic3dpbmciLCJjb3MiLCJQSSIsImZ4Tm93IiwidGltZXJJZCIsInJmeHR5cGVzIiwicnJ1biIsInJhZiIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsInRpY2siLCJjcmVhdGVGeE5vdyIsImdlbkZ4IiwiaW5jbHVkZVdpZHRoIiwiaGVpZ2h0IiwiY3JlYXRlVHdlZW4iLCJhbmltYXRpb24iLCJBbmltYXRpb24iLCJ0d2VlbmVycyIsImRlZmF1bHRQcmVmaWx0ZXIiLCJvbGRmaXJlIiwicHJvcFR3ZWVuIiwicmVzdG9yZURpc3BsYXkiLCJpc0JveCIsImFuaW0iLCJoaWRkZW4iLCJkYXRhU2hvdyIsInVucXVldWVkIiwib3ZlcmZsb3ciLCJvdmVyZmxvd1giLCJvdmVyZmxvd1kiLCJwcm9wRmlsdGVyIiwic3BlY2lhbEVhc2luZyIsInByb3BlcnRpZXMiLCJzdG9wcGVkIiwicHJlZmlsdGVycyIsImN1cnJlbnRUaW1lIiwic3RhcnRUaW1lIiwidHdlZW5zIiwib3JpZ2luYWxQcm9wZXJ0aWVzIiwib3JpZ2luYWxPcHRpb25zIiwiZ290b0VuZCIsInRpbWVyIiwiY29tcGxldGUiLCJ0d2VlbmVyIiwicHJlZmlsdGVyIiwic3BlZWQiLCJvcHQiLCJzcGVlZHMiLCJmYWRlVG8iLCJ0byIsImFuaW1hdGUiLCJvcHRhbGwiLCJkb0FuaW1hdGlvbiIsImZpbmlzaCIsInN0b3BRdWV1ZSIsInRpbWVycyIsImNzc0ZuIiwic2xpZGVEb3duIiwic2xpZGVVcCIsInNsaWRlVG9nZ2xlIiwiZmFkZUluIiwiZmFkZU91dCIsImZhZGVUb2dnbGUiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsInNsb3ciLCJmYXN0IiwidGltZSIsImNoZWNrT24iLCJvcHRTZWxlY3RlZCIsInJhZGlvVmFsdWUiLCJib29sSG9vayIsInJlbW92ZUF0dHIiLCJuVHlwZSIsImF0dHJIb29rcyIsImJvb2wiLCJhdHRyTmFtZXMiLCJnZXR0ZXIiLCJsb3dlcmNhc2VOYW1lIiwicmZvY3VzYWJsZSIsInJjbGlja2FibGUiLCJyZW1vdmVQcm9wIiwicHJvcEZpeCIsInRhYmluZGV4IiwicGFyc2VJbnQiLCJzdHJpcEFuZENvbGxhcHNlIiwiZ2V0Q2xhc3MiLCJhZGRDbGFzcyIsImNsYXNzZXMiLCJjdXJWYWx1ZSIsImNsYXp6IiwiZmluYWxWYWx1ZSIsInJlbW92ZUNsYXNzIiwidG9nZ2xlQ2xhc3MiLCJzdGF0ZVZhbCIsImNsYXNzTmFtZXMiLCJoYXNDbGFzcyIsInJyZXR1cm4iLCJ2YWxIb29rcyIsIm9wdGlvblNldCIsInJmb2N1c01vcnBoIiwib25seUhhbmRsZXJzIiwiYnViYmxlVHlwZSIsIm9udHlwZSIsImV2ZW50UGF0aCIsImlzVHJpZ2dlciIsInBhcmVudFdpbmRvdyIsInNpbXVsYXRlIiwidHJpZ2dlckhhbmRsZXIiLCJob3ZlciIsImZuT3ZlciIsImZuT3V0IiwiZm9jdXNpbiIsImF0dGFjaGVzIiwibm9uY2UiLCJycXVlcnkiLCJwYXJzZVhNTCIsIkRPTVBhcnNlciIsInBhcnNlRnJvbVN0cmluZyIsInJicmFja2V0IiwickNSTEYiLCJyc3VibWl0dGVyVHlwZXMiLCJyc3VibWl0dGFibGUiLCJidWlsZFBhcmFtcyIsInRyYWRpdGlvbmFsIiwicyIsInZhbHVlT3JGdW5jdGlvbiIsInNlcmlhbGl6ZSIsInNlcmlhbGl6ZUFycmF5IiwicjIwIiwicmhhc2giLCJyYW50aUNhY2hlIiwicmhlYWRlcnMiLCJybG9jYWxQcm90b2NvbCIsInJub0NvbnRlbnQiLCJycHJvdG9jb2wiLCJ0cmFuc3BvcnRzIiwiYWxsVHlwZXMiLCJvcmlnaW5BbmNob3IiLCJhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMiLCJzdHJ1Y3R1cmUiLCJkYXRhVHlwZUV4cHJlc3Npb24iLCJkYXRhVHlwZXMiLCJpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyIsImpxWEhSIiwiaW5zcGVjdGVkIiwic2Vla2luZ1RyYW5zcG9ydCIsImluc3BlY3QiLCJwcmVmaWx0ZXJPckZhY3RvcnkiLCJkYXRhVHlwZU9yVHJhbnNwb3J0IiwiYWpheEV4dGVuZCIsImZsYXRPcHRpb25zIiwiYWpheFNldHRpbmdzIiwiYWpheEhhbmRsZVJlc3BvbnNlcyIsInJlc3BvbnNlcyIsImN0IiwiZmluYWxEYXRhVHlwZSIsImZpcnN0RGF0YVR5cGUiLCJtaW1lVHlwZSIsImdldFJlc3BvbnNlSGVhZGVyIiwiY29udmVydGVycyIsImFqYXhDb252ZXJ0IiwicmVzcG9uc2UiLCJpc1N1Y2Nlc3MiLCJjb252MiIsImNvbnYiLCJyZXNwb25zZUZpZWxkcyIsImRhdGFGaWx0ZXIiLCJ0aHJvd3MiLCJhY3RpdmUiLCJsYXN0TW9kaWZpZWQiLCJldGFnIiwiaXNMb2NhbCIsInByb3RvY29sIiwiYXN5bmMiLCJhY2NlcHRzIiwianNvbiIsImFqYXhTZXR1cCIsImFqYXhQcmVmaWx0ZXIiLCJhamF4VHJhbnNwb3J0IiwidHJhbnNwb3J0IiwiY2FjaGVVUkwiLCJyZXNwb25zZUhlYWRlcnNTdHJpbmciLCJyZXNwb25zZUhlYWRlcnMiLCJ0aW1lb3V0VGltZXIiLCJ1cmxBbmNob3IiLCJmaXJlR2xvYmFscyIsInVuY2FjaGVkIiwiY2FsbGJhY2tDb250ZXh0IiwiZ2xvYmFsRXZlbnRDb250ZXh0IiwiY29tcGxldGVEZWZlcnJlZCIsInN0YXR1c0NvZGUiLCJyZXF1ZXN0SGVhZGVycyIsInJlcXVlc3RIZWFkZXJzTmFtZXMiLCJzdHJBYm9ydCIsImdldEFsbFJlc3BvbnNlSGVhZGVycyIsIm92ZXJyaWRlTWltZVR5cGUiLCJzdGF0dXMiLCJhYm9ydCIsInN0YXR1c1RleHQiLCJmaW5hbFRleHQiLCJjcm9zc0RvbWFpbiIsImhvc3QiLCJoYXNDb250ZW50IiwiaWZNb2RpZmllZCIsImhlYWRlcnMiLCJzZW5kIiwibmF0aXZlU3RhdHVzVGV4dCIsIm1vZGlmaWVkIiwiZ2V0SlNPTiIsImdldFNjcmlwdCIsIndyYXBBbGwiLCJmaXJzdEVsZW1lbnRDaGlsZCIsIndyYXBJbm5lciIsInVud3JhcCIsInZpc2libGUiLCJvZmZzZXRXaWR0aCIsIm9mZnNldEhlaWdodCIsIlhNTEh0dHBSZXF1ZXN0IiwieGhyU3VjY2Vzc1N0YXR1cyIsInhoclN1cHBvcnRlZCIsImNvcnMiLCJlcnJvckNhbGxiYWNrIiwidXNlcm5hbWUiLCJ4aHJGaWVsZHMiLCJvbmxvYWQiLCJvbmVycm9yIiwib25hYm9ydCIsIm9ucmVhZHlzdGF0ZWNoYW5nZSIsInJlc3BvbnNlVHlwZSIsInJlc3BvbnNlVGV4dCIsImJpbmFyeSIsImNoYXJzZXQiLCJzY3JpcHRDaGFyc2V0IiwiZXZ0Iiwib2xkQ2FsbGJhY2tzIiwicmpzb25wIiwianNvbnAiLCJqc29ucENhbGxiYWNrIiwib3JpZ2luYWxTZXR0aW5ncyIsImNhbGxiYWNrTmFtZSIsIm92ZXJ3cml0dGVuIiwicmVzcG9uc2VDb250YWluZXIiLCJqc29uUHJvcCIsImNyZWF0ZUhUTUxEb2N1bWVudCIsImltcGxlbWVudGF0aW9uIiwia2VlcFNjcmlwdHMiLCJwYXJzZWQiLCJhbmltYXRlZCIsImdldFdpbmRvdyIsInNldE9mZnNldCIsImN1clBvc2l0aW9uIiwiY3VyTGVmdCIsImN1ckNTU1RvcCIsImN1clRvcCIsImN1ck9mZnNldCIsImN1ckNTU0xlZnQiLCJjYWxjdWxhdGVQb3NpdGlvbiIsImN1ckVsZW0iLCJ1c2luZyIsIndpbiIsInJlY3QiLCJwYWdlWU9mZnNldCIsImNsaWVudFRvcCIsInBhZ2VYT2Zmc2V0IiwiY2xpZW50TGVmdCIsIm9mZnNldFBhcmVudCIsInBhcmVudE9mZnNldCIsInNjcm9sbFRvIiwiSGVpZ2h0IiwiV2lkdGgiLCJkZWZhdWx0RXh0cmEiLCJmdW5jTmFtZSIsInBhcnNlSlNPTiIsIl9qUXVlcnkiLCJfJCIsIlByZXNlbnRlciIsIkFwcCIsIk9yZGVyTW9kZWwiLCJPcmRlckNvbGxlY3Rpb24iLCJ1cmxSb290IiwiQXBpIiwibG9naW4iLCJzaWdudXAiLCJ1c2VyIiwiUHJlc2VudGVycyIsIlVpIiwiTG9naW4iLCJBcHBSb3V0ZXIiLCJob21lIiwic2hvd09yZGVycyIsIkNvbGxlY3Rpb25PcmRlciIsIlVzZXJMb2dpbiIsIlVzZXJTaWdudXAiLCJIZWFkZXJWaWV3IiwiT3JkZXJzVmlldyIsImxvZ2luVmlldyIsImV2ZW50QnVzIiwic2lnbnVwVmlldyIsIm9yZGVyTGlzdCIsIm9yZGVyc1ZpZXciLCIkY29udGVudCIsImhlYWRlclZpZXciLCJzd2l0Y2hDb250ZW50Iiwid2lkZ2V0Iiwic2V0VXNlckRhdGEiLCJzaG93SG9tZSIsInNob3dTaWdudXAiLCJhbGVydCIsInJlc3BvbnNlSlNPTiIsInRfaGVhZGVyIiwidXNlckRhdGEiLCJIZWFkZXIiLCJ0bF9vcmRlciIsIk9yZGVyTGlzdFZpZXciLCJvcmRlcnMiLCJ0X2xvZ2luIiwidF9zaWdudXAiLCJlbWFpbCIsImciLCJldmFsIl0sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbURBQTJDLGNBQWM7O0FBRXpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQTJCLDBCQUEwQixFQUFFO0FBQ3ZELHlDQUFpQyxlQUFlO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhEQUFzRCwrREFBK0Q7O0FBRXJIO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs4Q0NoRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQyxVQUFTQSxPQUFULEVBQWtCOztBQUVqQjtBQUNBO0FBQ0EsTUFBSUMsT0FBUSxPQUFPQyxJQUFQLElBQWUsUUFBZixJQUEyQkEsS0FBS0EsSUFBTCxLQUFjQSxJQUF6QyxJQUFpREEsSUFBbEQsSUFDQSxPQUFPQyxNQUFQLElBQWlCLFFBQWpCLElBQTZCQSxPQUFPQSxNQUFQLEtBQWtCQSxNQUEvQyxJQUF5REEsTUFEcEU7O0FBR0E7QUFDQSxNQUFJLElBQUos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QUVBZzdCLElBQUk1NUIsSUFBSixHIiwiZmlsZSI6Im1haW4ubWluLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG5cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGlkZW50aXR5IGZ1bmN0aW9uIGZvciBjYWxsaW5nIGhhcm1vbnkgaW1wb3J0cyB3aXRoIHRoZSBjb3JyZWN0IGNvbnRleHRcbiBcdF9fd2VicGFja19yZXF1aXJlX18uaSA9IGZ1bmN0aW9uKHZhbHVlKSB7IHJldHVybiB2YWx1ZTsgfTtcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4gXHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbiBcdFx0XHRcdGdldDogZ2V0dGVyXG4gXHRcdFx0fSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gMjIpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svYm9vdHN0cmFwIDA2ZjUyMGQyMDZkNmQ2MTI3NzZjIiwiLy8gICAgIEJhY2tib25lLmpzIDEuMy4zXG5cbi8vICAgICAoYykgMjAxMC0yMDE2IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4vLyAgICAgQmFja2JvbmUgbWF5IGJlIGZyZWVseSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4vLyAgICAgRm9yIGFsbCBkZXRhaWxzIGFuZCBkb2N1bWVudGF0aW9uOlxuLy8gICAgIGh0dHA6Ly9iYWNrYm9uZWpzLm9yZ1xuXG4oZnVuY3Rpb24oZmFjdG9yeSkge1xuXG4gIC8vIEVzdGFibGlzaCB0aGUgcm9vdCBvYmplY3QsIGB3aW5kb3dgIChgc2VsZmApIGluIHRoZSBicm93c2VyLCBvciBgZ2xvYmFsYCBvbiB0aGUgc2VydmVyLlxuICAvLyBXZSB1c2UgYHNlbGZgIGluc3RlYWQgb2YgYHdpbmRvd2AgZm9yIGBXZWJXb3JrZXJgIHN1cHBvcnQuXG4gIHZhciByb290ID0gKHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYuc2VsZiA9PT0gc2VsZiAmJiBzZWxmKSB8fFxuICAgICAgICAgICAgKHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsLmdsb2JhbCA9PT0gZ2xvYmFsICYmIGdsb2JhbCk7XG5cbiAgLy8gU2V0IHVwIEJhY2tib25lIGFwcHJvcHJpYXRlbHkgZm9yIHRoZSBlbnZpcm9ubWVudC4gU3RhcnQgd2l0aCBBTUQuXG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoWyd1bmRlcnNjb3JlJywgJ2pxdWVyeScsICdleHBvcnRzJ10sIGZ1bmN0aW9uKF8sICQsIGV4cG9ydHMpIHtcbiAgICAgIC8vIEV4cG9ydCBnbG9iYWwgZXZlbiBpbiBBTUQgY2FzZSBpbiBjYXNlIHRoaXMgc2NyaXB0IGlzIGxvYWRlZCB3aXRoXG4gICAgICAvLyBvdGhlcnMgdGhhdCBtYXkgc3RpbGwgZXhwZWN0IGEgZ2xvYmFsIEJhY2tib25lLlxuICAgICAgcm9vdC5CYWNrYm9uZSA9IGZhY3Rvcnkocm9vdCwgZXhwb3J0cywgXywgJCk7XG4gICAgfSk7XG5cbiAgLy8gTmV4dCBmb3IgTm9kZS5qcyBvciBDb21tb25KUy4galF1ZXJ5IG1heSBub3QgYmUgbmVlZGVkIGFzIGEgbW9kdWxlLlxuICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuICAgIHZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpLCAkO1xuICAgIHRyeSB7ICQgPSByZXF1aXJlKCdqcXVlcnknKTsgfSBjYXRjaCAoZSkge31cbiAgICBmYWN0b3J5KHJvb3QsIGV4cG9ydHMsIF8sICQpO1xuXG4gIC8vIEZpbmFsbHksIGFzIGEgYnJvd3NlciBnbG9iYWwuXG4gIH0gZWxzZSB7XG4gICAgcm9vdC5CYWNrYm9uZSA9IGZhY3Rvcnkocm9vdCwge30sIHJvb3QuXywgKHJvb3QualF1ZXJ5IHx8IHJvb3QuWmVwdG8gfHwgcm9vdC5lbmRlciB8fCByb290LiQpKTtcbiAgfVxuXG59KShmdW5jdGlvbihyb290LCBCYWNrYm9uZSwgXywgJCkge1xuXG4gIC8vIEluaXRpYWwgU2V0dXBcbiAgLy8gLS0tLS0tLS0tLS0tLVxuXG4gIC8vIFNhdmUgdGhlIHByZXZpb3VzIHZhbHVlIG9mIHRoZSBgQmFja2JvbmVgIHZhcmlhYmxlLCBzbyB0aGF0IGl0IGNhbiBiZVxuICAvLyByZXN0b3JlZCBsYXRlciBvbiwgaWYgYG5vQ29uZmxpY3RgIGlzIHVzZWQuXG4gIHZhciBwcmV2aW91c0JhY2tib25lID0gcm9vdC5CYWNrYm9uZTtcblxuICAvLyBDcmVhdGUgYSBsb2NhbCByZWZlcmVuY2UgdG8gYSBjb21tb24gYXJyYXkgbWV0aG9kIHdlJ2xsIHdhbnQgdG8gdXNlIGxhdGVyLlxuICB2YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cbiAgLy8gQ3VycmVudCB2ZXJzaW9uIG9mIHRoZSBsaWJyYXJ5LiBLZWVwIGluIHN5bmMgd2l0aCBgcGFja2FnZS5qc29uYC5cbiAgQmFja2JvbmUuVkVSU0lPTiA9ICcxLjMuMyc7XG5cbiAgLy8gRm9yIEJhY2tib25lJ3MgcHVycG9zZXMsIGpRdWVyeSwgWmVwdG8sIEVuZGVyLCBvciBNeSBMaWJyYXJ5IChraWRkaW5nKSBvd25zXG4gIC8vIHRoZSBgJGAgdmFyaWFibGUuXG4gIEJhY2tib25lLiQgPSAkO1xuXG4gIC8vIFJ1bnMgQmFja2JvbmUuanMgaW4gKm5vQ29uZmxpY3QqIG1vZGUsIHJldHVybmluZyB0aGUgYEJhY2tib25lYCB2YXJpYWJsZVxuICAvLyB0byBpdHMgcHJldmlvdXMgb3duZXIuIFJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhpcyBCYWNrYm9uZSBvYmplY3QuXG4gIEJhY2tib25lLm5vQ29uZmxpY3QgPSBmdW5jdGlvbigpIHtcbiAgICByb290LkJhY2tib25lID0gcHJldmlvdXNCYWNrYm9uZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBUdXJuIG9uIGBlbXVsYXRlSFRUUGAgdG8gc3VwcG9ydCBsZWdhY3kgSFRUUCBzZXJ2ZXJzLiBTZXR0aW5nIHRoaXMgb3B0aW9uXG4gIC8vIHdpbGwgZmFrZSBgXCJQQVRDSFwiYCwgYFwiUFVUXCJgIGFuZCBgXCJERUxFVEVcImAgcmVxdWVzdHMgdmlhIHRoZSBgX21ldGhvZGAgcGFyYW1ldGVyIGFuZFxuICAvLyBzZXQgYSBgWC1IdHRwLU1ldGhvZC1PdmVycmlkZWAgaGVhZGVyLlxuICBCYWNrYm9uZS5lbXVsYXRlSFRUUCA9IGZhbHNlO1xuXG4gIC8vIFR1cm4gb24gYGVtdWxhdGVKU09OYCB0byBzdXBwb3J0IGxlZ2FjeSBzZXJ2ZXJzIHRoYXQgY2FuJ3QgZGVhbCB3aXRoIGRpcmVjdFxuICAvLyBgYXBwbGljYXRpb24vanNvbmAgcmVxdWVzdHMgLi4uIHRoaXMgd2lsbCBlbmNvZGUgdGhlIGJvZHkgYXNcbiAgLy8gYGFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZGAgaW5zdGVhZCBhbmQgd2lsbCBzZW5kIHRoZSBtb2RlbCBpbiBhXG4gIC8vIGZvcm0gcGFyYW0gbmFtZWQgYG1vZGVsYC5cbiAgQmFja2JvbmUuZW11bGF0ZUpTT04gPSBmYWxzZTtcblxuICAvLyBQcm94eSBCYWNrYm9uZSBjbGFzcyBtZXRob2RzIHRvIFVuZGVyc2NvcmUgZnVuY3Rpb25zLCB3cmFwcGluZyB0aGUgbW9kZWwnc1xuICAvLyBgYXR0cmlidXRlc2Agb2JqZWN0IG9yIGNvbGxlY3Rpb24ncyBgbW9kZWxzYCBhcnJheSBiZWhpbmQgdGhlIHNjZW5lcy5cbiAgLy9cbiAgLy8gY29sbGVjdGlvbi5maWx0ZXIoZnVuY3Rpb24obW9kZWwpIHsgcmV0dXJuIG1vZGVsLmdldCgnYWdlJykgPiAxMCB9KTtcbiAgLy8gY29sbGVjdGlvbi5lYWNoKHRoaXMuYWRkVmlldyk7XG4gIC8vXG4gIC8vIGBGdW5jdGlvbiNhcHBseWAgY2FuIGJlIHNsb3cgc28gd2UgdXNlIHRoZSBtZXRob2QncyBhcmcgY291bnQsIGlmIHdlIGtub3cgaXQuXG4gIHZhciBhZGRNZXRob2QgPSBmdW5jdGlvbihsZW5ndGgsIG1ldGhvZCwgYXR0cmlidXRlKSB7XG4gICAgc3dpdGNoIChsZW5ndGgpIHtcbiAgICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX1ttZXRob2RdKHRoaXNbYXR0cmlidXRlXSk7XG4gICAgICB9O1xuICAgICAgY2FzZSAyOiByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIF9bbWV0aG9kXSh0aGlzW2F0dHJpYnV0ZV0sIHZhbHVlKTtcbiAgICAgIH07XG4gICAgICBjYXNlIDM6IHJldHVybiBmdW5jdGlvbihpdGVyYXRlZSwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gX1ttZXRob2RdKHRoaXNbYXR0cmlidXRlXSwgY2IoaXRlcmF0ZWUsIHRoaXMpLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICBjYXNlIDQ6IHJldHVybiBmdW5jdGlvbihpdGVyYXRlZSwgZGVmYXVsdFZhbCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gX1ttZXRob2RdKHRoaXNbYXR0cmlidXRlXSwgY2IoaXRlcmF0ZWUsIHRoaXMpLCBkZWZhdWx0VmFsLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICBkZWZhdWx0OiByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICBhcmdzLnVuc2hpZnQodGhpc1thdHRyaWJ1dGVdKTtcbiAgICAgICAgcmV0dXJuIF9bbWV0aG9kXS5hcHBseShfLCBhcmdzKTtcbiAgICAgIH07XG4gICAgfVxuICB9O1xuICB2YXIgYWRkVW5kZXJzY29yZU1ldGhvZHMgPSBmdW5jdGlvbihDbGFzcywgbWV0aG9kcywgYXR0cmlidXRlKSB7XG4gICAgXy5lYWNoKG1ldGhvZHMsIGZ1bmN0aW9uKGxlbmd0aCwgbWV0aG9kKSB7XG4gICAgICBpZiAoX1ttZXRob2RdKSBDbGFzcy5wcm90b3R5cGVbbWV0aG9kXSA9IGFkZE1ldGhvZChsZW5ndGgsIG1ldGhvZCwgYXR0cmlidXRlKTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBTdXBwb3J0IGBjb2xsZWN0aW9uLnNvcnRCeSgnYXR0cicpYCBhbmQgYGNvbGxlY3Rpb24uZmluZFdoZXJlKHtpZDogMX0pYC5cbiAgdmFyIGNiID0gZnVuY3Rpb24oaXRlcmF0ZWUsIGluc3RhbmNlKSB7XG4gICAgaWYgKF8uaXNGdW5jdGlvbihpdGVyYXRlZSkpIHJldHVybiBpdGVyYXRlZTtcbiAgICBpZiAoXy5pc09iamVjdChpdGVyYXRlZSkgJiYgIWluc3RhbmNlLl9pc01vZGVsKGl0ZXJhdGVlKSkgcmV0dXJuIG1vZGVsTWF0Y2hlcihpdGVyYXRlZSk7XG4gICAgaWYgKF8uaXNTdHJpbmcoaXRlcmF0ZWUpKSByZXR1cm4gZnVuY3Rpb24obW9kZWwpIHsgcmV0dXJuIG1vZGVsLmdldChpdGVyYXRlZSk7IH07XG4gICAgcmV0dXJuIGl0ZXJhdGVlO1xuICB9O1xuICB2YXIgbW9kZWxNYXRjaGVyID0gZnVuY3Rpb24oYXR0cnMpIHtcbiAgICB2YXIgbWF0Y2hlciA9IF8ubWF0Y2hlcyhhdHRycyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG1vZGVsKSB7XG4gICAgICByZXR1cm4gbWF0Y2hlcihtb2RlbC5hdHRyaWJ1dGVzKTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIEJhY2tib25lLkV2ZW50c1xuICAvLyAtLS0tLS0tLS0tLS0tLS1cblxuICAvLyBBIG1vZHVsZSB0aGF0IGNhbiBiZSBtaXhlZCBpbiB0byAqYW55IG9iamVjdCogaW4gb3JkZXIgdG8gcHJvdmlkZSBpdCB3aXRoXG4gIC8vIGEgY3VzdG9tIGV2ZW50IGNoYW5uZWwuIFlvdSBtYXkgYmluZCBhIGNhbGxiYWNrIHRvIGFuIGV2ZW50IHdpdGggYG9uYCBvclxuICAvLyByZW1vdmUgd2l0aCBgb2ZmYDsgYHRyaWdnZXJgLWluZyBhbiBldmVudCBmaXJlcyBhbGwgY2FsbGJhY2tzIGluXG4gIC8vIHN1Y2Nlc3Npb24uXG4gIC8vXG4gIC8vICAgICB2YXIgb2JqZWN0ID0ge307XG4gIC8vICAgICBfLmV4dGVuZChvYmplY3QsIEJhY2tib25lLkV2ZW50cyk7XG4gIC8vICAgICBvYmplY3Qub24oJ2V4cGFuZCcsIGZ1bmN0aW9uKCl7IGFsZXJ0KCdleHBhbmRlZCcpOyB9KTtcbiAgLy8gICAgIG9iamVjdC50cmlnZ2VyKCdleHBhbmQnKTtcbiAgLy9cbiAgdmFyIEV2ZW50cyA9IEJhY2tib25lLkV2ZW50cyA9IHt9O1xuXG4gIC8vIFJlZ3VsYXIgZXhwcmVzc2lvbiB1c2VkIHRvIHNwbGl0IGV2ZW50IHN0cmluZ3MuXG4gIHZhciBldmVudFNwbGl0dGVyID0gL1xccysvO1xuXG4gIC8vIEl0ZXJhdGVzIG92ZXIgdGhlIHN0YW5kYXJkIGBldmVudCwgY2FsbGJhY2tgIChhcyB3ZWxsIGFzIHRoZSBmYW5jeSBtdWx0aXBsZVxuICAvLyBzcGFjZS1zZXBhcmF0ZWQgZXZlbnRzIGBcImNoYW5nZSBibHVyXCIsIGNhbGxiYWNrYCBhbmQgalF1ZXJ5LXN0eWxlIGV2ZW50XG4gIC8vIG1hcHMgYHtldmVudDogY2FsbGJhY2t9YCkuXG4gIHZhciBldmVudHNBcGkgPSBmdW5jdGlvbihpdGVyYXRlZSwgZXZlbnRzLCBuYW1lLCBjYWxsYmFjaywgb3B0cykge1xuICAgIHZhciBpID0gMCwgbmFtZXM7XG4gICAgaWYgKG5hbWUgJiYgdHlwZW9mIG5hbWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAvLyBIYW5kbGUgZXZlbnQgbWFwcy5cbiAgICAgIGlmIChjYWxsYmFjayAhPT0gdm9pZCAwICYmICdjb250ZXh0JyBpbiBvcHRzICYmIG9wdHMuY29udGV4dCA9PT0gdm9pZCAwKSBvcHRzLmNvbnRleHQgPSBjYWxsYmFjaztcbiAgICAgIGZvciAobmFtZXMgPSBfLmtleXMobmFtZSk7IGkgPCBuYW1lcy5sZW5ndGggOyBpKyspIHtcbiAgICAgICAgZXZlbnRzID0gZXZlbnRzQXBpKGl0ZXJhdGVlLCBldmVudHMsIG5hbWVzW2ldLCBuYW1lW25hbWVzW2ldXSwgb3B0cyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChuYW1lICYmIGV2ZW50U3BsaXR0ZXIudGVzdChuYW1lKSkge1xuICAgICAgLy8gSGFuZGxlIHNwYWNlLXNlcGFyYXRlZCBldmVudCBuYW1lcyBieSBkZWxlZ2F0aW5nIHRoZW0gaW5kaXZpZHVhbGx5LlxuICAgICAgZm9yIChuYW1lcyA9IG5hbWUuc3BsaXQoZXZlbnRTcGxpdHRlcik7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBldmVudHMgPSBpdGVyYXRlZShldmVudHMsIG5hbWVzW2ldLCBjYWxsYmFjaywgb3B0cyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZpbmFsbHksIHN0YW5kYXJkIGV2ZW50cy5cbiAgICAgIGV2ZW50cyA9IGl0ZXJhdGVlKGV2ZW50cywgbmFtZSwgY2FsbGJhY2ssIG9wdHMpO1xuICAgIH1cbiAgICByZXR1cm4gZXZlbnRzO1xuICB9O1xuXG4gIC8vIEJpbmQgYW4gZXZlbnQgdG8gYSBgY2FsbGJhY2tgIGZ1bmN0aW9uLiBQYXNzaW5nIGBcImFsbFwiYCB3aWxsIGJpbmRcbiAgLy8gdGhlIGNhbGxiYWNrIHRvIGFsbCBldmVudHMgZmlyZWQuXG4gIEV2ZW50cy5vbiA9IGZ1bmN0aW9uKG5hbWUsIGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIGludGVybmFsT24odGhpcywgbmFtZSwgY2FsbGJhY2ssIGNvbnRleHQpO1xuICB9O1xuXG4gIC8vIEd1YXJkIHRoZSBgbGlzdGVuaW5nYCBhcmd1bWVudCBmcm9tIHRoZSBwdWJsaWMgQVBJLlxuICB2YXIgaW50ZXJuYWxPbiA9IGZ1bmN0aW9uKG9iaiwgbmFtZSwgY2FsbGJhY2ssIGNvbnRleHQsIGxpc3RlbmluZykge1xuICAgIG9iai5fZXZlbnRzID0gZXZlbnRzQXBpKG9uQXBpLCBvYmouX2V2ZW50cyB8fCB7fSwgbmFtZSwgY2FsbGJhY2ssIHtcbiAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICBjdHg6IG9iaixcbiAgICAgIGxpc3RlbmluZzogbGlzdGVuaW5nXG4gICAgfSk7XG5cbiAgICBpZiAobGlzdGVuaW5nKSB7XG4gICAgICB2YXIgbGlzdGVuZXJzID0gb2JqLl9saXN0ZW5lcnMgfHwgKG9iai5fbGlzdGVuZXJzID0ge30pO1xuICAgICAgbGlzdGVuZXJzW2xpc3RlbmluZy5pZF0gPSBsaXN0ZW5pbmc7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICAvLyBJbnZlcnNpb24tb2YtY29udHJvbCB2ZXJzaW9ucyBvZiBgb25gLiBUZWxsICp0aGlzKiBvYmplY3QgdG8gbGlzdGVuIHRvXG4gIC8vIGFuIGV2ZW50IGluIGFub3RoZXIgb2JqZWN0Li4uIGtlZXBpbmcgdHJhY2sgb2Ygd2hhdCBpdCdzIGxpc3RlbmluZyB0b1xuICAvLyBmb3IgZWFzaWVyIHVuYmluZGluZyBsYXRlci5cbiAgRXZlbnRzLmxpc3RlblRvID0gZnVuY3Rpb24ob2JqLCBuYW1lLCBjYWxsYmFjaykge1xuICAgIGlmICghb2JqKSByZXR1cm4gdGhpcztcbiAgICB2YXIgaWQgPSBvYmouX2xpc3RlbklkIHx8IChvYmouX2xpc3RlbklkID0gXy51bmlxdWVJZCgnbCcpKTtcbiAgICB2YXIgbGlzdGVuaW5nVG8gPSB0aGlzLl9saXN0ZW5pbmdUbyB8fCAodGhpcy5fbGlzdGVuaW5nVG8gPSB7fSk7XG4gICAgdmFyIGxpc3RlbmluZyA9IGxpc3RlbmluZ1RvW2lkXTtcblxuICAgIC8vIFRoaXMgb2JqZWN0IGlzIG5vdCBsaXN0ZW5pbmcgdG8gYW55IG90aGVyIGV2ZW50cyBvbiBgb2JqYCB5ZXQuXG4gICAgLy8gU2V0dXAgdGhlIG5lY2Vzc2FyeSByZWZlcmVuY2VzIHRvIHRyYWNrIHRoZSBsaXN0ZW5pbmcgY2FsbGJhY2tzLlxuICAgIGlmICghbGlzdGVuaW5nKSB7XG4gICAgICB2YXIgdGhpc0lkID0gdGhpcy5fbGlzdGVuSWQgfHwgKHRoaXMuX2xpc3RlbklkID0gXy51bmlxdWVJZCgnbCcpKTtcbiAgICAgIGxpc3RlbmluZyA9IGxpc3RlbmluZ1RvW2lkXSA9IHtvYmo6IG9iaiwgb2JqSWQ6IGlkLCBpZDogdGhpc0lkLCBsaXN0ZW5pbmdUbzogbGlzdGVuaW5nVG8sIGNvdW50OiAwfTtcbiAgICB9XG5cbiAgICAvLyBCaW5kIGNhbGxiYWNrcyBvbiBvYmosIGFuZCBrZWVwIHRyYWNrIG9mIHRoZW0gb24gbGlzdGVuaW5nLlxuICAgIGludGVybmFsT24ob2JqLCBuYW1lLCBjYWxsYmFjaywgdGhpcywgbGlzdGVuaW5nKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBUaGUgcmVkdWNpbmcgQVBJIHRoYXQgYWRkcyBhIGNhbGxiYWNrIHRvIHRoZSBgZXZlbnRzYCBvYmplY3QuXG4gIHZhciBvbkFwaSA9IGZ1bmN0aW9uKGV2ZW50cywgbmFtZSwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIHZhciBoYW5kbGVycyA9IGV2ZW50c1tuYW1lXSB8fCAoZXZlbnRzW25hbWVdID0gW10pO1xuICAgICAgdmFyIGNvbnRleHQgPSBvcHRpb25zLmNvbnRleHQsIGN0eCA9IG9wdGlvbnMuY3R4LCBsaXN0ZW5pbmcgPSBvcHRpb25zLmxpc3RlbmluZztcbiAgICAgIGlmIChsaXN0ZW5pbmcpIGxpc3RlbmluZy5jb3VudCsrO1xuXG4gICAgICBoYW5kbGVycy5wdXNoKHtjYWxsYmFjazogY2FsbGJhY2ssIGNvbnRleHQ6IGNvbnRleHQsIGN0eDogY29udGV4dCB8fCBjdHgsIGxpc3RlbmluZzogbGlzdGVuaW5nfSk7XG4gICAgfVxuICAgIHJldHVybiBldmVudHM7XG4gIH07XG5cbiAgLy8gUmVtb3ZlIG9uZSBvciBtYW55IGNhbGxiYWNrcy4gSWYgYGNvbnRleHRgIGlzIG51bGwsIHJlbW92ZXMgYWxsXG4gIC8vIGNhbGxiYWNrcyB3aXRoIHRoYXQgZnVuY3Rpb24uIElmIGBjYWxsYmFja2AgaXMgbnVsbCwgcmVtb3ZlcyBhbGxcbiAgLy8gY2FsbGJhY2tzIGZvciB0aGUgZXZlbnQuIElmIGBuYW1lYCBpcyBudWxsLCByZW1vdmVzIGFsbCBib3VuZFxuICAvLyBjYWxsYmFja3MgZm9yIGFsbCBldmVudHMuXG4gIEV2ZW50cy5vZmYgPSBmdW5jdGlvbihuYW1lLCBjYWxsYmFjaywgY29udGV4dCkge1xuICAgIGlmICghdGhpcy5fZXZlbnRzKSByZXR1cm4gdGhpcztcbiAgICB0aGlzLl9ldmVudHMgPSBldmVudHNBcGkob2ZmQXBpLCB0aGlzLl9ldmVudHMsIG5hbWUsIGNhbGxiYWNrLCB7XG4gICAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgICAgbGlzdGVuZXJzOiB0aGlzLl9saXN0ZW5lcnNcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBUZWxsIHRoaXMgb2JqZWN0IHRvIHN0b3AgbGlzdGVuaW5nIHRvIGVpdGhlciBzcGVjaWZpYyBldmVudHMgLi4uIG9yXG4gIC8vIHRvIGV2ZXJ5IG9iamVjdCBpdCdzIGN1cnJlbnRseSBsaXN0ZW5pbmcgdG8uXG4gIEV2ZW50cy5zdG9wTGlzdGVuaW5nID0gZnVuY3Rpb24ob2JqLCBuYW1lLCBjYWxsYmFjaykge1xuICAgIHZhciBsaXN0ZW5pbmdUbyA9IHRoaXMuX2xpc3RlbmluZ1RvO1xuICAgIGlmICghbGlzdGVuaW5nVG8pIHJldHVybiB0aGlzO1xuXG4gICAgdmFyIGlkcyA9IG9iaiA/IFtvYmouX2xpc3RlbklkXSA6IF8ua2V5cyhsaXN0ZW5pbmdUbyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGxpc3RlbmluZyA9IGxpc3RlbmluZ1RvW2lkc1tpXV07XG5cbiAgICAgIC8vIElmIGxpc3RlbmluZyBkb2Vzbid0IGV4aXN0LCB0aGlzIG9iamVjdCBpcyBub3QgY3VycmVudGx5XG4gICAgICAvLyBsaXN0ZW5pbmcgdG8gb2JqLiBCcmVhayBvdXQgZWFybHkuXG4gICAgICBpZiAoIWxpc3RlbmluZykgYnJlYWs7XG5cbiAgICAgIGxpc3RlbmluZy5vYmoub2ZmKG5hbWUsIGNhbGxiYWNrLCB0aGlzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBUaGUgcmVkdWNpbmcgQVBJIHRoYXQgcmVtb3ZlcyBhIGNhbGxiYWNrIGZyb20gdGhlIGBldmVudHNgIG9iamVjdC5cbiAgdmFyIG9mZkFwaSA9IGZ1bmN0aW9uKGV2ZW50cywgbmFtZSwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICBpZiAoIWV2ZW50cykgcmV0dXJuO1xuXG4gICAgdmFyIGkgPSAwLCBsaXN0ZW5pbmc7XG4gICAgdmFyIGNvbnRleHQgPSBvcHRpb25zLmNvbnRleHQsIGxpc3RlbmVycyA9IG9wdGlvbnMubGlzdGVuZXJzO1xuXG4gICAgLy8gRGVsZXRlIGFsbCBldmVudHMgbGlzdGVuZXJzIGFuZCBcImRyb3BcIiBldmVudHMuXG4gICAgaWYgKCFuYW1lICYmICFjYWxsYmFjayAmJiAhY29udGV4dCkge1xuICAgICAgdmFyIGlkcyA9IF8ua2V5cyhsaXN0ZW5lcnMpO1xuICAgICAgZm9yICg7IGkgPCBpZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGlzdGVuaW5nID0gbGlzdGVuZXJzW2lkc1tpXV07XG4gICAgICAgIGRlbGV0ZSBsaXN0ZW5lcnNbbGlzdGVuaW5nLmlkXTtcbiAgICAgICAgZGVsZXRlIGxpc3RlbmluZy5saXN0ZW5pbmdUb1tsaXN0ZW5pbmcub2JqSWRdO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBuYW1lcyA9IG5hbWUgPyBbbmFtZV0gOiBfLmtleXMoZXZlbnRzKTtcbiAgICBmb3IgKDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBuYW1lID0gbmFtZXNbaV07XG4gICAgICB2YXIgaGFuZGxlcnMgPSBldmVudHNbbmFtZV07XG5cbiAgICAgIC8vIEJhaWwgb3V0IGlmIHRoZXJlIGFyZSBubyBldmVudHMgc3RvcmVkLlxuICAgICAgaWYgKCFoYW5kbGVycykgYnJlYWs7XG5cbiAgICAgIC8vIFJlcGxhY2UgZXZlbnRzIGlmIHRoZXJlIGFyZSBhbnkgcmVtYWluaW5nLiAgT3RoZXJ3aXNlLCBjbGVhbiB1cC5cbiAgICAgIHZhciByZW1haW5pbmcgPSBbXTtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaGFuZGxlcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIGhhbmRsZXIgPSBoYW5kbGVyc1tqXTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrICE9PSBoYW5kbGVyLmNhbGxiYWNrICYmXG4gICAgICAgICAgICBjYWxsYmFjayAhPT0gaGFuZGxlci5jYWxsYmFjay5fY2FsbGJhY2sgfHxcbiAgICAgICAgICAgICAgY29udGV4dCAmJiBjb250ZXh0ICE9PSBoYW5kbGVyLmNvbnRleHRcbiAgICAgICAgKSB7XG4gICAgICAgICAgcmVtYWluaW5nLnB1c2goaGFuZGxlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGlzdGVuaW5nID0gaGFuZGxlci5saXN0ZW5pbmc7XG4gICAgICAgICAgaWYgKGxpc3RlbmluZyAmJiAtLWxpc3RlbmluZy5jb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgZGVsZXRlIGxpc3RlbmVyc1tsaXN0ZW5pbmcuaWRdO1xuICAgICAgICAgICAgZGVsZXRlIGxpc3RlbmluZy5saXN0ZW5pbmdUb1tsaXN0ZW5pbmcub2JqSWRdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBVcGRhdGUgdGFpbCBldmVudCBpZiB0aGUgbGlzdCBoYXMgYW55IGV2ZW50cy4gIE90aGVyd2lzZSwgY2xlYW4gdXAuXG4gICAgICBpZiAocmVtYWluaW5nLmxlbmd0aCkge1xuICAgICAgICBldmVudHNbbmFtZV0gPSByZW1haW5pbmc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGUgZXZlbnRzW25hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXZlbnRzO1xuICB9O1xuXG4gIC8vIEJpbmQgYW4gZXZlbnQgdG8gb25seSBiZSB0cmlnZ2VyZWQgYSBzaW5nbGUgdGltZS4gQWZ0ZXIgdGhlIGZpcnN0IHRpbWVcbiAgLy8gdGhlIGNhbGxiYWNrIGlzIGludm9rZWQsIGl0cyBsaXN0ZW5lciB3aWxsIGJlIHJlbW92ZWQuIElmIG11bHRpcGxlIGV2ZW50c1xuICAvLyBhcmUgcGFzc2VkIGluIHVzaW5nIHRoZSBzcGFjZS1zZXBhcmF0ZWQgc3ludGF4LCB0aGUgaGFuZGxlciB3aWxsIGZpcmVcbiAgLy8gb25jZSBmb3IgZWFjaCBldmVudCwgbm90IG9uY2UgZm9yIGEgY29tYmluYXRpb24gb2YgYWxsIGV2ZW50cy5cbiAgRXZlbnRzLm9uY2UgPSBmdW5jdGlvbihuYW1lLCBjYWxsYmFjaywgY29udGV4dCkge1xuICAgIC8vIE1hcCB0aGUgZXZlbnQgaW50byBhIGB7ZXZlbnQ6IG9uY2V9YCBvYmplY3QuXG4gICAgdmFyIGV2ZW50cyA9IGV2ZW50c0FwaShvbmNlTWFwLCB7fSwgbmFtZSwgY2FsbGJhY2ssIF8uYmluZCh0aGlzLm9mZiwgdGhpcykpO1xuICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycgJiYgY29udGV4dCA9PSBudWxsKSBjYWxsYmFjayA9IHZvaWQgMDtcbiAgICByZXR1cm4gdGhpcy5vbihldmVudHMsIGNhbGxiYWNrLCBjb250ZXh0KTtcbiAgfTtcblxuICAvLyBJbnZlcnNpb24tb2YtY29udHJvbCB2ZXJzaW9ucyBvZiBgb25jZWAuXG4gIEV2ZW50cy5saXN0ZW5Ub09uY2UgPSBmdW5jdGlvbihvYmosIG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgLy8gTWFwIHRoZSBldmVudCBpbnRvIGEgYHtldmVudDogb25jZX1gIG9iamVjdC5cbiAgICB2YXIgZXZlbnRzID0gZXZlbnRzQXBpKG9uY2VNYXAsIHt9LCBuYW1lLCBjYWxsYmFjaywgXy5iaW5kKHRoaXMuc3RvcExpc3RlbmluZywgdGhpcywgb2JqKSk7XG4gICAgcmV0dXJuIHRoaXMubGlzdGVuVG8ob2JqLCBldmVudHMpO1xuICB9O1xuXG4gIC8vIFJlZHVjZXMgdGhlIGV2ZW50IGNhbGxiYWNrcyBpbnRvIGEgbWFwIG9mIGB7ZXZlbnQ6IG9uY2VXcmFwcGVyfWAuXG4gIC8vIGBvZmZlcmAgdW5iaW5kcyB0aGUgYG9uY2VXcmFwcGVyYCBhZnRlciBpdCBoYXMgYmVlbiBjYWxsZWQuXG4gIHZhciBvbmNlTWFwID0gZnVuY3Rpb24obWFwLCBuYW1lLCBjYWxsYmFjaywgb2ZmZXIpIHtcbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIHZhciBvbmNlID0gbWFwW25hbWVdID0gXy5vbmNlKGZ1bmN0aW9uKCkge1xuICAgICAgICBvZmZlcihuYW1lLCBvbmNlKTtcbiAgICAgICAgY2FsbGJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH0pO1xuICAgICAgb25jZS5fY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB9XG4gICAgcmV0dXJuIG1hcDtcbiAgfTtcblxuICAvLyBUcmlnZ2VyIG9uZSBvciBtYW55IGV2ZW50cywgZmlyaW5nIGFsbCBib3VuZCBjYWxsYmFja3MuIENhbGxiYWNrcyBhcmVcbiAgLy8gcGFzc2VkIHRoZSBzYW1lIGFyZ3VtZW50cyBhcyBgdHJpZ2dlcmAgaXMsIGFwYXJ0IGZyb20gdGhlIGV2ZW50IG5hbWVcbiAgLy8gKHVubGVzcyB5b3UncmUgbGlzdGVuaW5nIG9uIGBcImFsbFwiYCwgd2hpY2ggd2lsbCBjYXVzZSB5b3VyIGNhbGxiYWNrIHRvXG4gIC8vIHJlY2VpdmUgdGhlIHRydWUgbmFtZSBvZiB0aGUgZXZlbnQgYXMgdGhlIGZpcnN0IGFyZ3VtZW50KS5cbiAgRXZlbnRzLnRyaWdnZXIgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgaWYgKCF0aGlzLl9ldmVudHMpIHJldHVybiB0aGlzO1xuXG4gICAgdmFyIGxlbmd0aCA9IE1hdGgubWF4KDAsIGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICB2YXIgYXJncyA9IEFycmF5KGxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykgYXJnc1tpXSA9IGFyZ3VtZW50c1tpICsgMV07XG5cbiAgICBldmVudHNBcGkodHJpZ2dlckFwaSwgdGhpcy5fZXZlbnRzLCBuYW1lLCB2b2lkIDAsIGFyZ3MpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIEhhbmRsZXMgdHJpZ2dlcmluZyB0aGUgYXBwcm9wcmlhdGUgZXZlbnQgY2FsbGJhY2tzLlxuICB2YXIgdHJpZ2dlckFwaSA9IGZ1bmN0aW9uKG9iakV2ZW50cywgbmFtZSwgY2FsbGJhY2ssIGFyZ3MpIHtcbiAgICBpZiAob2JqRXZlbnRzKSB7XG4gICAgICB2YXIgZXZlbnRzID0gb2JqRXZlbnRzW25hbWVdO1xuICAgICAgdmFyIGFsbEV2ZW50cyA9IG9iakV2ZW50cy5hbGw7XG4gICAgICBpZiAoZXZlbnRzICYmIGFsbEV2ZW50cykgYWxsRXZlbnRzID0gYWxsRXZlbnRzLnNsaWNlKCk7XG4gICAgICBpZiAoZXZlbnRzKSB0cmlnZ2VyRXZlbnRzKGV2ZW50cywgYXJncyk7XG4gICAgICBpZiAoYWxsRXZlbnRzKSB0cmlnZ2VyRXZlbnRzKGFsbEV2ZW50cywgW25hbWVdLmNvbmNhdChhcmdzKSk7XG4gICAgfVxuICAgIHJldHVybiBvYmpFdmVudHM7XG4gIH07XG5cbiAgLy8gQSBkaWZmaWN1bHQtdG8tYmVsaWV2ZSwgYnV0IG9wdGltaXplZCBpbnRlcm5hbCBkaXNwYXRjaCBmdW5jdGlvbiBmb3JcbiAgLy8gdHJpZ2dlcmluZyBldmVudHMuIFRyaWVzIHRvIGtlZXAgdGhlIHVzdWFsIGNhc2VzIHNwZWVkeSAobW9zdCBpbnRlcm5hbFxuICAvLyBCYWNrYm9uZSBldmVudHMgaGF2ZSAzIGFyZ3VtZW50cykuXG4gIHZhciB0cmlnZ2VyRXZlbnRzID0gZnVuY3Rpb24oZXZlbnRzLCBhcmdzKSB7XG4gICAgdmFyIGV2LCBpID0gLTEsIGwgPSBldmVudHMubGVuZ3RoLCBhMSA9IGFyZ3NbMF0sIGEyID0gYXJnc1sxXSwgYTMgPSBhcmdzWzJdO1xuICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMDogd2hpbGUgKCsraSA8IGwpIChldiA9IGV2ZW50c1tpXSkuY2FsbGJhY2suY2FsbChldi5jdHgpOyByZXR1cm47XG4gICAgICBjYXNlIDE6IHdoaWxlICgrK2kgPCBsKSAoZXYgPSBldmVudHNbaV0pLmNhbGxiYWNrLmNhbGwoZXYuY3R4LCBhMSk7IHJldHVybjtcbiAgICAgIGNhc2UgMjogd2hpbGUgKCsraSA8IGwpIChldiA9IGV2ZW50c1tpXSkuY2FsbGJhY2suY2FsbChldi5jdHgsIGExLCBhMik7IHJldHVybjtcbiAgICAgIGNhc2UgMzogd2hpbGUgKCsraSA8IGwpIChldiA9IGV2ZW50c1tpXSkuY2FsbGJhY2suY2FsbChldi5jdHgsIGExLCBhMiwgYTMpOyByZXR1cm47XG4gICAgICBkZWZhdWx0OiB3aGlsZSAoKytpIDwgbCkgKGV2ID0gZXZlbnRzW2ldKS5jYWxsYmFjay5hcHBseShldi5jdHgsIGFyZ3MpOyByZXR1cm47XG4gICAgfVxuICB9O1xuXG4gIC8vIEFsaWFzZXMgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuICBFdmVudHMuYmluZCAgID0gRXZlbnRzLm9uO1xuICBFdmVudHMudW5iaW5kID0gRXZlbnRzLm9mZjtcblxuICAvLyBBbGxvdyB0aGUgYEJhY2tib25lYCBvYmplY3QgdG8gc2VydmUgYXMgYSBnbG9iYWwgZXZlbnQgYnVzLCBmb3IgZm9sa3Mgd2hvXG4gIC8vIHdhbnQgZ2xvYmFsIFwicHVic3ViXCIgaW4gYSBjb252ZW5pZW50IHBsYWNlLlxuICBfLmV4dGVuZChCYWNrYm9uZSwgRXZlbnRzKTtcblxuICAvLyBCYWNrYm9uZS5Nb2RlbFxuICAvLyAtLS0tLS0tLS0tLS0tLVxuXG4gIC8vIEJhY2tib25lICoqTW9kZWxzKiogYXJlIHRoZSBiYXNpYyBkYXRhIG9iamVjdCBpbiB0aGUgZnJhbWV3b3JrIC0tXG4gIC8vIGZyZXF1ZW50bHkgcmVwcmVzZW50aW5nIGEgcm93IGluIGEgdGFibGUgaW4gYSBkYXRhYmFzZSBvbiB5b3VyIHNlcnZlci5cbiAgLy8gQSBkaXNjcmV0ZSBjaHVuayBvZiBkYXRhIGFuZCBhIGJ1bmNoIG9mIHVzZWZ1bCwgcmVsYXRlZCBtZXRob2RzIGZvclxuICAvLyBwZXJmb3JtaW5nIGNvbXB1dGF0aW9ucyBhbmQgdHJhbnNmb3JtYXRpb25zIG9uIHRoYXQgZGF0YS5cblxuICAvLyBDcmVhdGUgYSBuZXcgbW9kZWwgd2l0aCB0aGUgc3BlY2lmaWVkIGF0dHJpYnV0ZXMuIEEgY2xpZW50IGlkIChgY2lkYClcbiAgLy8gaXMgYXV0b21hdGljYWxseSBnZW5lcmF0ZWQgYW5kIGFzc2lnbmVkIGZvciB5b3UuXG4gIHZhciBNb2RlbCA9IEJhY2tib25lLk1vZGVsID0gZnVuY3Rpb24oYXR0cmlidXRlcywgb3B0aW9ucykge1xuICAgIHZhciBhdHRycyA9IGF0dHJpYnV0ZXMgfHwge307XG4gICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHt9KTtcbiAgICB0aGlzLmNpZCA9IF8udW5pcXVlSWQodGhpcy5jaWRQcmVmaXgpO1xuICAgIHRoaXMuYXR0cmlidXRlcyA9IHt9O1xuICAgIGlmIChvcHRpb25zLmNvbGxlY3Rpb24pIHRoaXMuY29sbGVjdGlvbiA9IG9wdGlvbnMuY29sbGVjdGlvbjtcbiAgICBpZiAob3B0aW9ucy5wYXJzZSkgYXR0cnMgPSB0aGlzLnBhcnNlKGF0dHJzLCBvcHRpb25zKSB8fCB7fTtcbiAgICB2YXIgZGVmYXVsdHMgPSBfLnJlc3VsdCh0aGlzLCAnZGVmYXVsdHMnKTtcbiAgICBhdHRycyA9IF8uZGVmYXVsdHMoXy5leHRlbmQoe30sIGRlZmF1bHRzLCBhdHRycyksIGRlZmF1bHRzKTtcbiAgICB0aGlzLnNldChhdHRycywgb3B0aW9ucyk7XG4gICAgdGhpcy5jaGFuZ2VkID0ge307XG4gICAgdGhpcy5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG5cbiAgLy8gQXR0YWNoIGFsbCBpbmhlcml0YWJsZSBtZXRob2RzIHRvIHRoZSBNb2RlbCBwcm90b3R5cGUuXG4gIF8uZXh0ZW5kKE1vZGVsLnByb3RvdHlwZSwgRXZlbnRzLCB7XG5cbiAgICAvLyBBIGhhc2ggb2YgYXR0cmlidXRlcyB3aG9zZSBjdXJyZW50IGFuZCBwcmV2aW91cyB2YWx1ZSBkaWZmZXIuXG4gICAgY2hhbmdlZDogbnVsbCxcblxuICAgIC8vIFRoZSB2YWx1ZSByZXR1cm5lZCBkdXJpbmcgdGhlIGxhc3QgZmFpbGVkIHZhbGlkYXRpb24uXG4gICAgdmFsaWRhdGlvbkVycm9yOiBudWxsLFxuXG4gICAgLy8gVGhlIGRlZmF1bHQgbmFtZSBmb3IgdGhlIEpTT04gYGlkYCBhdHRyaWJ1dGUgaXMgYFwiaWRcImAuIE1vbmdvREIgYW5kXG4gICAgLy8gQ291Y2hEQiB1c2VycyBtYXkgd2FudCB0byBzZXQgdGhpcyB0byBgXCJfaWRcImAuXG4gICAgaWRBdHRyaWJ1dGU6ICdpZCcsXG5cbiAgICAvLyBUaGUgcHJlZml4IGlzIHVzZWQgdG8gY3JlYXRlIHRoZSBjbGllbnQgaWQgd2hpY2ggaXMgdXNlZCB0byBpZGVudGlmeSBtb2RlbHMgbG9jYWxseS5cbiAgICAvLyBZb3UgbWF5IHdhbnQgdG8gb3ZlcnJpZGUgdGhpcyBpZiB5b3UncmUgZXhwZXJpZW5jaW5nIG5hbWUgY2xhc2hlcyB3aXRoIG1vZGVsIGlkcy5cbiAgICBjaWRQcmVmaXg6ICdjJyxcblxuICAgIC8vIEluaXRpYWxpemUgaXMgYW4gZW1wdHkgZnVuY3Rpb24gYnkgZGVmYXVsdC4gT3ZlcnJpZGUgaXQgd2l0aCB5b3VyIG93blxuICAgIC8vIGluaXRpYWxpemF0aW9uIGxvZ2ljLlxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKCl7fSxcblxuICAgIC8vIFJldHVybiBhIGNvcHkgb2YgdGhlIG1vZGVsJ3MgYGF0dHJpYnV0ZXNgIG9iamVjdC5cbiAgICB0b0pTT046IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBfLmNsb25lKHRoaXMuYXR0cmlidXRlcyk7XG4gICAgfSxcblxuICAgIC8vIFByb3h5IGBCYWNrYm9uZS5zeW5jYCBieSBkZWZhdWx0IC0tIGJ1dCBvdmVycmlkZSB0aGlzIGlmIHlvdSBuZWVkXG4gICAgLy8gY3VzdG9tIHN5bmNpbmcgc2VtYW50aWNzIGZvciAqdGhpcyogcGFydGljdWxhciBtb2RlbC5cbiAgICBzeW5jOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBCYWNrYm9uZS5zeW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSxcblxuICAgIC8vIEdldCB0aGUgdmFsdWUgb2YgYW4gYXR0cmlidXRlLlxuICAgIGdldDogZnVuY3Rpb24oYXR0cikge1xuICAgICAgcmV0dXJuIHRoaXMuYXR0cmlidXRlc1thdHRyXTtcbiAgICB9LFxuXG4gICAgLy8gR2V0IHRoZSBIVE1MLWVzY2FwZWQgdmFsdWUgb2YgYW4gYXR0cmlidXRlLlxuICAgIGVzY2FwZTogZnVuY3Rpb24oYXR0cikge1xuICAgICAgcmV0dXJuIF8uZXNjYXBlKHRoaXMuZ2V0KGF0dHIpKTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGF0dHJpYnV0ZSBjb250YWlucyBhIHZhbHVlIHRoYXQgaXMgbm90IG51bGxcbiAgICAvLyBvciB1bmRlZmluZWQuXG4gICAgaGFzOiBmdW5jdGlvbihhdHRyKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXQoYXR0cikgIT0gbnVsbDtcbiAgICB9LFxuXG4gICAgLy8gU3BlY2lhbC1jYXNlZCBwcm94eSB0byB1bmRlcnNjb3JlJ3MgYF8ubWF0Y2hlc2AgbWV0aG9kLlxuICAgIG1hdGNoZXM6IGZ1bmN0aW9uKGF0dHJzKSB7XG4gICAgICByZXR1cm4gISFfLml0ZXJhdGVlKGF0dHJzLCB0aGlzKSh0aGlzLmF0dHJpYnV0ZXMpO1xuICAgIH0sXG5cbiAgICAvLyBTZXQgYSBoYXNoIG9mIG1vZGVsIGF0dHJpYnV0ZXMgb24gdGhlIG9iamVjdCwgZmlyaW5nIGBcImNoYW5nZVwiYC4gVGhpcyBpc1xuICAgIC8vIHRoZSBjb3JlIHByaW1pdGl2ZSBvcGVyYXRpb24gb2YgYSBtb2RlbCwgdXBkYXRpbmcgdGhlIGRhdGEgYW5kIG5vdGlmeWluZ1xuICAgIC8vIGFueW9uZSB3aG8gbmVlZHMgdG8ga25vdyBhYm91dCB0aGUgY2hhbmdlIGluIHN0YXRlLiBUaGUgaGVhcnQgb2YgdGhlIGJlYXN0LlxuICAgIHNldDogZnVuY3Rpb24oa2V5LCB2YWwsIG9wdGlvbnMpIHtcbiAgICAgIGlmIChrZXkgPT0gbnVsbCkgcmV0dXJuIHRoaXM7XG5cbiAgICAgIC8vIEhhbmRsZSBib3RoIGBcImtleVwiLCB2YWx1ZWAgYW5kIGB7a2V5OiB2YWx1ZX1gIC1zdHlsZSBhcmd1bWVudHMuXG4gICAgICB2YXIgYXR0cnM7XG4gICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgYXR0cnMgPSBrZXk7XG4gICAgICAgIG9wdGlvbnMgPSB2YWw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAoYXR0cnMgPSB7fSlba2V5XSA9IHZhbDtcbiAgICAgIH1cblxuICAgICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHt9KTtcblxuICAgICAgLy8gUnVuIHZhbGlkYXRpb24uXG4gICAgICBpZiAoIXRoaXMuX3ZhbGlkYXRlKGF0dHJzLCBvcHRpb25zKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAvLyBFeHRyYWN0IGF0dHJpYnV0ZXMgYW5kIG9wdGlvbnMuXG4gICAgICB2YXIgdW5zZXQgICAgICA9IG9wdGlvbnMudW5zZXQ7XG4gICAgICB2YXIgc2lsZW50ICAgICA9IG9wdGlvbnMuc2lsZW50O1xuICAgICAgdmFyIGNoYW5nZXMgICAgPSBbXTtcbiAgICAgIHZhciBjaGFuZ2luZyAgID0gdGhpcy5fY2hhbmdpbmc7XG4gICAgICB0aGlzLl9jaGFuZ2luZyA9IHRydWU7XG5cbiAgICAgIGlmICghY2hhbmdpbmcpIHtcbiAgICAgICAgdGhpcy5fcHJldmlvdXNBdHRyaWJ1dGVzID0gXy5jbG9uZSh0aGlzLmF0dHJpYnV0ZXMpO1xuICAgICAgICB0aGlzLmNoYW5nZWQgPSB7fTtcbiAgICAgIH1cblxuICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLmF0dHJpYnV0ZXM7XG4gICAgICB2YXIgY2hhbmdlZCA9IHRoaXMuY2hhbmdlZDtcbiAgICAgIHZhciBwcmV2ICAgID0gdGhpcy5fcHJldmlvdXNBdHRyaWJ1dGVzO1xuXG4gICAgICAvLyBGb3IgZWFjaCBgc2V0YCBhdHRyaWJ1dGUsIHVwZGF0ZSBvciBkZWxldGUgdGhlIGN1cnJlbnQgdmFsdWUuXG4gICAgICBmb3IgKHZhciBhdHRyIGluIGF0dHJzKSB7XG4gICAgICAgIHZhbCA9IGF0dHJzW2F0dHJdO1xuICAgICAgICBpZiAoIV8uaXNFcXVhbChjdXJyZW50W2F0dHJdLCB2YWwpKSBjaGFuZ2VzLnB1c2goYXR0cik7XG4gICAgICAgIGlmICghXy5pc0VxdWFsKHByZXZbYXR0cl0sIHZhbCkpIHtcbiAgICAgICAgICBjaGFuZ2VkW2F0dHJdID0gdmFsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSBjaGFuZ2VkW2F0dHJdO1xuICAgICAgICB9XG4gICAgICAgIHVuc2V0ID8gZGVsZXRlIGN1cnJlbnRbYXR0cl0gOiBjdXJyZW50W2F0dHJdID0gdmFsO1xuICAgICAgfVxuXG4gICAgICAvLyBVcGRhdGUgdGhlIGBpZGAuXG4gICAgICBpZiAodGhpcy5pZEF0dHJpYnV0ZSBpbiBhdHRycykgdGhpcy5pZCA9IHRoaXMuZ2V0KHRoaXMuaWRBdHRyaWJ1dGUpO1xuXG4gICAgICAvLyBUcmlnZ2VyIGFsbCByZWxldmFudCBhdHRyaWJ1dGUgY2hhbmdlcy5cbiAgICAgIGlmICghc2lsZW50KSB7XG4gICAgICAgIGlmIChjaGFuZ2VzLmxlbmd0aCkgdGhpcy5fcGVuZGluZyA9IG9wdGlvbnM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHRoaXMudHJpZ2dlcignY2hhbmdlOicgKyBjaGFuZ2VzW2ldLCB0aGlzLCBjdXJyZW50W2NoYW5nZXNbaV1dLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBZb3UgbWlnaHQgYmUgd29uZGVyaW5nIHdoeSB0aGVyZSdzIGEgYHdoaWxlYCBsb29wIGhlcmUuIENoYW5nZXMgY2FuXG4gICAgICAvLyBiZSByZWN1cnNpdmVseSBuZXN0ZWQgd2l0aGluIGBcImNoYW5nZVwiYCBldmVudHMuXG4gICAgICBpZiAoY2hhbmdpbmcpIHJldHVybiB0aGlzO1xuICAgICAgaWYgKCFzaWxlbnQpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMuX3BlbmRpbmcpIHtcbiAgICAgICAgICBvcHRpb25zID0gdGhpcy5fcGVuZGluZztcbiAgICAgICAgICB0aGlzLl9wZW5kaW5nID0gZmFsc2U7XG4gICAgICAgICAgdGhpcy50cmlnZ2VyKCdjaGFuZ2UnLCB0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5fcGVuZGluZyA9IGZhbHNlO1xuICAgICAgdGhpcy5fY2hhbmdpbmcgPSBmYWxzZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBSZW1vdmUgYW4gYXR0cmlidXRlIGZyb20gdGhlIG1vZGVsLCBmaXJpbmcgYFwiY2hhbmdlXCJgLiBgdW5zZXRgIGlzIGEgbm9vcFxuICAgIC8vIGlmIHRoZSBhdHRyaWJ1dGUgZG9lc24ndCBleGlzdC5cbiAgICB1bnNldDogZnVuY3Rpb24oYXR0ciwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0KGF0dHIsIHZvaWQgMCwgXy5leHRlbmQoe30sIG9wdGlvbnMsIHt1bnNldDogdHJ1ZX0pKTtcbiAgICB9LFxuXG4gICAgLy8gQ2xlYXIgYWxsIGF0dHJpYnV0ZXMgb24gdGhlIG1vZGVsLCBmaXJpbmcgYFwiY2hhbmdlXCJgLlxuICAgIGNsZWFyOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgYXR0cnMgPSB7fTtcbiAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLmF0dHJpYnV0ZXMpIGF0dHJzW2tleV0gPSB2b2lkIDA7XG4gICAgICByZXR1cm4gdGhpcy5zZXQoYXR0cnMsIF8uZXh0ZW5kKHt9LCBvcHRpb25zLCB7dW5zZXQ6IHRydWV9KSk7XG4gICAgfSxcblxuICAgIC8vIERldGVybWluZSBpZiB0aGUgbW9kZWwgaGFzIGNoYW5nZWQgc2luY2UgdGhlIGxhc3QgYFwiY2hhbmdlXCJgIGV2ZW50LlxuICAgIC8vIElmIHlvdSBzcGVjaWZ5IGFuIGF0dHJpYnV0ZSBuYW1lLCBkZXRlcm1pbmUgaWYgdGhhdCBhdHRyaWJ1dGUgaGFzIGNoYW5nZWQuXG4gICAgaGFzQ2hhbmdlZDogZnVuY3Rpb24oYXR0cikge1xuICAgICAgaWYgKGF0dHIgPT0gbnVsbCkgcmV0dXJuICFfLmlzRW1wdHkodGhpcy5jaGFuZ2VkKTtcbiAgICAgIHJldHVybiBfLmhhcyh0aGlzLmNoYW5nZWQsIGF0dHIpO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm4gYW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIHRoZSBhdHRyaWJ1dGVzIHRoYXQgaGF2ZSBjaGFuZ2VkLCBvclxuICAgIC8vIGZhbHNlIGlmIHRoZXJlIGFyZSBubyBjaGFuZ2VkIGF0dHJpYnV0ZXMuIFVzZWZ1bCBmb3IgZGV0ZXJtaW5pbmcgd2hhdFxuICAgIC8vIHBhcnRzIG9mIGEgdmlldyBuZWVkIHRvIGJlIHVwZGF0ZWQgYW5kL29yIHdoYXQgYXR0cmlidXRlcyBuZWVkIHRvIGJlXG4gICAgLy8gcGVyc2lzdGVkIHRvIHRoZSBzZXJ2ZXIuIFVuc2V0IGF0dHJpYnV0ZXMgd2lsbCBiZSBzZXQgdG8gdW5kZWZpbmVkLlxuICAgIC8vIFlvdSBjYW4gYWxzbyBwYXNzIGFuIGF0dHJpYnV0ZXMgb2JqZWN0IHRvIGRpZmYgYWdhaW5zdCB0aGUgbW9kZWwsXG4gICAgLy8gZGV0ZXJtaW5pbmcgaWYgdGhlcmUgKndvdWxkIGJlKiBhIGNoYW5nZS5cbiAgICBjaGFuZ2VkQXR0cmlidXRlczogZnVuY3Rpb24oZGlmZikge1xuICAgICAgaWYgKCFkaWZmKSByZXR1cm4gdGhpcy5oYXNDaGFuZ2VkKCkgPyBfLmNsb25lKHRoaXMuY2hhbmdlZCkgOiBmYWxzZTtcbiAgICAgIHZhciBvbGQgPSB0aGlzLl9jaGFuZ2luZyA/IHRoaXMuX3ByZXZpb3VzQXR0cmlidXRlcyA6IHRoaXMuYXR0cmlidXRlcztcbiAgICAgIHZhciBjaGFuZ2VkID0ge307XG4gICAgICBmb3IgKHZhciBhdHRyIGluIGRpZmYpIHtcbiAgICAgICAgdmFyIHZhbCA9IGRpZmZbYXR0cl07XG4gICAgICAgIGlmIChfLmlzRXF1YWwob2xkW2F0dHJdLCB2YWwpKSBjb250aW51ZTtcbiAgICAgICAgY2hhbmdlZFthdHRyXSA9IHZhbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfLnNpemUoY2hhbmdlZCkgPyBjaGFuZ2VkIDogZmFsc2U7XG4gICAgfSxcblxuICAgIC8vIEdldCB0aGUgcHJldmlvdXMgdmFsdWUgb2YgYW4gYXR0cmlidXRlLCByZWNvcmRlZCBhdCB0aGUgdGltZSB0aGUgbGFzdFxuICAgIC8vIGBcImNoYW5nZVwiYCBldmVudCB3YXMgZmlyZWQuXG4gICAgcHJldmlvdXM6IGZ1bmN0aW9uKGF0dHIpIHtcbiAgICAgIGlmIChhdHRyID09IG51bGwgfHwgIXRoaXMuX3ByZXZpb3VzQXR0cmlidXRlcykgcmV0dXJuIG51bGw7XG4gICAgICByZXR1cm4gdGhpcy5fcHJldmlvdXNBdHRyaWJ1dGVzW2F0dHJdO1xuICAgIH0sXG5cbiAgICAvLyBHZXQgYWxsIG9mIHRoZSBhdHRyaWJ1dGVzIG9mIHRoZSBtb2RlbCBhdCB0aGUgdGltZSBvZiB0aGUgcHJldmlvdXNcbiAgICAvLyBgXCJjaGFuZ2VcImAgZXZlbnQuXG4gICAgcHJldmlvdXNBdHRyaWJ1dGVzOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBfLmNsb25lKHRoaXMuX3ByZXZpb3VzQXR0cmlidXRlcyk7XG4gICAgfSxcblxuICAgIC8vIEZldGNoIHRoZSBtb2RlbCBmcm9tIHRoZSBzZXJ2ZXIsIG1lcmdpbmcgdGhlIHJlc3BvbnNlIHdpdGggdGhlIG1vZGVsJ3NcbiAgICAvLyBsb2NhbCBhdHRyaWJ1dGVzLiBBbnkgY2hhbmdlZCBhdHRyaWJ1dGVzIHdpbGwgdHJpZ2dlciBhIFwiY2hhbmdlXCIgZXZlbnQuXG4gICAgZmV0Y2g6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBfLmV4dGVuZCh7cGFyc2U6IHRydWV9LCBvcHRpb25zKTtcbiAgICAgIHZhciBtb2RlbCA9IHRoaXM7XG4gICAgICB2YXIgc3VjY2VzcyA9IG9wdGlvbnMuc3VjY2VzcztcbiAgICAgIG9wdGlvbnMuc3VjY2VzcyA9IGZ1bmN0aW9uKHJlc3ApIHtcbiAgICAgICAgdmFyIHNlcnZlckF0dHJzID0gb3B0aW9ucy5wYXJzZSA/IG1vZGVsLnBhcnNlKHJlc3AsIG9wdGlvbnMpIDogcmVzcDtcbiAgICAgICAgaWYgKCFtb2RlbC5zZXQoc2VydmVyQXR0cnMsIG9wdGlvbnMpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChzdWNjZXNzKSBzdWNjZXNzLmNhbGwob3B0aW9ucy5jb250ZXh0LCBtb2RlbCwgcmVzcCwgb3B0aW9ucyk7XG4gICAgICAgIG1vZGVsLnRyaWdnZXIoJ3N5bmMnLCBtb2RlbCwgcmVzcCwgb3B0aW9ucyk7XG4gICAgICB9O1xuICAgICAgd3JhcEVycm9yKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHRoaXMuc3luYygncmVhZCcsIHRoaXMsIG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvLyBTZXQgYSBoYXNoIG9mIG1vZGVsIGF0dHJpYnV0ZXMsIGFuZCBzeW5jIHRoZSBtb2RlbCB0byB0aGUgc2VydmVyLlxuICAgIC8vIElmIHRoZSBzZXJ2ZXIgcmV0dXJucyBhbiBhdHRyaWJ1dGVzIGhhc2ggdGhhdCBkaWZmZXJzLCB0aGUgbW9kZWwnc1xuICAgIC8vIHN0YXRlIHdpbGwgYmUgYHNldGAgYWdhaW4uXG4gICAgc2F2ZTogZnVuY3Rpb24oa2V5LCB2YWwsIG9wdGlvbnMpIHtcbiAgICAgIC8vIEhhbmRsZSBib3RoIGBcImtleVwiLCB2YWx1ZWAgYW5kIGB7a2V5OiB2YWx1ZX1gIC1zdHlsZSBhcmd1bWVudHMuXG4gICAgICB2YXIgYXR0cnM7XG4gICAgICBpZiAoa2V5ID09IG51bGwgfHwgdHlwZW9mIGtleSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgYXR0cnMgPSBrZXk7XG4gICAgICAgIG9wdGlvbnMgPSB2YWw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAoYXR0cnMgPSB7fSlba2V5XSA9IHZhbDtcbiAgICAgIH1cblxuICAgICAgb3B0aW9ucyA9IF8uZXh0ZW5kKHt2YWxpZGF0ZTogdHJ1ZSwgcGFyc2U6IHRydWV9LCBvcHRpb25zKTtcbiAgICAgIHZhciB3YWl0ID0gb3B0aW9ucy53YWl0O1xuXG4gICAgICAvLyBJZiB3ZSdyZSBub3Qgd2FpdGluZyBhbmQgYXR0cmlidXRlcyBleGlzdCwgc2F2ZSBhY3RzIGFzXG4gICAgICAvLyBgc2V0KGF0dHIpLnNhdmUobnVsbCwgb3B0cylgIHdpdGggdmFsaWRhdGlvbi4gT3RoZXJ3aXNlLCBjaGVjayBpZlxuICAgICAgLy8gdGhlIG1vZGVsIHdpbGwgYmUgdmFsaWQgd2hlbiB0aGUgYXR0cmlidXRlcywgaWYgYW55LCBhcmUgc2V0LlxuICAgICAgaWYgKGF0dHJzICYmICF3YWl0KSB7XG4gICAgICAgIGlmICghdGhpcy5zZXQoYXR0cnMsIG9wdGlvbnMpKSByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKCF0aGlzLl92YWxpZGF0ZShhdHRycywgb3B0aW9ucykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvLyBBZnRlciBhIHN1Y2Nlc3NmdWwgc2VydmVyLXNpZGUgc2F2ZSwgdGhlIGNsaWVudCBpcyAob3B0aW9uYWxseSlcbiAgICAgIC8vIHVwZGF0ZWQgd2l0aCB0aGUgc2VydmVyLXNpZGUgc3RhdGUuXG4gICAgICB2YXIgbW9kZWwgPSB0aGlzO1xuICAgICAgdmFyIHN1Y2Nlc3MgPSBvcHRpb25zLnN1Y2Nlc3M7XG4gICAgICB2YXIgYXR0cmlidXRlcyA9IHRoaXMuYXR0cmlidXRlcztcbiAgICAgIG9wdGlvbnMuc3VjY2VzcyA9IGZ1bmN0aW9uKHJlc3ApIHtcbiAgICAgICAgLy8gRW5zdXJlIGF0dHJpYnV0ZXMgYXJlIHJlc3RvcmVkIGR1cmluZyBzeW5jaHJvbm91cyBzYXZlcy5cbiAgICAgICAgbW9kZWwuYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXM7XG4gICAgICAgIHZhciBzZXJ2ZXJBdHRycyA9IG9wdGlvbnMucGFyc2UgPyBtb2RlbC5wYXJzZShyZXNwLCBvcHRpb25zKSA6IHJlc3A7XG4gICAgICAgIGlmICh3YWl0KSBzZXJ2ZXJBdHRycyA9IF8uZXh0ZW5kKHt9LCBhdHRycywgc2VydmVyQXR0cnMpO1xuICAgICAgICBpZiAoc2VydmVyQXR0cnMgJiYgIW1vZGVsLnNldChzZXJ2ZXJBdHRycywgb3B0aW9ucykpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHN1Y2Nlc3MpIHN1Y2Nlc3MuY2FsbChvcHRpb25zLmNvbnRleHQsIG1vZGVsLCByZXNwLCBvcHRpb25zKTtcbiAgICAgICAgbW9kZWwudHJpZ2dlcignc3luYycsIG1vZGVsLCByZXNwLCBvcHRpb25zKTtcbiAgICAgIH07XG4gICAgICB3cmFwRXJyb3IodGhpcywgb3B0aW9ucyk7XG5cbiAgICAgIC8vIFNldCB0ZW1wb3JhcnkgYXR0cmlidXRlcyBpZiBge3dhaXQ6IHRydWV9YCB0byBwcm9wZXJseSBmaW5kIG5ldyBpZHMuXG4gICAgICBpZiAoYXR0cnMgJiYgd2FpdCkgdGhpcy5hdHRyaWJ1dGVzID0gXy5leHRlbmQoe30sIGF0dHJpYnV0ZXMsIGF0dHJzKTtcblxuICAgICAgdmFyIG1ldGhvZCA9IHRoaXMuaXNOZXcoKSA/ICdjcmVhdGUnIDogKG9wdGlvbnMucGF0Y2ggPyAncGF0Y2gnIDogJ3VwZGF0ZScpO1xuICAgICAgaWYgKG1ldGhvZCA9PT0gJ3BhdGNoJyAmJiAhb3B0aW9ucy5hdHRycykgb3B0aW9ucy5hdHRycyA9IGF0dHJzO1xuICAgICAgdmFyIHhociA9IHRoaXMuc3luYyhtZXRob2QsIHRoaXMsIG9wdGlvbnMpO1xuXG4gICAgICAvLyBSZXN0b3JlIGF0dHJpYnV0ZXMuXG4gICAgICB0aGlzLmF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzO1xuXG4gICAgICByZXR1cm4geGhyO1xuICAgIH0sXG5cbiAgICAvLyBEZXN0cm95IHRoaXMgbW9kZWwgb24gdGhlIHNlcnZlciBpZiBpdCB3YXMgYWxyZWFkeSBwZXJzaXN0ZWQuXG4gICAgLy8gT3B0aW1pc3RpY2FsbHkgcmVtb3ZlcyB0aGUgbW9kZWwgZnJvbSBpdHMgY29sbGVjdGlvbiwgaWYgaXQgaGFzIG9uZS5cbiAgICAvLyBJZiBgd2FpdDogdHJ1ZWAgaXMgcGFzc2VkLCB3YWl0cyBmb3IgdGhlIHNlcnZlciB0byByZXNwb25kIGJlZm9yZSByZW1vdmFsLlxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zID8gXy5jbG9uZShvcHRpb25zKSA6IHt9O1xuICAgICAgdmFyIG1vZGVsID0gdGhpcztcbiAgICAgIHZhciBzdWNjZXNzID0gb3B0aW9ucy5zdWNjZXNzO1xuICAgICAgdmFyIHdhaXQgPSBvcHRpb25zLndhaXQ7XG5cbiAgICAgIHZhciBkZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIG1vZGVsLnN0b3BMaXN0ZW5pbmcoKTtcbiAgICAgICAgbW9kZWwudHJpZ2dlcignZGVzdHJveScsIG1vZGVsLCBtb2RlbC5jb2xsZWN0aW9uLCBvcHRpb25zKTtcbiAgICAgIH07XG5cbiAgICAgIG9wdGlvbnMuc3VjY2VzcyA9IGZ1bmN0aW9uKHJlc3ApIHtcbiAgICAgICAgaWYgKHdhaXQpIGRlc3Ryb3koKTtcbiAgICAgICAgaWYgKHN1Y2Nlc3MpIHN1Y2Nlc3MuY2FsbChvcHRpb25zLmNvbnRleHQsIG1vZGVsLCByZXNwLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKCFtb2RlbC5pc05ldygpKSBtb2RlbC50cmlnZ2VyKCdzeW5jJywgbW9kZWwsIHJlc3AsIG9wdGlvbnMpO1xuICAgICAgfTtcblxuICAgICAgdmFyIHhociA9IGZhbHNlO1xuICAgICAgaWYgKHRoaXMuaXNOZXcoKSkge1xuICAgICAgICBfLmRlZmVyKG9wdGlvbnMuc3VjY2Vzcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3cmFwRXJyb3IodGhpcywgb3B0aW9ucyk7XG4gICAgICAgIHhociA9IHRoaXMuc3luYygnZGVsZXRlJywgdGhpcywgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBpZiAoIXdhaXQpIGRlc3Ryb3koKTtcbiAgICAgIHJldHVybiB4aHI7XG4gICAgfSxcblxuICAgIC8vIERlZmF1bHQgVVJMIGZvciB0aGUgbW9kZWwncyByZXByZXNlbnRhdGlvbiBvbiB0aGUgc2VydmVyIC0tIGlmIHlvdSdyZVxuICAgIC8vIHVzaW5nIEJhY2tib25lJ3MgcmVzdGZ1bCBtZXRob2RzLCBvdmVycmlkZSB0aGlzIHRvIGNoYW5nZSB0aGUgZW5kcG9pbnRcbiAgICAvLyB0aGF0IHdpbGwgYmUgY2FsbGVkLlxuICAgIHVybDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYmFzZSA9XG4gICAgICAgIF8ucmVzdWx0KHRoaXMsICd1cmxSb290JykgfHxcbiAgICAgICAgXy5yZXN1bHQodGhpcy5jb2xsZWN0aW9uLCAndXJsJykgfHxcbiAgICAgICAgdXJsRXJyb3IoKTtcbiAgICAgIGlmICh0aGlzLmlzTmV3KCkpIHJldHVybiBiYXNlO1xuICAgICAgdmFyIGlkID0gdGhpcy5nZXQodGhpcy5pZEF0dHJpYnV0ZSk7XG4gICAgICByZXR1cm4gYmFzZS5yZXBsYWNlKC9bXlxcL10kLywgJyQmLycpICsgZW5jb2RlVVJJQ29tcG9uZW50KGlkKTtcbiAgICB9LFxuXG4gICAgLy8gKipwYXJzZSoqIGNvbnZlcnRzIGEgcmVzcG9uc2UgaW50byB0aGUgaGFzaCBvZiBhdHRyaWJ1dGVzIHRvIGJlIGBzZXRgIG9uXG4gICAgLy8gdGhlIG1vZGVsLiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBpcyBqdXN0IHRvIHBhc3MgdGhlIHJlc3BvbnNlIGFsb25nLlxuICAgIHBhcnNlOiBmdW5jdGlvbihyZXNwLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gcmVzcDtcbiAgICB9LFxuXG4gICAgLy8gQ3JlYXRlIGEgbmV3IG1vZGVsIHdpdGggaWRlbnRpY2FsIGF0dHJpYnV0ZXMgdG8gdGhpcyBvbmUuXG4gICAgY2xvbmU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMuYXR0cmlidXRlcyk7XG4gICAgfSxcblxuICAgIC8vIEEgbW9kZWwgaXMgbmV3IGlmIGl0IGhhcyBuZXZlciBiZWVuIHNhdmVkIHRvIHRoZSBzZXJ2ZXIsIGFuZCBsYWNrcyBhbiBpZC5cbiAgICBpc05ldzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gIXRoaXMuaGFzKHRoaXMuaWRBdHRyaWJ1dGUpO1xuICAgIH0sXG5cbiAgICAvLyBDaGVjayBpZiB0aGUgbW9kZWwgaXMgY3VycmVudGx5IGluIGEgdmFsaWQgc3RhdGUuXG4gICAgaXNWYWxpZDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRoaXMuX3ZhbGlkYXRlKHt9LCBfLmV4dGVuZCh7fSwgb3B0aW9ucywge3ZhbGlkYXRlOiB0cnVlfSkpO1xuICAgIH0sXG5cbiAgICAvLyBSdW4gdmFsaWRhdGlvbiBhZ2FpbnN0IHRoZSBuZXh0IGNvbXBsZXRlIHNldCBvZiBtb2RlbCBhdHRyaWJ1dGVzLFxuICAgIC8vIHJldHVybmluZyBgdHJ1ZWAgaWYgYWxsIGlzIHdlbGwuIE90aGVyd2lzZSwgZmlyZSBhbiBgXCJpbnZhbGlkXCJgIGV2ZW50LlxuICAgIF92YWxpZGF0ZTogZnVuY3Rpb24oYXR0cnMsIG9wdGlvbnMpIHtcbiAgICAgIGlmICghb3B0aW9ucy52YWxpZGF0ZSB8fCAhdGhpcy52YWxpZGF0ZSkgcmV0dXJuIHRydWU7XG4gICAgICBhdHRycyA9IF8uZXh0ZW5kKHt9LCB0aGlzLmF0dHJpYnV0ZXMsIGF0dHJzKTtcbiAgICAgIHZhciBlcnJvciA9IHRoaXMudmFsaWRhdGlvbkVycm9yID0gdGhpcy52YWxpZGF0ZShhdHRycywgb3B0aW9ucykgfHwgbnVsbDtcbiAgICAgIGlmICghZXJyb3IpIHJldHVybiB0cnVlO1xuICAgICAgdGhpcy50cmlnZ2VyKCdpbnZhbGlkJywgdGhpcywgZXJyb3IsIF8uZXh0ZW5kKG9wdGlvbnMsIHt2YWxpZGF0aW9uRXJyb3I6IGVycm9yfSkpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICB9KTtcblxuICAvLyBVbmRlcnNjb3JlIG1ldGhvZHMgdGhhdCB3ZSB3YW50IHRvIGltcGxlbWVudCBvbiB0aGUgTW9kZWwsIG1hcHBlZCB0byB0aGVcbiAgLy8gbnVtYmVyIG9mIGFyZ3VtZW50cyB0aGV5IHRha2UuXG4gIHZhciBtb2RlbE1ldGhvZHMgPSB7a2V5czogMSwgdmFsdWVzOiAxLCBwYWlyczogMSwgaW52ZXJ0OiAxLCBwaWNrOiAwLFxuICAgICAgb21pdDogMCwgY2hhaW46IDEsIGlzRW1wdHk6IDF9O1xuXG4gIC8vIE1peCBpbiBlYWNoIFVuZGVyc2NvcmUgbWV0aG9kIGFzIGEgcHJveHkgdG8gYE1vZGVsI2F0dHJpYnV0ZXNgLlxuICBhZGRVbmRlcnNjb3JlTWV0aG9kcyhNb2RlbCwgbW9kZWxNZXRob2RzLCAnYXR0cmlidXRlcycpO1xuXG4gIC8vIEJhY2tib25lLkNvbGxlY3Rpb25cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIElmIG1vZGVscyB0ZW5kIHRvIHJlcHJlc2VudCBhIHNpbmdsZSByb3cgb2YgZGF0YSwgYSBCYWNrYm9uZSBDb2xsZWN0aW9uIGlzXG4gIC8vIG1vcmUgYW5hbG9nb3VzIHRvIGEgdGFibGUgZnVsbCBvZiBkYXRhIC4uLiBvciBhIHNtYWxsIHNsaWNlIG9yIHBhZ2Ugb2YgdGhhdFxuICAvLyB0YWJsZSwgb3IgYSBjb2xsZWN0aW9uIG9mIHJvd3MgdGhhdCBiZWxvbmcgdG9nZXRoZXIgZm9yIGEgcGFydGljdWxhciByZWFzb25cbiAgLy8gLS0gYWxsIG9mIHRoZSBtZXNzYWdlcyBpbiB0aGlzIHBhcnRpY3VsYXIgZm9sZGVyLCBhbGwgb2YgdGhlIGRvY3VtZW50c1xuICAvLyBiZWxvbmdpbmcgdG8gdGhpcyBwYXJ0aWN1bGFyIGF1dGhvciwgYW5kIHNvIG9uLiBDb2xsZWN0aW9ucyBtYWludGFpblxuICAvLyBpbmRleGVzIG9mIHRoZWlyIG1vZGVscywgYm90aCBpbiBvcmRlciwgYW5kIGZvciBsb29rdXAgYnkgYGlkYC5cblxuICAvLyBDcmVhdGUgYSBuZXcgKipDb2xsZWN0aW9uKiosIHBlcmhhcHMgdG8gY29udGFpbiBhIHNwZWNpZmljIHR5cGUgb2YgYG1vZGVsYC5cbiAgLy8gSWYgYSBgY29tcGFyYXRvcmAgaXMgc3BlY2lmaWVkLCB0aGUgQ29sbGVjdGlvbiB3aWxsIG1haW50YWluXG4gIC8vIGl0cyBtb2RlbHMgaW4gc29ydCBvcmRlciwgYXMgdGhleSdyZSBhZGRlZCBhbmQgcmVtb3ZlZC5cbiAgdmFyIENvbGxlY3Rpb24gPSBCYWNrYm9uZS5Db2xsZWN0aW9uID0gZnVuY3Rpb24obW9kZWxzLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHt9KTtcbiAgICBpZiAob3B0aW9ucy5tb2RlbCkgdGhpcy5tb2RlbCA9IG9wdGlvbnMubW9kZWw7XG4gICAgaWYgKG9wdGlvbnMuY29tcGFyYXRvciAhPT0gdm9pZCAwKSB0aGlzLmNvbXBhcmF0b3IgPSBvcHRpb25zLmNvbXBhcmF0b3I7XG4gICAgdGhpcy5fcmVzZXQoKTtcbiAgICB0aGlzLmluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAobW9kZWxzKSB0aGlzLnJlc2V0KG1vZGVscywgXy5leHRlbmQoe3NpbGVudDogdHJ1ZX0sIG9wdGlvbnMpKTtcbiAgfTtcblxuICAvLyBEZWZhdWx0IG9wdGlvbnMgZm9yIGBDb2xsZWN0aW9uI3NldGAuXG4gIHZhciBzZXRPcHRpb25zID0ge2FkZDogdHJ1ZSwgcmVtb3ZlOiB0cnVlLCBtZXJnZTogdHJ1ZX07XG4gIHZhciBhZGRPcHRpb25zID0ge2FkZDogdHJ1ZSwgcmVtb3ZlOiBmYWxzZX07XG5cbiAgLy8gU3BsaWNlcyBgaW5zZXJ0YCBpbnRvIGBhcnJheWAgYXQgaW5kZXggYGF0YC5cbiAgdmFyIHNwbGljZSA9IGZ1bmN0aW9uKGFycmF5LCBpbnNlcnQsIGF0KSB7XG4gICAgYXQgPSBNYXRoLm1pbihNYXRoLm1heChhdCwgMCksIGFycmF5Lmxlbmd0aCk7XG4gICAgdmFyIHRhaWwgPSBBcnJheShhcnJheS5sZW5ndGggLSBhdCk7XG4gICAgdmFyIGxlbmd0aCA9IGluc2VydC5sZW5ndGg7XG4gICAgdmFyIGk7XG4gICAgZm9yIChpID0gMDsgaSA8IHRhaWwubGVuZ3RoOyBpKyspIHRhaWxbaV0gPSBhcnJheVtpICsgYXRdO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykgYXJyYXlbaSArIGF0XSA9IGluc2VydFtpXTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdGFpbC5sZW5ndGg7IGkrKykgYXJyYXlbaSArIGxlbmd0aCArIGF0XSA9IHRhaWxbaV07XG4gIH07XG5cbiAgLy8gRGVmaW5lIHRoZSBDb2xsZWN0aW9uJ3MgaW5oZXJpdGFibGUgbWV0aG9kcy5cbiAgXy5leHRlbmQoQ29sbGVjdGlvbi5wcm90b3R5cGUsIEV2ZW50cywge1xuXG4gICAgLy8gVGhlIGRlZmF1bHQgbW9kZWwgZm9yIGEgY29sbGVjdGlvbiBpcyBqdXN0IGEgKipCYWNrYm9uZS5Nb2RlbCoqLlxuICAgIC8vIFRoaXMgc2hvdWxkIGJlIG92ZXJyaWRkZW4gaW4gbW9zdCBjYXNlcy5cbiAgICBtb2RlbDogTW9kZWwsXG5cbiAgICAvLyBJbml0aWFsaXplIGlzIGFuIGVtcHR5IGZ1bmN0aW9uIGJ5IGRlZmF1bHQuIE92ZXJyaWRlIGl0IHdpdGggeW91ciBvd25cbiAgICAvLyBpbml0aWFsaXphdGlvbiBsb2dpYy5cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbigpe30sXG5cbiAgICAvLyBUaGUgSlNPTiByZXByZXNlbnRhdGlvbiBvZiBhIENvbGxlY3Rpb24gaXMgYW4gYXJyYXkgb2YgdGhlXG4gICAgLy8gbW9kZWxzJyBhdHRyaWJ1dGVzLlxuICAgIHRvSlNPTjogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKG1vZGVsKSB7IHJldHVybiBtb2RlbC50b0pTT04ob3B0aW9ucyk7IH0pO1xuICAgIH0sXG5cbiAgICAvLyBQcm94eSBgQmFja2JvbmUuc3luY2AgYnkgZGVmYXVsdC5cbiAgICBzeW5jOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBCYWNrYm9uZS5zeW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSxcblxuICAgIC8vIEFkZCBhIG1vZGVsLCBvciBsaXN0IG9mIG1vZGVscyB0byB0aGUgc2V0LiBgbW9kZWxzYCBtYXkgYmUgQmFja2JvbmVcbiAgICAvLyBNb2RlbHMgb3IgcmF3IEphdmFTY3JpcHQgb2JqZWN0cyB0byBiZSBjb252ZXJ0ZWQgdG8gTW9kZWxzLCBvciBhbnlcbiAgICAvLyBjb21iaW5hdGlvbiBvZiB0aGUgdHdvLlxuICAgIGFkZDogZnVuY3Rpb24obW9kZWxzLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXQobW9kZWxzLCBfLmV4dGVuZCh7bWVyZ2U6IGZhbHNlfSwgb3B0aW9ucywgYWRkT3B0aW9ucykpO1xuICAgIH0sXG5cbiAgICAvLyBSZW1vdmUgYSBtb2RlbCwgb3IgYSBsaXN0IG9mIG1vZGVscyBmcm9tIHRoZSBzZXQuXG4gICAgcmVtb3ZlOiBmdW5jdGlvbihtb2RlbHMsIG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBfLmV4dGVuZCh7fSwgb3B0aW9ucyk7XG4gICAgICB2YXIgc2luZ3VsYXIgPSAhXy5pc0FycmF5KG1vZGVscyk7XG4gICAgICBtb2RlbHMgPSBzaW5ndWxhciA/IFttb2RlbHNdIDogbW9kZWxzLnNsaWNlKCk7XG4gICAgICB2YXIgcmVtb3ZlZCA9IHRoaXMuX3JlbW92ZU1vZGVscyhtb2RlbHMsIG9wdGlvbnMpO1xuICAgICAgaWYgKCFvcHRpb25zLnNpbGVudCAmJiByZW1vdmVkLmxlbmd0aCkge1xuICAgICAgICBvcHRpb25zLmNoYW5nZXMgPSB7YWRkZWQ6IFtdLCBtZXJnZWQ6IFtdLCByZW1vdmVkOiByZW1vdmVkfTtcbiAgICAgICAgdGhpcy50cmlnZ2VyKCd1cGRhdGUnLCB0aGlzLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzaW5ndWxhciA/IHJlbW92ZWRbMF0gOiByZW1vdmVkO1xuICAgIH0sXG5cbiAgICAvLyBVcGRhdGUgYSBjb2xsZWN0aW9uIGJ5IGBzZXRgLWluZyBhIG5ldyBsaXN0IG9mIG1vZGVscywgYWRkaW5nIG5ldyBvbmVzLFxuICAgIC8vIHJlbW92aW5nIG1vZGVscyB0aGF0IGFyZSBubyBsb25nZXIgcHJlc2VudCwgYW5kIG1lcmdpbmcgbW9kZWxzIHRoYXRcbiAgICAvLyBhbHJlYWR5IGV4aXN0IGluIHRoZSBjb2xsZWN0aW9uLCBhcyBuZWNlc3NhcnkuIFNpbWlsYXIgdG8gKipNb2RlbCNzZXQqKixcbiAgICAvLyB0aGUgY29yZSBvcGVyYXRpb24gZm9yIHVwZGF0aW5nIHRoZSBkYXRhIGNvbnRhaW5lZCBieSB0aGUgY29sbGVjdGlvbi5cbiAgICBzZXQ6IGZ1bmN0aW9uKG1vZGVscywgb3B0aW9ucykge1xuICAgICAgaWYgKG1vZGVscyA9PSBudWxsKSByZXR1cm47XG5cbiAgICAgIG9wdGlvbnMgPSBfLmV4dGVuZCh7fSwgc2V0T3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICBpZiAob3B0aW9ucy5wYXJzZSAmJiAhdGhpcy5faXNNb2RlbChtb2RlbHMpKSB7XG4gICAgICAgIG1vZGVscyA9IHRoaXMucGFyc2UobW9kZWxzLCBvcHRpb25zKSB8fCBbXTtcbiAgICAgIH1cblxuICAgICAgdmFyIHNpbmd1bGFyID0gIV8uaXNBcnJheShtb2RlbHMpO1xuICAgICAgbW9kZWxzID0gc2luZ3VsYXIgPyBbbW9kZWxzXSA6IG1vZGVscy5zbGljZSgpO1xuXG4gICAgICB2YXIgYXQgPSBvcHRpb25zLmF0O1xuICAgICAgaWYgKGF0ICE9IG51bGwpIGF0ID0gK2F0O1xuICAgICAgaWYgKGF0ID4gdGhpcy5sZW5ndGgpIGF0ID0gdGhpcy5sZW5ndGg7XG4gICAgICBpZiAoYXQgPCAwKSBhdCArPSB0aGlzLmxlbmd0aCArIDE7XG5cbiAgICAgIHZhciBzZXQgPSBbXTtcbiAgICAgIHZhciB0b0FkZCA9IFtdO1xuICAgICAgdmFyIHRvTWVyZ2UgPSBbXTtcbiAgICAgIHZhciB0b1JlbW92ZSA9IFtdO1xuICAgICAgdmFyIG1vZGVsTWFwID0ge307XG5cbiAgICAgIHZhciBhZGQgPSBvcHRpb25zLmFkZDtcbiAgICAgIHZhciBtZXJnZSA9IG9wdGlvbnMubWVyZ2U7XG4gICAgICB2YXIgcmVtb3ZlID0gb3B0aW9ucy5yZW1vdmU7XG5cbiAgICAgIHZhciBzb3J0ID0gZmFsc2U7XG4gICAgICB2YXIgc29ydGFibGUgPSB0aGlzLmNvbXBhcmF0b3IgJiYgYXQgPT0gbnVsbCAmJiBvcHRpb25zLnNvcnQgIT09IGZhbHNlO1xuICAgICAgdmFyIHNvcnRBdHRyID0gXy5pc1N0cmluZyh0aGlzLmNvbXBhcmF0b3IpID8gdGhpcy5jb21wYXJhdG9yIDogbnVsbDtcblxuICAgICAgLy8gVHVybiBiYXJlIG9iamVjdHMgaW50byBtb2RlbCByZWZlcmVuY2VzLCBhbmQgcHJldmVudCBpbnZhbGlkIG1vZGVsc1xuICAgICAgLy8gZnJvbSBiZWluZyBhZGRlZC5cbiAgICAgIHZhciBtb2RlbCwgaTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBtb2RlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbW9kZWwgPSBtb2RlbHNbaV07XG5cbiAgICAgICAgLy8gSWYgYSBkdXBsaWNhdGUgaXMgZm91bmQsIHByZXZlbnQgaXQgZnJvbSBiZWluZyBhZGRlZCBhbmRcbiAgICAgICAgLy8gb3B0aW9uYWxseSBtZXJnZSBpdCBpbnRvIHRoZSBleGlzdGluZyBtb2RlbC5cbiAgICAgICAgdmFyIGV4aXN0aW5nID0gdGhpcy5nZXQobW9kZWwpO1xuICAgICAgICBpZiAoZXhpc3RpbmcpIHtcbiAgICAgICAgICBpZiAobWVyZ2UgJiYgbW9kZWwgIT09IGV4aXN0aW5nKSB7XG4gICAgICAgICAgICB2YXIgYXR0cnMgPSB0aGlzLl9pc01vZGVsKG1vZGVsKSA/IG1vZGVsLmF0dHJpYnV0ZXMgOiBtb2RlbDtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnBhcnNlKSBhdHRycyA9IGV4aXN0aW5nLnBhcnNlKGF0dHJzLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGV4aXN0aW5nLnNldChhdHRycywgb3B0aW9ucyk7XG4gICAgICAgICAgICB0b01lcmdlLnB1c2goZXhpc3RpbmcpO1xuICAgICAgICAgICAgaWYgKHNvcnRhYmxlICYmICFzb3J0KSBzb3J0ID0gZXhpc3RpbmcuaGFzQ2hhbmdlZChzb3J0QXR0cik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghbW9kZWxNYXBbZXhpc3RpbmcuY2lkXSkge1xuICAgICAgICAgICAgbW9kZWxNYXBbZXhpc3RpbmcuY2lkXSA9IHRydWU7XG4gICAgICAgICAgICBzZXQucHVzaChleGlzdGluZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG1vZGVsc1tpXSA9IGV4aXN0aW5nO1xuXG4gICAgICAgIC8vIElmIHRoaXMgaXMgYSBuZXcsIHZhbGlkIG1vZGVsLCBwdXNoIGl0IHRvIHRoZSBgdG9BZGRgIGxpc3QuXG4gICAgICAgIH0gZWxzZSBpZiAoYWRkKSB7XG4gICAgICAgICAgbW9kZWwgPSBtb2RlbHNbaV0gPSB0aGlzLl9wcmVwYXJlTW9kZWwobW9kZWwsIG9wdGlvbnMpO1xuICAgICAgICAgIGlmIChtb2RlbCkge1xuICAgICAgICAgICAgdG9BZGQucHVzaChtb2RlbCk7XG4gICAgICAgICAgICB0aGlzLl9hZGRSZWZlcmVuY2UobW9kZWwsIG9wdGlvbnMpO1xuICAgICAgICAgICAgbW9kZWxNYXBbbW9kZWwuY2lkXSA9IHRydWU7XG4gICAgICAgICAgICBzZXQucHVzaChtb2RlbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFJlbW92ZSBzdGFsZSBtb2RlbHMuXG4gICAgICBpZiAocmVtb3ZlKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgbW9kZWwgPSB0aGlzLm1vZGVsc1tpXTtcbiAgICAgICAgICBpZiAoIW1vZGVsTWFwW21vZGVsLmNpZF0pIHRvUmVtb3ZlLnB1c2gobW9kZWwpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b1JlbW92ZS5sZW5ndGgpIHRoaXMuX3JlbW92ZU1vZGVscyh0b1JlbW92ZSwgb3B0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIC8vIFNlZSBpZiBzb3J0aW5nIGlzIG5lZWRlZCwgdXBkYXRlIGBsZW5ndGhgIGFuZCBzcGxpY2UgaW4gbmV3IG1vZGVscy5cbiAgICAgIHZhciBvcmRlckNoYW5nZWQgPSBmYWxzZTtcbiAgICAgIHZhciByZXBsYWNlID0gIXNvcnRhYmxlICYmIGFkZCAmJiByZW1vdmU7XG4gICAgICBpZiAoc2V0Lmxlbmd0aCAmJiByZXBsYWNlKSB7XG4gICAgICAgIG9yZGVyQ2hhbmdlZCA9IHRoaXMubGVuZ3RoICE9PSBzZXQubGVuZ3RoIHx8IF8uc29tZSh0aGlzLm1vZGVscywgZnVuY3Rpb24obSwgaW5kZXgpIHtcbiAgICAgICAgICByZXR1cm4gbSAhPT0gc2V0W2luZGV4XTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubW9kZWxzLmxlbmd0aCA9IDA7XG4gICAgICAgIHNwbGljZSh0aGlzLm1vZGVscywgc2V0LCAwKTtcbiAgICAgICAgdGhpcy5sZW5ndGggPSB0aGlzLm1vZGVscy5sZW5ndGg7XG4gICAgICB9IGVsc2UgaWYgKHRvQWRkLmxlbmd0aCkge1xuICAgICAgICBpZiAoc29ydGFibGUpIHNvcnQgPSB0cnVlO1xuICAgICAgICBzcGxpY2UodGhpcy5tb2RlbHMsIHRvQWRkLCBhdCA9PSBudWxsID8gdGhpcy5sZW5ndGggOiBhdCk7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gdGhpcy5tb2RlbHMubGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICAvLyBTaWxlbnRseSBzb3J0IHRoZSBjb2xsZWN0aW9uIGlmIGFwcHJvcHJpYXRlLlxuICAgICAgaWYgKHNvcnQpIHRoaXMuc29ydCh7c2lsZW50OiB0cnVlfSk7XG5cbiAgICAgIC8vIFVubGVzcyBzaWxlbmNlZCwgaXQncyB0aW1lIHRvIGZpcmUgYWxsIGFwcHJvcHJpYXRlIGFkZC9zb3J0L3VwZGF0ZSBldmVudHMuXG4gICAgICBpZiAoIW9wdGlvbnMuc2lsZW50KSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0b0FkZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChhdCAhPSBudWxsKSBvcHRpb25zLmluZGV4ID0gYXQgKyBpO1xuICAgICAgICAgIG1vZGVsID0gdG9BZGRbaV07XG4gICAgICAgICAgbW9kZWwudHJpZ2dlcignYWRkJywgbW9kZWwsIHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzb3J0IHx8IG9yZGVyQ2hhbmdlZCkgdGhpcy50cmlnZ2VyKCdzb3J0JywgdGhpcywgb3B0aW9ucyk7XG4gICAgICAgIGlmICh0b0FkZC5sZW5ndGggfHwgdG9SZW1vdmUubGVuZ3RoIHx8IHRvTWVyZ2UubGVuZ3RoKSB7XG4gICAgICAgICAgb3B0aW9ucy5jaGFuZ2VzID0ge1xuICAgICAgICAgICAgYWRkZWQ6IHRvQWRkLFxuICAgICAgICAgICAgcmVtb3ZlZDogdG9SZW1vdmUsXG4gICAgICAgICAgICBtZXJnZWQ6IHRvTWVyZ2VcbiAgICAgICAgICB9O1xuICAgICAgICAgIHRoaXMudHJpZ2dlcigndXBkYXRlJywgdGhpcywgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gUmV0dXJuIHRoZSBhZGRlZCAob3IgbWVyZ2VkKSBtb2RlbCAob3IgbW9kZWxzKS5cbiAgICAgIHJldHVybiBzaW5ndWxhciA/IG1vZGVsc1swXSA6IG1vZGVscztcbiAgICB9LFxuXG4gICAgLy8gV2hlbiB5b3UgaGF2ZSBtb3JlIGl0ZW1zIHRoYW4geW91IHdhbnQgdG8gYWRkIG9yIHJlbW92ZSBpbmRpdmlkdWFsbHksXG4gICAgLy8geW91IGNhbiByZXNldCB0aGUgZW50aXJlIHNldCB3aXRoIGEgbmV3IGxpc3Qgb2YgbW9kZWxzLCB3aXRob3V0IGZpcmluZ1xuICAgIC8vIGFueSBncmFudWxhciBgYWRkYCBvciBgcmVtb3ZlYCBldmVudHMuIEZpcmVzIGByZXNldGAgd2hlbiBmaW5pc2hlZC5cbiAgICAvLyBVc2VmdWwgZm9yIGJ1bGsgb3BlcmF0aW9ucyBhbmQgb3B0aW1pemF0aW9ucy5cbiAgICByZXNldDogZnVuY3Rpb24obW9kZWxzLCBvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyA/IF8uY2xvbmUob3B0aW9ucykgOiB7fTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tb2RlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5fcmVtb3ZlUmVmZXJlbmNlKHRoaXMubW9kZWxzW2ldLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIG9wdGlvbnMucHJldmlvdXNNb2RlbHMgPSB0aGlzLm1vZGVscztcbiAgICAgIHRoaXMuX3Jlc2V0KCk7XG4gICAgICBtb2RlbHMgPSB0aGlzLmFkZChtb2RlbHMsIF8uZXh0ZW5kKHtzaWxlbnQ6IHRydWV9LCBvcHRpb25zKSk7XG4gICAgICBpZiAoIW9wdGlvbnMuc2lsZW50KSB0aGlzLnRyaWdnZXIoJ3Jlc2V0JywgdGhpcywgb3B0aW9ucyk7XG4gICAgICByZXR1cm4gbW9kZWxzO1xuICAgIH0sXG5cbiAgICAvLyBBZGQgYSBtb2RlbCB0byB0aGUgZW5kIG9mIHRoZSBjb2xsZWN0aW9uLlxuICAgIHB1c2g6IGZ1bmN0aW9uKG1vZGVsLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gdGhpcy5hZGQobW9kZWwsIF8uZXh0ZW5kKHthdDogdGhpcy5sZW5ndGh9LCBvcHRpb25zKSk7XG4gICAgfSxcblxuICAgIC8vIFJlbW92ZSBhIG1vZGVsIGZyb20gdGhlIGVuZCBvZiB0aGUgY29sbGVjdGlvbi5cbiAgICBwb3A6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHZhciBtb2RlbCA9IHRoaXMuYXQodGhpcy5sZW5ndGggLSAxKTtcbiAgICAgIHJldHVybiB0aGlzLnJlbW92ZShtb2RlbCwgb3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8vIEFkZCBhIG1vZGVsIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGNvbGxlY3Rpb24uXG4gICAgdW5zaGlmdDogZnVuY3Rpb24obW9kZWwsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLmFkZChtb2RlbCwgXy5leHRlbmQoe2F0OiAwfSwgb3B0aW9ucykpO1xuICAgIH0sXG5cbiAgICAvLyBSZW1vdmUgYSBtb2RlbCBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGNvbGxlY3Rpb24uXG4gICAgc2hpZnQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHZhciBtb2RlbCA9IHRoaXMuYXQoMCk7XG4gICAgICByZXR1cm4gdGhpcy5yZW1vdmUobW9kZWwsIG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvLyBTbGljZSBvdXQgYSBzdWItYXJyYXkgb2YgbW9kZWxzIGZyb20gdGhlIGNvbGxlY3Rpb24uXG4gICAgc2xpY2U6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHNsaWNlLmFwcGx5KHRoaXMubW9kZWxzLCBhcmd1bWVudHMpO1xuICAgIH0sXG5cbiAgICAvLyBHZXQgYSBtb2RlbCBmcm9tIHRoZSBzZXQgYnkgaWQsIGNpZCwgbW9kZWwgb2JqZWN0IHdpdGggaWQgb3IgY2lkXG4gICAgLy8gcHJvcGVydGllcywgb3IgYW4gYXR0cmlidXRlcyBvYmplY3QgdGhhdCBpcyB0cmFuc2Zvcm1lZCB0aHJvdWdoIG1vZGVsSWQuXG4gICAgZ2V0OiBmdW5jdGlvbihvYmopIHtcbiAgICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIHZvaWQgMDtcbiAgICAgIHJldHVybiB0aGlzLl9ieUlkW29ial0gfHxcbiAgICAgICAgdGhpcy5fYnlJZFt0aGlzLm1vZGVsSWQob2JqLmF0dHJpYnV0ZXMgfHwgb2JqKV0gfHxcbiAgICAgICAgb2JqLmNpZCAmJiB0aGlzLl9ieUlkW29iai5jaWRdO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgbW9kZWwgaXMgaW4gdGhlIGNvbGxlY3Rpb24uXG4gICAgaGFzOiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiB0aGlzLmdldChvYmopICE9IG51bGw7XG4gICAgfSxcblxuICAgIC8vIEdldCB0aGUgbW9kZWwgYXQgdGhlIGdpdmVuIGluZGV4LlxuICAgIGF0OiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgaWYgKGluZGV4IDwgMCkgaW5kZXggKz0gdGhpcy5sZW5ndGg7XG4gICAgICByZXR1cm4gdGhpcy5tb2RlbHNbaW5kZXhdO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm4gbW9kZWxzIHdpdGggbWF0Y2hpbmcgYXR0cmlidXRlcy4gVXNlZnVsIGZvciBzaW1wbGUgY2FzZXMgb2ZcbiAgICAvLyBgZmlsdGVyYC5cbiAgICB3aGVyZTogZnVuY3Rpb24oYXR0cnMsIGZpcnN0KSB7XG4gICAgICByZXR1cm4gdGhpc1tmaXJzdCA/ICdmaW5kJyA6ICdmaWx0ZXInXShhdHRycyk7XG4gICAgfSxcblxuICAgIC8vIFJldHVybiB0aGUgZmlyc3QgbW9kZWwgd2l0aCBtYXRjaGluZyBhdHRyaWJ1dGVzLiBVc2VmdWwgZm9yIHNpbXBsZSBjYXNlc1xuICAgIC8vIG9mIGBmaW5kYC5cbiAgICBmaW5kV2hlcmU6IGZ1bmN0aW9uKGF0dHJzKSB7XG4gICAgICByZXR1cm4gdGhpcy53aGVyZShhdHRycywgdHJ1ZSk7XG4gICAgfSxcblxuICAgIC8vIEZvcmNlIHRoZSBjb2xsZWN0aW9uIHRvIHJlLXNvcnQgaXRzZWxmLiBZb3UgZG9uJ3QgbmVlZCB0byBjYWxsIHRoaXMgdW5kZXJcbiAgICAvLyBub3JtYWwgY2lyY3Vtc3RhbmNlcywgYXMgdGhlIHNldCB3aWxsIG1haW50YWluIHNvcnQgb3JkZXIgYXMgZWFjaCBpdGVtXG4gICAgLy8gaXMgYWRkZWQuXG4gICAgc29ydDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIGNvbXBhcmF0b3IgPSB0aGlzLmNvbXBhcmF0b3I7XG4gICAgICBpZiAoIWNvbXBhcmF0b3IpIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHNvcnQgYSBzZXQgd2l0aG91dCBhIGNvbXBhcmF0b3InKTtcbiAgICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7fSk7XG5cbiAgICAgIHZhciBsZW5ndGggPSBjb21wYXJhdG9yLmxlbmd0aDtcbiAgICAgIGlmIChfLmlzRnVuY3Rpb24oY29tcGFyYXRvcikpIGNvbXBhcmF0b3IgPSBfLmJpbmQoY29tcGFyYXRvciwgdGhpcyk7XG5cbiAgICAgIC8vIFJ1biBzb3J0IGJhc2VkIG9uIHR5cGUgb2YgYGNvbXBhcmF0b3JgLlxuICAgICAgaWYgKGxlbmd0aCA9PT0gMSB8fCBfLmlzU3RyaW5nKGNvbXBhcmF0b3IpKSB7XG4gICAgICAgIHRoaXMubW9kZWxzID0gdGhpcy5zb3J0QnkoY29tcGFyYXRvcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm1vZGVscy5zb3J0KGNvbXBhcmF0b3IpO1xuICAgICAgfVxuICAgICAgaWYgKCFvcHRpb25zLnNpbGVudCkgdGhpcy50cmlnZ2VyKCdzb3J0JywgdGhpcywgb3B0aW9ucyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gUGx1Y2sgYW4gYXR0cmlidXRlIGZyb20gZWFjaCBtb2RlbCBpbiB0aGUgY29sbGVjdGlvbi5cbiAgICBwbHVjazogZnVuY3Rpb24oYXR0cikge1xuICAgICAgcmV0dXJuIHRoaXMubWFwKGF0dHIgKyAnJyk7XG4gICAgfSxcblxuICAgIC8vIEZldGNoIHRoZSBkZWZhdWx0IHNldCBvZiBtb2RlbHMgZm9yIHRoaXMgY29sbGVjdGlvbiwgcmVzZXR0aW5nIHRoZVxuICAgIC8vIGNvbGxlY3Rpb24gd2hlbiB0aGV5IGFycml2ZS4gSWYgYHJlc2V0OiB0cnVlYCBpcyBwYXNzZWQsIHRoZSByZXNwb25zZVxuICAgIC8vIGRhdGEgd2lsbCBiZSBwYXNzZWQgdGhyb3VnaCB0aGUgYHJlc2V0YCBtZXRob2QgaW5zdGVhZCBvZiBgc2V0YC5cbiAgICBmZXRjaDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IF8uZXh0ZW5kKHtwYXJzZTogdHJ1ZX0sIG9wdGlvbnMpO1xuICAgICAgdmFyIHN1Y2Nlc3MgPSBvcHRpb25zLnN1Y2Nlc3M7XG4gICAgICB2YXIgY29sbGVjdGlvbiA9IHRoaXM7XG4gICAgICBvcHRpb25zLnN1Y2Nlc3MgPSBmdW5jdGlvbihyZXNwKSB7XG4gICAgICAgIHZhciBtZXRob2QgPSBvcHRpb25zLnJlc2V0ID8gJ3Jlc2V0JyA6ICdzZXQnO1xuICAgICAgICBjb2xsZWN0aW9uW21ldGhvZF0ocmVzcCwgb3B0aW9ucyk7XG4gICAgICAgIGlmIChzdWNjZXNzKSBzdWNjZXNzLmNhbGwob3B0aW9ucy5jb250ZXh0LCBjb2xsZWN0aW9uLCByZXNwLCBvcHRpb25zKTtcbiAgICAgICAgY29sbGVjdGlvbi50cmlnZ2VyKCdzeW5jJywgY29sbGVjdGlvbiwgcmVzcCwgb3B0aW9ucyk7XG4gICAgICB9O1xuICAgICAgd3JhcEVycm9yKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHRoaXMuc3luYygncmVhZCcsIHRoaXMsIG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvLyBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgYSBtb2RlbCBpbiB0aGlzIGNvbGxlY3Rpb24uIEFkZCB0aGUgbW9kZWwgdG8gdGhlXG4gICAgLy8gY29sbGVjdGlvbiBpbW1lZGlhdGVseSwgdW5sZXNzIGB3YWl0OiB0cnVlYCBpcyBwYXNzZWQsIGluIHdoaWNoIGNhc2Ugd2VcbiAgICAvLyB3YWl0IGZvciB0aGUgc2VydmVyIHRvIGFncmVlLlxuICAgIGNyZWF0ZTogZnVuY3Rpb24obW9kZWwsIG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zID8gXy5jbG9uZShvcHRpb25zKSA6IHt9O1xuICAgICAgdmFyIHdhaXQgPSBvcHRpb25zLndhaXQ7XG4gICAgICBtb2RlbCA9IHRoaXMuX3ByZXBhcmVNb2RlbChtb2RlbCwgb3B0aW9ucyk7XG4gICAgICBpZiAoIW1vZGVsKSByZXR1cm4gZmFsc2U7XG4gICAgICBpZiAoIXdhaXQpIHRoaXMuYWRkKG1vZGVsLCBvcHRpb25zKTtcbiAgICAgIHZhciBjb2xsZWN0aW9uID0gdGhpcztcbiAgICAgIHZhciBzdWNjZXNzID0gb3B0aW9ucy5zdWNjZXNzO1xuICAgICAgb3B0aW9ucy5zdWNjZXNzID0gZnVuY3Rpb24obSwgcmVzcCwgY2FsbGJhY2tPcHRzKSB7XG4gICAgICAgIGlmICh3YWl0KSBjb2xsZWN0aW9uLmFkZChtLCBjYWxsYmFja09wdHMpO1xuICAgICAgICBpZiAoc3VjY2Vzcykgc3VjY2Vzcy5jYWxsKGNhbGxiYWNrT3B0cy5jb250ZXh0LCBtLCByZXNwLCBjYWxsYmFja09wdHMpO1xuICAgICAgfTtcbiAgICAgIG1vZGVsLnNhdmUobnVsbCwgb3B0aW9ucyk7XG4gICAgICByZXR1cm4gbW9kZWw7XG4gICAgfSxcblxuICAgIC8vICoqcGFyc2UqKiBjb252ZXJ0cyBhIHJlc3BvbnNlIGludG8gYSBsaXN0IG9mIG1vZGVscyB0byBiZSBhZGRlZCB0byB0aGVcbiAgICAvLyBjb2xsZWN0aW9uLiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBpcyBqdXN0IHRvIHBhc3MgaXQgdGhyb3VnaC5cbiAgICBwYXJzZTogZnVuY3Rpb24ocmVzcCwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHJlc3A7XG4gICAgfSxcblxuICAgIC8vIENyZWF0ZSBhIG5ldyBjb2xsZWN0aW9uIHdpdGggYW4gaWRlbnRpY2FsIGxpc3Qgb2YgbW9kZWxzIGFzIHRoaXMgb25lLlxuICAgIGNsb25lOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzLm1vZGVscywge1xuICAgICAgICBtb2RlbDogdGhpcy5tb2RlbCxcbiAgICAgICAgY29tcGFyYXRvcjogdGhpcy5jb21wYXJhdG9yXG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgLy8gRGVmaW5lIGhvdyB0byB1bmlxdWVseSBpZGVudGlmeSBtb2RlbHMgaW4gdGhlIGNvbGxlY3Rpb24uXG4gICAgbW9kZWxJZDogZnVuY3Rpb24oYXR0cnMpIHtcbiAgICAgIHJldHVybiBhdHRyc1t0aGlzLm1vZGVsLnByb3RvdHlwZS5pZEF0dHJpYnV0ZSB8fCAnaWQnXTtcbiAgICB9LFxuXG4gICAgLy8gUHJpdmF0ZSBtZXRob2QgdG8gcmVzZXQgYWxsIGludGVybmFsIHN0YXRlLiBDYWxsZWQgd2hlbiB0aGUgY29sbGVjdGlvblxuICAgIC8vIGlzIGZpcnN0IGluaXRpYWxpemVkIG9yIHJlc2V0LlxuICAgIF9yZXNldDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgICB0aGlzLm1vZGVscyA9IFtdO1xuICAgICAgdGhpcy5fYnlJZCAgPSB7fTtcbiAgICB9LFxuXG4gICAgLy8gUHJlcGFyZSBhIGhhc2ggb2YgYXR0cmlidXRlcyAob3Igb3RoZXIgbW9kZWwpIHRvIGJlIGFkZGVkIHRvIHRoaXNcbiAgICAvLyBjb2xsZWN0aW9uLlxuICAgIF9wcmVwYXJlTW9kZWw6IGZ1bmN0aW9uKGF0dHJzLCBvcHRpb25zKSB7XG4gICAgICBpZiAodGhpcy5faXNNb2RlbChhdHRycykpIHtcbiAgICAgICAgaWYgKCFhdHRycy5jb2xsZWN0aW9uKSBhdHRycy5jb2xsZWN0aW9uID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGF0dHJzO1xuICAgICAgfVxuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgPyBfLmNsb25lKG9wdGlvbnMpIDoge307XG4gICAgICBvcHRpb25zLmNvbGxlY3Rpb24gPSB0aGlzO1xuICAgICAgdmFyIG1vZGVsID0gbmV3IHRoaXMubW9kZWwoYXR0cnMsIG9wdGlvbnMpO1xuICAgICAgaWYgKCFtb2RlbC52YWxpZGF0aW9uRXJyb3IpIHJldHVybiBtb2RlbDtcbiAgICAgIHRoaXMudHJpZ2dlcignaW52YWxpZCcsIHRoaXMsIG1vZGVsLnZhbGlkYXRpb25FcnJvciwgb3B0aW9ucyk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8vIEludGVybmFsIG1ldGhvZCBjYWxsZWQgYnkgYm90aCByZW1vdmUgYW5kIHNldC5cbiAgICBfcmVtb3ZlTW9kZWxzOiBmdW5jdGlvbihtb2RlbHMsIG9wdGlvbnMpIHtcbiAgICAgIHZhciByZW1vdmVkID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1vZGVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbW9kZWwgPSB0aGlzLmdldChtb2RlbHNbaV0pO1xuICAgICAgICBpZiAoIW1vZGVsKSBjb250aW51ZTtcblxuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmluZGV4T2YobW9kZWwpO1xuICAgICAgICB0aGlzLm1vZGVscy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB0aGlzLmxlbmd0aC0tO1xuXG4gICAgICAgIC8vIFJlbW92ZSByZWZlcmVuY2VzIGJlZm9yZSB0cmlnZ2VyaW5nICdyZW1vdmUnIGV2ZW50IHRvIHByZXZlbnQgYW5cbiAgICAgICAgLy8gaW5maW5pdGUgbG9vcC4gIzM2OTNcbiAgICAgICAgZGVsZXRlIHRoaXMuX2J5SWRbbW9kZWwuY2lkXTtcbiAgICAgICAgdmFyIGlkID0gdGhpcy5tb2RlbElkKG1vZGVsLmF0dHJpYnV0ZXMpO1xuICAgICAgICBpZiAoaWQgIT0gbnVsbCkgZGVsZXRlIHRoaXMuX2J5SWRbaWRdO1xuXG4gICAgICAgIGlmICghb3B0aW9ucy5zaWxlbnQpIHtcbiAgICAgICAgICBvcHRpb25zLmluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgbW9kZWwudHJpZ2dlcigncmVtb3ZlJywgbW9kZWwsIHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVtb3ZlZC5wdXNoKG1vZGVsKTtcbiAgICAgICAgdGhpcy5fcmVtb3ZlUmVmZXJlbmNlKG1vZGVsLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZW1vdmVkO1xuICAgIH0sXG5cbiAgICAvLyBNZXRob2QgZm9yIGNoZWNraW5nIHdoZXRoZXIgYW4gb2JqZWN0IHNob3VsZCBiZSBjb25zaWRlcmVkIGEgbW9kZWwgZm9yXG4gICAgLy8gdGhlIHB1cnBvc2VzIG9mIGFkZGluZyB0byB0aGUgY29sbGVjdGlvbi5cbiAgICBfaXNNb2RlbDogZnVuY3Rpb24obW9kZWwpIHtcbiAgICAgIHJldHVybiBtb2RlbCBpbnN0YW5jZW9mIE1vZGVsO1xuICAgIH0sXG5cbiAgICAvLyBJbnRlcm5hbCBtZXRob2QgdG8gY3JlYXRlIGEgbW9kZWwncyB0aWVzIHRvIGEgY29sbGVjdGlvbi5cbiAgICBfYWRkUmVmZXJlbmNlOiBmdW5jdGlvbihtb2RlbCwgb3B0aW9ucykge1xuICAgICAgdGhpcy5fYnlJZFttb2RlbC5jaWRdID0gbW9kZWw7XG4gICAgICB2YXIgaWQgPSB0aGlzLm1vZGVsSWQobW9kZWwuYXR0cmlidXRlcyk7XG4gICAgICBpZiAoaWQgIT0gbnVsbCkgdGhpcy5fYnlJZFtpZF0gPSBtb2RlbDtcbiAgICAgIG1vZGVsLm9uKCdhbGwnLCB0aGlzLl9vbk1vZGVsRXZlbnQsIHRoaXMpO1xuICAgIH0sXG5cbiAgICAvLyBJbnRlcm5hbCBtZXRob2QgdG8gc2V2ZXIgYSBtb2RlbCdzIHRpZXMgdG8gYSBjb2xsZWN0aW9uLlxuICAgIF9yZW1vdmVSZWZlcmVuY2U6IGZ1bmN0aW9uKG1vZGVsLCBvcHRpb25zKSB7XG4gICAgICBkZWxldGUgdGhpcy5fYnlJZFttb2RlbC5jaWRdO1xuICAgICAgdmFyIGlkID0gdGhpcy5tb2RlbElkKG1vZGVsLmF0dHJpYnV0ZXMpO1xuICAgICAgaWYgKGlkICE9IG51bGwpIGRlbGV0ZSB0aGlzLl9ieUlkW2lkXTtcbiAgICAgIGlmICh0aGlzID09PSBtb2RlbC5jb2xsZWN0aW9uKSBkZWxldGUgbW9kZWwuY29sbGVjdGlvbjtcbiAgICAgIG1vZGVsLm9mZignYWxsJywgdGhpcy5fb25Nb2RlbEV2ZW50LCB0aGlzKTtcbiAgICB9LFxuXG4gICAgLy8gSW50ZXJuYWwgbWV0aG9kIGNhbGxlZCBldmVyeSB0aW1lIGEgbW9kZWwgaW4gdGhlIHNldCBmaXJlcyBhbiBldmVudC5cbiAgICAvLyBTZXRzIG5lZWQgdG8gdXBkYXRlIHRoZWlyIGluZGV4ZXMgd2hlbiBtb2RlbHMgY2hhbmdlIGlkcy4gQWxsIG90aGVyXG4gICAgLy8gZXZlbnRzIHNpbXBseSBwcm94eSB0aHJvdWdoLiBcImFkZFwiIGFuZCBcInJlbW92ZVwiIGV2ZW50cyB0aGF0IG9yaWdpbmF0ZVxuICAgIC8vIGluIG90aGVyIGNvbGxlY3Rpb25zIGFyZSBpZ25vcmVkLlxuICAgIF9vbk1vZGVsRXZlbnQ6IGZ1bmN0aW9uKGV2ZW50LCBtb2RlbCwgY29sbGVjdGlvbiwgb3B0aW9ucykge1xuICAgICAgaWYgKG1vZGVsKSB7XG4gICAgICAgIGlmICgoZXZlbnQgPT09ICdhZGQnIHx8IGV2ZW50ID09PSAncmVtb3ZlJykgJiYgY29sbGVjdGlvbiAhPT0gdGhpcykgcmV0dXJuO1xuICAgICAgICBpZiAoZXZlbnQgPT09ICdkZXN0cm95JykgdGhpcy5yZW1vdmUobW9kZWwsIG9wdGlvbnMpO1xuICAgICAgICBpZiAoZXZlbnQgPT09ICdjaGFuZ2UnKSB7XG4gICAgICAgICAgdmFyIHByZXZJZCA9IHRoaXMubW9kZWxJZChtb2RlbC5wcmV2aW91c0F0dHJpYnV0ZXMoKSk7XG4gICAgICAgICAgdmFyIGlkID0gdGhpcy5tb2RlbElkKG1vZGVsLmF0dHJpYnV0ZXMpO1xuICAgICAgICAgIGlmIChwcmV2SWQgIT09IGlkKSB7XG4gICAgICAgICAgICBpZiAocHJldklkICE9IG51bGwpIGRlbGV0ZSB0aGlzLl9ieUlkW3ByZXZJZF07XG4gICAgICAgICAgICBpZiAoaWQgIT0gbnVsbCkgdGhpcy5fYnlJZFtpZF0gPSBtb2RlbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMudHJpZ2dlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICB9KTtcblxuICAvLyBVbmRlcnNjb3JlIG1ldGhvZHMgdGhhdCB3ZSB3YW50IHRvIGltcGxlbWVudCBvbiB0aGUgQ29sbGVjdGlvbi5cbiAgLy8gOTAlIG9mIHRoZSBjb3JlIHVzZWZ1bG5lc3Mgb2YgQmFja2JvbmUgQ29sbGVjdGlvbnMgaXMgYWN0dWFsbHkgaW1wbGVtZW50ZWRcbiAgLy8gcmlnaHQgaGVyZTpcbiAgdmFyIGNvbGxlY3Rpb25NZXRob2RzID0ge2ZvckVhY2g6IDMsIGVhY2g6IDMsIG1hcDogMywgY29sbGVjdDogMywgcmVkdWNlOiAwLFxuICAgICAgZm9sZGw6IDAsIGluamVjdDogMCwgcmVkdWNlUmlnaHQ6IDAsIGZvbGRyOiAwLCBmaW5kOiAzLCBkZXRlY3Q6IDMsIGZpbHRlcjogMyxcbiAgICAgIHNlbGVjdDogMywgcmVqZWN0OiAzLCBldmVyeTogMywgYWxsOiAzLCBzb21lOiAzLCBhbnk6IDMsIGluY2x1ZGU6IDMsIGluY2x1ZGVzOiAzLFxuICAgICAgY29udGFpbnM6IDMsIGludm9rZTogMCwgbWF4OiAzLCBtaW46IDMsIHRvQXJyYXk6IDEsIHNpemU6IDEsIGZpcnN0OiAzLFxuICAgICAgaGVhZDogMywgdGFrZTogMywgaW5pdGlhbDogMywgcmVzdDogMywgdGFpbDogMywgZHJvcDogMywgbGFzdDogMyxcbiAgICAgIHdpdGhvdXQ6IDAsIGRpZmZlcmVuY2U6IDAsIGluZGV4T2Y6IDMsIHNodWZmbGU6IDEsIGxhc3RJbmRleE9mOiAzLFxuICAgICAgaXNFbXB0eTogMSwgY2hhaW46IDEsIHNhbXBsZTogMywgcGFydGl0aW9uOiAzLCBncm91cEJ5OiAzLCBjb3VudEJ5OiAzLFxuICAgICAgc29ydEJ5OiAzLCBpbmRleEJ5OiAzLCBmaW5kSW5kZXg6IDMsIGZpbmRMYXN0SW5kZXg6IDN9O1xuXG4gIC8vIE1peCBpbiBlYWNoIFVuZGVyc2NvcmUgbWV0aG9kIGFzIGEgcHJveHkgdG8gYENvbGxlY3Rpb24jbW9kZWxzYC5cbiAgYWRkVW5kZXJzY29yZU1ldGhvZHMoQ29sbGVjdGlvbiwgY29sbGVjdGlvbk1ldGhvZHMsICdtb2RlbHMnKTtcblxuICAvLyBCYWNrYm9uZS5WaWV3XG4gIC8vIC0tLS0tLS0tLS0tLS1cblxuICAvLyBCYWNrYm9uZSBWaWV3cyBhcmUgYWxtb3N0IG1vcmUgY29udmVudGlvbiB0aGFuIHRoZXkgYXJlIGFjdHVhbCBjb2RlLiBBIFZpZXdcbiAgLy8gaXMgc2ltcGx5IGEgSmF2YVNjcmlwdCBvYmplY3QgdGhhdCByZXByZXNlbnRzIGEgbG9naWNhbCBjaHVuayBvZiBVSSBpbiB0aGVcbiAgLy8gRE9NLiBUaGlzIG1pZ2h0IGJlIGEgc2luZ2xlIGl0ZW0sIGFuIGVudGlyZSBsaXN0LCBhIHNpZGViYXIgb3IgcGFuZWwsIG9yXG4gIC8vIGV2ZW4gdGhlIHN1cnJvdW5kaW5nIGZyYW1lIHdoaWNoIHdyYXBzIHlvdXIgd2hvbGUgYXBwLiBEZWZpbmluZyBhIGNodW5rIG9mXG4gIC8vIFVJIGFzIGEgKipWaWV3KiogYWxsb3dzIHlvdSB0byBkZWZpbmUgeW91ciBET00gZXZlbnRzIGRlY2xhcmF0aXZlbHksIHdpdGhvdXRcbiAgLy8gaGF2aW5nIHRvIHdvcnJ5IGFib3V0IHJlbmRlciBvcmRlciAuLi4gYW5kIG1ha2VzIGl0IGVhc3kgZm9yIHRoZSB2aWV3IHRvXG4gIC8vIHJlYWN0IHRvIHNwZWNpZmljIGNoYW5nZXMgaW4gdGhlIHN0YXRlIG9mIHlvdXIgbW9kZWxzLlxuXG4gIC8vIENyZWF0aW5nIGEgQmFja2JvbmUuVmlldyBjcmVhdGVzIGl0cyBpbml0aWFsIGVsZW1lbnQgb3V0c2lkZSBvZiB0aGUgRE9NLFxuICAvLyBpZiBhbiBleGlzdGluZyBlbGVtZW50IGlzIG5vdCBwcm92aWRlZC4uLlxuICB2YXIgVmlldyA9IEJhY2tib25lLlZpZXcgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdGhpcy5jaWQgPSBfLnVuaXF1ZUlkKCd2aWV3Jyk7XG4gICAgXy5leHRlbmQodGhpcywgXy5waWNrKG9wdGlvbnMsIHZpZXdPcHRpb25zKSk7XG4gICAgdGhpcy5fZW5zdXJlRWxlbWVudCgpO1xuICAgIHRoaXMuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xuXG4gIC8vIENhY2hlZCByZWdleCB0byBzcGxpdCBrZXlzIGZvciBgZGVsZWdhdGVgLlxuICB2YXIgZGVsZWdhdGVFdmVudFNwbGl0dGVyID0gL14oXFxTKylcXHMqKC4qKSQvO1xuXG4gIC8vIExpc3Qgb2YgdmlldyBvcHRpb25zIHRvIGJlIHNldCBhcyBwcm9wZXJ0aWVzLlxuICB2YXIgdmlld09wdGlvbnMgPSBbJ21vZGVsJywgJ2NvbGxlY3Rpb24nLCAnZWwnLCAnaWQnLCAnYXR0cmlidXRlcycsICdjbGFzc05hbWUnLCAndGFnTmFtZScsICdldmVudHMnXTtcblxuICAvLyBTZXQgdXAgYWxsIGluaGVyaXRhYmxlICoqQmFja2JvbmUuVmlldyoqIHByb3BlcnRpZXMgYW5kIG1ldGhvZHMuXG4gIF8uZXh0ZW5kKFZpZXcucHJvdG90eXBlLCBFdmVudHMsIHtcblxuICAgIC8vIFRoZSBkZWZhdWx0IGB0YWdOYW1lYCBvZiBhIFZpZXcncyBlbGVtZW50IGlzIGBcImRpdlwiYC5cbiAgICB0YWdOYW1lOiAnZGl2JyxcblxuICAgIC8vIGpRdWVyeSBkZWxlZ2F0ZSBmb3IgZWxlbWVudCBsb29rdXAsIHNjb3BlZCB0byBET00gZWxlbWVudHMgd2l0aGluIHRoZVxuICAgIC8vIGN1cnJlbnQgdmlldy4gVGhpcyBzaG91bGQgYmUgcHJlZmVycmVkIHRvIGdsb2JhbCBsb29rdXBzIHdoZXJlIHBvc3NpYmxlLlxuICAgICQ6IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gICAgICByZXR1cm4gdGhpcy4kZWwuZmluZChzZWxlY3Rvcik7XG4gICAgfSxcblxuICAgIC8vIEluaXRpYWxpemUgaXMgYW4gZW1wdHkgZnVuY3Rpb24gYnkgZGVmYXVsdC4gT3ZlcnJpZGUgaXQgd2l0aCB5b3VyIG93blxuICAgIC8vIGluaXRpYWxpemF0aW9uIGxvZ2ljLlxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKCl7fSxcblxuICAgIC8vICoqcmVuZGVyKiogaXMgdGhlIGNvcmUgZnVuY3Rpb24gdGhhdCB5b3VyIHZpZXcgc2hvdWxkIG92ZXJyaWRlLCBpbiBvcmRlclxuICAgIC8vIHRvIHBvcHVsYXRlIGl0cyBlbGVtZW50IChgdGhpcy5lbGApLCB3aXRoIHRoZSBhcHByb3ByaWF0ZSBIVE1MLiBUaGVcbiAgICAvLyBjb252ZW50aW9uIGlzIGZvciAqKnJlbmRlcioqIHRvIGFsd2F5cyByZXR1cm4gYHRoaXNgLlxuICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gUmVtb3ZlIHRoaXMgdmlldyBieSB0YWtpbmcgdGhlIGVsZW1lbnQgb3V0IG9mIHRoZSBET00sIGFuZCByZW1vdmluZyBhbnlcbiAgICAvLyBhcHBsaWNhYmxlIEJhY2tib25lLkV2ZW50cyBsaXN0ZW5lcnMuXG4gICAgcmVtb3ZlOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX3JlbW92ZUVsZW1lbnQoKTtcbiAgICAgIHRoaXMuc3RvcExpc3RlbmluZygpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIFJlbW92ZSB0aGlzIHZpZXcncyBlbGVtZW50IGZyb20gdGhlIGRvY3VtZW50IGFuZCBhbGwgZXZlbnQgbGlzdGVuZXJzXG4gICAgLy8gYXR0YWNoZWQgdG8gaXQuIEV4cG9zZWQgZm9yIHN1YmNsYXNzZXMgdXNpbmcgYW4gYWx0ZXJuYXRpdmUgRE9NXG4gICAgLy8gbWFuaXB1bGF0aW9uIEFQSS5cbiAgICBfcmVtb3ZlRWxlbWVudDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLiRlbC5yZW1vdmUoKTtcbiAgICB9LFxuXG4gICAgLy8gQ2hhbmdlIHRoZSB2aWV3J3MgZWxlbWVudCAoYHRoaXMuZWxgIHByb3BlcnR5KSBhbmQgcmUtZGVsZWdhdGUgdGhlXG4gICAgLy8gdmlldydzIGV2ZW50cyBvbiB0aGUgbmV3IGVsZW1lbnQuXG4gICAgc2V0RWxlbWVudDogZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgdGhpcy51bmRlbGVnYXRlRXZlbnRzKCk7XG4gICAgICB0aGlzLl9zZXRFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgdGhpcy5kZWxlZ2F0ZUV2ZW50cygpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIENyZWF0ZXMgdGhlIGB0aGlzLmVsYCBhbmQgYHRoaXMuJGVsYCByZWZlcmVuY2VzIGZvciB0aGlzIHZpZXcgdXNpbmcgdGhlXG4gICAgLy8gZ2l2ZW4gYGVsYC4gYGVsYCBjYW4gYmUgYSBDU1Mgc2VsZWN0b3Igb3IgYW4gSFRNTCBzdHJpbmcsIGEgalF1ZXJ5XG4gICAgLy8gY29udGV4dCBvciBhbiBlbGVtZW50LiBTdWJjbGFzc2VzIGNhbiBvdmVycmlkZSB0aGlzIHRvIHV0aWxpemUgYW5cbiAgICAvLyBhbHRlcm5hdGl2ZSBET00gbWFuaXB1bGF0aW9uIEFQSSBhbmQgYXJlIG9ubHkgcmVxdWlyZWQgdG8gc2V0IHRoZVxuICAgIC8vIGB0aGlzLmVsYCBwcm9wZXJ0eS5cbiAgICBfc2V0RWxlbWVudDogZnVuY3Rpb24oZWwpIHtcbiAgICAgIHRoaXMuJGVsID0gZWwgaW5zdGFuY2VvZiBCYWNrYm9uZS4kID8gZWwgOiBCYWNrYm9uZS4kKGVsKTtcbiAgICAgIHRoaXMuZWwgPSB0aGlzLiRlbFswXTtcbiAgICB9LFxuXG4gICAgLy8gU2V0IGNhbGxiYWNrcywgd2hlcmUgYHRoaXMuZXZlbnRzYCBpcyBhIGhhc2ggb2ZcbiAgICAvL1xuICAgIC8vICp7XCJldmVudCBzZWxlY3RvclwiOiBcImNhbGxiYWNrXCJ9KlxuICAgIC8vXG4gICAgLy8gICAgIHtcbiAgICAvLyAgICAgICAnbW91c2Vkb3duIC50aXRsZSc6ICAnZWRpdCcsXG4gICAgLy8gICAgICAgJ2NsaWNrIC5idXR0b24nOiAgICAgJ3NhdmUnLFxuICAgIC8vICAgICAgICdjbGljayAub3Blbic6ICAgICAgIGZ1bmN0aW9uKGUpIHsgLi4uIH1cbiAgICAvLyAgICAgfVxuICAgIC8vXG4gICAgLy8gcGFpcnMuIENhbGxiYWNrcyB3aWxsIGJlIGJvdW5kIHRvIHRoZSB2aWV3LCB3aXRoIGB0aGlzYCBzZXQgcHJvcGVybHkuXG4gICAgLy8gVXNlcyBldmVudCBkZWxlZ2F0aW9uIGZvciBlZmZpY2llbmN5LlxuICAgIC8vIE9taXR0aW5nIHRoZSBzZWxlY3RvciBiaW5kcyB0aGUgZXZlbnQgdG8gYHRoaXMuZWxgLlxuICAgIGRlbGVnYXRlRXZlbnRzOiBmdW5jdGlvbihldmVudHMpIHtcbiAgICAgIGV2ZW50cyB8fCAoZXZlbnRzID0gXy5yZXN1bHQodGhpcywgJ2V2ZW50cycpKTtcbiAgICAgIGlmICghZXZlbnRzKSByZXR1cm4gdGhpcztcbiAgICAgIHRoaXMudW5kZWxlZ2F0ZUV2ZW50cygpO1xuICAgICAgZm9yICh2YXIga2V5IGluIGV2ZW50cykge1xuICAgICAgICB2YXIgbWV0aG9kID0gZXZlbnRzW2tleV07XG4gICAgICAgIGlmICghXy5pc0Z1bmN0aW9uKG1ldGhvZCkpIG1ldGhvZCA9IHRoaXNbbWV0aG9kXTtcbiAgICAgICAgaWYgKCFtZXRob2QpIGNvbnRpbnVlO1xuICAgICAgICB2YXIgbWF0Y2ggPSBrZXkubWF0Y2goZGVsZWdhdGVFdmVudFNwbGl0dGVyKTtcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZShtYXRjaFsxXSwgbWF0Y2hbMl0sIF8uYmluZChtZXRob2QsIHRoaXMpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBBZGQgYSBzaW5nbGUgZXZlbnQgbGlzdGVuZXIgdG8gdGhlIHZpZXcncyBlbGVtZW50IChvciBhIGNoaWxkIGVsZW1lbnRcbiAgICAvLyB1c2luZyBgc2VsZWN0b3JgKS4gVGhpcyBvbmx5IHdvcmtzIGZvciBkZWxlZ2F0ZS1hYmxlIGV2ZW50czogbm90IGBmb2N1c2AsXG4gICAgLy8gYGJsdXJgLCBhbmQgbm90IGBjaGFuZ2VgLCBgc3VibWl0YCwgYW5kIGByZXNldGAgaW4gSW50ZXJuZXQgRXhwbG9yZXIuXG4gICAgZGVsZWdhdGU6IGZ1bmN0aW9uKGV2ZW50TmFtZSwgc2VsZWN0b3IsIGxpc3RlbmVyKSB7XG4gICAgICB0aGlzLiRlbC5vbihldmVudE5hbWUgKyAnLmRlbGVnYXRlRXZlbnRzJyArIHRoaXMuY2lkLCBzZWxlY3RvciwgbGlzdGVuZXIpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIENsZWFycyBhbGwgY2FsbGJhY2tzIHByZXZpb3VzbHkgYm91bmQgdG8gdGhlIHZpZXcgYnkgYGRlbGVnYXRlRXZlbnRzYC5cbiAgICAvLyBZb3UgdXN1YWxseSBkb24ndCBuZWVkIHRvIHVzZSB0aGlzLCBidXQgbWF5IHdpc2ggdG8gaWYgeW91IGhhdmUgbXVsdGlwbGVcbiAgICAvLyBCYWNrYm9uZSB2aWV3cyBhdHRhY2hlZCB0byB0aGUgc2FtZSBET00gZWxlbWVudC5cbiAgICB1bmRlbGVnYXRlRXZlbnRzOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLiRlbCkgdGhpcy4kZWwub2ZmKCcuZGVsZWdhdGVFdmVudHMnICsgdGhpcy5jaWQpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIEEgZmluZXItZ3JhaW5lZCBgdW5kZWxlZ2F0ZUV2ZW50c2AgZm9yIHJlbW92aW5nIGEgc2luZ2xlIGRlbGVnYXRlZCBldmVudC5cbiAgICAvLyBgc2VsZWN0b3JgIGFuZCBgbGlzdGVuZXJgIGFyZSBib3RoIG9wdGlvbmFsLlxuICAgIHVuZGVsZWdhdGU6IGZ1bmN0aW9uKGV2ZW50TmFtZSwgc2VsZWN0b3IsIGxpc3RlbmVyKSB7XG4gICAgICB0aGlzLiRlbC5vZmYoZXZlbnROYW1lICsgJy5kZWxlZ2F0ZUV2ZW50cycgKyB0aGlzLmNpZCwgc2VsZWN0b3IsIGxpc3RlbmVyKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBQcm9kdWNlcyBhIERPTSBlbGVtZW50IHRvIGJlIGFzc2lnbmVkIHRvIHlvdXIgdmlldy4gRXhwb3NlZCBmb3JcbiAgICAvLyBzdWJjbGFzc2VzIHVzaW5nIGFuIGFsdGVybmF0aXZlIERPTSBtYW5pcHVsYXRpb24gQVBJLlxuICAgIF9jcmVhdGVFbGVtZW50OiBmdW5jdGlvbih0YWdOYW1lKSB7XG4gICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcbiAgICB9LFxuXG4gICAgLy8gRW5zdXJlIHRoYXQgdGhlIFZpZXcgaGFzIGEgRE9NIGVsZW1lbnQgdG8gcmVuZGVyIGludG8uXG4gICAgLy8gSWYgYHRoaXMuZWxgIGlzIGEgc3RyaW5nLCBwYXNzIGl0IHRocm91Z2ggYCQoKWAsIHRha2UgdGhlIGZpcnN0XG4gICAgLy8gbWF0Y2hpbmcgZWxlbWVudCwgYW5kIHJlLWFzc2lnbiBpdCB0byBgZWxgLiBPdGhlcndpc2UsIGNyZWF0ZVxuICAgIC8vIGFuIGVsZW1lbnQgZnJvbSB0aGUgYGlkYCwgYGNsYXNzTmFtZWAgYW5kIGB0YWdOYW1lYCBwcm9wZXJ0aWVzLlxuICAgIF9lbnN1cmVFbGVtZW50OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5lbCkge1xuICAgICAgICB2YXIgYXR0cnMgPSBfLmV4dGVuZCh7fSwgXy5yZXN1bHQodGhpcywgJ2F0dHJpYnV0ZXMnKSk7XG4gICAgICAgIGlmICh0aGlzLmlkKSBhdHRycy5pZCA9IF8ucmVzdWx0KHRoaXMsICdpZCcpO1xuICAgICAgICBpZiAodGhpcy5jbGFzc05hbWUpIGF0dHJzWydjbGFzcyddID0gXy5yZXN1bHQodGhpcywgJ2NsYXNzTmFtZScpO1xuICAgICAgICB0aGlzLnNldEVsZW1lbnQodGhpcy5fY3JlYXRlRWxlbWVudChfLnJlc3VsdCh0aGlzLCAndGFnTmFtZScpKSk7XG4gICAgICAgIHRoaXMuX3NldEF0dHJpYnV0ZXMoYXR0cnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zZXRFbGVtZW50KF8ucmVzdWx0KHRoaXMsICdlbCcpKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gU2V0IGF0dHJpYnV0ZXMgZnJvbSBhIGhhc2ggb24gdGhpcyB2aWV3J3MgZWxlbWVudC4gIEV4cG9zZWQgZm9yXG4gICAgLy8gc3ViY2xhc3NlcyB1c2luZyBhbiBhbHRlcm5hdGl2ZSBET00gbWFuaXB1bGF0aW9uIEFQSS5cbiAgICBfc2V0QXR0cmlidXRlczogZnVuY3Rpb24oYXR0cmlidXRlcykge1xuICAgICAgdGhpcy4kZWwuYXR0cihhdHRyaWJ1dGVzKTtcbiAgICB9XG5cbiAgfSk7XG5cbiAgLy8gQmFja2JvbmUuc3luY1xuICAvLyAtLS0tLS0tLS0tLS0tXG5cbiAgLy8gT3ZlcnJpZGUgdGhpcyBmdW5jdGlvbiB0byBjaGFuZ2UgdGhlIG1hbm5lciBpbiB3aGljaCBCYWNrYm9uZSBwZXJzaXN0c1xuICAvLyBtb2RlbHMgdG8gdGhlIHNlcnZlci4gWW91IHdpbGwgYmUgcGFzc2VkIHRoZSB0eXBlIG9mIHJlcXVlc3QsIGFuZCB0aGVcbiAgLy8gbW9kZWwgaW4gcXVlc3Rpb24uIEJ5IGRlZmF1bHQsIG1ha2VzIGEgUkVTVGZ1bCBBamF4IHJlcXVlc3RcbiAgLy8gdG8gdGhlIG1vZGVsJ3MgYHVybCgpYC4gU29tZSBwb3NzaWJsZSBjdXN0b21pemF0aW9ucyBjb3VsZCBiZTpcbiAgLy9cbiAgLy8gKiBVc2UgYHNldFRpbWVvdXRgIHRvIGJhdGNoIHJhcGlkLWZpcmUgdXBkYXRlcyBpbnRvIGEgc2luZ2xlIHJlcXVlc3QuXG4gIC8vICogU2VuZCB1cCB0aGUgbW9kZWxzIGFzIFhNTCBpbnN0ZWFkIG9mIEpTT04uXG4gIC8vICogUGVyc2lzdCBtb2RlbHMgdmlhIFdlYlNvY2tldHMgaW5zdGVhZCBvZiBBamF4LlxuICAvL1xuICAvLyBUdXJuIG9uIGBCYWNrYm9uZS5lbXVsYXRlSFRUUGAgaW4gb3JkZXIgdG8gc2VuZCBgUFVUYCBhbmQgYERFTEVURWAgcmVxdWVzdHNcbiAgLy8gYXMgYFBPU1RgLCB3aXRoIGEgYF9tZXRob2RgIHBhcmFtZXRlciBjb250YWluaW5nIHRoZSB0cnVlIEhUVFAgbWV0aG9kLFxuICAvLyBhcyB3ZWxsIGFzIGFsbCByZXF1ZXN0cyB3aXRoIHRoZSBib2R5IGFzIGBhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRgXG4gIC8vIGluc3RlYWQgb2YgYGFwcGxpY2F0aW9uL2pzb25gIHdpdGggdGhlIG1vZGVsIGluIGEgcGFyYW0gbmFtZWQgYG1vZGVsYC5cbiAgLy8gVXNlZnVsIHdoZW4gaW50ZXJmYWNpbmcgd2l0aCBzZXJ2ZXItc2lkZSBsYW5ndWFnZXMgbGlrZSAqKlBIUCoqIHRoYXQgbWFrZVxuICAvLyBpdCBkaWZmaWN1bHQgdG8gcmVhZCB0aGUgYm9keSBvZiBgUFVUYCByZXF1ZXN0cy5cbiAgQmFja2JvbmUuc3luYyA9IGZ1bmN0aW9uKG1ldGhvZCwgbW9kZWwsIG9wdGlvbnMpIHtcbiAgICB2YXIgdHlwZSA9IG1ldGhvZE1hcFttZXRob2RdO1xuXG4gICAgLy8gRGVmYXVsdCBvcHRpb25zLCB1bmxlc3Mgc3BlY2lmaWVkLlxuICAgIF8uZGVmYXVsdHMob3B0aW9ucyB8fCAob3B0aW9ucyA9IHt9KSwge1xuICAgICAgZW11bGF0ZUhUVFA6IEJhY2tib25lLmVtdWxhdGVIVFRQLFxuICAgICAgZW11bGF0ZUpTT046IEJhY2tib25lLmVtdWxhdGVKU09OXG4gICAgfSk7XG5cbiAgICAvLyBEZWZhdWx0IEpTT04tcmVxdWVzdCBvcHRpb25zLlxuICAgIHZhciBwYXJhbXMgPSB7dHlwZTogdHlwZSwgZGF0YVR5cGU6ICdqc29uJ307XG5cbiAgICAvLyBFbnN1cmUgdGhhdCB3ZSBoYXZlIGEgVVJMLlxuICAgIGlmICghb3B0aW9ucy51cmwpIHtcbiAgICAgIHBhcmFtcy51cmwgPSBfLnJlc3VsdChtb2RlbCwgJ3VybCcpIHx8IHVybEVycm9yKCk7XG4gICAgfVxuXG4gICAgLy8gRW5zdXJlIHRoYXQgd2UgaGF2ZSB0aGUgYXBwcm9wcmlhdGUgcmVxdWVzdCBkYXRhLlxuICAgIGlmIChvcHRpb25zLmRhdGEgPT0gbnVsbCAmJiBtb2RlbCAmJiAobWV0aG9kID09PSAnY3JlYXRlJyB8fCBtZXRob2QgPT09ICd1cGRhdGUnIHx8IG1ldGhvZCA9PT0gJ3BhdGNoJykpIHtcbiAgICAgIHBhcmFtcy5jb250ZW50VHlwZSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgIHBhcmFtcy5kYXRhID0gSlNPTi5zdHJpbmdpZnkob3B0aW9ucy5hdHRycyB8fCBtb2RlbC50b0pTT04ob3B0aW9ucykpO1xuICAgIH1cblxuICAgIC8vIEZvciBvbGRlciBzZXJ2ZXJzLCBlbXVsYXRlIEpTT04gYnkgZW5jb2RpbmcgdGhlIHJlcXVlc3QgaW50byBhbiBIVE1MLWZvcm0uXG4gICAgaWYgKG9wdGlvbnMuZW11bGF0ZUpTT04pIHtcbiAgICAgIHBhcmFtcy5jb250ZW50VHlwZSA9ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnO1xuICAgICAgcGFyYW1zLmRhdGEgPSBwYXJhbXMuZGF0YSA/IHttb2RlbDogcGFyYW1zLmRhdGF9IDoge307XG4gICAgfVxuXG4gICAgLy8gRm9yIG9sZGVyIHNlcnZlcnMsIGVtdWxhdGUgSFRUUCBieSBtaW1pY2tpbmcgdGhlIEhUVFAgbWV0aG9kIHdpdGggYF9tZXRob2RgXG4gICAgLy8gQW5kIGFuIGBYLUhUVFAtTWV0aG9kLU92ZXJyaWRlYCBoZWFkZXIuXG4gICAgaWYgKG9wdGlvbnMuZW11bGF0ZUhUVFAgJiYgKHR5cGUgPT09ICdQVVQnIHx8IHR5cGUgPT09ICdERUxFVEUnIHx8IHR5cGUgPT09ICdQQVRDSCcpKSB7XG4gICAgICBwYXJhbXMudHlwZSA9ICdQT1NUJztcbiAgICAgIGlmIChvcHRpb25zLmVtdWxhdGVKU09OKSBwYXJhbXMuZGF0YS5fbWV0aG9kID0gdHlwZTtcbiAgICAgIHZhciBiZWZvcmVTZW5kID0gb3B0aW9ucy5iZWZvcmVTZW5kO1xuICAgICAgb3B0aW9ucy5iZWZvcmVTZW5kID0gZnVuY3Rpb24oeGhyKSB7XG4gICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdYLUhUVFAtTWV0aG9kLU92ZXJyaWRlJywgdHlwZSk7XG4gICAgICAgIGlmIChiZWZvcmVTZW5kKSByZXR1cm4gYmVmb3JlU2VuZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBEb24ndCBwcm9jZXNzIGRhdGEgb24gYSBub24tR0VUIHJlcXVlc3QuXG4gICAgaWYgKHBhcmFtcy50eXBlICE9PSAnR0VUJyAmJiAhb3B0aW9ucy5lbXVsYXRlSlNPTikge1xuICAgICAgcGFyYW1zLnByb2Nlc3NEYXRhID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gUGFzcyBhbG9uZyBgdGV4dFN0YXR1c2AgYW5kIGBlcnJvclRocm93bmAgZnJvbSBqUXVlcnkuXG4gICAgdmFyIGVycm9yID0gb3B0aW9ucy5lcnJvcjtcbiAgICBvcHRpb25zLmVycm9yID0gZnVuY3Rpb24oeGhyLCB0ZXh0U3RhdHVzLCBlcnJvclRocm93bikge1xuICAgICAgb3B0aW9ucy50ZXh0U3RhdHVzID0gdGV4dFN0YXR1cztcbiAgICAgIG9wdGlvbnMuZXJyb3JUaHJvd24gPSBlcnJvclRocm93bjtcbiAgICAgIGlmIChlcnJvcikgZXJyb3IuY2FsbChvcHRpb25zLmNvbnRleHQsIHhociwgdGV4dFN0YXR1cywgZXJyb3JUaHJvd24pO1xuICAgIH07XG5cbiAgICAvLyBNYWtlIHRoZSByZXF1ZXN0LCBhbGxvd2luZyB0aGUgdXNlciB0byBvdmVycmlkZSBhbnkgQWpheCBvcHRpb25zLlxuICAgIHZhciB4aHIgPSBvcHRpb25zLnhociA9IEJhY2tib25lLmFqYXgoXy5leHRlbmQocGFyYW1zLCBvcHRpb25zKSk7XG4gICAgbW9kZWwudHJpZ2dlcigncmVxdWVzdCcsIG1vZGVsLCB4aHIsIG9wdGlvbnMpO1xuICAgIHJldHVybiB4aHI7XG4gIH07XG5cbiAgLy8gTWFwIGZyb20gQ1JVRCB0byBIVFRQIGZvciBvdXIgZGVmYXVsdCBgQmFja2JvbmUuc3luY2AgaW1wbGVtZW50YXRpb24uXG4gIHZhciBtZXRob2RNYXAgPSB7XG4gICAgJ2NyZWF0ZSc6ICdQT1NUJyxcbiAgICAndXBkYXRlJzogJ1BVVCcsXG4gICAgJ3BhdGNoJzogJ1BBVENIJyxcbiAgICAnZGVsZXRlJzogJ0RFTEVURScsXG4gICAgJ3JlYWQnOiAnR0VUJ1xuICB9O1xuXG4gIC8vIFNldCB0aGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiBgQmFja2JvbmUuYWpheGAgdG8gcHJveHkgdGhyb3VnaCB0byBgJGAuXG4gIC8vIE92ZXJyaWRlIHRoaXMgaWYgeW91J2QgbGlrZSB0byB1c2UgYSBkaWZmZXJlbnQgbGlicmFyeS5cbiAgQmFja2JvbmUuYWpheCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBCYWNrYm9uZS4kLmFqYXguYXBwbHkoQmFja2JvbmUuJCwgYXJndW1lbnRzKTtcbiAgfTtcblxuICAvLyBCYWNrYm9uZS5Sb3V0ZXJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gUm91dGVycyBtYXAgZmF1eC1VUkxzIHRvIGFjdGlvbnMsIGFuZCBmaXJlIGV2ZW50cyB3aGVuIHJvdXRlcyBhcmVcbiAgLy8gbWF0Y2hlZC4gQ3JlYXRpbmcgYSBuZXcgb25lIHNldHMgaXRzIGByb3V0ZXNgIGhhc2gsIGlmIG5vdCBzZXQgc3RhdGljYWxseS5cbiAgdmFyIFJvdXRlciA9IEJhY2tib25lLlJvdXRlciA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zIHx8IChvcHRpb25zID0ge30pO1xuICAgIGlmIChvcHRpb25zLnJvdXRlcykgdGhpcy5yb3V0ZXMgPSBvcHRpb25zLnJvdXRlcztcbiAgICB0aGlzLl9iaW5kUm91dGVzKCk7XG4gICAgdGhpcy5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG5cbiAgLy8gQ2FjaGVkIHJlZ3VsYXIgZXhwcmVzc2lvbnMgZm9yIG1hdGNoaW5nIG5hbWVkIHBhcmFtIHBhcnRzIGFuZCBzcGxhdHRlZFxuICAvLyBwYXJ0cyBvZiByb3V0ZSBzdHJpbmdzLlxuICB2YXIgb3B0aW9uYWxQYXJhbSA9IC9cXCgoLio/KVxcKS9nO1xuICB2YXIgbmFtZWRQYXJhbSAgICA9IC8oXFwoXFw/KT86XFx3Ky9nO1xuICB2YXIgc3BsYXRQYXJhbSAgICA9IC9cXCpcXHcrL2c7XG4gIHZhciBlc2NhcGVSZWdFeHAgID0gL1tcXC17fVxcW1xcXSs/LixcXFxcXFxeJHwjXFxzXS9nO1xuXG4gIC8vIFNldCB1cCBhbGwgaW5oZXJpdGFibGUgKipCYWNrYm9uZS5Sb3V0ZXIqKiBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzLlxuICBfLmV4dGVuZChSb3V0ZXIucHJvdG90eXBlLCBFdmVudHMsIHtcblxuICAgIC8vIEluaXRpYWxpemUgaXMgYW4gZW1wdHkgZnVuY3Rpb24gYnkgZGVmYXVsdC4gT3ZlcnJpZGUgaXQgd2l0aCB5b3VyIG93blxuICAgIC8vIGluaXRpYWxpemF0aW9uIGxvZ2ljLlxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKCl7fSxcblxuICAgIC8vIE1hbnVhbGx5IGJpbmQgYSBzaW5nbGUgbmFtZWQgcm91dGUgdG8gYSBjYWxsYmFjay4gRm9yIGV4YW1wbGU6XG4gICAgLy9cbiAgICAvLyAgICAgdGhpcy5yb3V0ZSgnc2VhcmNoLzpxdWVyeS9wOm51bScsICdzZWFyY2gnLCBmdW5jdGlvbihxdWVyeSwgbnVtKSB7XG4gICAgLy8gICAgICAgLi4uXG4gICAgLy8gICAgIH0pO1xuICAgIC8vXG4gICAgcm91dGU6IGZ1bmN0aW9uKHJvdXRlLCBuYW1lLCBjYWxsYmFjaykge1xuICAgICAgaWYgKCFfLmlzUmVnRXhwKHJvdXRlKSkgcm91dGUgPSB0aGlzLl9yb3V0ZVRvUmVnRXhwKHJvdXRlKTtcbiAgICAgIGlmIChfLmlzRnVuY3Rpb24obmFtZSkpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBuYW1lO1xuICAgICAgICBuYW1lID0gJyc7XG4gICAgICB9XG4gICAgICBpZiAoIWNhbGxiYWNrKSBjYWxsYmFjayA9IHRoaXNbbmFtZV07XG4gICAgICB2YXIgcm91dGVyID0gdGhpcztcbiAgICAgIEJhY2tib25lLmhpc3Rvcnkucm91dGUocm91dGUsIGZ1bmN0aW9uKGZyYWdtZW50KSB7XG4gICAgICAgIHZhciBhcmdzID0gcm91dGVyLl9leHRyYWN0UGFyYW1ldGVycyhyb3V0ZSwgZnJhZ21lbnQpO1xuICAgICAgICBpZiAocm91dGVyLmV4ZWN1dGUoY2FsbGJhY2ssIGFyZ3MsIG5hbWUpICE9PSBmYWxzZSkge1xuICAgICAgICAgIHJvdXRlci50cmlnZ2VyLmFwcGx5KHJvdXRlciwgWydyb3V0ZTonICsgbmFtZV0uY29uY2F0KGFyZ3MpKTtcbiAgICAgICAgICByb3V0ZXIudHJpZ2dlcigncm91dGUnLCBuYW1lLCBhcmdzKTtcbiAgICAgICAgICBCYWNrYm9uZS5oaXN0b3J5LnRyaWdnZXIoJ3JvdXRlJywgcm91dGVyLCBuYW1lLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gRXhlY3V0ZSBhIHJvdXRlIGhhbmRsZXIgd2l0aCB0aGUgcHJvdmlkZWQgcGFyYW1ldGVycy4gIFRoaXMgaXMgYW5cbiAgICAvLyBleGNlbGxlbnQgcGxhY2UgdG8gZG8gcHJlLXJvdXRlIHNldHVwIG9yIHBvc3Qtcm91dGUgY2xlYW51cC5cbiAgICBleGVjdXRlOiBmdW5jdGlvbihjYWxsYmFjaywgYXJncywgbmFtZSkge1xuICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9LFxuXG4gICAgLy8gU2ltcGxlIHByb3h5IHRvIGBCYWNrYm9uZS5oaXN0b3J5YCB0byBzYXZlIGEgZnJhZ21lbnQgaW50byB0aGUgaGlzdG9yeS5cbiAgICBuYXZpZ2F0ZTogZnVuY3Rpb24oZnJhZ21lbnQsIG9wdGlvbnMpIHtcbiAgICAgIEJhY2tib25lLmhpc3RvcnkubmF2aWdhdGUoZnJhZ21lbnQsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIEJpbmQgYWxsIGRlZmluZWQgcm91dGVzIHRvIGBCYWNrYm9uZS5oaXN0b3J5YC4gV2UgaGF2ZSB0byByZXZlcnNlIHRoZVxuICAgIC8vIG9yZGVyIG9mIHRoZSByb3V0ZXMgaGVyZSB0byBzdXBwb3J0IGJlaGF2aW9yIHdoZXJlIHRoZSBtb3N0IGdlbmVyYWxcbiAgICAvLyByb3V0ZXMgY2FuIGJlIGRlZmluZWQgYXQgdGhlIGJvdHRvbSBvZiB0aGUgcm91dGUgbWFwLlxuICAgIF9iaW5kUm91dGVzOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5yb3V0ZXMpIHJldHVybjtcbiAgICAgIHRoaXMucm91dGVzID0gXy5yZXN1bHQodGhpcywgJ3JvdXRlcycpO1xuICAgICAgdmFyIHJvdXRlLCByb3V0ZXMgPSBfLmtleXModGhpcy5yb3V0ZXMpO1xuICAgICAgd2hpbGUgKChyb3V0ZSA9IHJvdXRlcy5wb3AoKSkgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLnJvdXRlKHJvdXRlLCB0aGlzLnJvdXRlc1tyb3V0ZV0pO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBDb252ZXJ0IGEgcm91dGUgc3RyaW5nIGludG8gYSByZWd1bGFyIGV4cHJlc3Npb24sIHN1aXRhYmxlIGZvciBtYXRjaGluZ1xuICAgIC8vIGFnYWluc3QgdGhlIGN1cnJlbnQgbG9jYXRpb24gaGFzaC5cbiAgICBfcm91dGVUb1JlZ0V4cDogZnVuY3Rpb24ocm91dGUpIHtcbiAgICAgIHJvdXRlID0gcm91dGUucmVwbGFjZShlc2NhcGVSZWdFeHAsICdcXFxcJCYnKVxuICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKG9wdGlvbmFsUGFyYW0sICcoPzokMSk/JylcbiAgICAgICAgICAgICAgICAgICAucmVwbGFjZShuYW1lZFBhcmFtLCBmdW5jdGlvbihtYXRjaCwgb3B0aW9uYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25hbCA/IG1hdGNoIDogJyhbXi8/XSspJztcbiAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKHNwbGF0UGFyYW0sICcoW14/XSo/KScpO1xuICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoJ14nICsgcm91dGUgKyAnKD86XFxcXD8oW1xcXFxzXFxcXFNdKikpPyQnKTtcbiAgICB9LFxuXG4gICAgLy8gR2l2ZW4gYSByb3V0ZSwgYW5kIGEgVVJMIGZyYWdtZW50IHRoYXQgaXQgbWF0Y2hlcywgcmV0dXJuIHRoZSBhcnJheSBvZlxuICAgIC8vIGV4dHJhY3RlZCBkZWNvZGVkIHBhcmFtZXRlcnMuIEVtcHR5IG9yIHVubWF0Y2hlZCBwYXJhbWV0ZXJzIHdpbGwgYmVcbiAgICAvLyB0cmVhdGVkIGFzIGBudWxsYCB0byBub3JtYWxpemUgY3Jvc3MtYnJvd3NlciBiZWhhdmlvci5cbiAgICBfZXh0cmFjdFBhcmFtZXRlcnM6IGZ1bmN0aW9uKHJvdXRlLCBmcmFnbWVudCkge1xuICAgICAgdmFyIHBhcmFtcyA9IHJvdXRlLmV4ZWMoZnJhZ21lbnQpLnNsaWNlKDEpO1xuICAgICAgcmV0dXJuIF8ubWFwKHBhcmFtcywgZnVuY3Rpb24ocGFyYW0sIGkpIHtcbiAgICAgICAgLy8gRG9uJ3QgZGVjb2RlIHRoZSBzZWFyY2ggcGFyYW1zLlxuICAgICAgICBpZiAoaSA9PT0gcGFyYW1zLmxlbmd0aCAtIDEpIHJldHVybiBwYXJhbSB8fCBudWxsO1xuICAgICAgICByZXR1cm4gcGFyYW0gPyBkZWNvZGVVUklDb21wb25lbnQocGFyYW0pIDogbnVsbDtcbiAgICAgIH0pO1xuICAgIH1cblxuICB9KTtcblxuICAvLyBCYWNrYm9uZS5IaXN0b3J5XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBIYW5kbGVzIGNyb3NzLWJyb3dzZXIgaGlzdG9yeSBtYW5hZ2VtZW50LCBiYXNlZCBvbiBlaXRoZXJcbiAgLy8gW3B1c2hTdGF0ZV0oaHR0cDovL2RpdmVpbnRvaHRtbDUuaW5mby9oaXN0b3J5Lmh0bWwpIGFuZCByZWFsIFVSTHMsIG9yXG4gIC8vIFtvbmhhc2hjaGFuZ2VdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvRE9NL3dpbmRvdy5vbmhhc2hjaGFuZ2UpXG4gIC8vIGFuZCBVUkwgZnJhZ21lbnRzLiBJZiB0aGUgYnJvd3NlciBzdXBwb3J0cyBuZWl0aGVyIChvbGQgSUUsIG5hdGNoKSxcbiAgLy8gZmFsbHMgYmFjayB0byBwb2xsaW5nLlxuICB2YXIgSGlzdG9yeSA9IEJhY2tib25lLkhpc3RvcnkgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmhhbmRsZXJzID0gW107XG4gICAgdGhpcy5jaGVja1VybCA9IF8uYmluZCh0aGlzLmNoZWNrVXJsLCB0aGlzKTtcblxuICAgIC8vIEVuc3VyZSB0aGF0IGBIaXN0b3J5YCBjYW4gYmUgdXNlZCBvdXRzaWRlIG9mIHRoZSBicm93c2VyLlxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5sb2NhdGlvbiA9IHdpbmRvdy5sb2NhdGlvbjtcbiAgICAgIHRoaXMuaGlzdG9yeSA9IHdpbmRvdy5oaXN0b3J5O1xuICAgIH1cbiAgfTtcblxuICAvLyBDYWNoZWQgcmVnZXggZm9yIHN0cmlwcGluZyBhIGxlYWRpbmcgaGFzaC9zbGFzaCBhbmQgdHJhaWxpbmcgc3BhY2UuXG4gIHZhciByb3V0ZVN0cmlwcGVyID0gL15bI1xcL118XFxzKyQvZztcblxuICAvLyBDYWNoZWQgcmVnZXggZm9yIHN0cmlwcGluZyBsZWFkaW5nIGFuZCB0cmFpbGluZyBzbGFzaGVzLlxuICB2YXIgcm9vdFN0cmlwcGVyID0gL15cXC8rfFxcLyskL2c7XG5cbiAgLy8gQ2FjaGVkIHJlZ2V4IGZvciBzdHJpcHBpbmcgdXJscyBvZiBoYXNoLlxuICB2YXIgcGF0aFN0cmlwcGVyID0gLyMuKiQvO1xuXG4gIC8vIEhhcyB0aGUgaGlzdG9yeSBoYW5kbGluZyBhbHJlYWR5IGJlZW4gc3RhcnRlZD9cbiAgSGlzdG9yeS5zdGFydGVkID0gZmFsc2U7XG5cbiAgLy8gU2V0IHVwIGFsbCBpbmhlcml0YWJsZSAqKkJhY2tib25lLkhpc3RvcnkqKiBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzLlxuICBfLmV4dGVuZChIaXN0b3J5LnByb3RvdHlwZSwgRXZlbnRzLCB7XG5cbiAgICAvLyBUaGUgZGVmYXVsdCBpbnRlcnZhbCB0byBwb2xsIGZvciBoYXNoIGNoYW5nZXMsIGlmIG5lY2Vzc2FyeSwgaXNcbiAgICAvLyB0d2VudHkgdGltZXMgYSBzZWNvbmQuXG4gICAgaW50ZXJ2YWw6IDUwLFxuXG4gICAgLy8gQXJlIHdlIGF0IHRoZSBhcHAgcm9vdD9cbiAgICBhdFJvb3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHBhdGggPSB0aGlzLmxvY2F0aW9uLnBhdGhuYW1lLnJlcGxhY2UoL1teXFwvXSQvLCAnJCYvJyk7XG4gICAgICByZXR1cm4gcGF0aCA9PT0gdGhpcy5yb290ICYmICF0aGlzLmdldFNlYXJjaCgpO1xuICAgIH0sXG5cbiAgICAvLyBEb2VzIHRoZSBwYXRobmFtZSBtYXRjaCB0aGUgcm9vdD9cbiAgICBtYXRjaFJvb3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHBhdGggPSB0aGlzLmRlY29kZUZyYWdtZW50KHRoaXMubG9jYXRpb24ucGF0aG5hbWUpO1xuICAgICAgdmFyIHJvb3RQYXRoID0gcGF0aC5zbGljZSgwLCB0aGlzLnJvb3QubGVuZ3RoIC0gMSkgKyAnLyc7XG4gICAgICByZXR1cm4gcm9vdFBhdGggPT09IHRoaXMucm9vdDtcbiAgICB9LFxuXG4gICAgLy8gVW5pY29kZSBjaGFyYWN0ZXJzIGluIGBsb2NhdGlvbi5wYXRobmFtZWAgYXJlIHBlcmNlbnQgZW5jb2RlZCBzbyB0aGV5J3JlXG4gICAgLy8gZGVjb2RlZCBmb3IgY29tcGFyaXNvbi4gYCUyNWAgc2hvdWxkIG5vdCBiZSBkZWNvZGVkIHNpbmNlIGl0IG1heSBiZSBwYXJ0XG4gICAgLy8gb2YgYW4gZW5jb2RlZCBwYXJhbWV0ZXIuXG4gICAgZGVjb2RlRnJhZ21lbnQ6IGZ1bmN0aW9uKGZyYWdtZW50KSB7XG4gICAgICByZXR1cm4gZGVjb2RlVVJJKGZyYWdtZW50LnJlcGxhY2UoLyUyNS9nLCAnJTI1MjUnKSk7XG4gICAgfSxcblxuICAgIC8vIEluIElFNiwgdGhlIGhhc2ggZnJhZ21lbnQgYW5kIHNlYXJjaCBwYXJhbXMgYXJlIGluY29ycmVjdCBpZiB0aGVcbiAgICAvLyBmcmFnbWVudCBjb250YWlucyBgP2AuXG4gICAgZ2V0U2VhcmNoOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBtYXRjaCA9IHRoaXMubG9jYXRpb24uaHJlZi5yZXBsYWNlKC8jLiovLCAnJykubWF0Y2goL1xcPy4rLyk7XG4gICAgICByZXR1cm4gbWF0Y2ggPyBtYXRjaFswXSA6ICcnO1xuICAgIH0sXG5cbiAgICAvLyBHZXRzIHRoZSB0cnVlIGhhc2ggdmFsdWUuIENhbm5vdCB1c2UgbG9jYXRpb24uaGFzaCBkaXJlY3RseSBkdWUgdG8gYnVnXG4gICAgLy8gaW4gRmlyZWZveCB3aGVyZSBsb2NhdGlvbi5oYXNoIHdpbGwgYWx3YXlzIGJlIGRlY29kZWQuXG4gICAgZ2V0SGFzaDogZnVuY3Rpb24od2luZG93KSB7XG4gICAgICB2YXIgbWF0Y2ggPSAod2luZG93IHx8IHRoaXMpLmxvY2F0aW9uLmhyZWYubWF0Y2goLyMoLiopJC8pO1xuICAgICAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMV0gOiAnJztcbiAgICB9LFxuXG4gICAgLy8gR2V0IHRoZSBwYXRobmFtZSBhbmQgc2VhcmNoIHBhcmFtcywgd2l0aG91dCB0aGUgcm9vdC5cbiAgICBnZXRQYXRoOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwYXRoID0gdGhpcy5kZWNvZGVGcmFnbWVudChcbiAgICAgICAgdGhpcy5sb2NhdGlvbi5wYXRobmFtZSArIHRoaXMuZ2V0U2VhcmNoKClcbiAgICAgICkuc2xpY2UodGhpcy5yb290Lmxlbmd0aCAtIDEpO1xuICAgICAgcmV0dXJuIHBhdGguY2hhckF0KDApID09PSAnLycgPyBwYXRoLnNsaWNlKDEpIDogcGF0aDtcbiAgICB9LFxuXG4gICAgLy8gR2V0IHRoZSBjcm9zcy1icm93c2VyIG5vcm1hbGl6ZWQgVVJMIGZyYWdtZW50IGZyb20gdGhlIHBhdGggb3IgaGFzaC5cbiAgICBnZXRGcmFnbWVudDogZnVuY3Rpb24oZnJhZ21lbnQpIHtcbiAgICAgIGlmIChmcmFnbWVudCA9PSBudWxsKSB7XG4gICAgICAgIGlmICh0aGlzLl91c2VQdXNoU3RhdGUgfHwgIXRoaXMuX3dhbnRzSGFzaENoYW5nZSkge1xuICAgICAgICAgIGZyYWdtZW50ID0gdGhpcy5nZXRQYXRoKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZnJhZ21lbnQgPSB0aGlzLmdldEhhc2goKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZyYWdtZW50LnJlcGxhY2Uocm91dGVTdHJpcHBlciwgJycpO1xuICAgIH0sXG5cbiAgICAvLyBTdGFydCB0aGUgaGFzaCBjaGFuZ2UgaGFuZGxpbmcsIHJldHVybmluZyBgdHJ1ZWAgaWYgdGhlIGN1cnJlbnQgVVJMIG1hdGNoZXNcbiAgICAvLyBhbiBleGlzdGluZyByb3V0ZSwgYW5kIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgIHN0YXJ0OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBpZiAoSGlzdG9yeS5zdGFydGVkKSB0aHJvdyBuZXcgRXJyb3IoJ0JhY2tib25lLmhpc3RvcnkgaGFzIGFscmVhZHkgYmVlbiBzdGFydGVkJyk7XG4gICAgICBIaXN0b3J5LnN0YXJ0ZWQgPSB0cnVlO1xuXG4gICAgICAvLyBGaWd1cmUgb3V0IHRoZSBpbml0aWFsIGNvbmZpZ3VyYXRpb24uIERvIHdlIG5lZWQgYW4gaWZyYW1lP1xuICAgICAgLy8gSXMgcHVzaFN0YXRlIGRlc2lyZWQgLi4uIGlzIGl0IGF2YWlsYWJsZT9cbiAgICAgIHRoaXMub3B0aW9ucyAgICAgICAgICA9IF8uZXh0ZW5kKHtyb290OiAnLyd9LCB0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5yb290ICAgICAgICAgICAgID0gdGhpcy5vcHRpb25zLnJvb3Q7XG4gICAgICB0aGlzLl93YW50c0hhc2hDaGFuZ2UgPSB0aGlzLm9wdGlvbnMuaGFzaENoYW5nZSAhPT0gZmFsc2U7XG4gICAgICB0aGlzLl9oYXNIYXNoQ2hhbmdlICAgPSAnb25oYXNoY2hhbmdlJyBpbiB3aW5kb3cgJiYgKGRvY3VtZW50LmRvY3VtZW50TW9kZSA9PT0gdm9pZCAwIHx8IGRvY3VtZW50LmRvY3VtZW50TW9kZSA+IDcpO1xuICAgICAgdGhpcy5fdXNlSGFzaENoYW5nZSAgID0gdGhpcy5fd2FudHNIYXNoQ2hhbmdlICYmIHRoaXMuX2hhc0hhc2hDaGFuZ2U7XG4gICAgICB0aGlzLl93YW50c1B1c2hTdGF0ZSAgPSAhIXRoaXMub3B0aW9ucy5wdXNoU3RhdGU7XG4gICAgICB0aGlzLl9oYXNQdXNoU3RhdGUgICAgPSAhISh0aGlzLmhpc3RvcnkgJiYgdGhpcy5oaXN0b3J5LnB1c2hTdGF0ZSk7XG4gICAgICB0aGlzLl91c2VQdXNoU3RhdGUgICAgPSB0aGlzLl93YW50c1B1c2hTdGF0ZSAmJiB0aGlzLl9oYXNQdXNoU3RhdGU7XG4gICAgICB0aGlzLmZyYWdtZW50ICAgICAgICAgPSB0aGlzLmdldEZyYWdtZW50KCk7XG5cbiAgICAgIC8vIE5vcm1hbGl6ZSByb290IHRvIGFsd2F5cyBpbmNsdWRlIGEgbGVhZGluZyBhbmQgdHJhaWxpbmcgc2xhc2guXG4gICAgICB0aGlzLnJvb3QgPSAoJy8nICsgdGhpcy5yb290ICsgJy8nKS5yZXBsYWNlKHJvb3RTdHJpcHBlciwgJy8nKTtcblxuICAgICAgLy8gVHJhbnNpdGlvbiBmcm9tIGhhc2hDaGFuZ2UgdG8gcHVzaFN0YXRlIG9yIHZpY2UgdmVyc2EgaWYgYm90aCBhcmVcbiAgICAgIC8vIHJlcXVlc3RlZC5cbiAgICAgIGlmICh0aGlzLl93YW50c0hhc2hDaGFuZ2UgJiYgdGhpcy5fd2FudHNQdXNoU3RhdGUpIHtcblxuICAgICAgICAvLyBJZiB3ZSd2ZSBzdGFydGVkIG9mZiB3aXRoIGEgcm91dGUgZnJvbSBhIGBwdXNoU3RhdGVgLWVuYWJsZWRcbiAgICAgICAgLy8gYnJvd3NlciwgYnV0IHdlJ3JlIGN1cnJlbnRseSBpbiBhIGJyb3dzZXIgdGhhdCBkb2Vzbid0IHN1cHBvcnQgaXQuLi5cbiAgICAgICAgaWYgKCF0aGlzLl9oYXNQdXNoU3RhdGUgJiYgIXRoaXMuYXRSb290KCkpIHtcbiAgICAgICAgICB2YXIgcm9vdFBhdGggPSB0aGlzLnJvb3Quc2xpY2UoMCwgLTEpIHx8ICcvJztcbiAgICAgICAgICB0aGlzLmxvY2F0aW9uLnJlcGxhY2Uocm9vdFBhdGggKyAnIycgKyB0aGlzLmdldFBhdGgoKSk7XG4gICAgICAgICAgLy8gUmV0dXJuIGltbWVkaWF0ZWx5IGFzIGJyb3dzZXIgd2lsbCBkbyByZWRpcmVjdCB0byBuZXcgdXJsXG4gICAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgLy8gT3IgaWYgd2UndmUgc3RhcnRlZCBvdXQgd2l0aCBhIGhhc2gtYmFzZWQgcm91dGUsIGJ1dCB3ZSdyZSBjdXJyZW50bHlcbiAgICAgICAgLy8gaW4gYSBicm93c2VyIHdoZXJlIGl0IGNvdWxkIGJlIGBwdXNoU3RhdGVgLWJhc2VkIGluc3RlYWQuLi5cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9oYXNQdXNoU3RhdGUgJiYgdGhpcy5hdFJvb3QoKSkge1xuICAgICAgICAgIHRoaXMubmF2aWdhdGUodGhpcy5nZXRIYXNoKCksIHtyZXBsYWNlOiB0cnVlfSk7XG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgICAvLyBQcm94eSBhbiBpZnJhbWUgdG8gaGFuZGxlIGxvY2F0aW9uIGV2ZW50cyBpZiB0aGUgYnJvd3NlciBkb2Vzbid0XG4gICAgICAvLyBzdXBwb3J0IHRoZSBgaGFzaGNoYW5nZWAgZXZlbnQsIEhUTUw1IGhpc3RvcnksIG9yIHRoZSB1c2VyIHdhbnRzXG4gICAgICAvLyBgaGFzaENoYW5nZWAgYnV0IG5vdCBgcHVzaFN0YXRlYC5cbiAgICAgIGlmICghdGhpcy5faGFzSGFzaENoYW5nZSAmJiB0aGlzLl93YW50c0hhc2hDaGFuZ2UgJiYgIXRoaXMuX3VzZVB1c2hTdGF0ZSkge1xuICAgICAgICB0aGlzLmlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgICAgICB0aGlzLmlmcmFtZS5zcmMgPSAnamF2YXNjcmlwdDowJztcbiAgICAgICAgdGhpcy5pZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgdGhpcy5pZnJhbWUudGFiSW5kZXggPSAtMTtcbiAgICAgICAgdmFyIGJvZHkgPSBkb2N1bWVudC5ib2R5O1xuICAgICAgICAvLyBVc2luZyBgYXBwZW5kQ2hpbGRgIHdpbGwgdGhyb3cgb24gSUUgPCA5IGlmIHRoZSBkb2N1bWVudCBpcyBub3QgcmVhZHkuXG4gICAgICAgIHZhciBpV2luZG93ID0gYm9keS5pbnNlcnRCZWZvcmUodGhpcy5pZnJhbWUsIGJvZHkuZmlyc3RDaGlsZCkuY29udGVudFdpbmRvdztcbiAgICAgICAgaVdpbmRvdy5kb2N1bWVudC5vcGVuKCk7XG4gICAgICAgIGlXaW5kb3cuZG9jdW1lbnQuY2xvc2UoKTtcbiAgICAgICAgaVdpbmRvdy5sb2NhdGlvbi5oYXNoID0gJyMnICsgdGhpcy5mcmFnbWVudDtcbiAgICAgIH1cblxuICAgICAgLy8gQWRkIGEgY3Jvc3MtcGxhdGZvcm0gYGFkZEV2ZW50TGlzdGVuZXJgIHNoaW0gZm9yIG9sZGVyIGJyb3dzZXJzLlxuICAgICAgdmFyIGFkZEV2ZW50TGlzdGVuZXIgPSB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciB8fCBmdW5jdGlvbihldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiBhdHRhY2hFdmVudCgnb24nICsgZXZlbnROYW1lLCBsaXN0ZW5lcik7XG4gICAgICB9O1xuXG4gICAgICAvLyBEZXBlbmRpbmcgb24gd2hldGhlciB3ZSdyZSB1c2luZyBwdXNoU3RhdGUgb3IgaGFzaGVzLCBhbmQgd2hldGhlclxuICAgICAgLy8gJ29uaGFzaGNoYW5nZScgaXMgc3VwcG9ydGVkLCBkZXRlcm1pbmUgaG93IHdlIGNoZWNrIHRoZSBVUkwgc3RhdGUuXG4gICAgICBpZiAodGhpcy5fdXNlUHVzaFN0YXRlKSB7XG4gICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoJ3BvcHN0YXRlJywgdGhpcy5jaGVja1VybCwgZmFsc2UpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl91c2VIYXNoQ2hhbmdlICYmICF0aGlzLmlmcmFtZSkge1xuICAgICAgICBhZGRFdmVudExpc3RlbmVyKCdoYXNoY2hhbmdlJywgdGhpcy5jaGVja1VybCwgZmFsc2UpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl93YW50c0hhc2hDaGFuZ2UpIHtcbiAgICAgICAgdGhpcy5fY2hlY2tVcmxJbnRlcnZhbCA9IHNldEludGVydmFsKHRoaXMuY2hlY2tVcmwsIHRoaXMuaW50ZXJ2YWwpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5zaWxlbnQpIHJldHVybiB0aGlzLmxvYWRVcmwoKTtcbiAgICB9LFxuXG4gICAgLy8gRGlzYWJsZSBCYWNrYm9uZS5oaXN0b3J5LCBwZXJoYXBzIHRlbXBvcmFyaWx5LiBOb3QgdXNlZnVsIGluIGEgcmVhbCBhcHAsXG4gICAgLy8gYnV0IHBvc3NpYmx5IHVzZWZ1bCBmb3IgdW5pdCB0ZXN0aW5nIFJvdXRlcnMuXG4gICAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICAvLyBBZGQgYSBjcm9zcy1wbGF0Zm9ybSBgcmVtb3ZlRXZlbnRMaXN0ZW5lcmAgc2hpbSBmb3Igb2xkZXIgYnJvd3NlcnMuXG4gICAgICB2YXIgcmVtb3ZlRXZlbnRMaXN0ZW5lciA9IHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyIHx8IGZ1bmN0aW9uKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIGRldGFjaEV2ZW50KCdvbicgKyBldmVudE5hbWUsIGxpc3RlbmVyKTtcbiAgICAgIH07XG5cbiAgICAgIC8vIFJlbW92ZSB3aW5kb3cgbGlzdGVuZXJzLlxuICAgICAgaWYgKHRoaXMuX3VzZVB1c2hTdGF0ZSkge1xuICAgICAgICByZW1vdmVFdmVudExpc3RlbmVyKCdwb3BzdGF0ZScsIHRoaXMuY2hlY2tVcmwsIGZhbHNlKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fdXNlSGFzaENoYW5nZSAmJiAhdGhpcy5pZnJhbWUpIHtcbiAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcignaGFzaGNoYW5nZScsIHRoaXMuY2hlY2tVcmwsIGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2xlYW4gdXAgdGhlIGlmcmFtZSBpZiBuZWNlc3NhcnkuXG4gICAgICBpZiAodGhpcy5pZnJhbWUpIHtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCh0aGlzLmlmcmFtZSk7XG4gICAgICAgIHRoaXMuaWZyYW1lID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLy8gU29tZSBlbnZpcm9ubWVudHMgd2lsbCB0aHJvdyB3aGVuIGNsZWFyaW5nIGFuIHVuZGVmaW5lZCBpbnRlcnZhbC5cbiAgICAgIGlmICh0aGlzLl9jaGVja1VybEludGVydmFsKSBjbGVhckludGVydmFsKHRoaXMuX2NoZWNrVXJsSW50ZXJ2YWwpO1xuICAgICAgSGlzdG9yeS5zdGFydGVkID0gZmFsc2U7XG4gICAgfSxcblxuICAgIC8vIEFkZCBhIHJvdXRlIHRvIGJlIHRlc3RlZCB3aGVuIHRoZSBmcmFnbWVudCBjaGFuZ2VzLiBSb3V0ZXMgYWRkZWQgbGF0ZXJcbiAgICAvLyBtYXkgb3ZlcnJpZGUgcHJldmlvdXMgcm91dGVzLlxuICAgIHJvdXRlOiBmdW5jdGlvbihyb3V0ZSwgY2FsbGJhY2spIHtcbiAgICAgIHRoaXMuaGFuZGxlcnMudW5zaGlmdCh7cm91dGU6IHJvdXRlLCBjYWxsYmFjazogY2FsbGJhY2t9KTtcbiAgICB9LFxuXG4gICAgLy8gQ2hlY2tzIHRoZSBjdXJyZW50IFVSTCB0byBzZWUgaWYgaXQgaGFzIGNoYW5nZWQsIGFuZCBpZiBpdCBoYXMsXG4gICAgLy8gY2FsbHMgYGxvYWRVcmxgLCBub3JtYWxpemluZyBhY3Jvc3MgdGhlIGhpZGRlbiBpZnJhbWUuXG4gICAgY2hlY2tVcmw6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5nZXRGcmFnbWVudCgpO1xuXG4gICAgICAvLyBJZiB0aGUgdXNlciBwcmVzc2VkIHRoZSBiYWNrIGJ1dHRvbiwgdGhlIGlmcmFtZSdzIGhhc2ggd2lsbCBoYXZlXG4gICAgICAvLyBjaGFuZ2VkIGFuZCB3ZSBzaG91bGQgdXNlIHRoYXQgZm9yIGNvbXBhcmlzb24uXG4gICAgICBpZiAoY3VycmVudCA9PT0gdGhpcy5mcmFnbWVudCAmJiB0aGlzLmlmcmFtZSkge1xuICAgICAgICBjdXJyZW50ID0gdGhpcy5nZXRIYXNoKHRoaXMuaWZyYW1lLmNvbnRlbnRXaW5kb3cpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY3VycmVudCA9PT0gdGhpcy5mcmFnbWVudCkgcmV0dXJuIGZhbHNlO1xuICAgICAgaWYgKHRoaXMuaWZyYW1lKSB0aGlzLm5hdmlnYXRlKGN1cnJlbnQpO1xuICAgICAgdGhpcy5sb2FkVXJsKCk7XG4gICAgfSxcblxuICAgIC8vIEF0dGVtcHQgdG8gbG9hZCB0aGUgY3VycmVudCBVUkwgZnJhZ21lbnQuIElmIGEgcm91dGUgc3VjY2VlZHMgd2l0aCBhXG4gICAgLy8gbWF0Y2gsIHJldHVybnMgYHRydWVgLiBJZiBubyBkZWZpbmVkIHJvdXRlcyBtYXRjaGVzIHRoZSBmcmFnbWVudCxcbiAgICAvLyByZXR1cm5zIGBmYWxzZWAuXG4gICAgbG9hZFVybDogZnVuY3Rpb24oZnJhZ21lbnQpIHtcbiAgICAgIC8vIElmIHRoZSByb290IGRvZXNuJ3QgbWF0Y2gsIG5vIHJvdXRlcyBjYW4gbWF0Y2ggZWl0aGVyLlxuICAgICAgaWYgKCF0aGlzLm1hdGNoUm9vdCgpKSByZXR1cm4gZmFsc2U7XG4gICAgICBmcmFnbWVudCA9IHRoaXMuZnJhZ21lbnQgPSB0aGlzLmdldEZyYWdtZW50KGZyYWdtZW50KTtcbiAgICAgIHJldHVybiBfLnNvbWUodGhpcy5oYW5kbGVycywgZnVuY3Rpb24oaGFuZGxlcikge1xuICAgICAgICBpZiAoaGFuZGxlci5yb3V0ZS50ZXN0KGZyYWdtZW50KSkge1xuICAgICAgICAgIGhhbmRsZXIuY2FsbGJhY2soZnJhZ21lbnQpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgLy8gU2F2ZSBhIGZyYWdtZW50IGludG8gdGhlIGhhc2ggaGlzdG9yeSwgb3IgcmVwbGFjZSB0aGUgVVJMIHN0YXRlIGlmIHRoZVxuICAgIC8vICdyZXBsYWNlJyBvcHRpb24gaXMgcGFzc2VkLiBZb3UgYXJlIHJlc3BvbnNpYmxlIGZvciBwcm9wZXJseSBVUkwtZW5jb2RpbmdcbiAgICAvLyB0aGUgZnJhZ21lbnQgaW4gYWR2YW5jZS5cbiAgICAvL1xuICAgIC8vIFRoZSBvcHRpb25zIG9iamVjdCBjYW4gY29udGFpbiBgdHJpZ2dlcjogdHJ1ZWAgaWYgeW91IHdpc2ggdG8gaGF2ZSB0aGVcbiAgICAvLyByb3V0ZSBjYWxsYmFjayBiZSBmaXJlZCAobm90IHVzdWFsbHkgZGVzaXJhYmxlKSwgb3IgYHJlcGxhY2U6IHRydWVgLCBpZlxuICAgIC8vIHlvdSB3aXNoIHRvIG1vZGlmeSB0aGUgY3VycmVudCBVUkwgd2l0aG91dCBhZGRpbmcgYW4gZW50cnkgdG8gdGhlIGhpc3RvcnkuXG4gICAgbmF2aWdhdGU6IGZ1bmN0aW9uKGZyYWdtZW50LCBvcHRpb25zKSB7XG4gICAgICBpZiAoIUhpc3Rvcnkuc3RhcnRlZCkgcmV0dXJuIGZhbHNlO1xuICAgICAgaWYgKCFvcHRpb25zIHx8IG9wdGlvbnMgPT09IHRydWUpIG9wdGlvbnMgPSB7dHJpZ2dlcjogISFvcHRpb25zfTtcblxuICAgICAgLy8gTm9ybWFsaXplIHRoZSBmcmFnbWVudC5cbiAgICAgIGZyYWdtZW50ID0gdGhpcy5nZXRGcmFnbWVudChmcmFnbWVudCB8fCAnJyk7XG5cbiAgICAgIC8vIERvbid0IGluY2x1ZGUgYSB0cmFpbGluZyBzbGFzaCBvbiB0aGUgcm9vdC5cbiAgICAgIHZhciByb290UGF0aCA9IHRoaXMucm9vdDtcbiAgICAgIGlmIChmcmFnbWVudCA9PT0gJycgfHwgZnJhZ21lbnQuY2hhckF0KDApID09PSAnPycpIHtcbiAgICAgICAgcm9vdFBhdGggPSByb290UGF0aC5zbGljZSgwLCAtMSkgfHwgJy8nO1xuICAgICAgfVxuICAgICAgdmFyIHVybCA9IHJvb3RQYXRoICsgZnJhZ21lbnQ7XG5cbiAgICAgIC8vIFN0cmlwIHRoZSBoYXNoIGFuZCBkZWNvZGUgZm9yIG1hdGNoaW5nLlxuICAgICAgZnJhZ21lbnQgPSB0aGlzLmRlY29kZUZyYWdtZW50KGZyYWdtZW50LnJlcGxhY2UocGF0aFN0cmlwcGVyLCAnJykpO1xuXG4gICAgICBpZiAodGhpcy5mcmFnbWVudCA9PT0gZnJhZ21lbnQpIHJldHVybjtcbiAgICAgIHRoaXMuZnJhZ21lbnQgPSBmcmFnbWVudDtcblxuICAgICAgLy8gSWYgcHVzaFN0YXRlIGlzIGF2YWlsYWJsZSwgd2UgdXNlIGl0IHRvIHNldCB0aGUgZnJhZ21lbnQgYXMgYSByZWFsIFVSTC5cbiAgICAgIGlmICh0aGlzLl91c2VQdXNoU3RhdGUpIHtcbiAgICAgICAgdGhpcy5oaXN0b3J5W29wdGlvbnMucmVwbGFjZSA/ICdyZXBsYWNlU3RhdGUnIDogJ3B1c2hTdGF0ZSddKHt9LCBkb2N1bWVudC50aXRsZSwgdXJsKTtcblxuICAgICAgLy8gSWYgaGFzaCBjaGFuZ2VzIGhhdmVuJ3QgYmVlbiBleHBsaWNpdGx5IGRpc2FibGVkLCB1cGRhdGUgdGhlIGhhc2hcbiAgICAgIC8vIGZyYWdtZW50IHRvIHN0b3JlIGhpc3RvcnkuXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX3dhbnRzSGFzaENoYW5nZSkge1xuICAgICAgICB0aGlzLl91cGRhdGVIYXNoKHRoaXMubG9jYXRpb24sIGZyYWdtZW50LCBvcHRpb25zLnJlcGxhY2UpO1xuICAgICAgICBpZiAodGhpcy5pZnJhbWUgJiYgZnJhZ21lbnQgIT09IHRoaXMuZ2V0SGFzaCh0aGlzLmlmcmFtZS5jb250ZW50V2luZG93KSkge1xuICAgICAgICAgIHZhciBpV2luZG93ID0gdGhpcy5pZnJhbWUuY29udGVudFdpbmRvdztcblxuICAgICAgICAgIC8vIE9wZW5pbmcgYW5kIGNsb3NpbmcgdGhlIGlmcmFtZSB0cmlja3MgSUU3IGFuZCBlYXJsaWVyIHRvIHB1c2ggYVxuICAgICAgICAgIC8vIGhpc3RvcnkgZW50cnkgb24gaGFzaC10YWcgY2hhbmdlLiAgV2hlbiByZXBsYWNlIGlzIHRydWUsIHdlIGRvbid0XG4gICAgICAgICAgLy8gd2FudCB0aGlzLlxuICAgICAgICAgIGlmICghb3B0aW9ucy5yZXBsYWNlKSB7XG4gICAgICAgICAgICBpV2luZG93LmRvY3VtZW50Lm9wZW4oKTtcbiAgICAgICAgICAgIGlXaW5kb3cuZG9jdW1lbnQuY2xvc2UoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLl91cGRhdGVIYXNoKGlXaW5kb3cubG9jYXRpb24sIGZyYWdtZW50LCBvcHRpb25zLnJlcGxhY2UpO1xuICAgICAgICB9XG5cbiAgICAgIC8vIElmIHlvdSd2ZSB0b2xkIHVzIHRoYXQgeW91IGV4cGxpY2l0bHkgZG9uJ3Qgd2FudCBmYWxsYmFjayBoYXNoY2hhbmdlLVxuICAgICAgLy8gYmFzZWQgaGlzdG9yeSwgdGhlbiBgbmF2aWdhdGVgIGJlY29tZXMgYSBwYWdlIHJlZnJlc2guXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhdGlvbi5hc3NpZ24odXJsKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLnRyaWdnZXIpIHJldHVybiB0aGlzLmxvYWRVcmwoZnJhZ21lbnQpO1xuICAgIH0sXG5cbiAgICAvLyBVcGRhdGUgdGhlIGhhc2ggbG9jYXRpb24sIGVpdGhlciByZXBsYWNpbmcgdGhlIGN1cnJlbnQgZW50cnksIG9yIGFkZGluZ1xuICAgIC8vIGEgbmV3IG9uZSB0byB0aGUgYnJvd3NlciBoaXN0b3J5LlxuICAgIF91cGRhdGVIYXNoOiBmdW5jdGlvbihsb2NhdGlvbiwgZnJhZ21lbnQsIHJlcGxhY2UpIHtcbiAgICAgIGlmIChyZXBsYWNlKSB7XG4gICAgICAgIHZhciBocmVmID0gbG9jYXRpb24uaHJlZi5yZXBsYWNlKC8oamF2YXNjcmlwdDp8IykuKiQvLCAnJyk7XG4gICAgICAgIGxvY2F0aW9uLnJlcGxhY2UoaHJlZiArICcjJyArIGZyYWdtZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFNvbWUgYnJvd3NlcnMgcmVxdWlyZSB0aGF0IGBoYXNoYCBjb250YWlucyBhIGxlYWRpbmcgIy5cbiAgICAgICAgbG9jYXRpb24uaGFzaCA9ICcjJyArIGZyYWdtZW50O1xuICAgICAgfVxuICAgIH1cblxuICB9KTtcblxuICAvLyBDcmVhdGUgdGhlIGRlZmF1bHQgQmFja2JvbmUuaGlzdG9yeS5cbiAgQmFja2JvbmUuaGlzdG9yeSA9IG5ldyBIaXN0b3J5O1xuXG4gIC8vIEhlbHBlcnNcbiAgLy8gLS0tLS0tLVxuXG4gIC8vIEhlbHBlciBmdW5jdGlvbiB0byBjb3JyZWN0bHkgc2V0IHVwIHRoZSBwcm90b3R5cGUgY2hhaW4gZm9yIHN1YmNsYXNzZXMuXG4gIC8vIFNpbWlsYXIgdG8gYGdvb2cuaW5oZXJpdHNgLCBidXQgdXNlcyBhIGhhc2ggb2YgcHJvdG90eXBlIHByb3BlcnRpZXMgYW5kXG4gIC8vIGNsYXNzIHByb3BlcnRpZXMgdG8gYmUgZXh0ZW5kZWQuXG4gIHZhciBleHRlbmQgPSBmdW5jdGlvbihwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIHZhciBwYXJlbnQgPSB0aGlzO1xuICAgIHZhciBjaGlsZDtcblxuICAgIC8vIFRoZSBjb25zdHJ1Y3RvciBmdW5jdGlvbiBmb3IgdGhlIG5ldyBzdWJjbGFzcyBpcyBlaXRoZXIgZGVmaW5lZCBieSB5b3VcbiAgICAvLyAodGhlIFwiY29uc3RydWN0b3JcIiBwcm9wZXJ0eSBpbiB5b3VyIGBleHRlbmRgIGRlZmluaXRpb24pLCBvciBkZWZhdWx0ZWRcbiAgICAvLyBieSB1cyB0byBzaW1wbHkgY2FsbCB0aGUgcGFyZW50IGNvbnN0cnVjdG9yLlxuICAgIGlmIChwcm90b1Byb3BzICYmIF8uaGFzKHByb3RvUHJvcHMsICdjb25zdHJ1Y3RvcicpKSB7XG4gICAgICBjaGlsZCA9IHByb3RvUHJvcHMuY29uc3RydWN0b3I7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNoaWxkID0gZnVuY3Rpb24oKXsgcmV0dXJuIHBhcmVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9O1xuICAgIH1cblxuICAgIC8vIEFkZCBzdGF0aWMgcHJvcGVydGllcyB0byB0aGUgY29uc3RydWN0b3IgZnVuY3Rpb24sIGlmIHN1cHBsaWVkLlxuICAgIF8uZXh0ZW5kKGNoaWxkLCBwYXJlbnQsIHN0YXRpY1Byb3BzKTtcblxuICAgIC8vIFNldCB0aGUgcHJvdG90eXBlIGNoYWluIHRvIGluaGVyaXQgZnJvbSBgcGFyZW50YCwgd2l0aG91dCBjYWxsaW5nXG4gICAgLy8gYHBhcmVudGAncyBjb25zdHJ1Y3RvciBmdW5jdGlvbiBhbmQgYWRkIHRoZSBwcm90b3R5cGUgcHJvcGVydGllcy5cbiAgICBjaGlsZC5wcm90b3R5cGUgPSBfLmNyZWF0ZShwYXJlbnQucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgICBjaGlsZC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjaGlsZDtcblxuICAgIC8vIFNldCBhIGNvbnZlbmllbmNlIHByb3BlcnR5IGluIGNhc2UgdGhlIHBhcmVudCdzIHByb3RvdHlwZSBpcyBuZWVkZWRcbiAgICAvLyBsYXRlci5cbiAgICBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlO1xuXG4gICAgcmV0dXJuIGNoaWxkO1xuICB9O1xuXG4gIC8vIFNldCB1cCBpbmhlcml0YW5jZSBmb3IgdGhlIG1vZGVsLCBjb2xsZWN0aW9uLCByb3V0ZXIsIHZpZXcgYW5kIGhpc3RvcnkuXG4gIE1vZGVsLmV4dGVuZCA9IENvbGxlY3Rpb24uZXh0ZW5kID0gUm91dGVyLmV4dGVuZCA9IFZpZXcuZXh0ZW5kID0gSGlzdG9yeS5leHRlbmQgPSBleHRlbmQ7XG5cbiAgLy8gVGhyb3cgYW4gZXJyb3Igd2hlbiBhIFVSTCBpcyBuZWVkZWQsIGFuZCBub25lIGlzIHN1cHBsaWVkLlxuICB2YXIgdXJsRXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0EgXCJ1cmxcIiBwcm9wZXJ0eSBvciBmdW5jdGlvbiBtdXN0IGJlIHNwZWNpZmllZCcpO1xuICB9O1xuXG4gIC8vIFdyYXAgYW4gb3B0aW9uYWwgZXJyb3IgY2FsbGJhY2sgd2l0aCBhIGZhbGxiYWNrIGVycm9yIGV2ZW50LlxuICB2YXIgd3JhcEVycm9yID0gZnVuY3Rpb24obW9kZWwsIG9wdGlvbnMpIHtcbiAgICB2YXIgZXJyb3IgPSBvcHRpb25zLmVycm9yO1xuICAgIG9wdGlvbnMuZXJyb3IgPSBmdW5jdGlvbihyZXNwKSB7XG4gICAgICBpZiAoZXJyb3IpIGVycm9yLmNhbGwob3B0aW9ucy5jb250ZXh0LCBtb2RlbCwgcmVzcCwgb3B0aW9ucyk7XG4gICAgICBtb2RlbC50cmlnZ2VyKCdlcnJvcicsIG1vZGVsLCByZXNwLCBvcHRpb25zKTtcbiAgICB9O1xuICB9O1xuXG4gIHJldHVybiBCYWNrYm9uZTtcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9iYWNrYm9uZS9iYWNrYm9uZS5qcyIsIi8vICAgICBVbmRlcnNjb3JlLmpzIDEuOC4zXG4vLyAgICAgaHR0cDovL3VuZGVyc2NvcmVqcy5vcmdcbi8vICAgICAoYykgMjAwOS0yMDE1IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4vLyAgICAgVW5kZXJzY29yZSBtYXkgYmUgZnJlZWx5IGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cblxuKGZ1bmN0aW9uKCkge1xuXG4gIC8vIEJhc2VsaW5lIHNldHVwXG4gIC8vIC0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gRXN0YWJsaXNoIHRoZSByb290IG9iamVjdCwgYHdpbmRvd2AgaW4gdGhlIGJyb3dzZXIsIG9yIGBleHBvcnRzYCBvbiB0aGUgc2VydmVyLlxuICB2YXIgcm9vdCA9IHRoaXM7XG5cbiAgLy8gU2F2ZSB0aGUgcHJldmlvdXMgdmFsdWUgb2YgdGhlIGBfYCB2YXJpYWJsZS5cbiAgdmFyIHByZXZpb3VzVW5kZXJzY29yZSA9IHJvb3QuXztcblxuICAvLyBTYXZlIGJ5dGVzIGluIHRoZSBtaW5pZmllZCAoYnV0IG5vdCBnemlwcGVkKSB2ZXJzaW9uOlxuICB2YXIgQXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZSwgT2JqUHJvdG8gPSBPYmplY3QucHJvdG90eXBlLCBGdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGU7XG5cbiAgLy8gQ3JlYXRlIHF1aWNrIHJlZmVyZW5jZSB2YXJpYWJsZXMgZm9yIHNwZWVkIGFjY2VzcyB0byBjb3JlIHByb3RvdHlwZXMuXG4gIHZhclxuICAgIHB1c2ggICAgICAgICAgICAgPSBBcnJheVByb3RvLnB1c2gsXG4gICAgc2xpY2UgICAgICAgICAgICA9IEFycmF5UHJvdG8uc2xpY2UsXG4gICAgdG9TdHJpbmcgICAgICAgICA9IE9ialByb3RvLnRvU3RyaW5nLFxuICAgIGhhc093blByb3BlcnR5ICAgPSBPYmpQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuICAvLyBBbGwgKipFQ01BU2NyaXB0IDUqKiBuYXRpdmUgZnVuY3Rpb24gaW1wbGVtZW50YXRpb25zIHRoYXQgd2UgaG9wZSB0byB1c2VcbiAgLy8gYXJlIGRlY2xhcmVkIGhlcmUuXG4gIHZhclxuICAgIG5hdGl2ZUlzQXJyYXkgICAgICA9IEFycmF5LmlzQXJyYXksXG4gICAgbmF0aXZlS2V5cyAgICAgICAgID0gT2JqZWN0LmtleXMsXG4gICAgbmF0aXZlQmluZCAgICAgICAgID0gRnVuY1Byb3RvLmJpbmQsXG4gICAgbmF0aXZlQ3JlYXRlICAgICAgID0gT2JqZWN0LmNyZWF0ZTtcblxuICAvLyBOYWtlZCBmdW5jdGlvbiByZWZlcmVuY2UgZm9yIHN1cnJvZ2F0ZS1wcm90b3R5cGUtc3dhcHBpbmcuXG4gIHZhciBDdG9yID0gZnVuY3Rpb24oKXt9O1xuXG4gIC8vIENyZWF0ZSBhIHNhZmUgcmVmZXJlbmNlIHRvIHRoZSBVbmRlcnNjb3JlIG9iamVjdCBmb3IgdXNlIGJlbG93LlxuICB2YXIgXyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmIChvYmogaW5zdGFuY2VvZiBfKSByZXR1cm4gb2JqO1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBfKSkgcmV0dXJuIG5ldyBfKG9iaik7XG4gICAgdGhpcy5fd3JhcHBlZCA9IG9iajtcbiAgfTtcblxuICAvLyBFeHBvcnQgdGhlIFVuZGVyc2NvcmUgb2JqZWN0IGZvciAqKk5vZGUuanMqKiwgd2l0aFxuICAvLyBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSBmb3IgdGhlIG9sZCBgcmVxdWlyZSgpYCBBUEkuIElmIHdlJ3JlIGluXG4gIC8vIHRoZSBicm93c2VyLCBhZGQgYF9gIGFzIGEgZ2xvYmFsIG9iamVjdC5cbiAgaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gXztcbiAgICB9XG4gICAgZXhwb3J0cy5fID0gXztcbiAgfSBlbHNlIHtcbiAgICByb290Ll8gPSBfO1xuICB9XG5cbiAgLy8gQ3VycmVudCB2ZXJzaW9uLlxuICBfLlZFUlNJT04gPSAnMS44LjMnO1xuXG4gIC8vIEludGVybmFsIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBlZmZpY2llbnQgKGZvciBjdXJyZW50IGVuZ2luZXMpIHZlcnNpb25cbiAgLy8gb2YgdGhlIHBhc3NlZC1pbiBjYWxsYmFjaywgdG8gYmUgcmVwZWF0ZWRseSBhcHBsaWVkIGluIG90aGVyIFVuZGVyc2NvcmVcbiAgLy8gZnVuY3Rpb25zLlxuICB2YXIgb3B0aW1pemVDYiA9IGZ1bmN0aW9uKGZ1bmMsIGNvbnRleHQsIGFyZ0NvdW50KSB7XG4gICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgcmV0dXJuIGZ1bmM7XG4gICAgc3dpdGNoIChhcmdDb3VudCA9PSBudWxsID8gMyA6IGFyZ0NvdW50KSB7XG4gICAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIHZhbHVlKTtcbiAgICAgIH07XG4gICAgICBjYXNlIDI6IHJldHVybiBmdW5jdGlvbih2YWx1ZSwgb3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbChjb250ZXh0LCB2YWx1ZSwgb3RoZXIpO1xuICAgICAgfTtcbiAgICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICB9O1xuICAgICAgY2FzZSA0OiByZXR1cm4gZnVuY3Rpb24oYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkoY29udGV4dCwgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIEEgbW9zdGx5LWludGVybmFsIGZ1bmN0aW9uIHRvIGdlbmVyYXRlIGNhbGxiYWNrcyB0aGF0IGNhbiBiZSBhcHBsaWVkXG4gIC8vIHRvIGVhY2ggZWxlbWVudCBpbiBhIGNvbGxlY3Rpb24sIHJldHVybmluZyB0aGUgZGVzaXJlZCByZXN1bHQg4oCUIGVpdGhlclxuICAvLyBpZGVudGl0eSwgYW4gYXJiaXRyYXJ5IGNhbGxiYWNrLCBhIHByb3BlcnR5IG1hdGNoZXIsIG9yIGEgcHJvcGVydHkgYWNjZXNzb3IuXG4gIHZhciBjYiA9IGZ1bmN0aW9uKHZhbHVlLCBjb250ZXh0LCBhcmdDb3VudCkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSByZXR1cm4gXy5pZGVudGl0eTtcbiAgICBpZiAoXy5pc0Z1bmN0aW9uKHZhbHVlKSkgcmV0dXJuIG9wdGltaXplQ2IodmFsdWUsIGNvbnRleHQsIGFyZ0NvdW50KTtcbiAgICBpZiAoXy5pc09iamVjdCh2YWx1ZSkpIHJldHVybiBfLm1hdGNoZXIodmFsdWUpO1xuICAgIHJldHVybiBfLnByb3BlcnR5KHZhbHVlKTtcbiAgfTtcbiAgXy5pdGVyYXRlZSA9IGZ1bmN0aW9uKHZhbHVlLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIGNiKHZhbHVlLCBjb250ZXh0LCBJbmZpbml0eSk7XG4gIH07XG5cbiAgLy8gQW4gaW50ZXJuYWwgZnVuY3Rpb24gZm9yIGNyZWF0aW5nIGFzc2lnbmVyIGZ1bmN0aW9ucy5cbiAgdmFyIGNyZWF0ZUFzc2lnbmVyID0gZnVuY3Rpb24oa2V5c0Z1bmMsIHVuZGVmaW5lZE9ubHkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgIGlmIChsZW5ndGggPCAyIHx8IG9iaiA9PSBudWxsKSByZXR1cm4gb2JqO1xuICAgICAgZm9yICh2YXIgaW5kZXggPSAxOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2luZGV4XSxcbiAgICAgICAgICAgIGtleXMgPSBrZXlzRnVuYyhzb3VyY2UpLFxuICAgICAgICAgICAgbCA9IGtleXMubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgIGlmICghdW5kZWZpbmVkT25seSB8fCBvYmpba2V5XSA9PT0gdm9pZCAwKSBvYmpba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH07XG4gIH07XG5cbiAgLy8gQW4gaW50ZXJuYWwgZnVuY3Rpb24gZm9yIGNyZWF0aW5nIGEgbmV3IG9iamVjdCB0aGF0IGluaGVyaXRzIGZyb20gYW5vdGhlci5cbiAgdmFyIGJhc2VDcmVhdGUgPSBmdW5jdGlvbihwcm90b3R5cGUpIHtcbiAgICBpZiAoIV8uaXNPYmplY3QocHJvdG90eXBlKSkgcmV0dXJuIHt9O1xuICAgIGlmIChuYXRpdmVDcmVhdGUpIHJldHVybiBuYXRpdmVDcmVhdGUocHJvdG90eXBlKTtcbiAgICBDdG9yLnByb3RvdHlwZSA9IHByb3RvdHlwZTtcbiAgICB2YXIgcmVzdWx0ID0gbmV3IEN0b3I7XG4gICAgQ3Rvci5wcm90b3R5cGUgPSBudWxsO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgdmFyIHByb3BlcnR5ID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiA9PSBudWxsID8gdm9pZCAwIDogb2JqW2tleV07XG4gICAgfTtcbiAgfTtcblxuICAvLyBIZWxwZXIgZm9yIGNvbGxlY3Rpb24gbWV0aG9kcyB0byBkZXRlcm1pbmUgd2hldGhlciBhIGNvbGxlY3Rpb25cbiAgLy8gc2hvdWxkIGJlIGl0ZXJhdGVkIGFzIGFuIGFycmF5IG9yIGFzIGFuIG9iamVjdFxuICAvLyBSZWxhdGVkOiBodHRwOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy10b2xlbmd0aFxuICAvLyBBdm9pZHMgYSB2ZXJ5IG5hc3R5IGlPUyA4IEpJVCBidWcgb24gQVJNLTY0LiAjMjA5NFxuICB2YXIgTUFYX0FSUkFZX0lOREVYID0gTWF0aC5wb3coMiwgNTMpIC0gMTtcbiAgdmFyIGdldExlbmd0aCA9IHByb3BlcnR5KCdsZW5ndGgnKTtcbiAgdmFyIGlzQXJyYXlMaWtlID0gZnVuY3Rpb24oY29sbGVjdGlvbikge1xuICAgIHZhciBsZW5ndGggPSBnZXRMZW5ndGgoY29sbGVjdGlvbik7XG4gICAgcmV0dXJuIHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicgJiYgbGVuZ3RoID49IDAgJiYgbGVuZ3RoIDw9IE1BWF9BUlJBWV9JTkRFWDtcbiAgfTtcblxuICAvLyBDb2xsZWN0aW9uIEZ1bmN0aW9uc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIFRoZSBjb3JuZXJzdG9uZSwgYW4gYGVhY2hgIGltcGxlbWVudGF0aW9uLCBha2EgYGZvckVhY2hgLlxuICAvLyBIYW5kbGVzIHJhdyBvYmplY3RzIGluIGFkZGl0aW9uIHRvIGFycmF5LWxpa2VzLiBUcmVhdHMgYWxsXG4gIC8vIHNwYXJzZSBhcnJheS1saWtlcyBhcyBpZiB0aGV5IHdlcmUgZGVuc2UuXG4gIF8uZWFjaCA9IF8uZm9yRWFjaCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpdGVyYXRlZSA9IG9wdGltaXplQ2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgIHZhciBpLCBsZW5ndGg7XG4gICAgaWYgKGlzQXJyYXlMaWtlKG9iaikpIHtcbiAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IG9iai5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpdGVyYXRlZShvYmpbaV0sIGksIG9iaik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaik7XG4gICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGl0ZXJhdGVlKG9ialtrZXlzW2ldXSwga2V5c1tpXSwgb2JqKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIHJlc3VsdHMgb2YgYXBwbHlpbmcgdGhlIGl0ZXJhdGVlIHRvIGVhY2ggZWxlbWVudC5cbiAgXy5tYXAgPSBfLmNvbGxlY3QgPSBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgdmFyIGtleXMgPSAhaXNBcnJheUxpa2Uob2JqKSAmJiBfLmtleXMob2JqKSxcbiAgICAgICAgbGVuZ3RoID0gKGtleXMgfHwgb2JqKS5sZW5ndGgsXG4gICAgICAgIHJlc3VsdHMgPSBBcnJheShsZW5ndGgpO1xuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIHZhciBjdXJyZW50S2V5ID0ga2V5cyA/IGtleXNbaW5kZXhdIDogaW5kZXg7XG4gICAgICByZXN1bHRzW2luZGV4XSA9IGl0ZXJhdGVlKG9ialtjdXJyZW50S2V5XSwgY3VycmVudEtleSwgb2JqKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH07XG5cbiAgLy8gQ3JlYXRlIGEgcmVkdWNpbmcgZnVuY3Rpb24gaXRlcmF0aW5nIGxlZnQgb3IgcmlnaHQuXG4gIGZ1bmN0aW9uIGNyZWF0ZVJlZHVjZShkaXIpIHtcbiAgICAvLyBPcHRpbWl6ZWQgaXRlcmF0b3IgZnVuY3Rpb24gYXMgdXNpbmcgYXJndW1lbnRzLmxlbmd0aFxuICAgIC8vIGluIHRoZSBtYWluIGZ1bmN0aW9uIHdpbGwgZGVvcHRpbWl6ZSB0aGUsIHNlZSAjMTk5MS5cbiAgICBmdW5jdGlvbiBpdGVyYXRvcihvYmosIGl0ZXJhdGVlLCBtZW1vLCBrZXlzLCBpbmRleCwgbGVuZ3RoKSB7XG4gICAgICBmb3IgKDsgaW5kZXggPj0gMCAmJiBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gZGlyKSB7XG4gICAgICAgIHZhciBjdXJyZW50S2V5ID0ga2V5cyA/IGtleXNbaW5kZXhdIDogaW5kZXg7XG4gICAgICAgIG1lbW8gPSBpdGVyYXRlZShtZW1vLCBvYmpbY3VycmVudEtleV0sIGN1cnJlbnRLZXksIG9iaik7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWVtbztcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgbWVtbywgY29udGV4dCkge1xuICAgICAgaXRlcmF0ZWUgPSBvcHRpbWl6ZUNiKGl0ZXJhdGVlLCBjb250ZXh0LCA0KTtcbiAgICAgIHZhciBrZXlzID0gIWlzQXJyYXlMaWtlKG9iaikgJiYgXy5rZXlzKG9iaiksXG4gICAgICAgICAgbGVuZ3RoID0gKGtleXMgfHwgb2JqKS5sZW5ndGgsXG4gICAgICAgICAgaW5kZXggPSBkaXIgPiAwID8gMCA6IGxlbmd0aCAtIDE7XG4gICAgICAvLyBEZXRlcm1pbmUgdGhlIGluaXRpYWwgdmFsdWUgaWYgbm9uZSBpcyBwcm92aWRlZC5cbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMykge1xuICAgICAgICBtZW1vID0gb2JqW2tleXMgPyBrZXlzW2luZGV4XSA6IGluZGV4XTtcbiAgICAgICAgaW5kZXggKz0gZGlyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGl0ZXJhdG9yKG9iaiwgaXRlcmF0ZWUsIG1lbW8sIGtleXMsIGluZGV4LCBsZW5ndGgpO1xuICAgIH07XG4gIH1cblxuICAvLyAqKlJlZHVjZSoqIGJ1aWxkcyB1cCBhIHNpbmdsZSByZXN1bHQgZnJvbSBhIGxpc3Qgb2YgdmFsdWVzLCBha2EgYGluamVjdGAsXG4gIC8vIG9yIGBmb2xkbGAuXG4gIF8ucmVkdWNlID0gXy5mb2xkbCA9IF8uaW5qZWN0ID0gY3JlYXRlUmVkdWNlKDEpO1xuXG4gIC8vIFRoZSByaWdodC1hc3NvY2lhdGl2ZSB2ZXJzaW9uIG9mIHJlZHVjZSwgYWxzbyBrbm93biBhcyBgZm9sZHJgLlxuICBfLnJlZHVjZVJpZ2h0ID0gXy5mb2xkciA9IGNyZWF0ZVJlZHVjZSgtMSk7XG5cbiAgLy8gUmV0dXJuIHRoZSBmaXJzdCB2YWx1ZSB3aGljaCBwYXNzZXMgYSB0cnV0aCB0ZXN0LiBBbGlhc2VkIGFzIGBkZXRlY3RgLlxuICBfLmZpbmQgPSBfLmRldGVjdCA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIGtleTtcbiAgICBpZiAoaXNBcnJheUxpa2Uob2JqKSkge1xuICAgICAga2V5ID0gXy5maW5kSW5kZXgob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBrZXkgPSBfLmZpbmRLZXkob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIH1cbiAgICBpZiAoa2V5ICE9PSB2b2lkIDAgJiYga2V5ICE9PSAtMSkgcmV0dXJuIG9ialtrZXldO1xuICB9O1xuXG4gIC8vIFJldHVybiBhbGwgdGhlIGVsZW1lbnRzIHRoYXQgcGFzcyBhIHRydXRoIHRlc3QuXG4gIC8vIEFsaWFzZWQgYXMgYHNlbGVjdGAuXG4gIF8uZmlsdGVyID0gXy5zZWxlY3QgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHRzID0gW107XG4gICAgcHJlZGljYXRlID0gY2IocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBsaXN0KSkgcmVzdWx0cy5wdXNoKHZhbHVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICAvLyBSZXR1cm4gYWxsIHRoZSBlbGVtZW50cyBmb3Igd2hpY2ggYSB0cnV0aCB0ZXN0IGZhaWxzLlxuICBfLnJlamVjdCA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIF8uZmlsdGVyKG9iaiwgXy5uZWdhdGUoY2IocHJlZGljYXRlKSksIGNvbnRleHQpO1xuICB9O1xuXG4gIC8vIERldGVybWluZSB3aGV0aGVyIGFsbCBvZiB0aGUgZWxlbWVudHMgbWF0Y2ggYSB0cnV0aCB0ZXN0LlxuICAvLyBBbGlhc2VkIGFzIGBhbGxgLlxuICBfLmV2ZXJ5ID0gXy5hbGwgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgdmFyIGtleXMgPSAhaXNBcnJheUxpa2Uob2JqKSAmJiBfLmtleXMob2JqKSxcbiAgICAgICAgbGVuZ3RoID0gKGtleXMgfHwgb2JqKS5sZW5ndGg7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdmFyIGN1cnJlbnRLZXkgPSBrZXlzID8ga2V5c1tpbmRleF0gOiBpbmRleDtcbiAgICAgIGlmICghcHJlZGljYXRlKG9ialtjdXJyZW50S2V5XSwgY3VycmVudEtleSwgb2JqKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICAvLyBEZXRlcm1pbmUgaWYgYXQgbGVhc3Qgb25lIGVsZW1lbnQgaW4gdGhlIG9iamVjdCBtYXRjaGVzIGEgdHJ1dGggdGVzdC5cbiAgLy8gQWxpYXNlZCBhcyBgYW55YC5cbiAgXy5zb21lID0gXy5hbnkgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgdmFyIGtleXMgPSAhaXNBcnJheUxpa2Uob2JqKSAmJiBfLmtleXMob2JqKSxcbiAgICAgICAgbGVuZ3RoID0gKGtleXMgfHwgb2JqKS5sZW5ndGg7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdmFyIGN1cnJlbnRLZXkgPSBrZXlzID8ga2V5c1tpbmRleF0gOiBpbmRleDtcbiAgICAgIGlmIChwcmVkaWNhdGUob2JqW2N1cnJlbnRLZXldLCBjdXJyZW50S2V5LCBvYmopKSByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIC8vIERldGVybWluZSBpZiB0aGUgYXJyYXkgb3Igb2JqZWN0IGNvbnRhaW5zIGEgZ2l2ZW4gaXRlbSAodXNpbmcgYD09PWApLlxuICAvLyBBbGlhc2VkIGFzIGBpbmNsdWRlc2AgYW5kIGBpbmNsdWRlYC5cbiAgXy5jb250YWlucyA9IF8uaW5jbHVkZXMgPSBfLmluY2x1ZGUgPSBmdW5jdGlvbihvYmosIGl0ZW0sIGZyb21JbmRleCwgZ3VhcmQpIHtcbiAgICBpZiAoIWlzQXJyYXlMaWtlKG9iaikpIG9iaiA9IF8udmFsdWVzKG9iaik7XG4gICAgaWYgKHR5cGVvZiBmcm9tSW5kZXggIT0gJ251bWJlcicgfHwgZ3VhcmQpIGZyb21JbmRleCA9IDA7XG4gICAgcmV0dXJuIF8uaW5kZXhPZihvYmosIGl0ZW0sIGZyb21JbmRleCkgPj0gMDtcbiAgfTtcblxuICAvLyBJbnZva2UgYSBtZXRob2QgKHdpdGggYXJndW1lbnRzKSBvbiBldmVyeSBpdGVtIGluIGEgY29sbGVjdGlvbi5cbiAgXy5pbnZva2UgPSBmdW5jdGlvbihvYmosIG1ldGhvZCkge1xuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgIHZhciBpc0Z1bmMgPSBfLmlzRnVuY3Rpb24obWV0aG9kKTtcbiAgICByZXR1cm4gXy5tYXAob2JqLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgdmFyIGZ1bmMgPSBpc0Z1bmMgPyBtZXRob2QgOiB2YWx1ZVttZXRob2RdO1xuICAgICAgcmV0dXJuIGZ1bmMgPT0gbnVsbCA/IGZ1bmMgOiBmdW5jLmFwcGx5KHZhbHVlLCBhcmdzKTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBDb252ZW5pZW5jZSB2ZXJzaW9uIG9mIGEgY29tbW9uIHVzZSBjYXNlIG9mIGBtYXBgOiBmZXRjaGluZyBhIHByb3BlcnR5LlxuICBfLnBsdWNrID0gZnVuY3Rpb24ob2JqLCBrZXkpIHtcbiAgICByZXR1cm4gXy5tYXAob2JqLCBfLnByb3BlcnR5KGtleSkpO1xuICB9O1xuXG4gIC8vIENvbnZlbmllbmNlIHZlcnNpb24gb2YgYSBjb21tb24gdXNlIGNhc2Ugb2YgYGZpbHRlcmA6IHNlbGVjdGluZyBvbmx5IG9iamVjdHNcbiAgLy8gY29udGFpbmluZyBzcGVjaWZpYyBga2V5OnZhbHVlYCBwYWlycy5cbiAgXy53aGVyZSA9IGZ1bmN0aW9uKG9iaiwgYXR0cnMpIHtcbiAgICByZXR1cm4gXy5maWx0ZXIob2JqLCBfLm1hdGNoZXIoYXR0cnMpKTtcbiAgfTtcblxuICAvLyBDb252ZW5pZW5jZSB2ZXJzaW9uIG9mIGEgY29tbW9uIHVzZSBjYXNlIG9mIGBmaW5kYDogZ2V0dGluZyB0aGUgZmlyc3Qgb2JqZWN0XG4gIC8vIGNvbnRhaW5pbmcgc3BlY2lmaWMgYGtleTp2YWx1ZWAgcGFpcnMuXG4gIF8uZmluZFdoZXJlID0gZnVuY3Rpb24ob2JqLCBhdHRycykge1xuICAgIHJldHVybiBfLmZpbmQob2JqLCBfLm1hdGNoZXIoYXR0cnMpKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIG1heGltdW0gZWxlbWVudCAob3IgZWxlbWVudC1iYXNlZCBjb21wdXRhdGlvbikuXG4gIF8ubWF4ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHQgPSAtSW5maW5pdHksIGxhc3RDb21wdXRlZCA9IC1JbmZpbml0eSxcbiAgICAgICAgdmFsdWUsIGNvbXB1dGVkO1xuICAgIGlmIChpdGVyYXRlZSA9PSBudWxsICYmIG9iaiAhPSBudWxsKSB7XG4gICAgICBvYmogPSBpc0FycmF5TGlrZShvYmopID8gb2JqIDogXy52YWx1ZXMob2JqKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBvYmoubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFsdWUgPSBvYmpbaV07XG4gICAgICAgIGlmICh2YWx1ZSA+IHJlc3VsdCkge1xuICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUodmFsdWUsIGluZGV4LCBsaXN0KTtcbiAgICAgICAgaWYgKGNvbXB1dGVkID4gbGFzdENvbXB1dGVkIHx8IGNvbXB1dGVkID09PSAtSW5maW5pdHkgJiYgcmVzdWx0ID09PSAtSW5maW5pdHkpIHtcbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICBsYXN0Q29tcHV0ZWQgPSBjb21wdXRlZDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSBtaW5pbXVtIGVsZW1lbnQgKG9yIGVsZW1lbnQtYmFzZWQgY29tcHV0YXRpb24pLlxuICBfLm1pbiA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICB2YXIgcmVzdWx0ID0gSW5maW5pdHksIGxhc3RDb21wdXRlZCA9IEluZmluaXR5LFxuICAgICAgICB2YWx1ZSwgY29tcHV0ZWQ7XG4gICAgaWYgKGl0ZXJhdGVlID09IG51bGwgJiYgb2JqICE9IG51bGwpIHtcbiAgICAgIG9iaiA9IGlzQXJyYXlMaWtlKG9iaikgPyBvYmogOiBfLnZhbHVlcyhvYmopO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IG9iai5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YWx1ZSA9IG9ialtpXTtcbiAgICAgICAgaWYgKHZhbHVlIDwgcmVzdWx0KSB7XG4gICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSh2YWx1ZSwgaW5kZXgsIGxpc3QpO1xuICAgICAgICBpZiAoY29tcHV0ZWQgPCBsYXN0Q29tcHV0ZWQgfHwgY29tcHV0ZWQgPT09IEluZmluaXR5ICYmIHJlc3VsdCA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICBsYXN0Q29tcHV0ZWQgPSBjb21wdXRlZDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gU2h1ZmZsZSBhIGNvbGxlY3Rpb24sIHVzaW5nIHRoZSBtb2Rlcm4gdmVyc2lvbiBvZiB0aGVcbiAgLy8gW0Zpc2hlci1ZYXRlcyBzaHVmZmxlXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Zpc2hlcuKAk1lhdGVzX3NodWZmbGUpLlxuICBfLnNodWZmbGUgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgc2V0ID0gaXNBcnJheUxpa2Uob2JqKSA/IG9iaiA6IF8udmFsdWVzKG9iaik7XG4gICAgdmFyIGxlbmd0aCA9IHNldC5sZW5ndGg7XG4gICAgdmFyIHNodWZmbGVkID0gQXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpbmRleCA9IDAsIHJhbmQ7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICByYW5kID0gXy5yYW5kb20oMCwgaW5kZXgpO1xuICAgICAgaWYgKHJhbmQgIT09IGluZGV4KSBzaHVmZmxlZFtpbmRleF0gPSBzaHVmZmxlZFtyYW5kXTtcbiAgICAgIHNodWZmbGVkW3JhbmRdID0gc2V0W2luZGV4XTtcbiAgICB9XG4gICAgcmV0dXJuIHNodWZmbGVkO1xuICB9O1xuXG4gIC8vIFNhbXBsZSAqKm4qKiByYW5kb20gdmFsdWVzIGZyb20gYSBjb2xsZWN0aW9uLlxuICAvLyBJZiAqKm4qKiBpcyBub3Qgc3BlY2lmaWVkLCByZXR1cm5zIGEgc2luZ2xlIHJhbmRvbSBlbGVtZW50LlxuICAvLyBUaGUgaW50ZXJuYWwgYGd1YXJkYCBhcmd1bWVudCBhbGxvd3MgaXQgdG8gd29yayB3aXRoIGBtYXBgLlxuICBfLnNhbXBsZSA9IGZ1bmN0aW9uKG9iaiwgbiwgZ3VhcmQpIHtcbiAgICBpZiAobiA9PSBudWxsIHx8IGd1YXJkKSB7XG4gICAgICBpZiAoIWlzQXJyYXlMaWtlKG9iaikpIG9iaiA9IF8udmFsdWVzKG9iaik7XG4gICAgICByZXR1cm4gb2JqW18ucmFuZG9tKG9iai5sZW5ndGggLSAxKV07XG4gICAgfVxuICAgIHJldHVybiBfLnNodWZmbGUob2JqKS5zbGljZSgwLCBNYXRoLm1heCgwLCBuKSk7XG4gIH07XG5cbiAgLy8gU29ydCB0aGUgb2JqZWN0J3MgdmFsdWVzIGJ5IGEgY3JpdGVyaW9uIHByb2R1Y2VkIGJ5IGFuIGl0ZXJhdGVlLlxuICBfLnNvcnRCeSA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICByZXR1cm4gXy5wbHVjayhfLm1hcChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgIGNyaXRlcmlhOiBpdGVyYXRlZSh2YWx1ZSwgaW5kZXgsIGxpc3QpXG4gICAgICB9O1xuICAgIH0pLnNvcnQoZnVuY3Rpb24obGVmdCwgcmlnaHQpIHtcbiAgICAgIHZhciBhID0gbGVmdC5jcml0ZXJpYTtcbiAgICAgIHZhciBiID0gcmlnaHQuY3JpdGVyaWE7XG4gICAgICBpZiAoYSAhPT0gYikge1xuICAgICAgICBpZiAoYSA+IGIgfHwgYSA9PT0gdm9pZCAwKSByZXR1cm4gMTtcbiAgICAgICAgaWYgKGEgPCBiIHx8IGIgPT09IHZvaWQgMCkgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxlZnQuaW5kZXggLSByaWdodC5pbmRleDtcbiAgICB9KSwgJ3ZhbHVlJyk7XG4gIH07XG5cbiAgLy8gQW4gaW50ZXJuYWwgZnVuY3Rpb24gdXNlZCBmb3IgYWdncmVnYXRlIFwiZ3JvdXAgYnlcIiBvcGVyYXRpb25zLlxuICB2YXIgZ3JvdXAgPSBmdW5jdGlvbihiZWhhdmlvcikge1xuICAgIHJldHVybiBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCkge1xuICAgICAgICB2YXIga2V5ID0gaXRlcmF0ZWUodmFsdWUsIGluZGV4LCBvYmopO1xuICAgICAgICBiZWhhdmlvcihyZXN1bHQsIHZhbHVlLCBrZXkpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH07XG5cbiAgLy8gR3JvdXBzIHRoZSBvYmplY3QncyB2YWx1ZXMgYnkgYSBjcml0ZXJpb24uIFBhc3MgZWl0aGVyIGEgc3RyaW5nIGF0dHJpYnV0ZVxuICAvLyB0byBncm91cCBieSwgb3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIGNyaXRlcmlvbi5cbiAgXy5ncm91cEJ5ID0gZ3JvdXAoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgaWYgKF8uaGFzKHJlc3VsdCwga2V5KSkgcmVzdWx0W2tleV0ucHVzaCh2YWx1ZSk7IGVsc2UgcmVzdWx0W2tleV0gPSBbdmFsdWVdO1xuICB9KTtcblxuICAvLyBJbmRleGVzIHRoZSBvYmplY3QncyB2YWx1ZXMgYnkgYSBjcml0ZXJpb24sIHNpbWlsYXIgdG8gYGdyb3VwQnlgLCBidXQgZm9yXG4gIC8vIHdoZW4geW91IGtub3cgdGhhdCB5b3VyIGluZGV4IHZhbHVlcyB3aWxsIGJlIHVuaXF1ZS5cbiAgXy5pbmRleEJ5ID0gZ3JvdXAoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgfSk7XG5cbiAgLy8gQ291bnRzIGluc3RhbmNlcyBvZiBhbiBvYmplY3QgdGhhdCBncm91cCBieSBhIGNlcnRhaW4gY3JpdGVyaW9uLiBQYXNzXG4gIC8vIGVpdGhlciBhIHN0cmluZyBhdHRyaWJ1dGUgdG8gY291bnQgYnksIG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZVxuICAvLyBjcml0ZXJpb24uXG4gIF8uY291bnRCeSA9IGdyb3VwKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgIGlmIChfLmhhcyhyZXN1bHQsIGtleSkpIHJlc3VsdFtrZXldKys7IGVsc2UgcmVzdWx0W2tleV0gPSAxO1xuICB9KTtcblxuICAvLyBTYWZlbHkgY3JlYXRlIGEgcmVhbCwgbGl2ZSBhcnJheSBmcm9tIGFueXRoaW5nIGl0ZXJhYmxlLlxuICBfLnRvQXJyYXkgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAoIW9iaikgcmV0dXJuIFtdO1xuICAgIGlmIChfLmlzQXJyYXkob2JqKSkgcmV0dXJuIHNsaWNlLmNhbGwob2JqKTtcbiAgICBpZiAoaXNBcnJheUxpa2Uob2JqKSkgcmV0dXJuIF8ubWFwKG9iaiwgXy5pZGVudGl0eSk7XG4gICAgcmV0dXJuIF8udmFsdWVzKG9iaik7XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gYW4gb2JqZWN0LlxuICBfLnNpemUgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiAwO1xuICAgIHJldHVybiBpc0FycmF5TGlrZShvYmopID8gb2JqLmxlbmd0aCA6IF8ua2V5cyhvYmopLmxlbmd0aDtcbiAgfTtcblxuICAvLyBTcGxpdCBhIGNvbGxlY3Rpb24gaW50byB0d28gYXJyYXlzOiBvbmUgd2hvc2UgZWxlbWVudHMgYWxsIHNhdGlzZnkgdGhlIGdpdmVuXG4gIC8vIHByZWRpY2F0ZSwgYW5kIG9uZSB3aG9zZSBlbGVtZW50cyBhbGwgZG8gbm90IHNhdGlzZnkgdGhlIHByZWRpY2F0ZS5cbiAgXy5wYXJ0aXRpb24gPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgdmFyIHBhc3MgPSBbXSwgZmFpbCA9IFtdO1xuICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iaikge1xuICAgICAgKHByZWRpY2F0ZSh2YWx1ZSwga2V5LCBvYmopID8gcGFzcyA6IGZhaWwpLnB1c2godmFsdWUpO1xuICAgIH0pO1xuICAgIHJldHVybiBbcGFzcywgZmFpbF07XG4gIH07XG5cbiAgLy8gQXJyYXkgRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIEdldCB0aGUgZmlyc3QgZWxlbWVudCBvZiBhbiBhcnJheS4gUGFzc2luZyAqKm4qKiB3aWxsIHJldHVybiB0aGUgZmlyc3QgTlxuICAvLyB2YWx1ZXMgaW4gdGhlIGFycmF5LiBBbGlhc2VkIGFzIGBoZWFkYCBhbmQgYHRha2VgLiBUaGUgKipndWFyZCoqIGNoZWNrXG4gIC8vIGFsbG93cyBpdCB0byB3b3JrIHdpdGggYF8ubWFwYC5cbiAgXy5maXJzdCA9IF8uaGVhZCA9IF8udGFrZSA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xuICAgIGlmIChhcnJheSA9PSBudWxsKSByZXR1cm4gdm9pZCAwO1xuICAgIGlmIChuID09IG51bGwgfHwgZ3VhcmQpIHJldHVybiBhcnJheVswXTtcbiAgICByZXR1cm4gXy5pbml0aWFsKGFycmF5LCBhcnJheS5sZW5ndGggLSBuKTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGV2ZXJ5dGhpbmcgYnV0IHRoZSBsYXN0IGVudHJ5IG9mIHRoZSBhcnJheS4gRXNwZWNpYWxseSB1c2VmdWwgb25cbiAgLy8gdGhlIGFyZ3VtZW50cyBvYmplY3QuIFBhc3NpbmcgKipuKiogd2lsbCByZXR1cm4gYWxsIHRoZSB2YWx1ZXMgaW5cbiAgLy8gdGhlIGFycmF5LCBleGNsdWRpbmcgdGhlIGxhc3QgTi5cbiAgXy5pbml0aWFsID0gZnVuY3Rpb24oYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgcmV0dXJuIHNsaWNlLmNhbGwoYXJyYXksIDAsIE1hdGgubWF4KDAsIGFycmF5Lmxlbmd0aCAtIChuID09IG51bGwgfHwgZ3VhcmQgPyAxIDogbikpKTtcbiAgfTtcblxuICAvLyBHZXQgdGhlIGxhc3QgZWxlbWVudCBvZiBhbiBhcnJheS4gUGFzc2luZyAqKm4qKiB3aWxsIHJldHVybiB0aGUgbGFzdCBOXG4gIC8vIHZhbHVlcyBpbiB0aGUgYXJyYXkuXG4gIF8ubGFzdCA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xuICAgIGlmIChhcnJheSA9PSBudWxsKSByZXR1cm4gdm9pZCAwO1xuICAgIGlmIChuID09IG51bGwgfHwgZ3VhcmQpIHJldHVybiBhcnJheVthcnJheS5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4gXy5yZXN0KGFycmF5LCBNYXRoLm1heCgwLCBhcnJheS5sZW5ndGggLSBuKSk7XG4gIH07XG5cbiAgLy8gUmV0dXJucyBldmVyeXRoaW5nIGJ1dCB0aGUgZmlyc3QgZW50cnkgb2YgdGhlIGFycmF5LiBBbGlhc2VkIGFzIGB0YWlsYCBhbmQgYGRyb3BgLlxuICAvLyBFc3BlY2lhbGx5IHVzZWZ1bCBvbiB0aGUgYXJndW1lbnRzIG9iamVjdC4gUGFzc2luZyBhbiAqKm4qKiB3aWxsIHJldHVyblxuICAvLyB0aGUgcmVzdCBOIHZhbHVlcyBpbiB0aGUgYXJyYXkuXG4gIF8ucmVzdCA9IF8udGFpbCA9IF8uZHJvcCA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xuICAgIHJldHVybiBzbGljZS5jYWxsKGFycmF5LCBuID09IG51bGwgfHwgZ3VhcmQgPyAxIDogbik7XG4gIH07XG5cbiAgLy8gVHJpbSBvdXQgYWxsIGZhbHN5IHZhbHVlcyBmcm9tIGFuIGFycmF5LlxuICBfLmNvbXBhY3QgPSBmdW5jdGlvbihhcnJheSkge1xuICAgIHJldHVybiBfLmZpbHRlcihhcnJheSwgXy5pZGVudGl0eSk7XG4gIH07XG5cbiAgLy8gSW50ZXJuYWwgaW1wbGVtZW50YXRpb24gb2YgYSByZWN1cnNpdmUgYGZsYXR0ZW5gIGZ1bmN0aW9uLlxuICB2YXIgZmxhdHRlbiA9IGZ1bmN0aW9uKGlucHV0LCBzaGFsbG93LCBzdHJpY3QsIHN0YXJ0SW5kZXgpIHtcbiAgICB2YXIgb3V0cHV0ID0gW10sIGlkeCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0SW5kZXggfHwgMCwgbGVuZ3RoID0gZ2V0TGVuZ3RoKGlucHV0KTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdmFsdWUgPSBpbnB1dFtpXTtcbiAgICAgIGlmIChpc0FycmF5TGlrZSh2YWx1ZSkgJiYgKF8uaXNBcnJheSh2YWx1ZSkgfHwgXy5pc0FyZ3VtZW50cyh2YWx1ZSkpKSB7XG4gICAgICAgIC8vZmxhdHRlbiBjdXJyZW50IGxldmVsIG9mIGFycmF5IG9yIGFyZ3VtZW50cyBvYmplY3RcbiAgICAgICAgaWYgKCFzaGFsbG93KSB2YWx1ZSA9IGZsYXR0ZW4odmFsdWUsIHNoYWxsb3csIHN0cmljdCk7XG4gICAgICAgIHZhciBqID0gMCwgbGVuID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICBvdXRwdXQubGVuZ3RoICs9IGxlbjtcbiAgICAgICAgd2hpbGUgKGogPCBsZW4pIHtcbiAgICAgICAgICBvdXRwdXRbaWR4KytdID0gdmFsdWVbaisrXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghc3RyaWN0KSB7XG4gICAgICAgIG91dHB1dFtpZHgrK10gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfTtcblxuICAvLyBGbGF0dGVuIG91dCBhbiBhcnJheSwgZWl0aGVyIHJlY3Vyc2l2ZWx5IChieSBkZWZhdWx0KSwgb3IganVzdCBvbmUgbGV2ZWwuXG4gIF8uZmxhdHRlbiA9IGZ1bmN0aW9uKGFycmF5LCBzaGFsbG93KSB7XG4gICAgcmV0dXJuIGZsYXR0ZW4oYXJyYXksIHNoYWxsb3csIGZhbHNlKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gYSB2ZXJzaW9uIG9mIHRoZSBhcnJheSB0aGF0IGRvZXMgbm90IGNvbnRhaW4gdGhlIHNwZWNpZmllZCB2YWx1ZShzKS5cbiAgXy53aXRob3V0ID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICByZXR1cm4gXy5kaWZmZXJlbmNlKGFycmF5LCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICB9O1xuXG4gIC8vIFByb2R1Y2UgYSBkdXBsaWNhdGUtZnJlZSB2ZXJzaW9uIG9mIHRoZSBhcnJheS4gSWYgdGhlIGFycmF5IGhhcyBhbHJlYWR5XG4gIC8vIGJlZW4gc29ydGVkLCB5b3UgaGF2ZSB0aGUgb3B0aW9uIG9mIHVzaW5nIGEgZmFzdGVyIGFsZ29yaXRobS5cbiAgLy8gQWxpYXNlZCBhcyBgdW5pcXVlYC5cbiAgXy51bmlxID0gXy51bmlxdWUgPSBmdW5jdGlvbihhcnJheSwgaXNTb3J0ZWQsIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgaWYgKCFfLmlzQm9vbGVhbihpc1NvcnRlZCkpIHtcbiAgICAgIGNvbnRleHQgPSBpdGVyYXRlZTtcbiAgICAgIGl0ZXJhdGVlID0gaXNTb3J0ZWQ7XG4gICAgICBpc1NvcnRlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoaXRlcmF0ZWUgIT0gbnVsbCkgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHZhciBzZWVuID0gW107XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGdldExlbmd0aChhcnJheSk7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaV0sXG4gICAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSA/IGl0ZXJhdGVlKHZhbHVlLCBpLCBhcnJheSkgOiB2YWx1ZTtcbiAgICAgIGlmIChpc1NvcnRlZCkge1xuICAgICAgICBpZiAoIWkgfHwgc2VlbiAhPT0gY29tcHV0ZWQpIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgc2VlbiA9IGNvbXB1dGVkO1xuICAgICAgfSBlbHNlIGlmIChpdGVyYXRlZSkge1xuICAgICAgICBpZiAoIV8uY29udGFpbnMoc2VlbiwgY29tcHV0ZWQpKSB7XG4gICAgICAgICAgc2Vlbi5wdXNoKGNvbXB1dGVkKTtcbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIV8uY29udGFpbnMocmVzdWx0LCB2YWx1ZSkpIHtcbiAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFByb2R1Y2UgYW4gYXJyYXkgdGhhdCBjb250YWlucyB0aGUgdW5pb246IGVhY2ggZGlzdGluY3QgZWxlbWVudCBmcm9tIGFsbCBvZlxuICAvLyB0aGUgcGFzc2VkLWluIGFycmF5cy5cbiAgXy51bmlvbiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBfLnVuaXEoZmxhdHRlbihhcmd1bWVudHMsIHRydWUsIHRydWUpKTtcbiAgfTtcblxuICAvLyBQcm9kdWNlIGFuIGFycmF5IHRoYXQgY29udGFpbnMgZXZlcnkgaXRlbSBzaGFyZWQgYmV0d2VlbiBhbGwgdGhlXG4gIC8vIHBhc3NlZC1pbiBhcnJheXMuXG4gIF8uaW50ZXJzZWN0aW9uID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIGFyZ3NMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBnZXRMZW5ndGgoYXJyYXkpOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpdGVtID0gYXJyYXlbaV07XG4gICAgICBpZiAoXy5jb250YWlucyhyZXN1bHQsIGl0ZW0pKSBjb250aW51ZTtcbiAgICAgIGZvciAodmFyIGogPSAxOyBqIDwgYXJnc0xlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmICghXy5jb250YWlucyhhcmd1bWVudHNbal0sIGl0ZW0pKSBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChqID09PSBhcmdzTGVuZ3RoKSByZXN1bHQucHVzaChpdGVtKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBUYWtlIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gb25lIGFycmF5IGFuZCBhIG51bWJlciBvZiBvdGhlciBhcnJheXMuXG4gIC8vIE9ubHkgdGhlIGVsZW1lbnRzIHByZXNlbnQgaW4ganVzdCB0aGUgZmlyc3QgYXJyYXkgd2lsbCByZW1haW4uXG4gIF8uZGlmZmVyZW5jZSA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgdmFyIHJlc3QgPSBmbGF0dGVuKGFyZ3VtZW50cywgdHJ1ZSwgdHJ1ZSwgMSk7XG4gICAgcmV0dXJuIF8uZmlsdGVyKGFycmF5LCBmdW5jdGlvbih2YWx1ZSl7XG4gICAgICByZXR1cm4gIV8uY29udGFpbnMocmVzdCwgdmFsdWUpO1xuICAgIH0pO1xuICB9O1xuXG4gIC8vIFppcCB0b2dldGhlciBtdWx0aXBsZSBsaXN0cyBpbnRvIGEgc2luZ2xlIGFycmF5IC0tIGVsZW1lbnRzIHRoYXQgc2hhcmVcbiAgLy8gYW4gaW5kZXggZ28gdG9nZXRoZXIuXG4gIF8uemlwID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIF8udW56aXAoYXJndW1lbnRzKTtcbiAgfTtcblxuICAvLyBDb21wbGVtZW50IG9mIF8uemlwLiBVbnppcCBhY2NlcHRzIGFuIGFycmF5IG9mIGFycmF5cyBhbmQgZ3JvdXBzXG4gIC8vIGVhY2ggYXJyYXkncyBlbGVtZW50cyBvbiBzaGFyZWQgaW5kaWNlc1xuICBfLnVuemlwID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkgJiYgXy5tYXgoYXJyYXksIGdldExlbmd0aCkubGVuZ3RoIHx8IDA7XG4gICAgdmFyIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICByZXN1bHRbaW5kZXhdID0gXy5wbHVjayhhcnJheSwgaW5kZXgpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIENvbnZlcnRzIGxpc3RzIGludG8gb2JqZWN0cy4gUGFzcyBlaXRoZXIgYSBzaW5nbGUgYXJyYXkgb2YgYFtrZXksIHZhbHVlXWBcbiAgLy8gcGFpcnMsIG9yIHR3byBwYXJhbGxlbCBhcnJheXMgb2YgdGhlIHNhbWUgbGVuZ3RoIC0tIG9uZSBvZiBrZXlzLCBhbmQgb25lIG9mXG4gIC8vIHRoZSBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAgXy5vYmplY3QgPSBmdW5jdGlvbihsaXN0LCB2YWx1ZXMpIHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGdldExlbmd0aChsaXN0KTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodmFsdWVzKSB7XG4gICAgICAgIHJlc3VsdFtsaXN0W2ldXSA9IHZhbHVlc1tpXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdFtsaXN0W2ldWzBdXSA9IGxpc3RbaV1bMV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gR2VuZXJhdG9yIGZ1bmN0aW9uIHRvIGNyZWF0ZSB0aGUgZmluZEluZGV4IGFuZCBmaW5kTGFzdEluZGV4IGZ1bmN0aW9uc1xuICBmdW5jdGlvbiBjcmVhdGVQcmVkaWNhdGVJbmRleEZpbmRlcihkaXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oYXJyYXksIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgICAgcHJlZGljYXRlID0gY2IocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICAgIHZhciBsZW5ndGggPSBnZXRMZW5ndGgoYXJyYXkpO1xuICAgICAgdmFyIGluZGV4ID0gZGlyID4gMCA/IDAgOiBsZW5ndGggLSAxO1xuICAgICAgZm9yICg7IGluZGV4ID49IDAgJiYgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IGRpcikge1xuICAgICAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkgcmV0dXJuIGluZGV4O1xuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH07XG4gIH1cblxuICAvLyBSZXR1cm5zIHRoZSBmaXJzdCBpbmRleCBvbiBhbiBhcnJheS1saWtlIHRoYXQgcGFzc2VzIGEgcHJlZGljYXRlIHRlc3RcbiAgXy5maW5kSW5kZXggPSBjcmVhdGVQcmVkaWNhdGVJbmRleEZpbmRlcigxKTtcbiAgXy5maW5kTGFzdEluZGV4ID0gY3JlYXRlUHJlZGljYXRlSW5kZXhGaW5kZXIoLTEpO1xuXG4gIC8vIFVzZSBhIGNvbXBhcmF0b3IgZnVuY3Rpb24gdG8gZmlndXJlIG91dCB0aGUgc21hbGxlc3QgaW5kZXggYXQgd2hpY2hcbiAgLy8gYW4gb2JqZWN0IHNob3VsZCBiZSBpbnNlcnRlZCBzbyBhcyB0byBtYWludGFpbiBvcmRlci4gVXNlcyBiaW5hcnkgc2VhcmNoLlxuICBfLnNvcnRlZEluZGV4ID0gZnVuY3Rpb24oYXJyYXksIG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0LCAxKTtcbiAgICB2YXIgdmFsdWUgPSBpdGVyYXRlZShvYmopO1xuICAgIHZhciBsb3cgPSAwLCBoaWdoID0gZ2V0TGVuZ3RoKGFycmF5KTtcbiAgICB3aGlsZSAobG93IDwgaGlnaCkge1xuICAgICAgdmFyIG1pZCA9IE1hdGguZmxvb3IoKGxvdyArIGhpZ2gpIC8gMik7XG4gICAgICBpZiAoaXRlcmF0ZWUoYXJyYXlbbWlkXSkgPCB2YWx1ZSkgbG93ID0gbWlkICsgMTsgZWxzZSBoaWdoID0gbWlkO1xuICAgIH1cbiAgICByZXR1cm4gbG93O1xuICB9O1xuXG4gIC8vIEdlbmVyYXRvciBmdW5jdGlvbiB0byBjcmVhdGUgdGhlIGluZGV4T2YgYW5kIGxhc3RJbmRleE9mIGZ1bmN0aW9uc1xuICBmdW5jdGlvbiBjcmVhdGVJbmRleEZpbmRlcihkaXIsIHByZWRpY2F0ZUZpbmQsIHNvcnRlZEluZGV4KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGFycmF5LCBpdGVtLCBpZHgpIHtcbiAgICAgIHZhciBpID0gMCwgbGVuZ3RoID0gZ2V0TGVuZ3RoKGFycmF5KTtcbiAgICAgIGlmICh0eXBlb2YgaWR4ID09ICdudW1iZXInKSB7XG4gICAgICAgIGlmIChkaXIgPiAwKSB7XG4gICAgICAgICAgICBpID0gaWR4ID49IDAgPyBpZHggOiBNYXRoLm1heChpZHggKyBsZW5ndGgsIGkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGVuZ3RoID0gaWR4ID49IDAgPyBNYXRoLm1pbihpZHggKyAxLCBsZW5ndGgpIDogaWR4ICsgbGVuZ3RoICsgMTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzb3J0ZWRJbmRleCAmJiBpZHggJiYgbGVuZ3RoKSB7XG4gICAgICAgIGlkeCA9IHNvcnRlZEluZGV4KGFycmF5LCBpdGVtKTtcbiAgICAgICAgcmV0dXJuIGFycmF5W2lkeF0gPT09IGl0ZW0gPyBpZHggOiAtMTtcbiAgICAgIH1cbiAgICAgIGlmIChpdGVtICE9PSBpdGVtKSB7XG4gICAgICAgIGlkeCA9IHByZWRpY2F0ZUZpbmQoc2xpY2UuY2FsbChhcnJheSwgaSwgbGVuZ3RoKSwgXy5pc05hTik7XG4gICAgICAgIHJldHVybiBpZHggPj0gMCA/IGlkeCArIGkgOiAtMTtcbiAgICAgIH1cbiAgICAgIGZvciAoaWR4ID0gZGlyID4gMCA/IGkgOiBsZW5ndGggLSAxOyBpZHggPj0gMCAmJiBpZHggPCBsZW5ndGg7IGlkeCArPSBkaXIpIHtcbiAgICAgICAgaWYgKGFycmF5W2lkeF0gPT09IGl0ZW0pIHJldHVybiBpZHg7XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfTtcbiAgfVxuXG4gIC8vIFJldHVybiB0aGUgcG9zaXRpb24gb2YgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgYW4gaXRlbSBpbiBhbiBhcnJheSxcbiAgLy8gb3IgLTEgaWYgdGhlIGl0ZW0gaXMgbm90IGluY2x1ZGVkIGluIHRoZSBhcnJheS5cbiAgLy8gSWYgdGhlIGFycmF5IGlzIGxhcmdlIGFuZCBhbHJlYWR5IGluIHNvcnQgb3JkZXIsIHBhc3MgYHRydWVgXG4gIC8vIGZvciAqKmlzU29ydGVkKiogdG8gdXNlIGJpbmFyeSBzZWFyY2guXG4gIF8uaW5kZXhPZiA9IGNyZWF0ZUluZGV4RmluZGVyKDEsIF8uZmluZEluZGV4LCBfLnNvcnRlZEluZGV4KTtcbiAgXy5sYXN0SW5kZXhPZiA9IGNyZWF0ZUluZGV4RmluZGVyKC0xLCBfLmZpbmRMYXN0SW5kZXgpO1xuXG4gIC8vIEdlbmVyYXRlIGFuIGludGVnZXIgQXJyYXkgY29udGFpbmluZyBhbiBhcml0aG1ldGljIHByb2dyZXNzaW9uLiBBIHBvcnQgb2ZcbiAgLy8gdGhlIG5hdGl2ZSBQeXRob24gYHJhbmdlKClgIGZ1bmN0aW9uLiBTZWVcbiAgLy8gW3RoZSBQeXRob24gZG9jdW1lbnRhdGlvbl0oaHR0cDovL2RvY3MucHl0aG9uLm9yZy9saWJyYXJ5L2Z1bmN0aW9ucy5odG1sI3JhbmdlKS5cbiAgXy5yYW5nZSA9IGZ1bmN0aW9uKHN0YXJ0LCBzdG9wLCBzdGVwKSB7XG4gICAgaWYgKHN0b3AgPT0gbnVsbCkge1xuICAgICAgc3RvcCA9IHN0YXJ0IHx8IDA7XG4gICAgICBzdGFydCA9IDA7XG4gICAgfVxuICAgIHN0ZXAgPSBzdGVwIHx8IDE7XG5cbiAgICB2YXIgbGVuZ3RoID0gTWF0aC5tYXgoTWF0aC5jZWlsKChzdG9wIC0gc3RhcnQpIC8gc3RlcCksIDApO1xuICAgIHZhciByYW5nZSA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICBmb3IgKHZhciBpZHggPSAwOyBpZHggPCBsZW5ndGg7IGlkeCsrLCBzdGFydCArPSBzdGVwKSB7XG4gICAgICByYW5nZVtpZHhdID0gc3RhcnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJhbmdlO1xuICB9O1xuXG4gIC8vIEZ1bmN0aW9uIChhaGVtKSBGdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gRGV0ZXJtaW5lcyB3aGV0aGVyIHRvIGV4ZWN1dGUgYSBmdW5jdGlvbiBhcyBhIGNvbnN0cnVjdG9yXG4gIC8vIG9yIGEgbm9ybWFsIGZ1bmN0aW9uIHdpdGggdGhlIHByb3ZpZGVkIGFyZ3VtZW50c1xuICB2YXIgZXhlY3V0ZUJvdW5kID0gZnVuY3Rpb24oc291cmNlRnVuYywgYm91bmRGdW5jLCBjb250ZXh0LCBjYWxsaW5nQ29udGV4dCwgYXJncykge1xuICAgIGlmICghKGNhbGxpbmdDb250ZXh0IGluc3RhbmNlb2YgYm91bmRGdW5jKSkgcmV0dXJuIHNvdXJjZUZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgdmFyIHNlbGYgPSBiYXNlQ3JlYXRlKHNvdXJjZUZ1bmMucHJvdG90eXBlKTtcbiAgICB2YXIgcmVzdWx0ID0gc291cmNlRnVuYy5hcHBseShzZWxmLCBhcmdzKTtcbiAgICBpZiAoXy5pc09iamVjdChyZXN1bHQpKSByZXR1cm4gcmVzdWx0O1xuICAgIHJldHVybiBzZWxmO1xuICB9O1xuXG4gIC8vIENyZWF0ZSBhIGZ1bmN0aW9uIGJvdW5kIHRvIGEgZ2l2ZW4gb2JqZWN0IChhc3NpZ25pbmcgYHRoaXNgLCBhbmQgYXJndW1lbnRzLFxuICAvLyBvcHRpb25hbGx5KS4gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYEZ1bmN0aW9uLmJpbmRgIGlmXG4gIC8vIGF2YWlsYWJsZS5cbiAgXy5iaW5kID0gZnVuY3Rpb24oZnVuYywgY29udGV4dCkge1xuICAgIGlmIChuYXRpdmVCaW5kICYmIGZ1bmMuYmluZCA9PT0gbmF0aXZlQmluZCkgcmV0dXJuIG5hdGl2ZUJpbmQuYXBwbHkoZnVuYywgc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgICBpZiAoIV8uaXNGdW5jdGlvbihmdW5jKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQmluZCBtdXN0IGJlIGNhbGxlZCBvbiBhIGZ1bmN0aW9uJyk7XG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgdmFyIGJvdW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZXhlY3V0ZUJvdW5kKGZ1bmMsIGJvdW5kLCBjb250ZXh0LCB0aGlzLCBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbiAgICB9O1xuICAgIHJldHVybiBib3VuZDtcbiAgfTtcblxuICAvLyBQYXJ0aWFsbHkgYXBwbHkgYSBmdW5jdGlvbiBieSBjcmVhdGluZyBhIHZlcnNpb24gdGhhdCBoYXMgaGFkIHNvbWUgb2YgaXRzXG4gIC8vIGFyZ3VtZW50cyBwcmUtZmlsbGVkLCB3aXRob3V0IGNoYW5naW5nIGl0cyBkeW5hbWljIGB0aGlzYCBjb250ZXh0LiBfIGFjdHNcbiAgLy8gYXMgYSBwbGFjZWhvbGRlciwgYWxsb3dpbmcgYW55IGNvbWJpbmF0aW9uIG9mIGFyZ3VtZW50cyB0byBiZSBwcmUtZmlsbGVkLlxuICBfLnBhcnRpYWwgPSBmdW5jdGlvbihmdW5jKSB7XG4gICAgdmFyIGJvdW5kQXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICB2YXIgYm91bmQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwb3NpdGlvbiA9IDAsIGxlbmd0aCA9IGJvdW5kQXJncy5sZW5ndGg7XG4gICAgICB2YXIgYXJncyA9IEFycmF5KGxlbmd0aCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFyZ3NbaV0gPSBib3VuZEFyZ3NbaV0gPT09IF8gPyBhcmd1bWVudHNbcG9zaXRpb24rK10gOiBib3VuZEFyZ3NbaV07XG4gICAgICB9XG4gICAgICB3aGlsZSAocG9zaXRpb24gPCBhcmd1bWVudHMubGVuZ3RoKSBhcmdzLnB1c2goYXJndW1lbnRzW3Bvc2l0aW9uKytdKTtcbiAgICAgIHJldHVybiBleGVjdXRlQm91bmQoZnVuYywgYm91bmQsIHRoaXMsIHRoaXMsIGFyZ3MpO1xuICAgIH07XG4gICAgcmV0dXJuIGJvdW5kO1xuICB9O1xuXG4gIC8vIEJpbmQgYSBudW1iZXIgb2YgYW4gb2JqZWN0J3MgbWV0aG9kcyB0byB0aGF0IG9iamVjdC4gUmVtYWluaW5nIGFyZ3VtZW50c1xuICAvLyBhcmUgdGhlIG1ldGhvZCBuYW1lcyB0byBiZSBib3VuZC4gVXNlZnVsIGZvciBlbnN1cmluZyB0aGF0IGFsbCBjYWxsYmFja3NcbiAgLy8gZGVmaW5lZCBvbiBhbiBvYmplY3QgYmVsb25nIHRvIGl0LlxuICBfLmJpbmRBbGwgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgaSwgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCwga2V5O1xuICAgIGlmIChsZW5ndGggPD0gMSkgdGhyb3cgbmV3IEVycm9yKCdiaW5kQWxsIG11c3QgYmUgcGFzc2VkIGZ1bmN0aW9uIG5hbWVzJyk7XG4gICAgZm9yIChpID0gMTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXkgPSBhcmd1bWVudHNbaV07XG4gICAgICBvYmpba2V5XSA9IF8uYmluZChvYmpba2V5XSwgb2JqKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICAvLyBNZW1vaXplIGFuIGV4cGVuc2l2ZSBmdW5jdGlvbiBieSBzdG9yaW5nIGl0cyByZXN1bHRzLlxuICBfLm1lbW9pemUgPSBmdW5jdGlvbihmdW5jLCBoYXNoZXIpIHtcbiAgICB2YXIgbWVtb2l6ZSA9IGZ1bmN0aW9uKGtleSkge1xuICAgICAgdmFyIGNhY2hlID0gbWVtb2l6ZS5jYWNoZTtcbiAgICAgIHZhciBhZGRyZXNzID0gJycgKyAoaGFzaGVyID8gaGFzaGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiBrZXkpO1xuICAgICAgaWYgKCFfLmhhcyhjYWNoZSwgYWRkcmVzcykpIGNhY2hlW2FkZHJlc3NdID0gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIGNhY2hlW2FkZHJlc3NdO1xuICAgIH07XG4gICAgbWVtb2l6ZS5jYWNoZSA9IHt9O1xuICAgIHJldHVybiBtZW1vaXplO1xuICB9O1xuXG4gIC8vIERlbGF5cyBhIGZ1bmN0aW9uIGZvciB0aGUgZ2l2ZW4gbnVtYmVyIG9mIG1pbGxpc2Vjb25kcywgYW5kIHRoZW4gY2FsbHNcbiAgLy8gaXQgd2l0aCB0aGUgYXJndW1lbnRzIHN1cHBsaWVkLlxuICBfLmRlbGF5ID0gZnVuY3Rpb24oZnVuYywgd2FpdCkge1xuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gZnVuYy5hcHBseShudWxsLCBhcmdzKTtcbiAgICB9LCB3YWl0KTtcbiAgfTtcblxuICAvLyBEZWZlcnMgYSBmdW5jdGlvbiwgc2NoZWR1bGluZyBpdCB0byBydW4gYWZ0ZXIgdGhlIGN1cnJlbnQgY2FsbCBzdGFjayBoYXNcbiAgLy8gY2xlYXJlZC5cbiAgXy5kZWZlciA9IF8ucGFydGlhbChfLmRlbGF5LCBfLCAxKTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24sIHRoYXQsIHdoZW4gaW52b2tlZCwgd2lsbCBvbmx5IGJlIHRyaWdnZXJlZCBhdCBtb3N0IG9uY2VcbiAgLy8gZHVyaW5nIGEgZ2l2ZW4gd2luZG93IG9mIHRpbWUuIE5vcm1hbGx5LCB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uIHdpbGwgcnVuXG4gIC8vIGFzIG11Y2ggYXMgaXQgY2FuLCB3aXRob3V0IGV2ZXIgZ29pbmcgbW9yZSB0aGFuIG9uY2UgcGVyIGB3YWl0YCBkdXJhdGlvbjtcbiAgLy8gYnV0IGlmIHlvdSdkIGxpa2UgdG8gZGlzYWJsZSB0aGUgZXhlY3V0aW9uIG9uIHRoZSBsZWFkaW5nIGVkZ2UsIHBhc3NcbiAgLy8gYHtsZWFkaW5nOiBmYWxzZX1gLiBUbyBkaXNhYmxlIGV4ZWN1dGlvbiBvbiB0aGUgdHJhaWxpbmcgZWRnZSwgZGl0dG8uXG4gIF8udGhyb3R0bGUgPSBmdW5jdGlvbihmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gICAgdmFyIGNvbnRleHQsIGFyZ3MsIHJlc3VsdDtcbiAgICB2YXIgdGltZW91dCA9IG51bGw7XG4gICAgdmFyIHByZXZpb3VzID0gMDtcbiAgICBpZiAoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fTtcbiAgICB2YXIgbGF0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHByZXZpb3VzID0gb3B0aW9ucy5sZWFkaW5nID09PSBmYWxzZSA/IDAgOiBfLm5vdygpO1xuICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgaWYgKCF0aW1lb3V0KSBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbm93ID0gXy5ub3coKTtcbiAgICAgIGlmICghcHJldmlvdXMgJiYgb3B0aW9ucy5sZWFkaW5nID09PSBmYWxzZSkgcHJldmlvdXMgPSBub3c7XG4gICAgICB2YXIgcmVtYWluaW5nID0gd2FpdCAtIChub3cgLSBwcmV2aW91cyk7XG4gICAgICBjb250ZXh0ID0gdGhpcztcbiAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICBpZiAocmVtYWluaW5nIDw9IDAgfHwgcmVtYWluaW5nID4gd2FpdCkge1xuICAgICAgICBpZiAodGltZW91dCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBwcmV2aW91cyA9IG5vdztcbiAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgaWYgKCF0aW1lb3V0KSBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgICB9IGVsc2UgaWYgKCF0aW1lb3V0ICYmIG9wdGlvbnMudHJhaWxpbmcgIT09IGZhbHNlKSB7XG4gICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCByZW1haW5pbmcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiwgdGhhdCwgYXMgbG9uZyBhcyBpdCBjb250aW51ZXMgdG8gYmUgaW52b2tlZCwgd2lsbCBub3RcbiAgLy8gYmUgdHJpZ2dlcmVkLiBUaGUgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgaXQgc3RvcHMgYmVpbmcgY2FsbGVkIGZvclxuICAvLyBOIG1pbGxpc2Vjb25kcy4gSWYgYGltbWVkaWF0ZWAgaXMgcGFzc2VkLCB0cmlnZ2VyIHRoZSBmdW5jdGlvbiBvbiB0aGVcbiAgLy8gbGVhZGluZyBlZGdlLCBpbnN0ZWFkIG9mIHRoZSB0cmFpbGluZy5cbiAgXy5kZWJvdW5jZSA9IGZ1bmN0aW9uKGZ1bmMsIHdhaXQsIGltbWVkaWF0ZSkge1xuICAgIHZhciB0aW1lb3V0LCBhcmdzLCBjb250ZXh0LCB0aW1lc3RhbXAsIHJlc3VsdDtcblxuICAgIHZhciBsYXRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGxhc3QgPSBfLm5vdygpIC0gdGltZXN0YW1wO1xuXG4gICAgICBpZiAobGFzdCA8IHdhaXQgJiYgbGFzdCA+PSAwKSB7XG4gICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCB3YWl0IC0gbGFzdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgaWYgKCFpbW1lZGlhdGUpIHtcbiAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICAgIGlmICghdGltZW91dCkgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnRleHQgPSB0aGlzO1xuICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIHRpbWVzdGFtcCA9IF8ubm93KCk7XG4gICAgICB2YXIgY2FsbE5vdyA9IGltbWVkaWF0ZSAmJiAhdGltZW91dDtcbiAgICAgIGlmICghdGltZW91dCkgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQpO1xuICAgICAgaWYgKGNhbGxOb3cpIHtcbiAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyB0aGUgZmlyc3QgZnVuY3Rpb24gcGFzc2VkIGFzIGFuIGFyZ3VtZW50IHRvIHRoZSBzZWNvbmQsXG4gIC8vIGFsbG93aW5nIHlvdSB0byBhZGp1c3QgYXJndW1lbnRzLCBydW4gY29kZSBiZWZvcmUgYW5kIGFmdGVyLCBhbmRcbiAgLy8gY29uZGl0aW9uYWxseSBleGVjdXRlIHRoZSBvcmlnaW5hbCBmdW5jdGlvbi5cbiAgXy53cmFwID0gZnVuY3Rpb24oZnVuYywgd3JhcHBlcikge1xuICAgIHJldHVybiBfLnBhcnRpYWwod3JhcHBlciwgZnVuYyk7XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIG5lZ2F0ZWQgdmVyc2lvbiBvZiB0aGUgcGFzc2VkLWluIHByZWRpY2F0ZS5cbiAgXy5uZWdhdGUgPSBmdW5jdGlvbihwcmVkaWNhdGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gIXByZWRpY2F0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgaXMgdGhlIGNvbXBvc2l0aW9uIG9mIGEgbGlzdCBvZiBmdW5jdGlvbnMsIGVhY2hcbiAgLy8gY29uc3VtaW5nIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGZ1bmN0aW9uIHRoYXQgZm9sbG93cy5cbiAgXy5jb21wb3NlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgdmFyIHN0YXJ0ID0gYXJncy5sZW5ndGggLSAxO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpID0gc3RhcnQ7XG4gICAgICB2YXIgcmVzdWx0ID0gYXJnc1tzdGFydF0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHdoaWxlIChpLS0pIHJlc3VsdCA9IGFyZ3NbaV0uY2FsbCh0aGlzLCByZXN1bHQpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgb25seSBiZSBleGVjdXRlZCBvbiBhbmQgYWZ0ZXIgdGhlIE50aCBjYWxsLlxuICBfLmFmdGVyID0gZnVuY3Rpb24odGltZXMsIGZ1bmMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoLS10aW1lcyA8IDEpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgb25seSBiZSBleGVjdXRlZCB1cCB0byAoYnV0IG5vdCBpbmNsdWRpbmcpIHRoZSBOdGggY2FsbC5cbiAgXy5iZWZvcmUgPSBmdW5jdGlvbih0aW1lcywgZnVuYykge1xuICAgIHZhciBtZW1vO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICgtLXRpbWVzID4gMCkge1xuICAgICAgICBtZW1vID0gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgaWYgKHRpbWVzIDw9IDEpIGZ1bmMgPSBudWxsO1xuICAgICAgcmV0dXJuIG1lbW87XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIGF0IG1vc3Qgb25lIHRpbWUsIG5vIG1hdHRlciBob3dcbiAgLy8gb2Z0ZW4geW91IGNhbGwgaXQuIFVzZWZ1bCBmb3IgbGF6eSBpbml0aWFsaXphdGlvbi5cbiAgXy5vbmNlID0gXy5wYXJ0aWFsKF8uYmVmb3JlLCAyKTtcblxuICAvLyBPYmplY3QgRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBLZXlzIGluIElFIDwgOSB0aGF0IHdvbid0IGJlIGl0ZXJhdGVkIGJ5IGBmb3Iga2V5IGluIC4uLmAgYW5kIHRodXMgbWlzc2VkLlxuICB2YXIgaGFzRW51bUJ1ZyA9ICF7dG9TdHJpbmc6IG51bGx9LnByb3BlcnR5SXNFbnVtZXJhYmxlKCd0b1N0cmluZycpO1xuICB2YXIgbm9uRW51bWVyYWJsZVByb3BzID0gWyd2YWx1ZU9mJywgJ2lzUHJvdG90eXBlT2YnLCAndG9TdHJpbmcnLFxuICAgICAgICAgICAgICAgICAgICAgICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsICdoYXNPd25Qcm9wZXJ0eScsICd0b0xvY2FsZVN0cmluZyddO1xuXG4gIGZ1bmN0aW9uIGNvbGxlY3ROb25FbnVtUHJvcHMob2JqLCBrZXlzKSB7XG4gICAgdmFyIG5vbkVudW1JZHggPSBub25FbnVtZXJhYmxlUHJvcHMubGVuZ3RoO1xuICAgIHZhciBjb25zdHJ1Y3RvciA9IG9iai5jb25zdHJ1Y3RvcjtcbiAgICB2YXIgcHJvdG8gPSAoXy5pc0Z1bmN0aW9uKGNvbnN0cnVjdG9yKSAmJiBjb25zdHJ1Y3Rvci5wcm90b3R5cGUpIHx8IE9ialByb3RvO1xuXG4gICAgLy8gQ29uc3RydWN0b3IgaXMgYSBzcGVjaWFsIGNhc2UuXG4gICAgdmFyIHByb3AgPSAnY29uc3RydWN0b3InO1xuICAgIGlmIChfLmhhcyhvYmosIHByb3ApICYmICFfLmNvbnRhaW5zKGtleXMsIHByb3ApKSBrZXlzLnB1c2gocHJvcCk7XG5cbiAgICB3aGlsZSAobm9uRW51bUlkeC0tKSB7XG4gICAgICBwcm9wID0gbm9uRW51bWVyYWJsZVByb3BzW25vbkVudW1JZHhdO1xuICAgICAgaWYgKHByb3AgaW4gb2JqICYmIG9ialtwcm9wXSAhPT0gcHJvdG9bcHJvcF0gJiYgIV8uY29udGFpbnMoa2V5cywgcHJvcCkpIHtcbiAgICAgICAga2V5cy5wdXNoKHByb3ApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFJldHJpZXZlIHRoZSBuYW1lcyBvZiBhbiBvYmplY3QncyBvd24gcHJvcGVydGllcy5cbiAgLy8gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYE9iamVjdC5rZXlzYFxuICBfLmtleXMgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAoIV8uaXNPYmplY3Qob2JqKSkgcmV0dXJuIFtdO1xuICAgIGlmIChuYXRpdmVLZXlzKSByZXR1cm4gbmF0aXZlS2V5cyhvYmopO1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikgaWYgKF8uaGFzKG9iaiwga2V5KSkga2V5cy5wdXNoKGtleSk7XG4gICAgLy8gQWhlbSwgSUUgPCA5LlxuICAgIGlmIChoYXNFbnVtQnVnKSBjb2xsZWN0Tm9uRW51bVByb3BzKG9iaiwga2V5cyk7XG4gICAgcmV0dXJuIGtleXM7XG4gIH07XG5cbiAgLy8gUmV0cmlldmUgYWxsIHRoZSBwcm9wZXJ0eSBuYW1lcyBvZiBhbiBvYmplY3QuXG4gIF8uYWxsS2V5cyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmICghXy5pc09iamVjdChvYmopKSByZXR1cm4gW107XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSBrZXlzLnB1c2goa2V5KTtcbiAgICAvLyBBaGVtLCBJRSA8IDkuXG4gICAgaWYgKGhhc0VudW1CdWcpIGNvbGxlY3ROb25FbnVtUHJvcHMob2JqLCBrZXlzKTtcbiAgICByZXR1cm4ga2V5cztcbiAgfTtcblxuICAvLyBSZXRyaWV2ZSB0aGUgdmFsdWVzIG9mIGFuIG9iamVjdCdzIHByb3BlcnRpZXMuXG4gIF8udmFsdWVzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIGtleXMgPSBfLmtleXMob2JqKTtcbiAgICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgdmFyIHZhbHVlcyA9IEFycmF5KGxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFsdWVzW2ldID0gb2JqW2tleXNbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVzO1xuICB9O1xuXG4gIC8vIFJldHVybnMgdGhlIHJlc3VsdHMgb2YgYXBwbHlpbmcgdGhlIGl0ZXJhdGVlIHRvIGVhY2ggZWxlbWVudCBvZiB0aGUgb2JqZWN0XG4gIC8vIEluIGNvbnRyYXN0IHRvIF8ubWFwIGl0IHJldHVybnMgYW4gb2JqZWN0XG4gIF8ubWFwT2JqZWN0ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgIHZhciBrZXlzID0gIF8ua2V5cyhvYmopLFxuICAgICAgICAgIGxlbmd0aCA9IGtleXMubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdHMgPSB7fSxcbiAgICAgICAgICBjdXJyZW50S2V5O1xuICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICBjdXJyZW50S2V5ID0ga2V5c1tpbmRleF07XG4gICAgICAgIHJlc3VsdHNbY3VycmVudEtleV0gPSBpdGVyYXRlZShvYmpbY3VycmVudEtleV0sIGN1cnJlbnRLZXksIG9iaik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICAvLyBDb252ZXJ0IGFuIG9iamVjdCBpbnRvIGEgbGlzdCBvZiBgW2tleSwgdmFsdWVdYCBwYWlycy5cbiAgXy5wYWlycyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaik7XG4gICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIHZhciBwYWlycyA9IEFycmF5KGxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgcGFpcnNbaV0gPSBba2V5c1tpXSwgb2JqW2tleXNbaV1dXTtcbiAgICB9XG4gICAgcmV0dXJuIHBhaXJzO1xuICB9O1xuXG4gIC8vIEludmVydCB0aGUga2V5cyBhbmQgdmFsdWVzIG9mIGFuIG9iamVjdC4gVGhlIHZhbHVlcyBtdXN0IGJlIHNlcmlhbGl6YWJsZS5cbiAgXy5pbnZlcnQgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgdmFyIGtleXMgPSBfLmtleXMob2JqKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgcmVzdWx0W29ialtrZXlzW2ldXV0gPSBrZXlzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFJldHVybiBhIHNvcnRlZCBsaXN0IG9mIHRoZSBmdW5jdGlvbiBuYW1lcyBhdmFpbGFibGUgb24gdGhlIG9iamVjdC5cbiAgLy8gQWxpYXNlZCBhcyBgbWV0aG9kc2BcbiAgXy5mdW5jdGlvbnMgPSBfLm1ldGhvZHMgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgbmFtZXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICBpZiAoXy5pc0Z1bmN0aW9uKG9ialtrZXldKSkgbmFtZXMucHVzaChrZXkpO1xuICAgIH1cbiAgICByZXR1cm4gbmFtZXMuc29ydCgpO1xuICB9O1xuXG4gIC8vIEV4dGVuZCBhIGdpdmVuIG9iamVjdCB3aXRoIGFsbCB0aGUgcHJvcGVydGllcyBpbiBwYXNzZWQtaW4gb2JqZWN0KHMpLlxuICBfLmV4dGVuZCA9IGNyZWF0ZUFzc2lnbmVyKF8uYWxsS2V5cyk7XG5cbiAgLy8gQXNzaWducyBhIGdpdmVuIG9iamVjdCB3aXRoIGFsbCB0aGUgb3duIHByb3BlcnRpZXMgaW4gdGhlIHBhc3NlZC1pbiBvYmplY3QocylcbiAgLy8gKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9hc3NpZ24pXG4gIF8uZXh0ZW5kT3duID0gXy5hc3NpZ24gPSBjcmVhdGVBc3NpZ25lcihfLmtleXMpO1xuXG4gIC8vIFJldHVybnMgdGhlIGZpcnN0IGtleSBvbiBhbiBvYmplY3QgdGhhdCBwYXNzZXMgYSBwcmVkaWNhdGUgdGVzdFxuICBfLmZpbmRLZXkgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgdmFyIGtleXMgPSBfLmtleXMob2JqKSwga2V5O1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgaWYgKHByZWRpY2F0ZShvYmpba2V5XSwga2V5LCBvYmopKSByZXR1cm4ga2V5O1xuICAgIH1cbiAgfTtcblxuICAvLyBSZXR1cm4gYSBjb3B5IG9mIHRoZSBvYmplY3Qgb25seSBjb250YWluaW5nIHRoZSB3aGl0ZWxpc3RlZCBwcm9wZXJ0aWVzLlxuICBfLnBpY2sgPSBmdW5jdGlvbihvYmplY3QsIG9pdGVyYXRlZSwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHQgPSB7fSwgb2JqID0gb2JqZWN0LCBpdGVyYXRlZSwga2V5cztcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiByZXN1bHQ7XG4gICAgaWYgKF8uaXNGdW5jdGlvbihvaXRlcmF0ZWUpKSB7XG4gICAgICBrZXlzID0gXy5hbGxLZXlzKG9iaik7XG4gICAgICBpdGVyYXRlZSA9IG9wdGltaXplQ2Iob2l0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAga2V5cyA9IGZsYXR0ZW4oYXJndW1lbnRzLCBmYWxzZSwgZmFsc2UsIDEpO1xuICAgICAgaXRlcmF0ZWUgPSBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmopIHsgcmV0dXJuIGtleSBpbiBvYmo7IH07XG4gICAgICBvYmogPSBPYmplY3Qob2JqKTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgdmFyIHZhbHVlID0gb2JqW2tleV07XG4gICAgICBpZiAoaXRlcmF0ZWUodmFsdWUsIGtleSwgb2JqKSkgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAgLy8gUmV0dXJuIGEgY29weSBvZiB0aGUgb2JqZWN0IHdpdGhvdXQgdGhlIGJsYWNrbGlzdGVkIHByb3BlcnRpZXMuXG4gIF8ub21pdCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpZiAoXy5pc0Z1bmN0aW9uKGl0ZXJhdGVlKSkge1xuICAgICAgaXRlcmF0ZWUgPSBfLm5lZ2F0ZShpdGVyYXRlZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBrZXlzID0gXy5tYXAoZmxhdHRlbihhcmd1bWVudHMsIGZhbHNlLCBmYWxzZSwgMSksIFN0cmluZyk7XG4gICAgICBpdGVyYXRlZSA9IGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgcmV0dXJuICFfLmNvbnRhaW5zKGtleXMsIGtleSk7XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gXy5waWNrKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpO1xuICB9O1xuXG4gIC8vIEZpbGwgaW4gYSBnaXZlbiBvYmplY3Qgd2l0aCBkZWZhdWx0IHByb3BlcnRpZXMuXG4gIF8uZGVmYXVsdHMgPSBjcmVhdGVBc3NpZ25lcihfLmFsbEtleXMsIHRydWUpO1xuXG4gIC8vIENyZWF0ZXMgYW4gb2JqZWN0IHRoYXQgaW5oZXJpdHMgZnJvbSB0aGUgZ2l2ZW4gcHJvdG90eXBlIG9iamVjdC5cbiAgLy8gSWYgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIGFyZSBwcm92aWRlZCB0aGVuIHRoZXkgd2lsbCBiZSBhZGRlZCB0byB0aGVcbiAgLy8gY3JlYXRlZCBvYmplY3QuXG4gIF8uY3JlYXRlID0gZnVuY3Rpb24ocHJvdG90eXBlLCBwcm9wcykge1xuICAgIHZhciByZXN1bHQgPSBiYXNlQ3JlYXRlKHByb3RvdHlwZSk7XG4gICAgaWYgKHByb3BzKSBfLmV4dGVuZE93bihyZXN1bHQsIHByb3BzKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIENyZWF0ZSBhIChzaGFsbG93LWNsb25lZCkgZHVwbGljYXRlIG9mIGFuIG9iamVjdC5cbiAgXy5jbG9uZSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmICghXy5pc09iamVjdChvYmopKSByZXR1cm4gb2JqO1xuICAgIHJldHVybiBfLmlzQXJyYXkob2JqKSA/IG9iai5zbGljZSgpIDogXy5leHRlbmQoe30sIG9iaik7XG4gIH07XG5cbiAgLy8gSW52b2tlcyBpbnRlcmNlcHRvciB3aXRoIHRoZSBvYmosIGFuZCB0aGVuIHJldHVybnMgb2JqLlxuICAvLyBUaGUgcHJpbWFyeSBwdXJwb3NlIG9mIHRoaXMgbWV0aG9kIGlzIHRvIFwidGFwIGludG9cIiBhIG1ldGhvZCBjaGFpbiwgaW5cbiAgLy8gb3JkZXIgdG8gcGVyZm9ybSBvcGVyYXRpb25zIG9uIGludGVybWVkaWF0ZSByZXN1bHRzIHdpdGhpbiB0aGUgY2hhaW4uXG4gIF8udGFwID0gZnVuY3Rpb24ob2JqLCBpbnRlcmNlcHRvcikge1xuICAgIGludGVyY2VwdG9yKG9iaik7XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICAvLyBSZXR1cm5zIHdoZXRoZXIgYW4gb2JqZWN0IGhhcyBhIGdpdmVuIHNldCBvZiBga2V5OnZhbHVlYCBwYWlycy5cbiAgXy5pc01hdGNoID0gZnVuY3Rpb24ob2JqZWN0LCBhdHRycykge1xuICAgIHZhciBrZXlzID0gXy5rZXlzKGF0dHJzKSwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgaWYgKG9iamVjdCA9PSBudWxsKSByZXR1cm4gIWxlbmd0aDtcbiAgICB2YXIgb2JqID0gT2JqZWN0KG9iamVjdCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICBpZiAoYXR0cnNba2V5XSAhPT0gb2JqW2tleV0gfHwgIShrZXkgaW4gb2JqKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuXG4gIC8vIEludGVybmFsIHJlY3Vyc2l2ZSBjb21wYXJpc29uIGZ1bmN0aW9uIGZvciBgaXNFcXVhbGAuXG4gIHZhciBlcSA9IGZ1bmN0aW9uKGEsIGIsIGFTdGFjaywgYlN0YWNrKSB7XG4gICAgLy8gSWRlbnRpY2FsIG9iamVjdHMgYXJlIGVxdWFsLiBgMCA9PT0gLTBgLCBidXQgdGhleSBhcmVuJ3QgaWRlbnRpY2FsLlxuICAgIC8vIFNlZSB0aGUgW0hhcm1vbnkgYGVnYWxgIHByb3Bvc2FsXShodHRwOi8vd2lraS5lY21hc2NyaXB0Lm9yZy9kb2t1LnBocD9pZD1oYXJtb255OmVnYWwpLlxuICAgIGlmIChhID09PSBiKSByZXR1cm4gYSAhPT0gMCB8fCAxIC8gYSA9PT0gMSAvIGI7XG4gICAgLy8gQSBzdHJpY3QgY29tcGFyaXNvbiBpcyBuZWNlc3NhcnkgYmVjYXVzZSBgbnVsbCA9PSB1bmRlZmluZWRgLlxuICAgIGlmIChhID09IG51bGwgfHwgYiA9PSBudWxsKSByZXR1cm4gYSA9PT0gYjtcbiAgICAvLyBVbndyYXAgYW55IHdyYXBwZWQgb2JqZWN0cy5cbiAgICBpZiAoYSBpbnN0YW5jZW9mIF8pIGEgPSBhLl93cmFwcGVkO1xuICAgIGlmIChiIGluc3RhbmNlb2YgXykgYiA9IGIuX3dyYXBwZWQ7XG4gICAgLy8gQ29tcGFyZSBgW1tDbGFzc11dYCBuYW1lcy5cbiAgICB2YXIgY2xhc3NOYW1lID0gdG9TdHJpbmcuY2FsbChhKTtcbiAgICBpZiAoY2xhc3NOYW1lICE9PSB0b1N0cmluZy5jYWxsKGIpKSByZXR1cm4gZmFsc2U7XG4gICAgc3dpdGNoIChjbGFzc05hbWUpIHtcbiAgICAgIC8vIFN0cmluZ3MsIG51bWJlcnMsIHJlZ3VsYXIgZXhwcmVzc2lvbnMsIGRhdGVzLCBhbmQgYm9vbGVhbnMgYXJlIGNvbXBhcmVkIGJ5IHZhbHVlLlxuICAgICAgY2FzZSAnW29iamVjdCBSZWdFeHBdJzpcbiAgICAgIC8vIFJlZ0V4cHMgYXJlIGNvZXJjZWQgdG8gc3RyaW5ncyBmb3IgY29tcGFyaXNvbiAoTm90ZTogJycgKyAvYS9pID09PSAnL2EvaScpXG4gICAgICBjYXNlICdbb2JqZWN0IFN0cmluZ10nOlxuICAgICAgICAvLyBQcmltaXRpdmVzIGFuZCB0aGVpciBjb3JyZXNwb25kaW5nIG9iamVjdCB3cmFwcGVycyBhcmUgZXF1aXZhbGVudDsgdGh1cywgYFwiNVwiYCBpc1xuICAgICAgICAvLyBlcXVpdmFsZW50IHRvIGBuZXcgU3RyaW5nKFwiNVwiKWAuXG4gICAgICAgIHJldHVybiAnJyArIGEgPT09ICcnICsgYjtcbiAgICAgIGNhc2UgJ1tvYmplY3QgTnVtYmVyXSc6XG4gICAgICAgIC8vIGBOYU5gcyBhcmUgZXF1aXZhbGVudCwgYnV0IG5vbi1yZWZsZXhpdmUuXG4gICAgICAgIC8vIE9iamVjdChOYU4pIGlzIGVxdWl2YWxlbnQgdG8gTmFOXG4gICAgICAgIGlmICgrYSAhPT0gK2EpIHJldHVybiArYiAhPT0gK2I7XG4gICAgICAgIC8vIEFuIGBlZ2FsYCBjb21wYXJpc29uIGlzIHBlcmZvcm1lZCBmb3Igb3RoZXIgbnVtZXJpYyB2YWx1ZXMuXG4gICAgICAgIHJldHVybiArYSA9PT0gMCA/IDEgLyArYSA9PT0gMSAvIGIgOiArYSA9PT0gK2I7XG4gICAgICBjYXNlICdbb2JqZWN0IERhdGVdJzpcbiAgICAgIGNhc2UgJ1tvYmplY3QgQm9vbGVhbl0nOlxuICAgICAgICAvLyBDb2VyY2UgZGF0ZXMgYW5kIGJvb2xlYW5zIHRvIG51bWVyaWMgcHJpbWl0aXZlIHZhbHVlcy4gRGF0ZXMgYXJlIGNvbXBhcmVkIGJ5IHRoZWlyXG4gICAgICAgIC8vIG1pbGxpc2Vjb25kIHJlcHJlc2VudGF0aW9ucy4gTm90ZSB0aGF0IGludmFsaWQgZGF0ZXMgd2l0aCBtaWxsaXNlY29uZCByZXByZXNlbnRhdGlvbnNcbiAgICAgICAgLy8gb2YgYE5hTmAgYXJlIG5vdCBlcXVpdmFsZW50LlxuICAgICAgICByZXR1cm4gK2EgPT09ICtiO1xuICAgIH1cblxuICAgIHZhciBhcmVBcnJheXMgPSBjbGFzc05hbWUgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgaWYgKCFhcmVBcnJheXMpIHtcbiAgICAgIGlmICh0eXBlb2YgYSAhPSAnb2JqZWN0JyB8fCB0eXBlb2YgYiAhPSAnb2JqZWN0JykgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAvLyBPYmplY3RzIHdpdGggZGlmZmVyZW50IGNvbnN0cnVjdG9ycyBhcmUgbm90IGVxdWl2YWxlbnQsIGJ1dCBgT2JqZWN0YHMgb3IgYEFycmF5YHNcbiAgICAgIC8vIGZyb20gZGlmZmVyZW50IGZyYW1lcyBhcmUuXG4gICAgICB2YXIgYUN0b3IgPSBhLmNvbnN0cnVjdG9yLCBiQ3RvciA9IGIuY29uc3RydWN0b3I7XG4gICAgICBpZiAoYUN0b3IgIT09IGJDdG9yICYmICEoXy5pc0Z1bmN0aW9uKGFDdG9yKSAmJiBhQ3RvciBpbnN0YW5jZW9mIGFDdG9yICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXy5pc0Z1bmN0aW9uKGJDdG9yKSAmJiBiQ3RvciBpbnN0YW5jZW9mIGJDdG9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAmJiAoJ2NvbnN0cnVjdG9yJyBpbiBhICYmICdjb25zdHJ1Y3RvcicgaW4gYikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBBc3N1bWUgZXF1YWxpdHkgZm9yIGN5Y2xpYyBzdHJ1Y3R1cmVzLiBUaGUgYWxnb3JpdGhtIGZvciBkZXRlY3RpbmcgY3ljbGljXG4gICAgLy8gc3RydWN0dXJlcyBpcyBhZGFwdGVkIGZyb20gRVMgNS4xIHNlY3Rpb24gMTUuMTIuMywgYWJzdHJhY3Qgb3BlcmF0aW9uIGBKT2AuXG5cbiAgICAvLyBJbml0aWFsaXppbmcgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgLy8gSXQncyBkb25lIGhlcmUgc2luY2Ugd2Ugb25seSBuZWVkIHRoZW0gZm9yIG9iamVjdHMgYW5kIGFycmF5cyBjb21wYXJpc29uLlxuICAgIGFTdGFjayA9IGFTdGFjayB8fCBbXTtcbiAgICBiU3RhY2sgPSBiU3RhY2sgfHwgW107XG4gICAgdmFyIGxlbmd0aCA9IGFTdGFjay5sZW5ndGg7XG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAvLyBMaW5lYXIgc2VhcmNoLiBQZXJmb3JtYW5jZSBpcyBpbnZlcnNlbHkgcHJvcG9ydGlvbmFsIHRvIHRoZSBudW1iZXIgb2ZcbiAgICAgIC8vIHVuaXF1ZSBuZXN0ZWQgc3RydWN0dXJlcy5cbiAgICAgIGlmIChhU3RhY2tbbGVuZ3RoXSA9PT0gYSkgcmV0dXJuIGJTdGFja1tsZW5ndGhdID09PSBiO1xuICAgIH1cblxuICAgIC8vIEFkZCB0aGUgZmlyc3Qgb2JqZWN0IHRvIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICBhU3RhY2sucHVzaChhKTtcbiAgICBiU3RhY2sucHVzaChiKTtcblxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyBhbmQgYXJyYXlzLlxuICAgIGlmIChhcmVBcnJheXMpIHtcbiAgICAgIC8vIENvbXBhcmUgYXJyYXkgbGVuZ3RocyB0byBkZXRlcm1pbmUgaWYgYSBkZWVwIGNvbXBhcmlzb24gaXMgbmVjZXNzYXJ5LlxuICAgICAgbGVuZ3RoID0gYS5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoICE9PSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgICAgLy8gRGVlcCBjb21wYXJlIHRoZSBjb250ZW50cywgaWdub3Jpbmcgbm9uLW51bWVyaWMgcHJvcGVydGllcy5cbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICBpZiAoIWVxKGFbbGVuZ3RoXSwgYltsZW5ndGhdLCBhU3RhY2ssIGJTdGFjaykpIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRGVlcCBjb21wYXJlIG9iamVjdHMuXG4gICAgICB2YXIga2V5cyA9IF8ua2V5cyhhKSwga2V5O1xuICAgICAgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgICAvLyBFbnN1cmUgdGhhdCBib3RoIG9iamVjdHMgY29udGFpbiB0aGUgc2FtZSBudW1iZXIgb2YgcHJvcGVydGllcyBiZWZvcmUgY29tcGFyaW5nIGRlZXAgZXF1YWxpdHkuXG4gICAgICBpZiAoXy5rZXlzKGIpLmxlbmd0aCAhPT0gbGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgLy8gRGVlcCBjb21wYXJlIGVhY2ggbWVtYmVyXG4gICAgICAgIGtleSA9IGtleXNbbGVuZ3RoXTtcbiAgICAgICAgaWYgKCEoXy5oYXMoYiwga2V5KSAmJiBlcShhW2tleV0sIGJba2V5XSwgYVN0YWNrLCBiU3RhY2spKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBSZW1vdmUgdGhlIGZpcnN0IG9iamVjdCBmcm9tIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICBhU3RhY2sucG9wKCk7XG4gICAgYlN0YWNrLnBvcCgpO1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIC8vIFBlcmZvcm0gYSBkZWVwIGNvbXBhcmlzb24gdG8gY2hlY2sgaWYgdHdvIG9iamVjdHMgYXJlIGVxdWFsLlxuICBfLmlzRXF1YWwgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIGVxKGEsIGIpO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gYXJyYXksIHN0cmluZywgb3Igb2JqZWN0IGVtcHR5P1xuICAvLyBBbiBcImVtcHR5XCIgb2JqZWN0IGhhcyBubyBlbnVtZXJhYmxlIG93bi1wcm9wZXJ0aWVzLlxuICBfLmlzRW1wdHkgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiB0cnVlO1xuICAgIGlmIChpc0FycmF5TGlrZShvYmopICYmIChfLmlzQXJyYXkob2JqKSB8fCBfLmlzU3RyaW5nKG9iaikgfHwgXy5pc0FyZ3VtZW50cyhvYmopKSkgcmV0dXJuIG9iai5sZW5ndGggPT09IDA7XG4gICAgcmV0dXJuIF8ua2V5cyhvYmopLmxlbmd0aCA9PT0gMDtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGEgRE9NIGVsZW1lbnQ/XG4gIF8uaXNFbGVtZW50ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuICEhKG9iaiAmJiBvYmoubm9kZVR5cGUgPT09IDEpO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFsdWUgYW4gYXJyYXk/XG4gIC8vIERlbGVnYXRlcyB0byBFQ01BNSdzIG5hdGl2ZSBBcnJheS5pc0FycmF5XG4gIF8uaXNBcnJheSA9IG5hdGl2ZUlzQXJyYXkgfHwgZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhcmlhYmxlIGFuIG9iamVjdD9cbiAgXy5pc09iamVjdCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciB0eXBlID0gdHlwZW9mIG9iajtcbiAgICByZXR1cm4gdHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlID09PSAnb2JqZWN0JyAmJiAhIW9iajtcbiAgfTtcblxuICAvLyBBZGQgc29tZSBpc1R5cGUgbWV0aG9kczogaXNBcmd1bWVudHMsIGlzRnVuY3Rpb24sIGlzU3RyaW5nLCBpc051bWJlciwgaXNEYXRlLCBpc1JlZ0V4cCwgaXNFcnJvci5cbiAgXy5lYWNoKFsnQXJndW1lbnRzJywgJ0Z1bmN0aW9uJywgJ1N0cmluZycsICdOdW1iZXInLCAnRGF0ZScsICdSZWdFeHAnLCAnRXJyb3InXSwgZnVuY3Rpb24obmFtZSkge1xuICAgIF9bJ2lzJyArIG5hbWVdID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCAnICsgbmFtZSArICddJztcbiAgICB9O1xuICB9KTtcblxuICAvLyBEZWZpbmUgYSBmYWxsYmFjayB2ZXJzaW9uIG9mIHRoZSBtZXRob2QgaW4gYnJvd3NlcnMgKGFoZW0sIElFIDwgOSksIHdoZXJlXG4gIC8vIHRoZXJlIGlzbid0IGFueSBpbnNwZWN0YWJsZSBcIkFyZ3VtZW50c1wiIHR5cGUuXG4gIGlmICghXy5pc0FyZ3VtZW50cyhhcmd1bWVudHMpKSB7XG4gICAgXy5pc0FyZ3VtZW50cyA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIF8uaGFzKG9iaiwgJ2NhbGxlZScpO1xuICAgIH07XG4gIH1cblxuICAvLyBPcHRpbWl6ZSBgaXNGdW5jdGlvbmAgaWYgYXBwcm9wcmlhdGUuIFdvcmsgYXJvdW5kIHNvbWUgdHlwZW9mIGJ1Z3MgaW4gb2xkIHY4LFxuICAvLyBJRSAxMSAoIzE2MjEpLCBhbmQgaW4gU2FmYXJpIDggKCMxOTI5KS5cbiAgaWYgKHR5cGVvZiAvLi8gIT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgSW50OEFycmF5ICE9ICdvYmplY3QnKSB7XG4gICAgXy5pc0Z1bmN0aW9uID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iaiA9PSAnZnVuY3Rpb24nIHx8IGZhbHNlO1xuICAgIH07XG4gIH1cblxuICAvLyBJcyBhIGdpdmVuIG9iamVjdCBhIGZpbml0ZSBudW1iZXI/XG4gIF8uaXNGaW5pdGUgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gaXNGaW5pdGUob2JqKSAmJiAhaXNOYU4ocGFyc2VGbG9hdChvYmopKTtcbiAgfTtcblxuICAvLyBJcyB0aGUgZ2l2ZW4gdmFsdWUgYE5hTmA/IChOYU4gaXMgdGhlIG9ubHkgbnVtYmVyIHdoaWNoIGRvZXMgbm90IGVxdWFsIGl0c2VsZikuXG4gIF8uaXNOYU4gPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gXy5pc051bWJlcihvYmopICYmIG9iaiAhPT0gK29iajtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGEgYm9vbGVhbj9cbiAgXy5pc0Jvb2xlYW4gPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSB0cnVlIHx8IG9iaiA9PT0gZmFsc2UgfHwgdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBCb29sZWFuXSc7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YWx1ZSBlcXVhbCB0byBudWxsP1xuICBfLmlzTnVsbCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBvYmogPT09IG51bGw7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YXJpYWJsZSB1bmRlZmluZWQ/XG4gIF8uaXNVbmRlZmluZWQgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSB2b2lkIDA7XG4gIH07XG5cbiAgLy8gU2hvcnRjdXQgZnVuY3Rpb24gZm9yIGNoZWNraW5nIGlmIGFuIG9iamVjdCBoYXMgYSBnaXZlbiBwcm9wZXJ0eSBkaXJlY3RseVxuICAvLyBvbiBpdHNlbGYgKGluIG90aGVyIHdvcmRzLCBub3Qgb24gYSBwcm90b3R5cGUpLlxuICBfLmhhcyA9IGZ1bmN0aW9uKG9iaiwga2V5KSB7XG4gICAgcmV0dXJuIG9iaiAhPSBudWxsICYmIGhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpO1xuICB9O1xuXG4gIC8vIFV0aWxpdHkgRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gUnVuIFVuZGVyc2NvcmUuanMgaW4gKm5vQ29uZmxpY3QqIG1vZGUsIHJldHVybmluZyB0aGUgYF9gIHZhcmlhYmxlIHRvIGl0c1xuICAvLyBwcmV2aW91cyBvd25lci4gUmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgVW5kZXJzY29yZSBvYmplY3QuXG4gIF8ubm9Db25mbGljdCA9IGZ1bmN0aW9uKCkge1xuICAgIHJvb3QuXyA9IHByZXZpb3VzVW5kZXJzY29yZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBLZWVwIHRoZSBpZGVudGl0eSBmdW5jdGlvbiBhcm91bmQgZm9yIGRlZmF1bHQgaXRlcmF0ZWVzLlxuICBfLmlkZW50aXR5ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG5cbiAgLy8gUHJlZGljYXRlLWdlbmVyYXRpbmcgZnVuY3Rpb25zLiBPZnRlbiB1c2VmdWwgb3V0c2lkZSBvZiBVbmRlcnNjb3JlLlxuICBfLmNvbnN0YW50ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgfTtcblxuICBfLm5vb3AgPSBmdW5jdGlvbigpe307XG5cbiAgXy5wcm9wZXJ0eSA9IHByb3BlcnR5O1xuXG4gIC8vIEdlbmVyYXRlcyBhIGZ1bmN0aW9uIGZvciBhIGdpdmVuIG9iamVjdCB0aGF0IHJldHVybnMgYSBnaXZlbiBwcm9wZXJ0eS5cbiAgXy5wcm9wZXJ0eU9mID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PSBudWxsID8gZnVuY3Rpb24oKXt9IDogZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gb2JqW2tleV07XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgcHJlZGljYXRlIGZvciBjaGVja2luZyB3aGV0aGVyIGFuIG9iamVjdCBoYXMgYSBnaXZlbiBzZXQgb2ZcbiAgLy8gYGtleTp2YWx1ZWAgcGFpcnMuXG4gIF8ubWF0Y2hlciA9IF8ubWF0Y2hlcyA9IGZ1bmN0aW9uKGF0dHJzKSB7XG4gICAgYXR0cnMgPSBfLmV4dGVuZE93bih7fSwgYXR0cnMpO1xuICAgIHJldHVybiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBfLmlzTWF0Y2gob2JqLCBhdHRycyk7XG4gICAgfTtcbiAgfTtcblxuICAvLyBSdW4gYSBmdW5jdGlvbiAqKm4qKiB0aW1lcy5cbiAgXy50aW1lcyA9IGZ1bmN0aW9uKG4sIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgdmFyIGFjY3VtID0gQXJyYXkoTWF0aC5tYXgoMCwgbikpO1xuICAgIGl0ZXJhdGVlID0gb3B0aW1pemVDYihpdGVyYXRlZSwgY29udGV4dCwgMSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIGFjY3VtW2ldID0gaXRlcmF0ZWUoaSk7XG4gICAgcmV0dXJuIGFjY3VtO1xuICB9O1xuXG4gIC8vIFJldHVybiBhIHJhbmRvbSBpbnRlZ2VyIGJldHdlZW4gbWluIGFuZCBtYXggKGluY2x1c2l2ZSkuXG4gIF8ucmFuZG9tID0gZnVuY3Rpb24obWluLCBtYXgpIHtcbiAgICBpZiAobWF4ID09IG51bGwpIHtcbiAgICAgIG1heCA9IG1pbjtcbiAgICAgIG1pbiA9IDA7XG4gICAgfVxuICAgIHJldHVybiBtaW4gKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluICsgMSkpO1xuICB9O1xuXG4gIC8vIEEgKHBvc3NpYmx5IGZhc3Rlcikgd2F5IHRvIGdldCB0aGUgY3VycmVudCB0aW1lc3RhbXAgYXMgYW4gaW50ZWdlci5cbiAgXy5ub3cgPSBEYXRlLm5vdyB8fCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gIH07XG5cbiAgIC8vIExpc3Qgb2YgSFRNTCBlbnRpdGllcyBmb3IgZXNjYXBpbmcuXG4gIHZhciBlc2NhcGVNYXAgPSB7XG4gICAgJyYnOiAnJmFtcDsnLFxuICAgICc8JzogJyZsdDsnLFxuICAgICc+JzogJyZndDsnLFxuICAgICdcIic6ICcmcXVvdDsnLFxuICAgIFwiJ1wiOiAnJiN4Mjc7JyxcbiAgICAnYCc6ICcmI3g2MDsnXG4gIH07XG4gIHZhciB1bmVzY2FwZU1hcCA9IF8uaW52ZXJ0KGVzY2FwZU1hcCk7XG5cbiAgLy8gRnVuY3Rpb25zIGZvciBlc2NhcGluZyBhbmQgdW5lc2NhcGluZyBzdHJpbmdzIHRvL2Zyb20gSFRNTCBpbnRlcnBvbGF0aW9uLlxuICB2YXIgY3JlYXRlRXNjYXBlciA9IGZ1bmN0aW9uKG1hcCkge1xuICAgIHZhciBlc2NhcGVyID0gZnVuY3Rpb24obWF0Y2gpIHtcbiAgICAgIHJldHVybiBtYXBbbWF0Y2hdO1xuICAgIH07XG4gICAgLy8gUmVnZXhlcyBmb3IgaWRlbnRpZnlpbmcgYSBrZXkgdGhhdCBuZWVkcyB0byBiZSBlc2NhcGVkXG4gICAgdmFyIHNvdXJjZSA9ICcoPzonICsgXy5rZXlzKG1hcCkuam9pbignfCcpICsgJyknO1xuICAgIHZhciB0ZXN0UmVnZXhwID0gUmVnRXhwKHNvdXJjZSk7XG4gICAgdmFyIHJlcGxhY2VSZWdleHAgPSBSZWdFeHAoc291cmNlLCAnZycpO1xuICAgIHJldHVybiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgIHN0cmluZyA9IHN0cmluZyA9PSBudWxsID8gJycgOiAnJyArIHN0cmluZztcbiAgICAgIHJldHVybiB0ZXN0UmVnZXhwLnRlc3Qoc3RyaW5nKSA/IHN0cmluZy5yZXBsYWNlKHJlcGxhY2VSZWdleHAsIGVzY2FwZXIpIDogc3RyaW5nO1xuICAgIH07XG4gIH07XG4gIF8uZXNjYXBlID0gY3JlYXRlRXNjYXBlcihlc2NhcGVNYXApO1xuICBfLnVuZXNjYXBlID0gY3JlYXRlRXNjYXBlcih1bmVzY2FwZU1hcCk7XG5cbiAgLy8gSWYgdGhlIHZhbHVlIG9mIHRoZSBuYW1lZCBgcHJvcGVydHlgIGlzIGEgZnVuY3Rpb24gdGhlbiBpbnZva2UgaXQgd2l0aCB0aGVcbiAgLy8gYG9iamVjdGAgYXMgY29udGV4dDsgb3RoZXJ3aXNlLCByZXR1cm4gaXQuXG4gIF8ucmVzdWx0ID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSwgZmFsbGJhY2spIHtcbiAgICB2YXIgdmFsdWUgPSBvYmplY3QgPT0gbnVsbCA/IHZvaWQgMCA6IG9iamVjdFtwcm9wZXJ0eV07XG4gICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgIHZhbHVlID0gZmFsbGJhY2s7XG4gICAgfVxuICAgIHJldHVybiBfLmlzRnVuY3Rpb24odmFsdWUpID8gdmFsdWUuY2FsbChvYmplY3QpIDogdmFsdWU7XG4gIH07XG5cbiAgLy8gR2VuZXJhdGUgYSB1bmlxdWUgaW50ZWdlciBpZCAodW5pcXVlIHdpdGhpbiB0aGUgZW50aXJlIGNsaWVudCBzZXNzaW9uKS5cbiAgLy8gVXNlZnVsIGZvciB0ZW1wb3JhcnkgRE9NIGlkcy5cbiAgdmFyIGlkQ291bnRlciA9IDA7XG4gIF8udW5pcXVlSWQgPSBmdW5jdGlvbihwcmVmaXgpIHtcbiAgICB2YXIgaWQgPSArK2lkQ291bnRlciArICcnO1xuICAgIHJldHVybiBwcmVmaXggPyBwcmVmaXggKyBpZCA6IGlkO1xuICB9O1xuXG4gIC8vIEJ5IGRlZmF1bHQsIFVuZGVyc2NvcmUgdXNlcyBFUkItc3R5bGUgdGVtcGxhdGUgZGVsaW1pdGVycywgY2hhbmdlIHRoZVxuICAvLyBmb2xsb3dpbmcgdGVtcGxhdGUgc2V0dGluZ3MgdG8gdXNlIGFsdGVybmF0aXZlIGRlbGltaXRlcnMuXG4gIF8udGVtcGxhdGVTZXR0aW5ncyA9IHtcbiAgICBldmFsdWF0ZSAgICA6IC88JShbXFxzXFxTXSs/KSU+L2csXG4gICAgaW50ZXJwb2xhdGUgOiAvPCU9KFtcXHNcXFNdKz8pJT4vZyxcbiAgICBlc2NhcGUgICAgICA6IC88JS0oW1xcc1xcU10rPyklPi9nXG4gIH07XG5cbiAgLy8gV2hlbiBjdXN0b21pemluZyBgdGVtcGxhdGVTZXR0aW5nc2AsIGlmIHlvdSBkb24ndCB3YW50IHRvIGRlZmluZSBhblxuICAvLyBpbnRlcnBvbGF0aW9uLCBldmFsdWF0aW9uIG9yIGVzY2FwaW5nIHJlZ2V4LCB3ZSBuZWVkIG9uZSB0aGF0IGlzXG4gIC8vIGd1YXJhbnRlZWQgbm90IHRvIG1hdGNoLlxuICB2YXIgbm9NYXRjaCA9IC8oLileLztcblxuICAvLyBDZXJ0YWluIGNoYXJhY3RlcnMgbmVlZCB0byBiZSBlc2NhcGVkIHNvIHRoYXQgdGhleSBjYW4gYmUgcHV0IGludG8gYVxuICAvLyBzdHJpbmcgbGl0ZXJhbC5cbiAgdmFyIGVzY2FwZXMgPSB7XG4gICAgXCInXCI6ICAgICAgXCInXCIsXG4gICAgJ1xcXFwnOiAgICAgJ1xcXFwnLFxuICAgICdcXHInOiAgICAgJ3InLFxuICAgICdcXG4nOiAgICAgJ24nLFxuICAgICdcXHUyMDI4JzogJ3UyMDI4JyxcbiAgICAnXFx1MjAyOSc6ICd1MjAyOSdcbiAgfTtcblxuICB2YXIgZXNjYXBlciA9IC9cXFxcfCd8XFxyfFxcbnxcXHUyMDI4fFxcdTIwMjkvZztcblxuICB2YXIgZXNjYXBlQ2hhciA9IGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgcmV0dXJuICdcXFxcJyArIGVzY2FwZXNbbWF0Y2hdO1xuICB9O1xuXG4gIC8vIEphdmFTY3JpcHQgbWljcm8tdGVtcGxhdGluZywgc2ltaWxhciB0byBKb2huIFJlc2lnJ3MgaW1wbGVtZW50YXRpb24uXG4gIC8vIFVuZGVyc2NvcmUgdGVtcGxhdGluZyBoYW5kbGVzIGFyYml0cmFyeSBkZWxpbWl0ZXJzLCBwcmVzZXJ2ZXMgd2hpdGVzcGFjZSxcbiAgLy8gYW5kIGNvcnJlY3RseSBlc2NhcGVzIHF1b3RlcyB3aXRoaW4gaW50ZXJwb2xhdGVkIGNvZGUuXG4gIC8vIE5COiBgb2xkU2V0dGluZ3NgIG9ubHkgZXhpc3RzIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cbiAgXy50ZW1wbGF0ZSA9IGZ1bmN0aW9uKHRleHQsIHNldHRpbmdzLCBvbGRTZXR0aW5ncykge1xuICAgIGlmICghc2V0dGluZ3MgJiYgb2xkU2V0dGluZ3MpIHNldHRpbmdzID0gb2xkU2V0dGluZ3M7XG4gICAgc2V0dGluZ3MgPSBfLmRlZmF1bHRzKHt9LCBzZXR0aW5ncywgXy50ZW1wbGF0ZVNldHRpbmdzKTtcblxuICAgIC8vIENvbWJpbmUgZGVsaW1pdGVycyBpbnRvIG9uZSByZWd1bGFyIGV4cHJlc3Npb24gdmlhIGFsdGVybmF0aW9uLlxuICAgIHZhciBtYXRjaGVyID0gUmVnRXhwKFtcbiAgICAgIChzZXR0aW5ncy5lc2NhcGUgfHwgbm9NYXRjaCkuc291cmNlLFxuICAgICAgKHNldHRpbmdzLmludGVycG9sYXRlIHx8IG5vTWF0Y2gpLnNvdXJjZSxcbiAgICAgIChzZXR0aW5ncy5ldmFsdWF0ZSB8fCBub01hdGNoKS5zb3VyY2VcbiAgICBdLmpvaW4oJ3wnKSArICd8JCcsICdnJyk7XG5cbiAgICAvLyBDb21waWxlIHRoZSB0ZW1wbGF0ZSBzb3VyY2UsIGVzY2FwaW5nIHN0cmluZyBsaXRlcmFscyBhcHByb3ByaWF0ZWx5LlxuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIHNvdXJjZSA9IFwiX19wKz0nXCI7XG4gICAgdGV4dC5yZXBsYWNlKG1hdGNoZXIsIGZ1bmN0aW9uKG1hdGNoLCBlc2NhcGUsIGludGVycG9sYXRlLCBldmFsdWF0ZSwgb2Zmc2V0KSB7XG4gICAgICBzb3VyY2UgKz0gdGV4dC5zbGljZShpbmRleCwgb2Zmc2V0KS5yZXBsYWNlKGVzY2FwZXIsIGVzY2FwZUNoYXIpO1xuICAgICAgaW5kZXggPSBvZmZzZXQgKyBtYXRjaC5sZW5ndGg7XG5cbiAgICAgIGlmIChlc2NhcGUpIHtcbiAgICAgICAgc291cmNlICs9IFwiJytcXG4oKF9fdD0oXCIgKyBlc2NhcGUgKyBcIikpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xcbidcIjtcbiAgICAgIH0gZWxzZSBpZiAoaW50ZXJwb2xhdGUpIHtcbiAgICAgICAgc291cmNlICs9IFwiJytcXG4oKF9fdD0oXCIgKyBpbnRlcnBvbGF0ZSArIFwiKSk9PW51bGw/Jyc6X190KStcXG4nXCI7XG4gICAgICB9IGVsc2UgaWYgKGV2YWx1YXRlKSB7XG4gICAgICAgIHNvdXJjZSArPSBcIic7XFxuXCIgKyBldmFsdWF0ZSArIFwiXFxuX19wKz0nXCI7XG4gICAgICB9XG5cbiAgICAgIC8vIEFkb2JlIFZNcyBuZWVkIHRoZSBtYXRjaCByZXR1cm5lZCB0byBwcm9kdWNlIHRoZSBjb3JyZWN0IG9mZmVzdC5cbiAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9KTtcbiAgICBzb3VyY2UgKz0gXCInO1xcblwiO1xuXG4gICAgLy8gSWYgYSB2YXJpYWJsZSBpcyBub3Qgc3BlY2lmaWVkLCBwbGFjZSBkYXRhIHZhbHVlcyBpbiBsb2NhbCBzY29wZS5cbiAgICBpZiAoIXNldHRpbmdzLnZhcmlhYmxlKSBzb3VyY2UgPSAnd2l0aChvYmp8fHt9KXtcXG4nICsgc291cmNlICsgJ31cXG4nO1xuXG4gICAgc291cmNlID0gXCJ2YXIgX190LF9fcD0nJyxfX2o9QXJyYXkucHJvdG90eXBlLmpvaW4sXCIgK1xuICAgICAgXCJwcmludD1mdW5jdGlvbigpe19fcCs9X19qLmNhbGwoYXJndW1lbnRzLCcnKTt9O1xcblwiICtcbiAgICAgIHNvdXJjZSArICdyZXR1cm4gX19wO1xcbic7XG5cbiAgICB0cnkge1xuICAgICAgdmFyIHJlbmRlciA9IG5ldyBGdW5jdGlvbihzZXR0aW5ncy52YXJpYWJsZSB8fCAnb2JqJywgJ18nLCBzb3VyY2UpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGUuc291cmNlID0gc291cmNlO1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG5cbiAgICB2YXIgdGVtcGxhdGUgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICByZXR1cm4gcmVuZGVyLmNhbGwodGhpcywgZGF0YSwgXyk7XG4gICAgfTtcblxuICAgIC8vIFByb3ZpZGUgdGhlIGNvbXBpbGVkIHNvdXJjZSBhcyBhIGNvbnZlbmllbmNlIGZvciBwcmVjb21waWxhdGlvbi5cbiAgICB2YXIgYXJndW1lbnQgPSBzZXR0aW5ncy52YXJpYWJsZSB8fCAnb2JqJztcbiAgICB0ZW1wbGF0ZS5zb3VyY2UgPSAnZnVuY3Rpb24oJyArIGFyZ3VtZW50ICsgJyl7XFxuJyArIHNvdXJjZSArICd9JztcblxuICAgIHJldHVybiB0ZW1wbGF0ZTtcbiAgfTtcblxuICAvLyBBZGQgYSBcImNoYWluXCIgZnVuY3Rpb24uIFN0YXJ0IGNoYWluaW5nIGEgd3JhcHBlZCBVbmRlcnNjb3JlIG9iamVjdC5cbiAgXy5jaGFpbiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBpbnN0YW5jZSA9IF8ob2JqKTtcbiAgICBpbnN0YW5jZS5fY2hhaW4gPSB0cnVlO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfTtcblxuICAvLyBPT1BcbiAgLy8gLS0tLS0tLS0tLS0tLS0tXG4gIC8vIElmIFVuZGVyc2NvcmUgaXMgY2FsbGVkIGFzIGEgZnVuY3Rpb24sIGl0IHJldHVybnMgYSB3cmFwcGVkIG9iamVjdCB0aGF0XG4gIC8vIGNhbiBiZSB1c2VkIE9PLXN0eWxlLiBUaGlzIHdyYXBwZXIgaG9sZHMgYWx0ZXJlZCB2ZXJzaW9ucyBvZiBhbGwgdGhlXG4gIC8vIHVuZGVyc2NvcmUgZnVuY3Rpb25zLiBXcmFwcGVkIG9iamVjdHMgbWF5IGJlIGNoYWluZWQuXG5cbiAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGNvbnRpbnVlIGNoYWluaW5nIGludGVybWVkaWF0ZSByZXN1bHRzLlxuICB2YXIgcmVzdWx0ID0gZnVuY3Rpb24oaW5zdGFuY2UsIG9iaikge1xuICAgIHJldHVybiBpbnN0YW5jZS5fY2hhaW4gPyBfKG9iaikuY2hhaW4oKSA6IG9iajtcbiAgfTtcblxuICAvLyBBZGQgeW91ciBvd24gY3VzdG9tIGZ1bmN0aW9ucyB0byB0aGUgVW5kZXJzY29yZSBvYmplY3QuXG4gIF8ubWl4aW4gPSBmdW5jdGlvbihvYmopIHtcbiAgICBfLmVhY2goXy5mdW5jdGlvbnMob2JqKSwgZnVuY3Rpb24obmFtZSkge1xuICAgICAgdmFyIGZ1bmMgPSBfW25hbWVdID0gb2JqW25hbWVdO1xuICAgICAgXy5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbdGhpcy5fd3JhcHBlZF07XG4gICAgICAgIHB1c2guYXBwbHkoYXJncywgYXJndW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCh0aGlzLCBmdW5jLmFwcGx5KF8sIGFyZ3MpKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gQWRkIGFsbCBvZiB0aGUgVW5kZXJzY29yZSBmdW5jdGlvbnMgdG8gdGhlIHdyYXBwZXIgb2JqZWN0LlxuICBfLm1peGluKF8pO1xuXG4gIC8vIEFkZCBhbGwgbXV0YXRvciBBcnJheSBmdW5jdGlvbnMgdG8gdGhlIHdyYXBwZXIuXG4gIF8uZWFjaChbJ3BvcCcsICdwdXNoJywgJ3JldmVyc2UnLCAnc2hpZnQnLCAnc29ydCcsICdzcGxpY2UnLCAndW5zaGlmdCddLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIG1ldGhvZCA9IEFycmF5UHJvdG9bbmFtZV07XG4gICAgXy5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBvYmogPSB0aGlzLl93cmFwcGVkO1xuICAgICAgbWV0aG9kLmFwcGx5KG9iaiwgYXJndW1lbnRzKTtcbiAgICAgIGlmICgobmFtZSA9PT0gJ3NoaWZ0JyB8fCBuYW1lID09PSAnc3BsaWNlJykgJiYgb2JqLmxlbmd0aCA9PT0gMCkgZGVsZXRlIG9ialswXTtcbiAgICAgIHJldHVybiByZXN1bHQodGhpcywgb2JqKTtcbiAgICB9O1xuICB9KTtcblxuICAvLyBBZGQgYWxsIGFjY2Vzc29yIEFycmF5IGZ1bmN0aW9ucyB0byB0aGUgd3JhcHBlci5cbiAgXy5lYWNoKFsnY29uY2F0JywgJ2pvaW4nLCAnc2xpY2UnXSwgZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBtZXRob2QgPSBBcnJheVByb3RvW25hbWVdO1xuICAgIF8ucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gcmVzdWx0KHRoaXMsIG1ldGhvZC5hcHBseSh0aGlzLl93cmFwcGVkLCBhcmd1bWVudHMpKTtcbiAgICB9O1xuICB9KTtcblxuICAvLyBFeHRyYWN0cyB0aGUgcmVzdWx0IGZyb20gYSB3cmFwcGVkIGFuZCBjaGFpbmVkIG9iamVjdC5cbiAgXy5wcm90b3R5cGUudmFsdWUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JhcHBlZDtcbiAgfTtcblxuICAvLyBQcm92aWRlIHVud3JhcHBpbmcgcHJveHkgZm9yIHNvbWUgbWV0aG9kcyB1c2VkIGluIGVuZ2luZSBvcGVyYXRpb25zXG4gIC8vIHN1Y2ggYXMgYXJpdGhtZXRpYyBhbmQgSlNPTiBzdHJpbmdpZmljYXRpb24uXG4gIF8ucHJvdG90eXBlLnZhbHVlT2YgPSBfLnByb3RvdHlwZS50b0pTT04gPSBfLnByb3RvdHlwZS52YWx1ZTtcblxuICBfLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAnJyArIHRoaXMuX3dyYXBwZWQ7XG4gIH07XG5cbiAgLy8gQU1EIHJlZ2lzdHJhdGlvbiBoYXBwZW5zIGF0IHRoZSBlbmQgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBBTUQgbG9hZGVyc1xuICAvLyB0aGF0IG1heSBub3QgZW5mb3JjZSBuZXh0LXR1cm4gc2VtYW50aWNzIG9uIG1vZHVsZXMuIEV2ZW4gdGhvdWdoIGdlbmVyYWxcbiAgLy8gcHJhY3RpY2UgZm9yIEFNRCByZWdpc3RyYXRpb24gaXMgdG8gYmUgYW5vbnltb3VzLCB1bmRlcnNjb3JlIHJlZ2lzdGVyc1xuICAvLyBhcyBhIG5hbWVkIG1vZHVsZSBiZWNhdXNlLCBsaWtlIGpRdWVyeSwgaXQgaXMgYSBiYXNlIGxpYnJhcnkgdGhhdCBpc1xuICAvLyBwb3B1bGFyIGVub3VnaCB0byBiZSBidW5kbGVkIGluIGEgdGhpcmQgcGFydHkgbGliLCBidXQgbm90IGJlIHBhcnQgb2ZcbiAgLy8gYW4gQU1EIGxvYWQgcmVxdWVzdC4gVGhvc2UgY2FzZXMgY291bGQgZ2VuZXJhdGUgYW4gZXJyb3Igd2hlbiBhblxuICAvLyBhbm9ueW1vdXMgZGVmaW5lKCkgaXMgY2FsbGVkIG91dHNpZGUgb2YgYSBsb2FkZXIgcmVxdWVzdC5cbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZSgndW5kZXJzY29yZScsIFtdLCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBfO1xuICAgIH0pO1xuICB9XG59LmNhbGwodGhpcykpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi91bmRlcnNjb3JlL3VuZGVyc2NvcmUuanMiLCJ2YXIgbG9jYWxTdG9yYWdlID0gXy5leHRlbmQoe30sIEJhY2tib25lLkV2ZW50cylcblxuLy8gQWRkIGNvbnZlbmllbmNlIEpTT04gcGFyc2Uvc3RyaW5naWd5IGZ1bmN0aW9ucyB0byBHbG9iYWxcbmxvY2FsU3RvcmFnZS5zZXRJdGVtID0gZnVuY3Rpb24gKGtleSwgb2JqKSB7XG4gIHdpbmRvdy5sb2NhbFN0b3JhZ2Uuc2V0SXRlbShrZXksIEpTT04uc3RyaW5naWZ5KG9iaikpXG4gIGxvY2FsU3RvcmFnZS50cmlnZ2VyKCdsb2NhbHN0b3JhZ2U6c2V0OicgKyBrZXksIG9iailcbn1cblxubG9jYWxTdG9yYWdlLmdldEl0ZW0gPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHZhciBzdHIgPSB3aW5kb3cubG9jYWxTdG9yYWdlLmdldEl0ZW0oa2V5KVxuICBpZiAoc3RyKSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2Uoc3RyKVxuICB9XG59XG5cbmxvY2FsU3RvcmFnZS5oYXNJdGVtID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gd2luZG93LmxvY2FsU3RvcmFnZS5oYXNPd25Qcm9wZXJ0eShrZXkpXG59XG5cbmxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtID0gZnVuY3Rpb24gKGtleSkge1xuICB3aW5kb3cubG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oa2V5KVxuICBsb2NhbFN0b3JhZ2UudHJpZ2dlcignbG9jYWxzdG9yYWdlOnJlbW92ZTonICsga2V5KVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxvY2FsU3RvcmFnZVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vanMvbG9jYWxTdG9yYWdlLmpzIiwidmFyIEV2ZW50QnVzID0gXy5leHRlbmQoe30sIEJhY2tib25lLkV2ZW50cylcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEJ1c1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2pzL2V2ZW50QnVzLmpzIiwiLyohXG4gKiBqUXVlcnkgSmF2YVNjcmlwdCBMaWJyYXJ5IHYzLjEuMVxuICogaHR0cHM6Ly9qcXVlcnkuY29tL1xuICpcbiAqIEluY2x1ZGVzIFNpenpsZS5qc1xuICogaHR0cHM6Ly9zaXp6bGVqcy5jb20vXG4gKlxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cHM6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqXG4gKiBEYXRlOiAyMDE2LTA5LTIyVDIyOjMwWlxuICovXG4oIGZ1bmN0aW9uKCBnbG9iYWwsIGZhY3RvcnkgKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0aWYgKCB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdC8vIEZvciBDb21tb25KUyBhbmQgQ29tbW9uSlMtbGlrZSBlbnZpcm9ubWVudHMgd2hlcmUgYSBwcm9wZXIgYHdpbmRvd2Bcblx0XHQvLyBpcyBwcmVzZW50LCBleGVjdXRlIHRoZSBmYWN0b3J5IGFuZCBnZXQgalF1ZXJ5LlxuXHRcdC8vIEZvciBlbnZpcm9ubWVudHMgdGhhdCBkbyBub3QgaGF2ZSBhIGB3aW5kb3dgIHdpdGggYSBgZG9jdW1lbnRgXG5cdFx0Ly8gKHN1Y2ggYXMgTm9kZS5qcyksIGV4cG9zZSBhIGZhY3RvcnkgYXMgbW9kdWxlLmV4cG9ydHMuXG5cdFx0Ly8gVGhpcyBhY2NlbnR1YXRlcyB0aGUgbmVlZCBmb3IgdGhlIGNyZWF0aW9uIG9mIGEgcmVhbCBgd2luZG93YC5cblx0XHQvLyBlLmcuIHZhciBqUXVlcnkgPSByZXF1aXJlKFwianF1ZXJ5XCIpKHdpbmRvdyk7XG5cdFx0Ly8gU2VlIHRpY2tldCAjMTQ1NDkgZm9yIG1vcmUgaW5mby5cblx0XHRtb2R1bGUuZXhwb3J0cyA9IGdsb2JhbC5kb2N1bWVudCA/XG5cdFx0XHRmYWN0b3J5KCBnbG9iYWwsIHRydWUgKSA6XG5cdFx0XHRmdW5jdGlvbiggdyApIHtcblx0XHRcdFx0aWYgKCAhdy5kb2N1bWVudCApIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoIFwialF1ZXJ5IHJlcXVpcmVzIGEgd2luZG93IHdpdGggYSBkb2N1bWVudFwiICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGZhY3RvcnkoIHcgKTtcblx0XHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0ZmFjdG9yeSggZ2xvYmFsICk7XG5cdH1cblxuLy8gUGFzcyB0aGlzIGlmIHdpbmRvdyBpcyBub3QgZGVmaW5lZCB5ZXRcbn0gKSggdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHRoaXMsIGZ1bmN0aW9uKCB3aW5kb3csIG5vR2xvYmFsICkge1xuXG4vLyBFZGdlIDw9IDEyIC0gMTMrLCBGaXJlZm94IDw9MTggLSA0NSssIElFIDEwIC0gMTEsIFNhZmFyaSA1LjEgLSA5KywgaU9TIDYgLSA5LjFcbi8vIHRocm93IGV4Y2VwdGlvbnMgd2hlbiBub24tc3RyaWN0IGNvZGUgKGUuZy4sIEFTUC5ORVQgNC41KSBhY2Nlc3NlcyBzdHJpY3QgbW9kZVxuLy8gYXJndW1lbnRzLmNhbGxlZS5jYWxsZXIgKHRyYWMtMTMzMzUpLiBCdXQgYXMgb2YgalF1ZXJ5IDMuMCAoMjAxNiksIHN0cmljdCBtb2RlIHNob3VsZCBiZSBjb21tb25cbi8vIGVub3VnaCB0aGF0IGFsbCBzdWNoIGF0dGVtcHRzIGFyZSBndWFyZGVkIGluIGEgdHJ5IGJsb2NrLlxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBhcnIgPSBbXTtcblxudmFyIGRvY3VtZW50ID0gd2luZG93LmRvY3VtZW50O1xuXG52YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG5cbnZhciBzbGljZSA9IGFyci5zbGljZTtcblxudmFyIGNvbmNhdCA9IGFyci5jb25jYXQ7XG5cbnZhciBwdXNoID0gYXJyLnB1c2g7XG5cbnZhciBpbmRleE9mID0gYXJyLmluZGV4T2Y7XG5cbnZhciBjbGFzczJ0eXBlID0ge307XG5cbnZhciB0b1N0cmluZyA9IGNsYXNzMnR5cGUudG9TdHJpbmc7XG5cbnZhciBoYXNPd24gPSBjbGFzczJ0eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgZm5Ub1N0cmluZyA9IGhhc093bi50b1N0cmluZztcblxudmFyIE9iamVjdEZ1bmN0aW9uU3RyaW5nID0gZm5Ub1N0cmluZy5jYWxsKCBPYmplY3QgKTtcblxudmFyIHN1cHBvcnQgPSB7fTtcblxuXG5cblx0ZnVuY3Rpb24gRE9NRXZhbCggY29kZSwgZG9jICkge1xuXHRcdGRvYyA9IGRvYyB8fCBkb2N1bWVudDtcblxuXHRcdHZhciBzY3JpcHQgPSBkb2MuY3JlYXRlRWxlbWVudCggXCJzY3JpcHRcIiApO1xuXG5cdFx0c2NyaXB0LnRleHQgPSBjb2RlO1xuXHRcdGRvYy5oZWFkLmFwcGVuZENoaWxkKCBzY3JpcHQgKS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBzY3JpcHQgKTtcblx0fVxuLyogZ2xvYmFsIFN5bWJvbCAqL1xuLy8gRGVmaW5pbmcgdGhpcyBnbG9iYWwgaW4gLmVzbGludHJjLmpzb24gd291bGQgY3JlYXRlIGEgZGFuZ2VyIG9mIHVzaW5nIHRoZSBnbG9iYWxcbi8vIHVuZ3VhcmRlZCBpbiBhbm90aGVyIHBsYWNlLCBpdCBzZWVtcyBzYWZlciB0byBkZWZpbmUgZ2xvYmFsIG9ubHkgZm9yIHRoaXMgbW9kdWxlXG5cblxuXG52YXJcblx0dmVyc2lvbiA9IFwiMy4xLjFcIixcblxuXHQvLyBEZWZpbmUgYSBsb2NhbCBjb3B5IG9mIGpRdWVyeVxuXHRqUXVlcnkgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQgKSB7XG5cblx0XHQvLyBUaGUgalF1ZXJ5IG9iamVjdCBpcyBhY3R1YWxseSBqdXN0IHRoZSBpbml0IGNvbnN0cnVjdG9yICdlbmhhbmNlZCdcblx0XHQvLyBOZWVkIGluaXQgaWYgalF1ZXJ5IGlzIGNhbGxlZCAoanVzdCBhbGxvdyBlcnJvciB0byBiZSB0aHJvd24gaWYgbm90IGluY2x1ZGVkKVxuXHRcdHJldHVybiBuZXcgalF1ZXJ5LmZuLmluaXQoIHNlbGVjdG9yLCBjb250ZXh0ICk7XG5cdH0sXG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5XG5cdC8vIE1ha2Ugc3VyZSB3ZSB0cmltIEJPTSBhbmQgTkJTUFxuXHRydHJpbSA9IC9eW1xcc1xcdUZFRkZcXHhBMF0rfFtcXHNcXHVGRUZGXFx4QTBdKyQvZyxcblxuXHQvLyBNYXRjaGVzIGRhc2hlZCBzdHJpbmcgZm9yIGNhbWVsaXppbmdcblx0cm1zUHJlZml4ID0gL14tbXMtLyxcblx0cmRhc2hBbHBoYSA9IC8tKFthLXpdKS9nLFxuXG5cdC8vIFVzZWQgYnkgalF1ZXJ5LmNhbWVsQ2FzZSBhcyBjYWxsYmFjayB0byByZXBsYWNlKClcblx0ZmNhbWVsQ2FzZSA9IGZ1bmN0aW9uKCBhbGwsIGxldHRlciApIHtcblx0XHRyZXR1cm4gbGV0dGVyLnRvVXBwZXJDYXNlKCk7XG5cdH07XG5cbmpRdWVyeS5mbiA9IGpRdWVyeS5wcm90b3R5cGUgPSB7XG5cblx0Ly8gVGhlIGN1cnJlbnQgdmVyc2lvbiBvZiBqUXVlcnkgYmVpbmcgdXNlZFxuXHRqcXVlcnk6IHZlcnNpb24sXG5cblx0Y29uc3RydWN0b3I6IGpRdWVyeSxcblxuXHQvLyBUaGUgZGVmYXVsdCBsZW5ndGggb2YgYSBqUXVlcnkgb2JqZWN0IGlzIDBcblx0bGVuZ3RoOiAwLFxuXG5cdHRvQXJyYXk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBzbGljZS5jYWxsKCB0aGlzICk7XG5cdH0sXG5cblx0Ly8gR2V0IHRoZSBOdGggZWxlbWVudCBpbiB0aGUgbWF0Y2hlZCBlbGVtZW50IHNldCBPUlxuXHQvLyBHZXQgdGhlIHdob2xlIG1hdGNoZWQgZWxlbWVudCBzZXQgYXMgYSBjbGVhbiBhcnJheVxuXHRnZXQ6IGZ1bmN0aW9uKCBudW0gKSB7XG5cblx0XHQvLyBSZXR1cm4gYWxsIHRoZSBlbGVtZW50cyBpbiBhIGNsZWFuIGFycmF5XG5cdFx0aWYgKCBudW0gPT0gbnVsbCApIHtcblx0XHRcdHJldHVybiBzbGljZS5jYWxsKCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0Ly8gUmV0dXJuIGp1c3QgdGhlIG9uZSBlbGVtZW50IGZyb20gdGhlIHNldFxuXHRcdHJldHVybiBudW0gPCAwID8gdGhpc1sgbnVtICsgdGhpcy5sZW5ndGggXSA6IHRoaXNbIG51bSBdO1xuXHR9LFxuXG5cdC8vIFRha2UgYW4gYXJyYXkgb2YgZWxlbWVudHMgYW5kIHB1c2ggaXQgb250byB0aGUgc3RhY2tcblx0Ly8gKHJldHVybmluZyB0aGUgbmV3IG1hdGNoZWQgZWxlbWVudCBzZXQpXG5cdHB1c2hTdGFjazogZnVuY3Rpb24oIGVsZW1zICkge1xuXG5cdFx0Ly8gQnVpbGQgYSBuZXcgalF1ZXJ5IG1hdGNoZWQgZWxlbWVudCBzZXRcblx0XHR2YXIgcmV0ID0galF1ZXJ5Lm1lcmdlKCB0aGlzLmNvbnN0cnVjdG9yKCksIGVsZW1zICk7XG5cblx0XHQvLyBBZGQgdGhlIG9sZCBvYmplY3Qgb250byB0aGUgc3RhY2sgKGFzIGEgcmVmZXJlbmNlKVxuXHRcdHJldC5wcmV2T2JqZWN0ID0gdGhpcztcblxuXHRcdC8vIFJldHVybiB0aGUgbmV3bHktZm9ybWVkIGVsZW1lbnQgc2V0XG5cdFx0cmV0dXJuIHJldDtcblx0fSxcblxuXHQvLyBFeGVjdXRlIGEgY2FsbGJhY2sgZm9yIGV2ZXJ5IGVsZW1lbnQgaW4gdGhlIG1hdGNoZWQgc2V0LlxuXHRlYWNoOiBmdW5jdGlvbiggY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5lYWNoKCB0aGlzLCBjYWxsYmFjayApO1xuXHR9LFxuXG5cdG1hcDogZnVuY3Rpb24oIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggalF1ZXJ5Lm1hcCggdGhpcywgZnVuY3Rpb24oIGVsZW0sIGkgKSB7XG5cdFx0XHRyZXR1cm4gY2FsbGJhY2suY2FsbCggZWxlbSwgaSwgZWxlbSApO1xuXHRcdH0gKSApO1xuXHR9LFxuXG5cdHNsaWNlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHNsaWNlLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKSApO1xuXHR9LFxuXG5cdGZpcnN0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5lcSggMCApO1xuXHR9LFxuXG5cdGxhc3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmVxKCAtMSApO1xuXHR9LFxuXG5cdGVxOiBmdW5jdGlvbiggaSApIHtcblx0XHR2YXIgbGVuID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRqID0gK2kgKyAoIGkgPCAwID8gbGVuIDogMCApO1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggaiA+PSAwICYmIGogPCBsZW4gPyBbIHRoaXNbIGogXSBdIDogW10gKTtcblx0fSxcblxuXHRlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnByZXZPYmplY3QgfHwgdGhpcy5jb25zdHJ1Y3RvcigpO1xuXHR9LFxuXG5cdC8vIEZvciBpbnRlcm5hbCB1c2Ugb25seS5cblx0Ly8gQmVoYXZlcyBsaWtlIGFuIEFycmF5J3MgbWV0aG9kLCBub3QgbGlrZSBhIGpRdWVyeSBtZXRob2QuXG5cdHB1c2g6IHB1c2gsXG5cdHNvcnQ6IGFyci5zb3J0LFxuXHRzcGxpY2U6IGFyci5zcGxpY2Vcbn07XG5cbmpRdWVyeS5leHRlbmQgPSBqUXVlcnkuZm4uZXh0ZW5kID0gZnVuY3Rpb24oKSB7XG5cdHZhciBvcHRpb25zLCBuYW1lLCBzcmMsIGNvcHksIGNvcHlJc0FycmF5LCBjbG9uZSxcblx0XHR0YXJnZXQgPSBhcmd1bWVudHNbIDAgXSB8fCB7fSxcblx0XHRpID0gMSxcblx0XHRsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxuXHRcdGRlZXAgPSBmYWxzZTtcblxuXHQvLyBIYW5kbGUgYSBkZWVwIGNvcHkgc2l0dWF0aW9uXG5cdGlmICggdHlwZW9mIHRhcmdldCA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0ZGVlcCA9IHRhcmdldDtcblxuXHRcdC8vIFNraXAgdGhlIGJvb2xlYW4gYW5kIHRoZSB0YXJnZXRcblx0XHR0YXJnZXQgPSBhcmd1bWVudHNbIGkgXSB8fCB7fTtcblx0XHRpKys7XG5cdH1cblxuXHQvLyBIYW5kbGUgY2FzZSB3aGVuIHRhcmdldCBpcyBhIHN0cmluZyBvciBzb21ldGhpbmcgKHBvc3NpYmxlIGluIGRlZXAgY29weSlcblx0aWYgKCB0eXBlb2YgdGFyZ2V0ICE9PSBcIm9iamVjdFwiICYmICFqUXVlcnkuaXNGdW5jdGlvbiggdGFyZ2V0ICkgKSB7XG5cdFx0dGFyZ2V0ID0ge307XG5cdH1cblxuXHQvLyBFeHRlbmQgalF1ZXJ5IGl0c2VsZiBpZiBvbmx5IG9uZSBhcmd1bWVudCBpcyBwYXNzZWRcblx0aWYgKCBpID09PSBsZW5ndGggKSB7XG5cdFx0dGFyZ2V0ID0gdGhpcztcblx0XHRpLS07XG5cdH1cblxuXHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblxuXHRcdC8vIE9ubHkgZGVhbCB3aXRoIG5vbi1udWxsL3VuZGVmaW5lZCB2YWx1ZXNcblx0XHRpZiAoICggb3B0aW9ucyA9IGFyZ3VtZW50c1sgaSBdICkgIT0gbnVsbCApIHtcblxuXHRcdFx0Ly8gRXh0ZW5kIHRoZSBiYXNlIG9iamVjdFxuXHRcdFx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuXHRcdFx0XHRzcmMgPSB0YXJnZXRbIG5hbWUgXTtcblx0XHRcdFx0Y29weSA9IG9wdGlvbnNbIG5hbWUgXTtcblxuXHRcdFx0XHQvLyBQcmV2ZW50IG5ldmVyLWVuZGluZyBsb29wXG5cdFx0XHRcdGlmICggdGFyZ2V0ID09PSBjb3B5ICkge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmVjdXJzZSBpZiB3ZSdyZSBtZXJnaW5nIHBsYWluIG9iamVjdHMgb3IgYXJyYXlzXG5cdFx0XHRcdGlmICggZGVlcCAmJiBjb3B5ICYmICggalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGNvcHkgKSB8fFxuXHRcdFx0XHRcdCggY29weUlzQXJyYXkgPSBqUXVlcnkuaXNBcnJheSggY29weSApICkgKSApIHtcblxuXHRcdFx0XHRcdGlmICggY29weUlzQXJyYXkgKSB7XG5cdFx0XHRcdFx0XHRjb3B5SXNBcnJheSA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0Y2xvbmUgPSBzcmMgJiYgalF1ZXJ5LmlzQXJyYXkoIHNyYyApID8gc3JjIDogW107XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y2xvbmUgPSBzcmMgJiYgalF1ZXJ5LmlzUGxhaW5PYmplY3QoIHNyYyApID8gc3JjIDoge307XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gTmV2ZXIgbW92ZSBvcmlnaW5hbCBvYmplY3RzLCBjbG9uZSB0aGVtXG5cdFx0XHRcdFx0dGFyZ2V0WyBuYW1lIF0gPSBqUXVlcnkuZXh0ZW5kKCBkZWVwLCBjbG9uZSwgY29weSApO1xuXG5cdFx0XHRcdC8vIERvbid0IGJyaW5nIGluIHVuZGVmaW5lZCB2YWx1ZXNcblx0XHRcdFx0fSBlbHNlIGlmICggY29weSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHRhcmdldFsgbmFtZSBdID0gY29weTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybiB0aGUgbW9kaWZpZWQgb2JqZWN0XG5cdHJldHVybiB0YXJnZXQ7XG59O1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gVW5pcXVlIGZvciBlYWNoIGNvcHkgb2YgalF1ZXJ5IG9uIHRoZSBwYWdlXG5cdGV4cGFuZG86IFwialF1ZXJ5XCIgKyAoIHZlcnNpb24gKyBNYXRoLnJhbmRvbSgpICkucmVwbGFjZSggL1xcRC9nLCBcIlwiICksXG5cblx0Ly8gQXNzdW1lIGpRdWVyeSBpcyByZWFkeSB3aXRob3V0IHRoZSByZWFkeSBtb2R1bGVcblx0aXNSZWFkeTogdHJ1ZSxcblxuXHRlcnJvcjogZnVuY3Rpb24oIG1zZyApIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoIG1zZyApO1xuXHR9LFxuXG5cdG5vb3A6IGZ1bmN0aW9uKCkge30sXG5cblx0aXNGdW5jdGlvbjogZnVuY3Rpb24oIG9iaiApIHtcblx0XHRyZXR1cm4galF1ZXJ5LnR5cGUoIG9iaiApID09PSBcImZ1bmN0aW9uXCI7XG5cdH0sXG5cblx0aXNBcnJheTogQXJyYXkuaXNBcnJheSxcblxuXHRpc1dpbmRvdzogZnVuY3Rpb24oIG9iaiApIHtcblx0XHRyZXR1cm4gb2JqICE9IG51bGwgJiYgb2JqID09PSBvYmoud2luZG93O1xuXHR9LFxuXG5cdGlzTnVtZXJpYzogZnVuY3Rpb24oIG9iaiApIHtcblxuXHRcdC8vIEFzIG9mIGpRdWVyeSAzLjAsIGlzTnVtZXJpYyBpcyBsaW1pdGVkIHRvXG5cdFx0Ly8gc3RyaW5ncyBhbmQgbnVtYmVycyAocHJpbWl0aXZlcyBvciBvYmplY3RzKVxuXHRcdC8vIHRoYXQgY2FuIGJlIGNvZXJjZWQgdG8gZmluaXRlIG51bWJlcnMgKGdoLTI2NjIpXG5cdFx0dmFyIHR5cGUgPSBqUXVlcnkudHlwZSggb2JqICk7XG5cdFx0cmV0dXJuICggdHlwZSA9PT0gXCJudW1iZXJcIiB8fCB0eXBlID09PSBcInN0cmluZ1wiICkgJiZcblxuXHRcdFx0Ly8gcGFyc2VGbG9hdCBOYU5zIG51bWVyaWMtY2FzdCBmYWxzZSBwb3NpdGl2ZXMgKFwiXCIpXG5cdFx0XHQvLyAuLi5idXQgbWlzaW50ZXJwcmV0cyBsZWFkaW5nLW51bWJlciBzdHJpbmdzLCBwYXJ0aWN1bGFybHkgaGV4IGxpdGVyYWxzIChcIjB4Li4uXCIpXG5cdFx0XHQvLyBzdWJ0cmFjdGlvbiBmb3JjZXMgaW5maW5pdGllcyB0byBOYU5cblx0XHRcdCFpc05hTiggb2JqIC0gcGFyc2VGbG9hdCggb2JqICkgKTtcblx0fSxcblxuXHRpc1BsYWluT2JqZWN0OiBmdW5jdGlvbiggb2JqICkge1xuXHRcdHZhciBwcm90bywgQ3RvcjtcblxuXHRcdC8vIERldGVjdCBvYnZpb3VzIG5lZ2F0aXZlc1xuXHRcdC8vIFVzZSB0b1N0cmluZyBpbnN0ZWFkIG9mIGpRdWVyeS50eXBlIHRvIGNhdGNoIGhvc3Qgb2JqZWN0c1xuXHRcdGlmICggIW9iaiB8fCB0b1N0cmluZy5jYWxsKCBvYmogKSAhPT0gXCJbb2JqZWN0IE9iamVjdF1cIiApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRwcm90byA9IGdldFByb3RvKCBvYmogKTtcblxuXHRcdC8vIE9iamVjdHMgd2l0aCBubyBwcm90b3R5cGUgKGUuZy4sIGBPYmplY3QuY3JlYXRlKCBudWxsIClgKSBhcmUgcGxhaW5cblx0XHRpZiAoICFwcm90byApIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdC8vIE9iamVjdHMgd2l0aCBwcm90b3R5cGUgYXJlIHBsYWluIGlmZiB0aGV5IHdlcmUgY29uc3RydWN0ZWQgYnkgYSBnbG9iYWwgT2JqZWN0IGZ1bmN0aW9uXG5cdFx0Q3RvciA9IGhhc093bi5jYWxsKCBwcm90bywgXCJjb25zdHJ1Y3RvclwiICkgJiYgcHJvdG8uY29uc3RydWN0b3I7XG5cdFx0cmV0dXJuIHR5cGVvZiBDdG9yID09PSBcImZ1bmN0aW9uXCIgJiYgZm5Ub1N0cmluZy5jYWxsKCBDdG9yICkgPT09IE9iamVjdEZ1bmN0aW9uU3RyaW5nO1xuXHR9LFxuXG5cdGlzRW1wdHlPYmplY3Q6IGZ1bmN0aW9uKCBvYmogKSB7XG5cblx0XHQvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuXHRcdC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZXNsaW50L2VzbGludC9pc3N1ZXMvNjEyNVxuXHRcdHZhciBuYW1lO1xuXG5cdFx0Zm9yICggbmFtZSBpbiBvYmogKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdHR5cGU6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0aWYgKCBvYmogPT0gbnVsbCApIHtcblx0XHRcdHJldHVybiBvYmogKyBcIlwiO1xuXHRcdH1cblxuXHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD0yLjMgb25seSAoZnVuY3Rpb25pc2ggUmVnRXhwKVxuXHRcdHJldHVybiB0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBvYmogPT09IFwiZnVuY3Rpb25cIiA/XG5cdFx0XHRjbGFzczJ0eXBlWyB0b1N0cmluZy5jYWxsKCBvYmogKSBdIHx8IFwib2JqZWN0XCIgOlxuXHRcdFx0dHlwZW9mIG9iajtcblx0fSxcblxuXHQvLyBFdmFsdWF0ZXMgYSBzY3JpcHQgaW4gYSBnbG9iYWwgY29udGV4dFxuXHRnbG9iYWxFdmFsOiBmdW5jdGlvbiggY29kZSApIHtcblx0XHRET01FdmFsKCBjb2RlICk7XG5cdH0sXG5cblx0Ly8gQ29udmVydCBkYXNoZWQgdG8gY2FtZWxDYXNlOyB1c2VkIGJ5IHRoZSBjc3MgYW5kIGRhdGEgbW9kdWxlc1xuXHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSwgRWRnZSAxMiAtIDEzXG5cdC8vIE1pY3Jvc29mdCBmb3Jnb3QgdG8gaHVtcCB0aGVpciB2ZW5kb3IgcHJlZml4ICgjOTU3Milcblx0Y2FtZWxDYXNlOiBmdW5jdGlvbiggc3RyaW5nICkge1xuXHRcdHJldHVybiBzdHJpbmcucmVwbGFjZSggcm1zUHJlZml4LCBcIm1zLVwiICkucmVwbGFjZSggcmRhc2hBbHBoYSwgZmNhbWVsQ2FzZSApO1xuXHR9LFxuXG5cdG5vZGVOYW1lOiBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0XHRyZXR1cm4gZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUudG9Mb3dlckNhc2UoKTtcblx0fSxcblxuXHRlYWNoOiBmdW5jdGlvbiggb2JqLCBjYWxsYmFjayApIHtcblx0XHR2YXIgbGVuZ3RoLCBpID0gMDtcblxuXHRcdGlmICggaXNBcnJheUxpa2UoIG9iaiApICkge1xuXHRcdFx0bGVuZ3RoID0gb2JqLmxlbmd0aDtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrLmNhbGwoIG9ialsgaSBdLCBpLCBvYmpbIGkgXSApID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRmb3IgKCBpIGluIG9iaiApIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjay5jYWxsKCBvYmpbIGkgXSwgaSwgb2JqWyBpIF0gKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gb2JqO1xuXHR9LFxuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seVxuXHR0cmltOiBmdW5jdGlvbiggdGV4dCApIHtcblx0XHRyZXR1cm4gdGV4dCA9PSBudWxsID9cblx0XHRcdFwiXCIgOlxuXHRcdFx0KCB0ZXh0ICsgXCJcIiApLnJlcGxhY2UoIHJ0cmltLCBcIlwiICk7XG5cdH0sXG5cblx0Ly8gcmVzdWx0cyBpcyBmb3IgaW50ZXJuYWwgdXNhZ2Ugb25seVxuXHRtYWtlQXJyYXk6IGZ1bmN0aW9uKCBhcnIsIHJlc3VsdHMgKSB7XG5cdFx0dmFyIHJldCA9IHJlc3VsdHMgfHwgW107XG5cblx0XHRpZiAoIGFyciAhPSBudWxsICkge1xuXHRcdFx0aWYgKCBpc0FycmF5TGlrZSggT2JqZWN0KCBhcnIgKSApICkge1xuXHRcdFx0XHRqUXVlcnkubWVyZ2UoIHJldCxcblx0XHRcdFx0XHR0eXBlb2YgYXJyID09PSBcInN0cmluZ1wiID9cblx0XHRcdFx0XHRbIGFyciBdIDogYXJyXG5cdFx0XHRcdCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwdXNoLmNhbGwoIHJldCwgYXJyICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJldDtcblx0fSxcblxuXHRpbkFycmF5OiBmdW5jdGlvbiggZWxlbSwgYXJyLCBpICkge1xuXHRcdHJldHVybiBhcnIgPT0gbnVsbCA/IC0xIDogaW5kZXhPZi5jYWxsKCBhcnIsIGVsZW0sIGkgKTtcblx0fSxcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcblx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRtZXJnZTogZnVuY3Rpb24oIGZpcnN0LCBzZWNvbmQgKSB7XG5cdFx0dmFyIGxlbiA9ICtzZWNvbmQubGVuZ3RoLFxuXHRcdFx0aiA9IDAsXG5cdFx0XHRpID0gZmlyc3QubGVuZ3RoO1xuXG5cdFx0Zm9yICggOyBqIDwgbGVuOyBqKysgKSB7XG5cdFx0XHRmaXJzdFsgaSsrIF0gPSBzZWNvbmRbIGogXTtcblx0XHR9XG5cblx0XHRmaXJzdC5sZW5ndGggPSBpO1xuXG5cdFx0cmV0dXJuIGZpcnN0O1xuXHR9LFxuXG5cdGdyZXA6IGZ1bmN0aW9uKCBlbGVtcywgY2FsbGJhY2ssIGludmVydCApIHtcblx0XHR2YXIgY2FsbGJhY2tJbnZlcnNlLFxuXHRcdFx0bWF0Y2hlcyA9IFtdLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRsZW5ndGggPSBlbGVtcy5sZW5ndGgsXG5cdFx0XHRjYWxsYmFja0V4cGVjdCA9ICFpbnZlcnQ7XG5cblx0XHQvLyBHbyB0aHJvdWdoIHRoZSBhcnJheSwgb25seSBzYXZpbmcgdGhlIGl0ZW1zXG5cdFx0Ly8gdGhhdCBwYXNzIHRoZSB2YWxpZGF0b3IgZnVuY3Rpb25cblx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdGNhbGxiYWNrSW52ZXJzZSA9ICFjYWxsYmFjayggZWxlbXNbIGkgXSwgaSApO1xuXHRcdFx0aWYgKCBjYWxsYmFja0ludmVyc2UgIT09IGNhbGxiYWNrRXhwZWN0ICkge1xuXHRcdFx0XHRtYXRjaGVzLnB1c2goIGVsZW1zWyBpIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gbWF0Y2hlcztcblx0fSxcblxuXHQvLyBhcmcgaXMgZm9yIGludGVybmFsIHVzYWdlIG9ubHlcblx0bWFwOiBmdW5jdGlvbiggZWxlbXMsIGNhbGxiYWNrLCBhcmcgKSB7XG5cdFx0dmFyIGxlbmd0aCwgdmFsdWUsXG5cdFx0XHRpID0gMCxcblx0XHRcdHJldCA9IFtdO1xuXG5cdFx0Ly8gR28gdGhyb3VnaCB0aGUgYXJyYXksIHRyYW5zbGF0aW5nIGVhY2ggb2YgdGhlIGl0ZW1zIHRvIHRoZWlyIG5ldyB2YWx1ZXNcblx0XHRpZiAoIGlzQXJyYXlMaWtlKCBlbGVtcyApICkge1xuXHRcdFx0bGVuZ3RoID0gZWxlbXMubGVuZ3RoO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdHZhbHVlID0gY2FsbGJhY2soIGVsZW1zWyBpIF0sIGksIGFyZyApO1xuXG5cdFx0XHRcdGlmICggdmFsdWUgIT0gbnVsbCApIHtcblx0XHRcdFx0XHRyZXQucHVzaCggdmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0Ly8gR28gdGhyb3VnaCBldmVyeSBrZXkgb24gdGhlIG9iamVjdCxcblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yICggaSBpbiBlbGVtcyApIHtcblx0XHRcdFx0dmFsdWUgPSBjYWxsYmFjayggZWxlbXNbIGkgXSwgaSwgYXJnICk7XG5cblx0XHRcdFx0aWYgKCB2YWx1ZSAhPSBudWxsICkge1xuXHRcdFx0XHRcdHJldC5wdXNoKCB2YWx1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gRmxhdHRlbiBhbnkgbmVzdGVkIGFycmF5c1xuXHRcdHJldHVybiBjb25jYXQuYXBwbHkoIFtdLCByZXQgKTtcblx0fSxcblxuXHQvLyBBIGdsb2JhbCBHVUlEIGNvdW50ZXIgZm9yIG9iamVjdHNcblx0Z3VpZDogMSxcblxuXHQvLyBCaW5kIGEgZnVuY3Rpb24gdG8gYSBjb250ZXh0LCBvcHRpb25hbGx5IHBhcnRpYWxseSBhcHBseWluZyBhbnlcblx0Ly8gYXJndW1lbnRzLlxuXHRwcm94eTogZnVuY3Rpb24oIGZuLCBjb250ZXh0ICkge1xuXHRcdHZhciB0bXAsIGFyZ3MsIHByb3h5O1xuXG5cdFx0aWYgKCB0eXBlb2YgY29udGV4dCA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHRtcCA9IGZuWyBjb250ZXh0IF07XG5cdFx0XHRjb250ZXh0ID0gZm47XG5cdFx0XHRmbiA9IHRtcDtcblx0XHR9XG5cblx0XHQvLyBRdWljayBjaGVjayB0byBkZXRlcm1pbmUgaWYgdGFyZ2V0IGlzIGNhbGxhYmxlLCBpbiB0aGUgc3BlY1xuXHRcdC8vIHRoaXMgdGhyb3dzIGEgVHlwZUVycm9yLCBidXQgd2Ugd2lsbCBqdXN0IHJldHVybiB1bmRlZmluZWQuXG5cdFx0aWYgKCAhalF1ZXJ5LmlzRnVuY3Rpb24oIGZuICkgKSB7XG5cdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdC8vIFNpbXVsYXRlZCBiaW5kXG5cdFx0YXJncyA9IHNsaWNlLmNhbGwoIGFyZ3VtZW50cywgMiApO1xuXHRcdHByb3h5ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gZm4uYXBwbHkoIGNvbnRleHQgfHwgdGhpcywgYXJncy5jb25jYXQoIHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApICkgKTtcblx0XHR9O1xuXG5cdFx0Ly8gU2V0IHRoZSBndWlkIG9mIHVuaXF1ZSBoYW5kbGVyIHRvIHRoZSBzYW1lIG9mIG9yaWdpbmFsIGhhbmRsZXIsIHNvIGl0IGNhbiBiZSByZW1vdmVkXG5cdFx0cHJveHkuZ3VpZCA9IGZuLmd1aWQgPSBmbi5ndWlkIHx8IGpRdWVyeS5ndWlkKys7XG5cblx0XHRyZXR1cm4gcHJveHk7XG5cdH0sXG5cblx0bm93OiBEYXRlLm5vdyxcblxuXHQvLyBqUXVlcnkuc3VwcG9ydCBpcyBub3QgdXNlZCBpbiBDb3JlIGJ1dCBvdGhlciBwcm9qZWN0cyBhdHRhY2ggdGhlaXJcblx0Ly8gcHJvcGVydGllcyB0byBpdCBzbyBpdCBuZWVkcyB0byBleGlzdC5cblx0c3VwcG9ydDogc3VwcG9ydFxufSApO1xuXG5pZiAoIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiApIHtcblx0alF1ZXJ5LmZuWyBTeW1ib2wuaXRlcmF0b3IgXSA9IGFyclsgU3ltYm9sLml0ZXJhdG9yIF07XG59XG5cbi8vIFBvcHVsYXRlIHRoZSBjbGFzczJ0eXBlIG1hcFxualF1ZXJ5LmVhY2goIFwiQm9vbGVhbiBOdW1iZXIgU3RyaW5nIEZ1bmN0aW9uIEFycmF5IERhdGUgUmVnRXhwIE9iamVjdCBFcnJvciBTeW1ib2xcIi5zcGxpdCggXCIgXCIgKSxcbmZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXHRjbGFzczJ0eXBlWyBcIltvYmplY3QgXCIgKyBuYW1lICsgXCJdXCIgXSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbn0gKTtcblxuZnVuY3Rpb24gaXNBcnJheUxpa2UoIG9iaiApIHtcblxuXHQvLyBTdXBwb3J0OiByZWFsIGlPUyA4LjIgb25seSAobm90IHJlcHJvZHVjaWJsZSBpbiBzaW11bGF0b3IpXG5cdC8vIGBpbmAgY2hlY2sgdXNlZCB0byBwcmV2ZW50IEpJVCBlcnJvciAoZ2gtMjE0NSlcblx0Ly8gaGFzT3duIGlzbid0IHVzZWQgaGVyZSBkdWUgdG8gZmFsc2UgbmVnYXRpdmVzXG5cdC8vIHJlZ2FyZGluZyBOb2RlbGlzdCBsZW5ndGggaW4gSUVcblx0dmFyIGxlbmd0aCA9ICEhb2JqICYmIFwibGVuZ3RoXCIgaW4gb2JqICYmIG9iai5sZW5ndGgsXG5cdFx0dHlwZSA9IGpRdWVyeS50eXBlKCBvYmogKTtcblxuXHRpZiAoIHR5cGUgPT09IFwiZnVuY3Rpb25cIiB8fCBqUXVlcnkuaXNXaW5kb3coIG9iaiApICkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdHJldHVybiB0eXBlID09PSBcImFycmF5XCIgfHwgbGVuZ3RoID09PSAwIHx8XG5cdFx0dHlwZW9mIGxlbmd0aCA9PT0gXCJudW1iZXJcIiAmJiBsZW5ndGggPiAwICYmICggbGVuZ3RoIC0gMSApIGluIG9iajtcbn1cbnZhciBTaXp6bGUgPVxuLyohXG4gKiBTaXp6bGUgQ1NTIFNlbGVjdG9yIEVuZ2luZSB2Mi4zLjNcbiAqIGh0dHBzOi8vc2l6emxlanMuY29tL1xuICpcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqXG4gKiBEYXRlOiAyMDE2LTA4LTA4XG4gKi9cbihmdW5jdGlvbiggd2luZG93ICkge1xuXG52YXIgaSxcblx0c3VwcG9ydCxcblx0RXhwcixcblx0Z2V0VGV4dCxcblx0aXNYTUwsXG5cdHRva2VuaXplLFxuXHRjb21waWxlLFxuXHRzZWxlY3QsXG5cdG91dGVybW9zdENvbnRleHQsXG5cdHNvcnRJbnB1dCxcblx0aGFzRHVwbGljYXRlLFxuXG5cdC8vIExvY2FsIGRvY3VtZW50IHZhcnNcblx0c2V0RG9jdW1lbnQsXG5cdGRvY3VtZW50LFxuXHRkb2NFbGVtLFxuXHRkb2N1bWVudElzSFRNTCxcblx0cmJ1Z2d5UVNBLFxuXHRyYnVnZ3lNYXRjaGVzLFxuXHRtYXRjaGVzLFxuXHRjb250YWlucyxcblxuXHQvLyBJbnN0YW5jZS1zcGVjaWZpYyBkYXRhXG5cdGV4cGFuZG8gPSBcInNpenpsZVwiICsgMSAqIG5ldyBEYXRlKCksXG5cdHByZWZlcnJlZERvYyA9IHdpbmRvdy5kb2N1bWVudCxcblx0ZGlycnVucyA9IDAsXG5cdGRvbmUgPSAwLFxuXHRjbGFzc0NhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0dG9rZW5DYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG5cdGNvbXBpbGVyQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHRzb3J0T3JkZXIgPSBmdW5jdGlvbiggYSwgYiApIHtcblx0XHRpZiAoIGEgPT09IGIgKSB7XG5cdFx0XHRoYXNEdXBsaWNhdGUgPSB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gMDtcblx0fSxcblxuXHQvLyBJbnN0YW5jZSBtZXRob2RzXG5cdGhhc093biA9ICh7fSkuaGFzT3duUHJvcGVydHksXG5cdGFyciA9IFtdLFxuXHRwb3AgPSBhcnIucG9wLFxuXHRwdXNoX25hdGl2ZSA9IGFyci5wdXNoLFxuXHRwdXNoID0gYXJyLnB1c2gsXG5cdHNsaWNlID0gYXJyLnNsaWNlLFxuXHQvLyBVc2UgYSBzdHJpcHBlZC1kb3duIGluZGV4T2YgYXMgaXQncyBmYXN0ZXIgdGhhbiBuYXRpdmVcblx0Ly8gaHR0cHM6Ly9qc3BlcmYuY29tL3Rob3ItaW5kZXhvZi12cy1mb3IvNVxuXHRpbmRleE9mID0gZnVuY3Rpb24oIGxpc3QsIGVsZW0gKSB7XG5cdFx0dmFyIGkgPSAwLFxuXHRcdFx0bGVuID0gbGlzdC5sZW5ndGg7XG5cdFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRpZiAoIGxpc3RbaV0gPT09IGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gLTE7XG5cdH0sXG5cblx0Ym9vbGVhbnMgPSBcImNoZWNrZWR8c2VsZWN0ZWR8YXN5bmN8YXV0b2ZvY3VzfGF1dG9wbGF5fGNvbnRyb2xzfGRlZmVyfGRpc2FibGVkfGhpZGRlbnxpc21hcHxsb29wfG11bHRpcGxlfG9wZW58cmVhZG9ubHl8cmVxdWlyZWR8c2NvcGVkXCIsXG5cblx0Ly8gUmVndWxhciBleHByZXNzaW9uc1xuXG5cdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtc2VsZWN0b3JzLyN3aGl0ZXNwYWNlXG5cdHdoaXRlc3BhY2UgPSBcIltcXFxceDIwXFxcXHRcXFxcclxcXFxuXFxcXGZdXCIsXG5cblx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvQ1NTMjEvc3luZGF0YS5odG1sI3ZhbHVlLWRlZi1pZGVudGlmaWVyXG5cdGlkZW50aWZpZXIgPSBcIig/OlxcXFxcXFxcLnxbXFxcXHctXXxbXlxcMC1cXFxceGEwXSkrXCIsXG5cblx0Ly8gQXR0cmlidXRlIHNlbGVjdG9yczogaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNhdHRyaWJ1dGUtc2VsZWN0b3JzXG5cdGF0dHJpYnV0ZXMgPSBcIlxcXFxbXCIgKyB3aGl0ZXNwYWNlICsgXCIqKFwiICsgaWRlbnRpZmllciArIFwiKSg/OlwiICsgd2hpdGVzcGFjZSArXG5cdFx0Ly8gT3BlcmF0b3IgKGNhcHR1cmUgMilcblx0XHRcIiooWypeJHwhfl0/PSlcIiArIHdoaXRlc3BhY2UgK1xuXHRcdC8vIFwiQXR0cmlidXRlIHZhbHVlcyBtdXN0IGJlIENTUyBpZGVudGlmaWVycyBbY2FwdHVyZSA1XSBvciBzdHJpbmdzIFtjYXB0dXJlIDMgb3IgY2FwdHVyZSA0XVwiXG5cdFx0XCIqKD86JygoPzpcXFxcXFxcXC58W15cXFxcXFxcXCddKSopJ3xcXFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcIl0pKilcXFwifChcIiArIGlkZW50aWZpZXIgKyBcIikpfClcIiArIHdoaXRlc3BhY2UgK1xuXHRcdFwiKlxcXFxdXCIsXG5cblx0cHNldWRvcyA9IFwiOihcIiArIGlkZW50aWZpZXIgKyBcIikoPzpcXFxcKChcIiArXG5cdFx0Ly8gVG8gcmVkdWNlIHRoZSBudW1iZXIgb2Ygc2VsZWN0b3JzIG5lZWRpbmcgdG9rZW5pemUgaW4gdGhlIHByZUZpbHRlciwgcHJlZmVyIGFyZ3VtZW50czpcblx0XHQvLyAxLiBxdW90ZWQgKGNhcHR1cmUgMzsgY2FwdHVyZSA0IG9yIGNhcHR1cmUgNSlcblx0XHRcIignKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcJ10pKiknfFxcXCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFxcXFwiXSkqKVxcXCIpfFwiICtcblx0XHQvLyAyLiBzaW1wbGUgKGNhcHR1cmUgNilcblx0XHRcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXCgpW1xcXFxdXXxcIiArIGF0dHJpYnV0ZXMgKyBcIikqKXxcIiArXG5cdFx0Ly8gMy4gYW55dGhpbmcgZWxzZSAoY2FwdHVyZSAyKVxuXHRcdFwiLipcIiArXG5cdFx0XCIpXFxcXCl8KVwiLFxuXG5cdC8vIExlYWRpbmcgYW5kIG5vbi1lc2NhcGVkIHRyYWlsaW5nIHdoaXRlc3BhY2UsIGNhcHR1cmluZyBzb21lIG5vbi13aGl0ZXNwYWNlIGNoYXJhY3RlcnMgcHJlY2VkaW5nIHRoZSBsYXR0ZXJcblx0cndoaXRlc3BhY2UgPSBuZXcgUmVnRXhwKCB3aGl0ZXNwYWNlICsgXCIrXCIsIFwiZ1wiICksXG5cdHJ0cmltID0gbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIrfCgoPzpefFteXFxcXFxcXFxdKSg/OlxcXFxcXFxcLikqKVwiICsgd2hpdGVzcGFjZSArIFwiKyRcIiwgXCJnXCIgKSxcblxuXHRyY29tbWEgPSBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIiosXCIgKyB3aGl0ZXNwYWNlICsgXCIqXCIgKSxcblx0cmNvbWJpbmF0b3JzID0gbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqKFs+K35dfFwiICsgd2hpdGVzcGFjZSArIFwiKVwiICsgd2hpdGVzcGFjZSArIFwiKlwiICksXG5cblx0cmF0dHJpYnV0ZVF1b3RlcyA9IG5ldyBSZWdFeHAoIFwiPVwiICsgd2hpdGVzcGFjZSArIFwiKihbXlxcXFxdJ1xcXCJdKj8pXCIgKyB3aGl0ZXNwYWNlICsgXCIqXFxcXF1cIiwgXCJnXCIgKSxcblxuXHRycHNldWRvID0gbmV3IFJlZ0V4cCggcHNldWRvcyApLFxuXHRyaWRlbnRpZmllciA9IG5ldyBSZWdFeHAoIFwiXlwiICsgaWRlbnRpZmllciArIFwiJFwiICksXG5cblx0bWF0Y2hFeHByID0ge1xuXHRcdFwiSURcIjogbmV3IFJlZ0V4cCggXCJeIyhcIiArIGlkZW50aWZpZXIgKyBcIilcIiApLFxuXHRcdFwiQ0xBU1NcIjogbmV3IFJlZ0V4cCggXCJeXFxcXC4oXCIgKyBpZGVudGlmaWVyICsgXCIpXCIgKSxcblx0XHRcIlRBR1wiOiBuZXcgUmVnRXhwKCBcIl4oXCIgKyBpZGVudGlmaWVyICsgXCJ8WypdKVwiICksXG5cdFx0XCJBVFRSXCI6IG5ldyBSZWdFeHAoIFwiXlwiICsgYXR0cmlidXRlcyApLFxuXHRcdFwiUFNFVURPXCI6IG5ldyBSZWdFeHAoIFwiXlwiICsgcHNldWRvcyApLFxuXHRcdFwiQ0hJTERcIjogbmV3IFJlZ0V4cCggXCJeOihvbmx5fGZpcnN0fGxhc3R8bnRofG50aC1sYXN0KS0oY2hpbGR8b2YtdHlwZSkoPzpcXFxcKFwiICsgd2hpdGVzcGFjZSArXG5cdFx0XHRcIiooZXZlbnxvZGR8KChbKy1dfCkoXFxcXGQqKW58KVwiICsgd2hpdGVzcGFjZSArIFwiKig/OihbKy1dfClcIiArIHdoaXRlc3BhY2UgK1xuXHRcdFx0XCIqKFxcXFxkKyl8KSlcIiArIHdoaXRlc3BhY2UgKyBcIipcXFxcKXwpXCIsIFwiaVwiICksXG5cdFx0XCJib29sXCI6IG5ldyBSZWdFeHAoIFwiXig/OlwiICsgYm9vbGVhbnMgKyBcIikkXCIsIFwiaVwiICksXG5cdFx0Ly8gRm9yIHVzZSBpbiBsaWJyYXJpZXMgaW1wbGVtZW50aW5nIC5pcygpXG5cdFx0Ly8gV2UgdXNlIHRoaXMgZm9yIFBPUyBtYXRjaGluZyBpbiBgc2VsZWN0YFxuXHRcdFwibmVlZHNDb250ZXh0XCI6IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiKls+K35dfDooZXZlbnxvZGR8ZXF8Z3R8bHR8bnRofGZpcnN0fGxhc3QpKD86XFxcXChcIiArXG5cdFx0XHR3aGl0ZXNwYWNlICsgXCIqKCg/Oi1cXFxcZCk/XFxcXGQqKVwiICsgd2hpdGVzcGFjZSArIFwiKlxcXFwpfCkoPz1bXi1dfCQpXCIsIFwiaVwiIClcblx0fSxcblxuXHRyaW5wdXRzID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9uKSQvaSxcblx0cmhlYWRlciA9IC9eaFxcZCQvaSxcblxuXHRybmF0aXZlID0gL15bXntdK1xce1xccypcXFtuYXRpdmUgXFx3LyxcblxuXHQvLyBFYXNpbHktcGFyc2VhYmxlL3JldHJpZXZhYmxlIElEIG9yIFRBRyBvciBDTEFTUyBzZWxlY3RvcnNcblx0cnF1aWNrRXhwciA9IC9eKD86IyhbXFx3LV0rKXwoXFx3Kyl8XFwuKFtcXHctXSspKSQvLFxuXG5cdHJzaWJsaW5nID0gL1srfl0vLFxuXG5cdC8vIENTUyBlc2NhcGVzXG5cdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL0NTUzIxL3N5bmRhdGEuaHRtbCNlc2NhcGVkLWNoYXJhY3RlcnNcblx0cnVuZXNjYXBlID0gbmV3IFJlZ0V4cCggXCJcXFxcXFxcXChbXFxcXGRhLWZdezEsNn1cIiArIHdoaXRlc3BhY2UgKyBcIj98KFwiICsgd2hpdGVzcGFjZSArIFwiKXwuKVwiLCBcImlnXCIgKSxcblx0ZnVuZXNjYXBlID0gZnVuY3Rpb24oIF8sIGVzY2FwZWQsIGVzY2FwZWRXaGl0ZXNwYWNlICkge1xuXHRcdHZhciBoaWdoID0gXCIweFwiICsgZXNjYXBlZCAtIDB4MTAwMDA7XG5cdFx0Ly8gTmFOIG1lYW5zIG5vbi1jb2RlcG9pbnRcblx0XHQvLyBTdXBwb3J0OiBGaXJlZm94PDI0XG5cdFx0Ly8gV29ya2Fyb3VuZCBlcnJvbmVvdXMgbnVtZXJpYyBpbnRlcnByZXRhdGlvbiBvZiArXCIweFwiXG5cdFx0cmV0dXJuIGhpZ2ggIT09IGhpZ2ggfHwgZXNjYXBlZFdoaXRlc3BhY2UgP1xuXHRcdFx0ZXNjYXBlZCA6XG5cdFx0XHRoaWdoIDwgMCA/XG5cdFx0XHRcdC8vIEJNUCBjb2RlcG9pbnRcblx0XHRcdFx0U3RyaW5nLmZyb21DaGFyQ29kZSggaGlnaCArIDB4MTAwMDAgKSA6XG5cdFx0XHRcdC8vIFN1cHBsZW1lbnRhbCBQbGFuZSBjb2RlcG9pbnQgKHN1cnJvZ2F0ZSBwYWlyKVxuXHRcdFx0XHRTdHJpbmcuZnJvbUNoYXJDb2RlKCBoaWdoID4+IDEwIHwgMHhEODAwLCBoaWdoICYgMHgzRkYgfCAweERDMDAgKTtcblx0fSxcblxuXHQvLyBDU1Mgc3RyaW5nL2lkZW50aWZpZXIgc2VyaWFsaXphdGlvblxuXHQvLyBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3Nzb20vI2NvbW1vbi1zZXJpYWxpemluZy1pZGlvbXNcblx0cmNzc2VzY2FwZSA9IC8oW1xcMC1cXHgxZlxceDdmXXxeLT9cXGQpfF4tJHxbXlxcMC1cXHgxZlxceDdmLVxcdUZGRkZcXHctXS9nLFxuXHRmY3NzZXNjYXBlID0gZnVuY3Rpb24oIGNoLCBhc0NvZGVQb2ludCApIHtcblx0XHRpZiAoIGFzQ29kZVBvaW50ICkge1xuXG5cdFx0XHQvLyBVKzAwMDAgTlVMTCBiZWNvbWVzIFUrRkZGRCBSRVBMQUNFTUVOVCBDSEFSQUNURVJcblx0XHRcdGlmICggY2ggPT09IFwiXFwwXCIgKSB7XG5cdFx0XHRcdHJldHVybiBcIlxcdUZGRkRcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29udHJvbCBjaGFyYWN0ZXJzIGFuZCAoZGVwZW5kZW50IHVwb24gcG9zaXRpb24pIG51bWJlcnMgZ2V0IGVzY2FwZWQgYXMgY29kZSBwb2ludHNcblx0XHRcdHJldHVybiBjaC5zbGljZSggMCwgLTEgKSArIFwiXFxcXFwiICsgY2guY2hhckNvZGVBdCggY2gubGVuZ3RoIC0gMSApLnRvU3RyaW5nKCAxNiApICsgXCIgXCI7XG5cdFx0fVxuXG5cdFx0Ly8gT3RoZXIgcG90ZW50aWFsbHktc3BlY2lhbCBBU0NJSSBjaGFyYWN0ZXJzIGdldCBiYWNrc2xhc2gtZXNjYXBlZFxuXHRcdHJldHVybiBcIlxcXFxcIiArIGNoO1xuXHR9LFxuXG5cdC8vIFVzZWQgZm9yIGlmcmFtZXNcblx0Ly8gU2VlIHNldERvY3VtZW50KClcblx0Ly8gUmVtb3ZpbmcgdGhlIGZ1bmN0aW9uIHdyYXBwZXIgY2F1c2VzIGEgXCJQZXJtaXNzaW9uIERlbmllZFwiXG5cdC8vIGVycm9yIGluIElFXG5cdHVubG9hZEhhbmRsZXIgPSBmdW5jdGlvbigpIHtcblx0XHRzZXREb2N1bWVudCgpO1xuXHR9LFxuXG5cdGRpc2FibGVkQW5jZXN0b3IgPSBhZGRDb21iaW5hdG9yKFxuXHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IHRydWUgJiYgKFwiZm9ybVwiIGluIGVsZW0gfHwgXCJsYWJlbFwiIGluIGVsZW0pO1xuXHRcdH0sXG5cdFx0eyBkaXI6IFwicGFyZW50Tm9kZVwiLCBuZXh0OiBcImxlZ2VuZFwiIH1cblx0KTtcblxuLy8gT3B0aW1pemUgZm9yIHB1c2guYXBwbHkoIF8sIE5vZGVMaXN0IClcbnRyeSB7XG5cdHB1c2guYXBwbHkoXG5cdFx0KGFyciA9IHNsaWNlLmNhbGwoIHByZWZlcnJlZERvYy5jaGlsZE5vZGVzICkpLFxuXHRcdHByZWZlcnJlZERvYy5jaGlsZE5vZGVzXG5cdCk7XG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQ8NC4wXG5cdC8vIERldGVjdCBzaWxlbnRseSBmYWlsaW5nIHB1c2guYXBwbHlcblx0YXJyWyBwcmVmZXJyZWREb2MuY2hpbGROb2Rlcy5sZW5ndGggXS5ub2RlVHlwZTtcbn0gY2F0Y2ggKCBlICkge1xuXHRwdXNoID0geyBhcHBseTogYXJyLmxlbmd0aCA/XG5cblx0XHQvLyBMZXZlcmFnZSBzbGljZSBpZiBwb3NzaWJsZVxuXHRcdGZ1bmN0aW9uKCB0YXJnZXQsIGVscyApIHtcblx0XHRcdHB1c2hfbmF0aXZlLmFwcGx5KCB0YXJnZXQsIHNsaWNlLmNhbGwoZWxzKSApO1xuXHRcdH0gOlxuXG5cdFx0Ly8gU3VwcG9ydDogSUU8OVxuXHRcdC8vIE90aGVyd2lzZSBhcHBlbmQgZGlyZWN0bHlcblx0XHRmdW5jdGlvbiggdGFyZ2V0LCBlbHMgKSB7XG5cdFx0XHR2YXIgaiA9IHRhcmdldC5sZW5ndGgsXG5cdFx0XHRcdGkgPSAwO1xuXHRcdFx0Ly8gQ2FuJ3QgdHJ1c3QgTm9kZUxpc3QubGVuZ3RoXG5cdFx0XHR3aGlsZSAoICh0YXJnZXRbaisrXSA9IGVsc1tpKytdKSApIHt9XG5cdFx0XHR0YXJnZXQubGVuZ3RoID0gaiAtIDE7XG5cdFx0fVxuXHR9O1xufVxuXG5mdW5jdGlvbiBTaXp6bGUoIHNlbGVjdG9yLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICkge1xuXHR2YXIgbSwgaSwgZWxlbSwgbmlkLCBtYXRjaCwgZ3JvdXBzLCBuZXdTZWxlY3Rvcixcblx0XHRuZXdDb250ZXh0ID0gY29udGV4dCAmJiBjb250ZXh0Lm93bmVyRG9jdW1lbnQsXG5cblx0XHQvLyBub2RlVHlwZSBkZWZhdWx0cyB0byA5LCBzaW5jZSBjb250ZXh0IGRlZmF1bHRzIHRvIGRvY3VtZW50XG5cdFx0bm9kZVR5cGUgPSBjb250ZXh0ID8gY29udGV4dC5ub2RlVHlwZSA6IDk7XG5cblx0cmVzdWx0cyA9IHJlc3VsdHMgfHwgW107XG5cblx0Ly8gUmV0dXJuIGVhcmx5IGZyb20gY2FsbHMgd2l0aCBpbnZhbGlkIHNlbGVjdG9yIG9yIGNvbnRleHRcblx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgfHwgIXNlbGVjdG9yIHx8XG5cdFx0bm9kZVR5cGUgIT09IDEgJiYgbm9kZVR5cGUgIT09IDkgJiYgbm9kZVR5cGUgIT09IDExICkge1xuXG5cdFx0cmV0dXJuIHJlc3VsdHM7XG5cdH1cblxuXHQvLyBUcnkgdG8gc2hvcnRjdXQgZmluZCBvcGVyYXRpb25zIChhcyBvcHBvc2VkIHRvIGZpbHRlcnMpIGluIEhUTUwgZG9jdW1lbnRzXG5cdGlmICggIXNlZWQgKSB7XG5cblx0XHRpZiAoICggY29udGV4dCA/IGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0IDogcHJlZmVycmVkRG9jICkgIT09IGRvY3VtZW50ICkge1xuXHRcdFx0c2V0RG9jdW1lbnQoIGNvbnRleHQgKTtcblx0XHR9XG5cdFx0Y29udGV4dCA9IGNvbnRleHQgfHwgZG9jdW1lbnQ7XG5cblx0XHRpZiAoIGRvY3VtZW50SXNIVE1MICkge1xuXG5cdFx0XHQvLyBJZiB0aGUgc2VsZWN0b3IgaXMgc3VmZmljaWVudGx5IHNpbXBsZSwgdHJ5IHVzaW5nIGEgXCJnZXQqQnkqXCIgRE9NIG1ldGhvZFxuXHRcdFx0Ly8gKGV4Y2VwdGluZyBEb2N1bWVudEZyYWdtZW50IGNvbnRleHQsIHdoZXJlIHRoZSBtZXRob2RzIGRvbid0IGV4aXN0KVxuXHRcdFx0aWYgKCBub2RlVHlwZSAhPT0gMTEgJiYgKG1hdGNoID0gcnF1aWNrRXhwci5leGVjKCBzZWxlY3RvciApKSApIHtcblxuXHRcdFx0XHQvLyBJRCBzZWxlY3RvclxuXHRcdFx0XHRpZiAoIChtID0gbWF0Y2hbMV0pICkge1xuXG5cdFx0XHRcdFx0Ly8gRG9jdW1lbnQgY29udGV4dFxuXHRcdFx0XHRcdGlmICggbm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIChlbGVtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZCggbSApKSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSwgT3BlcmEsIFdlYmtpdFxuXHRcdFx0XHRcdFx0XHQvLyBUT0RPOiBpZGVudGlmeSB2ZXJzaW9uc1xuXHRcdFx0XHRcdFx0XHQvLyBnZXRFbGVtZW50QnlJZCBjYW4gbWF0Y2ggZWxlbWVudHMgYnkgbmFtZSBpbnN0ZWFkIG9mIElEXG5cdFx0XHRcdFx0XHRcdGlmICggZWxlbS5pZCA9PT0gbSApIHtcblx0XHRcdFx0XHRcdFx0XHRyZXN1bHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBFbGVtZW50IGNvbnRleHRcblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSwgT3BlcmEsIFdlYmtpdFxuXHRcdFx0XHRcdFx0Ly8gVE9ETzogaWRlbnRpZnkgdmVyc2lvbnNcblx0XHRcdFx0XHRcdC8vIGdldEVsZW1lbnRCeUlkIGNhbiBtYXRjaCBlbGVtZW50cyBieSBuYW1lIGluc3RlYWQgb2YgSURcblx0XHRcdFx0XHRcdGlmICggbmV3Q29udGV4dCAmJiAoZWxlbSA9IG5ld0NvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIG0gKSkgJiZcblx0XHRcdFx0XHRcdFx0Y29udGFpbnMoIGNvbnRleHQsIGVsZW0gKSAmJlxuXHRcdFx0XHRcdFx0XHRlbGVtLmlkID09PSBtICkge1xuXG5cdFx0XHRcdFx0XHRcdHJlc3VsdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gVHlwZSBzZWxlY3RvclxuXHRcdFx0XHR9IGVsc2UgaWYgKCBtYXRjaFsyXSApIHtcblx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCBzZWxlY3RvciApICk7XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cblx0XHRcdFx0Ly8gQ2xhc3Mgc2VsZWN0b3Jcblx0XHRcdFx0fSBlbHNlIGlmICggKG0gPSBtYXRjaFszXSkgJiYgc3VwcG9ydC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICYmXG5cdFx0XHRcdFx0Y29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICkge1xuXG5cdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCBtICkgKTtcblx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBUYWtlIGFkdmFudGFnZSBvZiBxdWVyeVNlbGVjdG9yQWxsXG5cdFx0XHRpZiAoIHN1cHBvcnQucXNhICYmXG5cdFx0XHRcdCFjb21waWxlckNhY2hlWyBzZWxlY3RvciArIFwiIFwiIF0gJiZcblx0XHRcdFx0KCFyYnVnZ3lRU0EgfHwgIXJidWdneVFTQS50ZXN0KCBzZWxlY3RvciApKSApIHtcblxuXHRcdFx0XHRpZiAoIG5vZGVUeXBlICE9PSAxICkge1xuXHRcdFx0XHRcdG5ld0NvbnRleHQgPSBjb250ZXh0O1xuXHRcdFx0XHRcdG5ld1NlbGVjdG9yID0gc2VsZWN0b3I7XG5cblx0XHRcdFx0Ly8gcVNBIGxvb2tzIG91dHNpZGUgRWxlbWVudCBjb250ZXh0LCB3aGljaCBpcyBub3Qgd2hhdCB3ZSB3YW50XG5cdFx0XHRcdC8vIFRoYW5rcyB0byBBbmRyZXcgRHVwb250IGZvciB0aGlzIHdvcmthcm91bmQgdGVjaG5pcXVlXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OFxuXHRcdFx0XHQvLyBFeGNsdWRlIG9iamVjdCBlbGVtZW50c1xuXHRcdFx0XHR9IGVsc2UgaWYgKCBjb250ZXh0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHRcdFx0XHQvLyBDYXB0dXJlIHRoZSBjb250ZXh0IElELCBzZXR0aW5nIGl0IGZpcnN0IGlmIG5lY2Vzc2FyeVxuXHRcdFx0XHRcdGlmICggKG5pZCA9IGNvbnRleHQuZ2V0QXR0cmlidXRlKCBcImlkXCIgKSkgKSB7XG5cdFx0XHRcdFx0XHRuaWQgPSBuaWQucmVwbGFjZSggcmNzc2VzY2FwZSwgZmNzc2VzY2FwZSApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjb250ZXh0LnNldEF0dHJpYnV0ZSggXCJpZFwiLCAobmlkID0gZXhwYW5kbykgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBQcmVmaXggZXZlcnkgc2VsZWN0b3IgaW4gdGhlIGxpc3Rcblx0XHRcdFx0XHRncm91cHMgPSB0b2tlbml6ZSggc2VsZWN0b3IgKTtcblx0XHRcdFx0XHRpID0gZ3JvdXBzLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGdyb3Vwc1tpXSA9IFwiI1wiICsgbmlkICsgXCIgXCIgKyB0b1NlbGVjdG9yKCBncm91cHNbaV0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bmV3U2VsZWN0b3IgPSBncm91cHMuam9pbiggXCIsXCIgKTtcblxuXHRcdFx0XHRcdC8vIEV4cGFuZCBjb250ZXh0IGZvciBzaWJsaW5nIHNlbGVjdG9yc1xuXHRcdFx0XHRcdG5ld0NvbnRleHQgPSByc2libGluZy50ZXN0KCBzZWxlY3RvciApICYmIHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fFxuXHRcdFx0XHRcdFx0Y29udGV4dDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggbmV3U2VsZWN0b3IgKSB7XG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsXG5cdFx0XHRcdFx0XHRcdG5ld0NvbnRleHQucXVlcnlTZWxlY3RvckFsbCggbmV3U2VsZWN0b3IgKVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdH0gY2F0Y2ggKCBxc2FFcnJvciApIHtcblx0XHRcdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRcdFx0aWYgKCBuaWQgPT09IGV4cGFuZG8gKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnRleHQucmVtb3ZlQXR0cmlidXRlKCBcImlkXCIgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBBbGwgb3RoZXJzXG5cdHJldHVybiBzZWxlY3QoIHNlbGVjdG9yLnJlcGxhY2UoIHJ0cmltLCBcIiQxXCIgKSwgY29udGV4dCwgcmVzdWx0cywgc2VlZCApO1xufVxuXG4vKipcbiAqIENyZWF0ZSBrZXktdmFsdWUgY2FjaGVzIG9mIGxpbWl0ZWQgc2l6ZVxuICogQHJldHVybnMge2Z1bmN0aW9uKHN0cmluZywgb2JqZWN0KX0gUmV0dXJucyB0aGUgT2JqZWN0IGRhdGEgYWZ0ZXIgc3RvcmluZyBpdCBvbiBpdHNlbGYgd2l0aFxuICpcdHByb3BlcnR5IG5hbWUgdGhlIChzcGFjZS1zdWZmaXhlZCkgc3RyaW5nIGFuZCAoaWYgdGhlIGNhY2hlIGlzIGxhcmdlciB0aGFuIEV4cHIuY2FjaGVMZW5ndGgpXG4gKlx0ZGVsZXRpbmcgdGhlIG9sZGVzdCBlbnRyeVxuICovXG5mdW5jdGlvbiBjcmVhdGVDYWNoZSgpIHtcblx0dmFyIGtleXMgPSBbXTtcblxuXHRmdW5jdGlvbiBjYWNoZSgga2V5LCB2YWx1ZSApIHtcblx0XHQvLyBVc2UgKGtleSArIFwiIFwiKSB0byBhdm9pZCBjb2xsaXNpb24gd2l0aCBuYXRpdmUgcHJvdG90eXBlIHByb3BlcnRpZXMgKHNlZSBJc3N1ZSAjMTU3KVxuXHRcdGlmICgga2V5cy5wdXNoKCBrZXkgKyBcIiBcIiApID4gRXhwci5jYWNoZUxlbmd0aCApIHtcblx0XHRcdC8vIE9ubHkga2VlcCB0aGUgbW9zdCByZWNlbnQgZW50cmllc1xuXHRcdFx0ZGVsZXRlIGNhY2hlWyBrZXlzLnNoaWZ0KCkgXTtcblx0XHR9XG5cdFx0cmV0dXJuIChjYWNoZVsga2V5ICsgXCIgXCIgXSA9IHZhbHVlKTtcblx0fVxuXHRyZXR1cm4gY2FjaGU7XG59XG5cbi8qKlxuICogTWFyayBhIGZ1bmN0aW9uIGZvciBzcGVjaWFsIHVzZSBieSBTaXp6bGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBtYXJrXG4gKi9cbmZ1bmN0aW9uIG1hcmtGdW5jdGlvbiggZm4gKSB7XG5cdGZuWyBleHBhbmRvIF0gPSB0cnVlO1xuXHRyZXR1cm4gZm47XG59XG5cbi8qKlxuICogU3VwcG9ydCB0ZXN0aW5nIHVzaW5nIGFuIGVsZW1lbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFBhc3NlZCB0aGUgY3JlYXRlZCBlbGVtZW50IGFuZCByZXR1cm5zIGEgYm9vbGVhbiByZXN1bHRcbiAqL1xuZnVuY3Rpb24gYXNzZXJ0KCBmbiApIHtcblx0dmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImZpZWxkc2V0XCIpO1xuXG5cdHRyeSB7XG5cdFx0cmV0dXJuICEhZm4oIGVsICk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0gZmluYWxseSB7XG5cdFx0Ly8gUmVtb3ZlIGZyb20gaXRzIHBhcmVudCBieSBkZWZhdWx0XG5cdFx0aWYgKCBlbC5wYXJlbnROb2RlICkge1xuXHRcdFx0ZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggZWwgKTtcblx0XHR9XG5cdFx0Ly8gcmVsZWFzZSBtZW1vcnkgaW4gSUVcblx0XHRlbCA9IG51bGw7XG5cdH1cbn1cblxuLyoqXG4gKiBBZGRzIHRoZSBzYW1lIGhhbmRsZXIgZm9yIGFsbCBvZiB0aGUgc3BlY2lmaWVkIGF0dHJzXG4gKiBAcGFyYW0ge1N0cmluZ30gYXR0cnMgUGlwZS1zZXBhcmF0ZWQgbGlzdCBvZiBhdHRyaWJ1dGVzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIFRoZSBtZXRob2QgdGhhdCB3aWxsIGJlIGFwcGxpZWRcbiAqL1xuZnVuY3Rpb24gYWRkSGFuZGxlKCBhdHRycywgaGFuZGxlciApIHtcblx0dmFyIGFyciA9IGF0dHJzLnNwbGl0KFwifFwiKSxcblx0XHRpID0gYXJyLmxlbmd0aDtcblxuXHR3aGlsZSAoIGktLSApIHtcblx0XHRFeHByLmF0dHJIYW5kbGVbIGFycltpXSBdID0gaGFuZGxlcjtcblx0fVxufVxuXG4vKipcbiAqIENoZWNrcyBkb2N1bWVudCBvcmRlciBvZiB0d28gc2libGluZ3NcbiAqIEBwYXJhbSB7RWxlbWVudH0gYVxuICogQHBhcmFtIHtFbGVtZW50fSBiXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBSZXR1cm5zIGxlc3MgdGhhbiAwIGlmIGEgcHJlY2VkZXMgYiwgZ3JlYXRlciB0aGFuIDAgaWYgYSBmb2xsb3dzIGJcbiAqL1xuZnVuY3Rpb24gc2libGluZ0NoZWNrKCBhLCBiICkge1xuXHR2YXIgY3VyID0gYiAmJiBhLFxuXHRcdGRpZmYgPSBjdXIgJiYgYS5ub2RlVHlwZSA9PT0gMSAmJiBiLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRhLnNvdXJjZUluZGV4IC0gYi5zb3VyY2VJbmRleDtcblxuXHQvLyBVc2UgSUUgc291cmNlSW5kZXggaWYgYXZhaWxhYmxlIG9uIGJvdGggbm9kZXNcblx0aWYgKCBkaWZmICkge1xuXHRcdHJldHVybiBkaWZmO1xuXHR9XG5cblx0Ly8gQ2hlY2sgaWYgYiBmb2xsb3dzIGFcblx0aWYgKCBjdXIgKSB7XG5cdFx0d2hpbGUgKCAoY3VyID0gY3VyLm5leHRTaWJsaW5nKSApIHtcblx0XHRcdGlmICggY3VyID09PSBiICkge1xuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGEgPyAxIDogLTE7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBpbnB1dCB0eXBlc1xuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW5wdXRQc2V1ZG8oIHR5cGUgKSB7XG5cdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHR2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRyZXR1cm4gbmFtZSA9PT0gXCJpbnB1dFwiICYmIGVsZW0udHlwZSA9PT0gdHlwZTtcblx0fTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIGJ1dHRvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJ1dHRvblBzZXVkbyggdHlwZSApIHtcblx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdHJldHVybiAobmFtZSA9PT0gXCJpbnB1dFwiIHx8IG5hbWUgPT09IFwiYnV0dG9uXCIpICYmIGVsZW0udHlwZSA9PT0gdHlwZTtcblx0fTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIDplbmFibGVkLzpkaXNhYmxlZFxuICogQHBhcmFtIHtCb29sZWFufSBkaXNhYmxlZCB0cnVlIGZvciA6ZGlzYWJsZWQ7IGZhbHNlIGZvciA6ZW5hYmxlZFxuICovXG5mdW5jdGlvbiBjcmVhdGVEaXNhYmxlZFBzZXVkbyggZGlzYWJsZWQgKSB7XG5cblx0Ly8gS25vd24gOmRpc2FibGVkIGZhbHNlIHBvc2l0aXZlczogZmllbGRzZXRbZGlzYWJsZWRdID4gbGVnZW5kOm50aC1vZi10eXBlKG4rMikgOmNhbi1kaXNhYmxlXG5cdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdC8vIE9ubHkgY2VydGFpbiBlbGVtZW50cyBjYW4gbWF0Y2ggOmVuYWJsZWQgb3IgOmRpc2FibGVkXG5cdFx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc2NyaXB0aW5nLmh0bWwjc2VsZWN0b3ItZW5hYmxlZFxuXHRcdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3NjcmlwdGluZy5odG1sI3NlbGVjdG9yLWRpc2FibGVkXG5cdFx0aWYgKCBcImZvcm1cIiBpbiBlbGVtICkge1xuXG5cdFx0XHQvLyBDaGVjayBmb3IgaW5oZXJpdGVkIGRpc2FibGVkbmVzcyBvbiByZWxldmFudCBub24tZGlzYWJsZWQgZWxlbWVudHM6XG5cdFx0XHQvLyAqIGxpc3RlZCBmb3JtLWFzc29jaWF0ZWQgZWxlbWVudHMgaW4gYSBkaXNhYmxlZCBmaWVsZHNldFxuXHRcdFx0Ly8gICBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9mb3Jtcy5odG1sI2NhdGVnb3J5LWxpc3RlZFxuXHRcdFx0Ly8gICBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9mb3Jtcy5odG1sI2NvbmNlcHQtZmUtZGlzYWJsZWRcblx0XHRcdC8vICogb3B0aW9uIGVsZW1lbnRzIGluIGEgZGlzYWJsZWQgb3B0Z3JvdXBcblx0XHRcdC8vICAgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZm9ybXMuaHRtbCNjb25jZXB0LW9wdGlvbi1kaXNhYmxlZFxuXHRcdFx0Ly8gQWxsIHN1Y2ggZWxlbWVudHMgaGF2ZSBhIFwiZm9ybVwiIHByb3BlcnR5LlxuXHRcdFx0aWYgKCBlbGVtLnBhcmVudE5vZGUgJiYgZWxlbS5kaXNhYmxlZCA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0Ly8gT3B0aW9uIGVsZW1lbnRzIGRlZmVyIHRvIGEgcGFyZW50IG9wdGdyb3VwIGlmIHByZXNlbnRcblx0XHRcdFx0aWYgKCBcImxhYmVsXCIgaW4gZWxlbSApIHtcblx0XHRcdFx0XHRpZiAoIFwibGFiZWxcIiBpbiBlbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbS5wYXJlbnROb2RlLmRpc2FibGVkID09PSBkaXNhYmxlZDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IGRpc2FibGVkO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDYgLSAxMVxuXHRcdFx0XHQvLyBVc2UgdGhlIGlzRGlzYWJsZWQgc2hvcnRjdXQgcHJvcGVydHkgdG8gY2hlY2sgZm9yIGRpc2FibGVkIGZpZWxkc2V0IGFuY2VzdG9yc1xuXHRcdFx0XHRyZXR1cm4gZWxlbS5pc0Rpc2FibGVkID09PSBkaXNhYmxlZCB8fFxuXG5cdFx0XHRcdFx0Ly8gV2hlcmUgdGhlcmUgaXMgbm8gaXNEaXNhYmxlZCwgY2hlY2sgbWFudWFsbHlcblx0XHRcdFx0XHQvKiBqc2hpbnQgLVcwMTggKi9cblx0XHRcdFx0XHRlbGVtLmlzRGlzYWJsZWQgIT09ICFkaXNhYmxlZCAmJlxuXHRcdFx0XHRcdFx0ZGlzYWJsZWRBbmNlc3RvciggZWxlbSApID09PSBkaXNhYmxlZDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IGRpc2FibGVkO1xuXG5cdFx0Ly8gVHJ5IHRvIHdpbm5vdyBvdXQgZWxlbWVudHMgdGhhdCBjYW4ndCBiZSBkaXNhYmxlZCBiZWZvcmUgdHJ1c3RpbmcgdGhlIGRpc2FibGVkIHByb3BlcnR5LlxuXHRcdC8vIFNvbWUgdmljdGltcyBnZXQgY2F1Z2h0IGluIG91ciBuZXQgKGxhYmVsLCBsZWdlbmQsIG1lbnUsIHRyYWNrKSwgYnV0IGl0IHNob3VsZG4ndFxuXHRcdC8vIGV2ZW4gZXhpc3Qgb24gdGhlbSwgbGV0IGFsb25lIGhhdmUgYSBib29sZWFuIHZhbHVlLlxuXHRcdH0gZWxzZSBpZiAoIFwibGFiZWxcIiBpbiBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IGRpc2FibGVkO1xuXHRcdH1cblxuXHRcdC8vIFJlbWFpbmluZyBlbGVtZW50cyBhcmUgbmVpdGhlciA6ZW5hYmxlZCBub3IgOmRpc2FibGVkXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgcG9zaXRpb25hbHNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oIGZuICkge1xuXHRyZXR1cm4gbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBhcmd1bWVudCApIHtcblx0XHRhcmd1bWVudCA9ICthcmd1bWVudDtcblx0XHRyZXR1cm4gbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWVkLCBtYXRjaGVzICkge1xuXHRcdFx0dmFyIGosXG5cdFx0XHRcdG1hdGNoSW5kZXhlcyA9IGZuKCBbXSwgc2VlZC5sZW5ndGgsIGFyZ3VtZW50ICksXG5cdFx0XHRcdGkgPSBtYXRjaEluZGV4ZXMubGVuZ3RoO1xuXG5cdFx0XHQvLyBNYXRjaCBlbGVtZW50cyBmb3VuZCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4ZXNcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoIHNlZWRbIChqID0gbWF0Y2hJbmRleGVzW2ldKSBdICkge1xuXHRcdFx0XHRcdHNlZWRbal0gPSAhKG1hdGNoZXNbal0gPSBzZWVkW2pdKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXHR9KTtcbn1cblxuLyoqXG4gKiBDaGVja3MgYSBub2RlIGZvciB2YWxpZGl0eSBhcyBhIFNpenpsZSBjb250ZXh0XG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0PX0gY29udGV4dFxuICogQHJldHVybnMge0VsZW1lbnR8T2JqZWN0fEJvb2xlYW59IFRoZSBpbnB1dCBub2RlIGlmIGFjY2VwdGFibGUsIG90aGVyd2lzZSBhIGZhbHN5IHZhbHVlXG4gKi9cbmZ1bmN0aW9uIHRlc3RDb250ZXh0KCBjb250ZXh0ICkge1xuXHRyZXR1cm4gY29udGV4dCAmJiB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBjb250ZXh0O1xufVxuXG4vLyBFeHBvc2Ugc3VwcG9ydCB2YXJzIGZvciBjb252ZW5pZW5jZVxuc3VwcG9ydCA9IFNpenpsZS5zdXBwb3J0ID0ge307XG5cbi8qKlxuICogRGV0ZWN0cyBYTUwgbm9kZXNcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3R9IGVsZW0gQW4gZWxlbWVudCBvciBhIGRvY3VtZW50XG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZmYgZWxlbSBpcyBhIG5vbi1IVE1MIFhNTCBub2RlXG4gKi9cbmlzWE1MID0gU2l6emxlLmlzWE1MID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdC8vIGRvY3VtZW50RWxlbWVudCBpcyB2ZXJpZmllZCBmb3IgY2FzZXMgd2hlcmUgaXQgZG9lc24ndCB5ZXQgZXhpc3Rcblx0Ly8gKHN1Y2ggYXMgbG9hZGluZyBpZnJhbWVzIGluIElFIC0gIzQ4MzMpXG5cdHZhciBkb2N1bWVudEVsZW1lbnQgPSBlbGVtICYmIChlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSkuZG9jdW1lbnRFbGVtZW50O1xuXHRyZXR1cm4gZG9jdW1lbnRFbGVtZW50ID8gZG9jdW1lbnRFbGVtZW50Lm5vZGVOYW1lICE9PSBcIkhUTUxcIiA6IGZhbHNlO1xufTtcblxuLyoqXG4gKiBTZXRzIGRvY3VtZW50LXJlbGF0ZWQgdmFyaWFibGVzIG9uY2UgYmFzZWQgb24gdGhlIGN1cnJlbnQgZG9jdW1lbnRcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3R9IFtkb2NdIEFuIGVsZW1lbnQgb3IgZG9jdW1lbnQgb2JqZWN0IHRvIHVzZSB0byBzZXQgdGhlIGRvY3VtZW50XG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjdXJyZW50IGRvY3VtZW50XG4gKi9cbnNldERvY3VtZW50ID0gU2l6emxlLnNldERvY3VtZW50ID0gZnVuY3Rpb24oIG5vZGUgKSB7XG5cdHZhciBoYXNDb21wYXJlLCBzdWJXaW5kb3csXG5cdFx0ZG9jID0gbm9kZSA/IG5vZGUub3duZXJEb2N1bWVudCB8fCBub2RlIDogcHJlZmVycmVkRG9jO1xuXG5cdC8vIFJldHVybiBlYXJseSBpZiBkb2MgaXMgaW52YWxpZCBvciBhbHJlYWR5IHNlbGVjdGVkXG5cdGlmICggZG9jID09PSBkb2N1bWVudCB8fCBkb2Mubm9kZVR5cGUgIT09IDkgfHwgIWRvYy5kb2N1bWVudEVsZW1lbnQgKSB7XG5cdFx0cmV0dXJuIGRvY3VtZW50O1xuXHR9XG5cblx0Ly8gVXBkYXRlIGdsb2JhbCB2YXJpYWJsZXNcblx0ZG9jdW1lbnQgPSBkb2M7XG5cdGRvY0VsZW0gPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cdGRvY3VtZW50SXNIVE1MID0gIWlzWE1MKCBkb2N1bWVudCApO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDktMTEsIEVkZ2Vcblx0Ly8gQWNjZXNzaW5nIGlmcmFtZSBkb2N1bWVudHMgYWZ0ZXIgdW5sb2FkIHRocm93cyBcInBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3JzIChqUXVlcnkgIzEzOTM2KVxuXHRpZiAoIHByZWZlcnJlZERvYyAhPT0gZG9jdW1lbnQgJiZcblx0XHQoc3ViV2luZG93ID0gZG9jdW1lbnQuZGVmYXVsdFZpZXcpICYmIHN1YldpbmRvdy50b3AgIT09IHN1YldpbmRvdyApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDExLCBFZGdlXG5cdFx0aWYgKCBzdWJXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lciApIHtcblx0XHRcdHN1YldpbmRvdy5hZGRFdmVudExpc3RlbmVyKCBcInVubG9hZFwiLCB1bmxvYWRIYW5kbGVyLCBmYWxzZSApO1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgOSAtIDEwIG9ubHlcblx0XHR9IGVsc2UgaWYgKCBzdWJXaW5kb3cuYXR0YWNoRXZlbnQgKSB7XG5cdFx0XHRzdWJXaW5kb3cuYXR0YWNoRXZlbnQoIFwib251bmxvYWRcIiwgdW5sb2FkSGFuZGxlciApO1xuXHRcdH1cblx0fVxuXG5cdC8qIEF0dHJpYnV0ZXNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIFN1cHBvcnQ6IElFPDhcblx0Ly8gVmVyaWZ5IHRoYXQgZ2V0QXR0cmlidXRlIHJlYWxseSByZXR1cm5zIGF0dHJpYnV0ZXMgYW5kIG5vdCBwcm9wZXJ0aWVzXG5cdC8vIChleGNlcHRpbmcgSUU4IGJvb2xlYW5zKVxuXHRzdXBwb3J0LmF0dHJpYnV0ZXMgPSBhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRcdGVsLmNsYXNzTmFtZSA9IFwiaVwiO1xuXHRcdHJldHVybiAhZWwuZ2V0QXR0cmlidXRlKFwiY2xhc3NOYW1lXCIpO1xuXHR9KTtcblxuXHQvKiBnZXRFbGVtZW50KHMpQnkqXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBDaGVjayBpZiBnZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIikgcmV0dXJucyBvbmx5IGVsZW1lbnRzXG5cdHN1cHBvcnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgPSBhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRcdGVsLmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVDb21tZW50KFwiXCIpICk7XG5cdFx0cmV0dXJuICFlbC5nZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIikubGVuZ3RoO1xuXHR9KTtcblxuXHQvLyBTdXBwb3J0OiBJRTw5XG5cdHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSA9IHJuYXRpdmUudGVzdCggZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSApO1xuXG5cdC8vIFN1cHBvcnQ6IElFPDEwXG5cdC8vIENoZWNrIGlmIGdldEVsZW1lbnRCeUlkIHJldHVybnMgZWxlbWVudHMgYnkgbmFtZVxuXHQvLyBUaGUgYnJva2VuIGdldEVsZW1lbnRCeUlkIG1ldGhvZHMgZG9uJ3QgcGljayB1cCBwcm9ncmFtbWF0aWNhbGx5LXNldCBuYW1lcyxcblx0Ly8gc28gdXNlIGEgcm91bmRhYm91dCBnZXRFbGVtZW50c0J5TmFtZSB0ZXN0XG5cdHN1cHBvcnQuZ2V0QnlJZCA9IGFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdFx0ZG9jRWxlbS5hcHBlbmRDaGlsZCggZWwgKS5pZCA9IGV4cGFuZG87XG5cdFx0cmV0dXJuICFkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZSB8fCAhZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUoIGV4cGFuZG8gKS5sZW5ndGg7XG5cdH0pO1xuXG5cdC8vIElEIGZpbHRlciBhbmQgZmluZFxuXHRpZiAoIHN1cHBvcnQuZ2V0QnlJZCApIHtcblx0XHRFeHByLmZpbHRlcltcIklEXCJdID0gZnVuY3Rpb24oIGlkICkge1xuXHRcdFx0dmFyIGF0dHJJZCA9IGlkLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZShcImlkXCIpID09PSBhdHRySWQ7XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0RXhwci5maW5kW1wiSURcIl0gPSBmdW5jdGlvbiggaWQsIGNvbnRleHQgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRCeUlkICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50SXNIVE1MICkge1xuXHRcdFx0XHR2YXIgZWxlbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIGlkICk7XG5cdFx0XHRcdHJldHVybiBlbGVtID8gWyBlbGVtIF0gOiBbXTtcblx0XHRcdH1cblx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdEV4cHIuZmlsdGVyW1wiSURcIl0gPSAgZnVuY3Rpb24oIGlkICkge1xuXHRcdFx0dmFyIGF0dHJJZCA9IGlkLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciBub2RlID0gdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlTm9kZSAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuXHRcdFx0XHRcdGVsZW0uZ2V0QXR0cmlidXRlTm9kZShcImlkXCIpO1xuXHRcdFx0XHRyZXR1cm4gbm9kZSAmJiBub2RlLnZhbHVlID09PSBhdHRySWQ7XG5cdFx0XHR9O1xuXHRcdH07XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA2IC0gNyBvbmx5XG5cdFx0Ly8gZ2V0RWxlbWVudEJ5SWQgaXMgbm90IHJlbGlhYmxlIGFzIGEgZmluZCBzaG9ydGN1dFxuXHRcdEV4cHIuZmluZFtcIklEXCJdID0gZnVuY3Rpb24oIGlkLCBjb250ZXh0ICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50QnlJZCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudElzSFRNTCApIHtcblx0XHRcdFx0dmFyIG5vZGUsIGksIGVsZW1zLFxuXHRcdFx0XHRcdGVsZW0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKCBpZCApO1xuXG5cdFx0XHRcdGlmICggZWxlbSApIHtcblxuXHRcdFx0XHRcdC8vIFZlcmlmeSB0aGUgaWQgYXR0cmlidXRlXG5cdFx0XHRcdFx0bm9kZSA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZShcImlkXCIpO1xuXHRcdFx0XHRcdGlmICggbm9kZSAmJiBub2RlLnZhbHVlID09PSBpZCApIHtcblx0XHRcdFx0XHRcdHJldHVybiBbIGVsZW0gXTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBGYWxsIGJhY2sgb24gZ2V0RWxlbWVudHNCeU5hbWVcblx0XHRcdFx0XHRlbGVtcyA9IGNvbnRleHQuZ2V0RWxlbWVudHNCeU5hbWUoIGlkICk7XG5cdFx0XHRcdFx0aSA9IDA7XG5cdFx0XHRcdFx0d2hpbGUgKCAoZWxlbSA9IGVsZW1zW2krK10pICkge1xuXHRcdFx0XHRcdFx0bm9kZSA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZShcImlkXCIpO1xuXHRcdFx0XHRcdFx0aWYgKCBub2RlICYmIG5vZGUudmFsdWUgPT09IGlkICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gWyBlbGVtIF07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIFtdO1xuXHRcdFx0fVxuXHRcdH07XG5cdH1cblxuXHQvLyBUYWdcblx0RXhwci5maW5kW1wiVEFHXCJdID0gc3VwcG9ydC5nZXRFbGVtZW50c0J5VGFnTmFtZSA/XG5cdFx0ZnVuY3Rpb24oIHRhZywgY29udGV4dCApIHtcblx0XHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0XHRcdHJldHVybiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgKTtcblxuXHRcdFx0Ly8gRG9jdW1lbnRGcmFnbWVudCBub2RlcyBkb24ndCBoYXZlIGdFQlROXG5cdFx0XHR9IGVsc2UgaWYgKCBzdXBwb3J0LnFzYSApIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCggdGFnICk7XG5cdFx0XHR9XG5cdFx0fSA6XG5cblx0XHRmdW5jdGlvbiggdGFnLCBjb250ZXh0ICkge1xuXHRcdFx0dmFyIGVsZW0sXG5cdFx0XHRcdHRtcCA9IFtdLFxuXHRcdFx0XHRpID0gMCxcblx0XHRcdFx0Ly8gQnkgaGFwcHkgY29pbmNpZGVuY2UsIGEgKGJyb2tlbikgZ0VCVE4gYXBwZWFycyBvbiBEb2N1bWVudEZyYWdtZW50IG5vZGVzIHRvb1xuXHRcdFx0XHRyZXN1bHRzID0gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggdGFnICk7XG5cblx0XHRcdC8vIEZpbHRlciBvdXQgcG9zc2libGUgY29tbWVudHNcblx0XHRcdGlmICggdGFnID09PSBcIipcIiApIHtcblx0XHRcdFx0d2hpbGUgKCAoZWxlbSA9IHJlc3VsdHNbaSsrXSkgKSB7XG5cdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRcdFx0dG1wLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdG1wO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0fTtcblxuXHQvLyBDbGFzc1xuXHRFeHByLmZpbmRbXCJDTEFTU1wiXSA9IHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAmJiBmdW5jdGlvbiggY2xhc3NOYW1lLCBjb250ZXh0ICkge1xuXHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudElzSFRNTCApIHtcblx0XHRcdHJldHVybiBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoIGNsYXNzTmFtZSApO1xuXHRcdH1cblx0fTtcblxuXHQvKiBRU0EvbWF0Y2hlc1NlbGVjdG9yXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBRU0EgYW5kIG1hdGNoZXNTZWxlY3RvciBzdXBwb3J0XG5cblx0Ly8gbWF0Y2hlc1NlbGVjdG9yKDphY3RpdmUpIHJlcG9ydHMgZmFsc2Ugd2hlbiB0cnVlIChJRTkvT3BlcmEgMTEuNSlcblx0cmJ1Z2d5TWF0Y2hlcyA9IFtdO1xuXG5cdC8vIHFTYSg6Zm9jdXMpIHJlcG9ydHMgZmFsc2Ugd2hlbiB0cnVlIChDaHJvbWUgMjEpXG5cdC8vIFdlIGFsbG93IHRoaXMgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBJRTgvOSB0aGF0IHRocm93cyBhbiBlcnJvclxuXHQvLyB3aGVuZXZlciBgZG9jdW1lbnQuYWN0aXZlRWxlbWVudGAgaXMgYWNjZXNzZWQgb24gYW4gaWZyYW1lXG5cdC8vIFNvLCB3ZSBhbGxvdyA6Zm9jdXMgdG8gcGFzcyB0aHJvdWdoIFFTQSBhbGwgdGhlIHRpbWUgdG8gYXZvaWQgdGhlIElFIGVycm9yXG5cdC8vIFNlZSBodHRwczovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTMzNzhcblx0cmJ1Z2d5UVNBID0gW107XG5cblx0aWYgKCAoc3VwcG9ydC5xc2EgPSBybmF0aXZlLnRlc3QoIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwgKSkgKSB7XG5cdFx0Ly8gQnVpbGQgUVNBIHJlZ2V4XG5cdFx0Ly8gUmVnZXggc3RyYXRlZ3kgYWRvcHRlZCBmcm9tIERpZWdvIFBlcmluaVxuXHRcdGFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdFx0XHQvLyBTZWxlY3QgaXMgc2V0IHRvIGVtcHR5IHN0cmluZyBvbiBwdXJwb3NlXG5cdFx0XHQvLyBUaGlzIGlzIHRvIHRlc3QgSUUncyB0cmVhdG1lbnQgb2Ygbm90IGV4cGxpY2l0bHlcblx0XHRcdC8vIHNldHRpbmcgYSBib29sZWFuIGNvbnRlbnQgYXR0cmlidXRlLFxuXHRcdFx0Ly8gc2luY2UgaXRzIHByZXNlbmNlIHNob3VsZCBiZSBlbm91Z2hcblx0XHRcdC8vIGh0dHBzOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMjM1OVxuXHRcdFx0ZG9jRWxlbS5hcHBlbmRDaGlsZCggZWwgKS5pbm5lckhUTUwgPSBcIjxhIGlkPSdcIiArIGV4cGFuZG8gKyBcIic+PC9hPlwiICtcblx0XHRcdFx0XCI8c2VsZWN0IGlkPSdcIiArIGV4cGFuZG8gKyBcIi1cXHJcXFxcJyBtc2FsbG93Y2FwdHVyZT0nJz5cIiArXG5cdFx0XHRcdFwiPG9wdGlvbiBzZWxlY3RlZD0nJz48L29wdGlvbj48L3NlbGVjdD5cIjtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU4LCBPcGVyYSAxMS0xMi4xNlxuXHRcdFx0Ly8gTm90aGluZyBzaG91bGQgYmUgc2VsZWN0ZWQgd2hlbiBlbXB0eSBzdHJpbmdzIGZvbGxvdyBePSBvciAkPSBvciAqPVxuXHRcdFx0Ly8gVGhlIHRlc3QgYXR0cmlidXRlIG11c3QgYmUgdW5rbm93biBpbiBPcGVyYSBidXQgXCJzYWZlXCIgZm9yIFdpblJUXG5cdFx0XHQvLyBodHRwczovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2hoNDY1Mzg4LmFzcHgjYXR0cmlidXRlX3NlY3Rpb25cblx0XHRcdGlmICggZWwucXVlcnlTZWxlY3RvckFsbChcIlttc2FsbG93Y2FwdHVyZV49JyddXCIpLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiWypeJF09XCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86Jyd8XFxcIlxcXCIpXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU4XG5cdFx0XHQvLyBCb29sZWFuIGF0dHJpYnV0ZXMgYW5kIFwidmFsdWVcIiBhcmUgbm90IHRyZWF0ZWQgY29ycmVjdGx5XG5cdFx0XHRpZiAoICFlbC5xdWVyeVNlbGVjdG9yQWxsKFwiW3NlbGVjdGVkXVwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIlxcXFxbXCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86dmFsdWV8XCIgKyBib29sZWFucyArIFwiKVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZTwyOSwgQW5kcm9pZDw0LjQsIFNhZmFyaTw3LjArLCBpT1M8Ny4wKywgUGhhbnRvbUpTPDEuOS44K1xuXHRcdFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbCggXCJbaWR+PVwiICsgZXhwYW5kbyArIFwiLV1cIiApLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goXCJ+PVwiKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gV2Via2l0L09wZXJhIC0gOmNoZWNrZWQgc2hvdWxkIHJldHVybiBzZWxlY3RlZCBvcHRpb24gZWxlbWVudHNcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTEvUkVDLWNzczMtc2VsZWN0b3JzLTIwMTEwOTI5LyNjaGVja2VkXG5cdFx0XHQvLyBJRTggdGhyb3dzIGVycm9yIGhlcmUgYW5kIHdpbGwgbm90IHNlZSBsYXRlciB0ZXN0c1xuXHRcdFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbChcIjpjaGVja2VkXCIpLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goXCI6Y2hlY2tlZFwiKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogU2FmYXJpIDgrLCBpT1MgOCtcblx0XHRcdC8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzY4NTFcblx0XHRcdC8vIEluLXBhZ2UgYHNlbGVjdG9yI2lkIHNpYmxpbmctY29tYmluYXRvciBzZWxlY3RvcmAgZmFpbHNcblx0XHRcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiYSNcIiArIGV4cGFuZG8gKyBcIisqXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKFwiLiMuK1srfl1cIik7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRcdFx0ZWwuaW5uZXJIVE1MID0gXCI8YSBocmVmPScnIGRpc2FibGVkPSdkaXNhYmxlZCc+PC9hPlwiICtcblx0XHRcdFx0XCI8c2VsZWN0IGRpc2FibGVkPSdkaXNhYmxlZCc+PG9wdGlvbi8+PC9zZWxlY3Q+XCI7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IFdpbmRvd3MgOCBOYXRpdmUgQXBwc1xuXHRcdFx0Ly8gVGhlIHR5cGUgYW5kIG5hbWUgYXR0cmlidXRlcyBhcmUgcmVzdHJpY3RlZCBkdXJpbmcgLmlubmVySFRNTCBhc3NpZ25tZW50XG5cdFx0XHR2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG5cdFx0XHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCBcImhpZGRlblwiICk7XG5cdFx0XHRlbC5hcHBlbmRDaGlsZCggaW5wdXQgKS5zZXRBdHRyaWJ1dGUoIFwibmFtZVwiLCBcIkRcIiApO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRThcblx0XHRcdC8vIEVuZm9yY2UgY2FzZS1zZW5zaXRpdml0eSBvZiBuYW1lIGF0dHJpYnV0ZVxuXHRcdFx0aWYgKCBlbC5xdWVyeVNlbGVjdG9yQWxsKFwiW25hbWU9ZF1cIikubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJuYW1lXCIgKyB3aGl0ZXNwYWNlICsgXCIqWypeJHwhfl0/PVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZGIDMuNSAtIDplbmFibGVkLzpkaXNhYmxlZCBhbmQgaGlkZGVuIGVsZW1lbnRzIChoaWRkZW4gZWxlbWVudHMgYXJlIHN0aWxsIGVuYWJsZWQpXG5cdFx0XHQvLyBJRTggdGhyb3dzIGVycm9yIGhlcmUgYW5kIHdpbGwgbm90IHNlZSBsYXRlciB0ZXN0c1xuXHRcdFx0aWYgKCBlbC5xdWVyeVNlbGVjdG9yQWxsKFwiOmVuYWJsZWRcIikubGVuZ3RoICE9PSAyICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCI6ZW5hYmxlZFwiLCBcIjpkaXNhYmxlZFwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOS0xMStcblx0XHRcdC8vIElFJ3MgOmRpc2FibGVkIHNlbGVjdG9yIGRvZXMgbm90IHBpY2sgdXAgdGhlIGNoaWxkcmVuIG9mIGRpc2FibGVkIGZpZWxkc2V0c1xuXHRcdFx0ZG9jRWxlbS5hcHBlbmRDaGlsZCggZWwgKS5kaXNhYmxlZCA9IHRydWU7XG5cdFx0XHRpZiAoIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCI6ZGlzYWJsZWRcIikubGVuZ3RoICE9PSAyICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCI6ZW5hYmxlZFwiLCBcIjpkaXNhYmxlZFwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE9wZXJhIDEwLTExIGRvZXMgbm90IHRocm93IG9uIHBvc3QtY29tbWEgaW52YWxpZCBwc2V1ZG9zXG5cdFx0XHRlbC5xdWVyeVNlbGVjdG9yQWxsKFwiKiw6eFwiKTtcblx0XHRcdHJidWdneVFTQS5wdXNoKFwiLC4qOlwiKTtcblx0XHR9KTtcblx0fVxuXG5cdGlmICggKHN1cHBvcnQubWF0Y2hlc1NlbGVjdG9yID0gcm5hdGl2ZS50ZXN0KCAobWF0Y2hlcyA9IGRvY0VsZW0ubWF0Y2hlcyB8fFxuXHRcdGRvY0VsZW0ud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8XG5cdFx0ZG9jRWxlbS5tb3pNYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRkb2NFbGVtLm9NYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRkb2NFbGVtLm1zTWF0Y2hlc1NlbGVjdG9yKSApKSApIHtcblxuXHRcdGFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdFx0XHQvLyBDaGVjayB0byBzZWUgaWYgaXQncyBwb3NzaWJsZSB0byBkbyBtYXRjaGVzU2VsZWN0b3Jcblx0XHRcdC8vIG9uIGEgZGlzY29ubmVjdGVkIG5vZGUgKElFIDkpXG5cdFx0XHRzdXBwb3J0LmRpc2Nvbm5lY3RlZE1hdGNoID0gbWF0Y2hlcy5jYWxsKCBlbCwgXCIqXCIgKTtcblxuXHRcdFx0Ly8gVGhpcyBzaG91bGQgZmFpbCB3aXRoIGFuIGV4Y2VwdGlvblxuXHRcdFx0Ly8gR2Vja28gZG9lcyBub3QgZXJyb3IsIHJldHVybnMgZmFsc2UgaW5zdGVhZFxuXHRcdFx0bWF0Y2hlcy5jYWxsKCBlbCwgXCJbcyE9JyddOnhcIiApO1xuXHRcdFx0cmJ1Z2d5TWF0Y2hlcy5wdXNoKCBcIiE9XCIsIHBzZXVkb3MgKTtcblx0XHR9KTtcblx0fVxuXG5cdHJidWdneVFTQSA9IHJidWdneVFTQS5sZW5ndGggJiYgbmV3IFJlZ0V4cCggcmJ1Z2d5UVNBLmpvaW4oXCJ8XCIpICk7XG5cdHJidWdneU1hdGNoZXMgPSByYnVnZ3lNYXRjaGVzLmxlbmd0aCAmJiBuZXcgUmVnRXhwKCByYnVnZ3lNYXRjaGVzLmpvaW4oXCJ8XCIpICk7XG5cblx0LyogQ29udGFpbnNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXHRoYXNDb21wYXJlID0gcm5hdGl2ZS50ZXN0KCBkb2NFbGVtLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uICk7XG5cblx0Ly8gRWxlbWVudCBjb250YWlucyBhbm90aGVyXG5cdC8vIFB1cnBvc2VmdWxseSBzZWxmLWV4Y2x1c2l2ZVxuXHQvLyBBcyBpbiwgYW4gZWxlbWVudCBkb2VzIG5vdCBjb250YWluIGl0c2VsZlxuXHRjb250YWlucyA9IGhhc0NvbXBhcmUgfHwgcm5hdGl2ZS50ZXN0KCBkb2NFbGVtLmNvbnRhaW5zICkgP1xuXHRcdGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdFx0dmFyIGFkb3duID0gYS5ub2RlVHlwZSA9PT0gOSA/IGEuZG9jdW1lbnRFbGVtZW50IDogYSxcblx0XHRcdFx0YnVwID0gYiAmJiBiLnBhcmVudE5vZGU7XG5cdFx0XHRyZXR1cm4gYSA9PT0gYnVwIHx8ICEhKCBidXAgJiYgYnVwLm5vZGVUeXBlID09PSAxICYmIChcblx0XHRcdFx0YWRvd24uY29udGFpbnMgP1xuXHRcdFx0XHRcdGFkb3duLmNvbnRhaW5zKCBidXAgKSA6XG5cdFx0XHRcdFx0YS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiAmJiBhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBidXAgKSAmIDE2XG5cdFx0XHQpKTtcblx0XHR9IDpcblx0XHRmdW5jdGlvbiggYSwgYiApIHtcblx0XHRcdGlmICggYiApIHtcblx0XHRcdFx0d2hpbGUgKCAoYiA9IGIucGFyZW50Tm9kZSkgKSB7XG5cdFx0XHRcdFx0aWYgKCBiID09PSBhICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcblxuXHQvKiBTb3J0aW5nXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBEb2N1bWVudCBvcmRlciBzb3J0aW5nXG5cdHNvcnRPcmRlciA9IGhhc0NvbXBhcmUgP1xuXHRmdW5jdGlvbiggYSwgYiApIHtcblxuXHRcdC8vIEZsYWcgZm9yIGR1cGxpY2F0ZSByZW1vdmFsXG5cdFx0aWYgKCBhID09PSBiICkge1xuXHRcdFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblxuXHRcdC8vIFNvcnQgb24gbWV0aG9kIGV4aXN0ZW5jZSBpZiBvbmx5IG9uZSBpbnB1dCBoYXMgY29tcGFyZURvY3VtZW50UG9zaXRpb25cblx0XHR2YXIgY29tcGFyZSA9ICFhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uIC0gIWIuY29tcGFyZURvY3VtZW50UG9zaXRpb247XG5cdFx0aWYgKCBjb21wYXJlICkge1xuXHRcdFx0cmV0dXJuIGNvbXBhcmU7XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsY3VsYXRlIHBvc2l0aW9uIGlmIGJvdGggaW5wdXRzIGJlbG9uZyB0byB0aGUgc2FtZSBkb2N1bWVudFxuXHRcdGNvbXBhcmUgPSAoIGEub3duZXJEb2N1bWVudCB8fCBhICkgPT09ICggYi5vd25lckRvY3VtZW50IHx8IGIgKSA/XG5cdFx0XHRhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBiICkgOlxuXG5cdFx0XHQvLyBPdGhlcndpc2Ugd2Uga25vdyB0aGV5IGFyZSBkaXNjb25uZWN0ZWRcblx0XHRcdDE7XG5cblx0XHQvLyBEaXNjb25uZWN0ZWQgbm9kZXNcblx0XHRpZiAoIGNvbXBhcmUgJiAxIHx8XG5cdFx0XHQoIXN1cHBvcnQuc29ydERldGFjaGVkICYmIGIuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGEgKSA9PT0gY29tcGFyZSkgKSB7XG5cblx0XHRcdC8vIENob29zZSB0aGUgZmlyc3QgZWxlbWVudCB0aGF0IGlzIHJlbGF0ZWQgdG8gb3VyIHByZWZlcnJlZCBkb2N1bWVudFxuXHRcdFx0aWYgKCBhID09PSBkb2N1bWVudCB8fCBhLm93bmVyRG9jdW1lbnQgPT09IHByZWZlcnJlZERvYyAmJiBjb250YWlucyhwcmVmZXJyZWREb2MsIGEpICkge1xuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGIgPT09IGRvY3VtZW50IHx8IGIub3duZXJEb2N1bWVudCA9PT0gcHJlZmVycmVkRG9jICYmIGNvbnRhaW5zKHByZWZlcnJlZERvYywgYikgKSB7XG5cdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYWludGFpbiBvcmlnaW5hbCBvcmRlclxuXHRcdFx0cmV0dXJuIHNvcnRJbnB1dCA/XG5cdFx0XHRcdCggaW5kZXhPZiggc29ydElucHV0LCBhICkgLSBpbmRleE9mKCBzb3J0SW5wdXQsIGIgKSApIDpcblx0XHRcdFx0MDtcblx0XHR9XG5cblx0XHRyZXR1cm4gY29tcGFyZSAmIDQgPyAtMSA6IDE7XG5cdH0gOlxuXHRmdW5jdGlvbiggYSwgYiApIHtcblx0XHQvLyBFeGl0IGVhcmx5IGlmIHRoZSBub2RlcyBhcmUgaWRlbnRpY2FsXG5cdFx0aWYgKCBhID09PSBiICkge1xuXHRcdFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblxuXHRcdHZhciBjdXIsXG5cdFx0XHRpID0gMCxcblx0XHRcdGF1cCA9IGEucGFyZW50Tm9kZSxcblx0XHRcdGJ1cCA9IGIucGFyZW50Tm9kZSxcblx0XHRcdGFwID0gWyBhIF0sXG5cdFx0XHRicCA9IFsgYiBdO1xuXG5cdFx0Ly8gUGFyZW50bGVzcyBub2RlcyBhcmUgZWl0aGVyIGRvY3VtZW50cyBvciBkaXNjb25uZWN0ZWRcblx0XHRpZiAoICFhdXAgfHwgIWJ1cCApIHtcblx0XHRcdHJldHVybiBhID09PSBkb2N1bWVudCA/IC0xIDpcblx0XHRcdFx0YiA9PT0gZG9jdW1lbnQgPyAxIDpcblx0XHRcdFx0YXVwID8gLTEgOlxuXHRcdFx0XHRidXAgPyAxIDpcblx0XHRcdFx0c29ydElucHV0ID9cblx0XHRcdFx0KCBpbmRleE9mKCBzb3J0SW5wdXQsIGEgKSAtIGluZGV4T2YoIHNvcnRJbnB1dCwgYiApICkgOlxuXHRcdFx0XHQwO1xuXG5cdFx0Ly8gSWYgdGhlIG5vZGVzIGFyZSBzaWJsaW5ncywgd2UgY2FuIGRvIGEgcXVpY2sgY2hlY2tcblx0XHR9IGVsc2UgaWYgKCBhdXAgPT09IGJ1cCApIHtcblx0XHRcdHJldHVybiBzaWJsaW5nQ2hlY2soIGEsIGIgKTtcblx0XHR9XG5cblx0XHQvLyBPdGhlcndpc2Ugd2UgbmVlZCBmdWxsIGxpc3RzIG9mIHRoZWlyIGFuY2VzdG9ycyBmb3IgY29tcGFyaXNvblxuXHRcdGN1ciA9IGE7XG5cdFx0d2hpbGUgKCAoY3VyID0gY3VyLnBhcmVudE5vZGUpICkge1xuXHRcdFx0YXAudW5zaGlmdCggY3VyICk7XG5cdFx0fVxuXHRcdGN1ciA9IGI7XG5cdFx0d2hpbGUgKCAoY3VyID0gY3VyLnBhcmVudE5vZGUpICkge1xuXHRcdFx0YnAudW5zaGlmdCggY3VyICk7XG5cdFx0fVxuXG5cdFx0Ly8gV2FsayBkb3duIHRoZSB0cmVlIGxvb2tpbmcgZm9yIGEgZGlzY3JlcGFuY3lcblx0XHR3aGlsZSAoIGFwW2ldID09PSBicFtpXSApIHtcblx0XHRcdGkrKztcblx0XHR9XG5cblx0XHRyZXR1cm4gaSA/XG5cdFx0XHQvLyBEbyBhIHNpYmxpbmcgY2hlY2sgaWYgdGhlIG5vZGVzIGhhdmUgYSBjb21tb24gYW5jZXN0b3Jcblx0XHRcdHNpYmxpbmdDaGVjayggYXBbaV0sIGJwW2ldICkgOlxuXG5cdFx0XHQvLyBPdGhlcndpc2Ugbm9kZXMgaW4gb3VyIGRvY3VtZW50IHNvcnQgZmlyc3Rcblx0XHRcdGFwW2ldID09PSBwcmVmZXJyZWREb2MgPyAtMSA6XG5cdFx0XHRicFtpXSA9PT0gcHJlZmVycmVkRG9jID8gMSA6XG5cdFx0XHQwO1xuXHR9O1xuXG5cdHJldHVybiBkb2N1bWVudDtcbn07XG5cblNpenpsZS5tYXRjaGVzID0gZnVuY3Rpb24oIGV4cHIsIGVsZW1lbnRzICkge1xuXHRyZXR1cm4gU2l6emxlKCBleHByLCBudWxsLCBudWxsLCBlbGVtZW50cyApO1xufTtcblxuU2l6emxlLm1hdGNoZXNTZWxlY3RvciA9IGZ1bmN0aW9uKCBlbGVtLCBleHByICkge1xuXHQvLyBTZXQgZG9jdW1lbnQgdmFycyBpZiBuZWVkZWRcblx0aWYgKCAoIGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtICkgIT09IGRvY3VtZW50ICkge1xuXHRcdHNldERvY3VtZW50KCBlbGVtICk7XG5cdH1cblxuXHQvLyBNYWtlIHN1cmUgdGhhdCBhdHRyaWJ1dGUgc2VsZWN0b3JzIGFyZSBxdW90ZWRcblx0ZXhwciA9IGV4cHIucmVwbGFjZSggcmF0dHJpYnV0ZVF1b3RlcywgXCI9JyQxJ11cIiApO1xuXG5cdGlmICggc3VwcG9ydC5tYXRjaGVzU2VsZWN0b3IgJiYgZG9jdW1lbnRJc0hUTUwgJiZcblx0XHQhY29tcGlsZXJDYWNoZVsgZXhwciArIFwiIFwiIF0gJiZcblx0XHQoICFyYnVnZ3lNYXRjaGVzIHx8ICFyYnVnZ3lNYXRjaGVzLnRlc3QoIGV4cHIgKSApICYmXG5cdFx0KCAhcmJ1Z2d5UVNBICAgICB8fCAhcmJ1Z2d5UVNBLnRlc3QoIGV4cHIgKSApICkge1xuXG5cdFx0dHJ5IHtcblx0XHRcdHZhciByZXQgPSBtYXRjaGVzLmNhbGwoIGVsZW0sIGV4cHIgKTtcblxuXHRcdFx0Ly8gSUUgOSdzIG1hdGNoZXNTZWxlY3RvciByZXR1cm5zIGZhbHNlIG9uIGRpc2Nvbm5lY3RlZCBub2Rlc1xuXHRcdFx0aWYgKCByZXQgfHwgc3VwcG9ydC5kaXNjb25uZWN0ZWRNYXRjaCB8fFxuXHRcdFx0XHRcdC8vIEFzIHdlbGwsIGRpc2Nvbm5lY3RlZCBub2RlcyBhcmUgc2FpZCB0byBiZSBpbiBhIGRvY3VtZW50XG5cdFx0XHRcdFx0Ly8gZnJhZ21lbnQgaW4gSUUgOVxuXHRcdFx0XHRcdGVsZW0uZG9jdW1lbnQgJiYgZWxlbS5kb2N1bWVudC5ub2RlVHlwZSAhPT0gMTEgKSB7XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoZSkge31cblx0fVxuXG5cdHJldHVybiBTaXp6bGUoIGV4cHIsIGRvY3VtZW50LCBudWxsLCBbIGVsZW0gXSApLmxlbmd0aCA+IDA7XG59O1xuXG5TaXp6bGUuY29udGFpbnMgPSBmdW5jdGlvbiggY29udGV4dCwgZWxlbSApIHtcblx0Ly8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXG5cdGlmICggKCBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCApICE9PSBkb2N1bWVudCApIHtcblx0XHRzZXREb2N1bWVudCggY29udGV4dCApO1xuXHR9XG5cdHJldHVybiBjb250YWlucyggY29udGV4dCwgZWxlbSApO1xufTtcblxuU2l6emxlLmF0dHIgPSBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0Ly8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXG5cdGlmICggKCBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSApICE9PSBkb2N1bWVudCApIHtcblx0XHRzZXREb2N1bWVudCggZWxlbSApO1xuXHR9XG5cblx0dmFyIGZuID0gRXhwci5hdHRySGFuZGxlWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSxcblx0XHQvLyBEb24ndCBnZXQgZm9vbGVkIGJ5IE9iamVjdC5wcm90b3R5cGUgcHJvcGVydGllcyAoalF1ZXJ5ICMxMzgwNylcblx0XHR2YWwgPSBmbiAmJiBoYXNPd24uY2FsbCggRXhwci5hdHRySGFuZGxlLCBuYW1lLnRvTG93ZXJDYXNlKCkgKSA/XG5cdFx0XHRmbiggZWxlbSwgbmFtZSwgIWRvY3VtZW50SXNIVE1MICkgOlxuXHRcdFx0dW5kZWZpbmVkO1xuXG5cdHJldHVybiB2YWwgIT09IHVuZGVmaW5lZCA/XG5cdFx0dmFsIDpcblx0XHRzdXBwb3J0LmF0dHJpYnV0ZXMgfHwgIWRvY3VtZW50SXNIVE1MID9cblx0XHRcdGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lICkgOlxuXHRcdFx0KHZhbCA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZShuYW1lKSkgJiYgdmFsLnNwZWNpZmllZCA/XG5cdFx0XHRcdHZhbC52YWx1ZSA6XG5cdFx0XHRcdG51bGw7XG59O1xuXG5TaXp6bGUuZXNjYXBlID0gZnVuY3Rpb24oIHNlbCApIHtcblx0cmV0dXJuIChzZWwgKyBcIlwiKS5yZXBsYWNlKCByY3NzZXNjYXBlLCBmY3NzZXNjYXBlICk7XG59O1xuXG5TaXp6bGUuZXJyb3IgPSBmdW5jdGlvbiggbXNnICkge1xuXHR0aHJvdyBuZXcgRXJyb3IoIFwiU3ludGF4IGVycm9yLCB1bnJlY29nbml6ZWQgZXhwcmVzc2lvbjogXCIgKyBtc2cgKTtcbn07XG5cbi8qKlxuICogRG9jdW1lbnQgc29ydGluZyBhbmQgcmVtb3ZpbmcgZHVwbGljYXRlc1xuICogQHBhcmFtIHtBcnJheUxpa2V9IHJlc3VsdHNcbiAqL1xuU2l6emxlLnVuaXF1ZVNvcnQgPSBmdW5jdGlvbiggcmVzdWx0cyApIHtcblx0dmFyIGVsZW0sXG5cdFx0ZHVwbGljYXRlcyA9IFtdLFxuXHRcdGogPSAwLFxuXHRcdGkgPSAwO1xuXG5cdC8vIFVubGVzcyB3ZSAqa25vdyogd2UgY2FuIGRldGVjdCBkdXBsaWNhdGVzLCBhc3N1bWUgdGhlaXIgcHJlc2VuY2Vcblx0aGFzRHVwbGljYXRlID0gIXN1cHBvcnQuZGV0ZWN0RHVwbGljYXRlcztcblx0c29ydElucHV0ID0gIXN1cHBvcnQuc29ydFN0YWJsZSAmJiByZXN1bHRzLnNsaWNlKCAwICk7XG5cdHJlc3VsdHMuc29ydCggc29ydE9yZGVyICk7XG5cblx0aWYgKCBoYXNEdXBsaWNhdGUgKSB7XG5cdFx0d2hpbGUgKCAoZWxlbSA9IHJlc3VsdHNbaSsrXSkgKSB7XG5cdFx0XHRpZiAoIGVsZW0gPT09IHJlc3VsdHNbIGkgXSApIHtcblx0XHRcdFx0aiA9IGR1cGxpY2F0ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdHJlc3VsdHMuc3BsaWNlKCBkdXBsaWNhdGVzWyBqIF0sIDEgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBDbGVhciBpbnB1dCBhZnRlciBzb3J0aW5nIHRvIHJlbGVhc2Ugb2JqZWN0c1xuXHQvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9zaXp6bGUvcHVsbC8yMjVcblx0c29ydElucHV0ID0gbnVsbDtcblxuXHRyZXR1cm4gcmVzdWx0cztcbn07XG5cbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbiBmb3IgcmV0cmlldmluZyB0aGUgdGV4dCB2YWx1ZSBvZiBhbiBhcnJheSBvZiBET00gbm9kZXNcbiAqIEBwYXJhbSB7QXJyYXl8RWxlbWVudH0gZWxlbVxuICovXG5nZXRUZXh0ID0gU2l6emxlLmdldFRleHQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0dmFyIG5vZGUsXG5cdFx0cmV0ID0gXCJcIixcblx0XHRpID0gMCxcblx0XHRub2RlVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cblx0aWYgKCAhbm9kZVR5cGUgKSB7XG5cdFx0Ly8gSWYgbm8gbm9kZVR5cGUsIHRoaXMgaXMgZXhwZWN0ZWQgdG8gYmUgYW4gYXJyYXlcblx0XHR3aGlsZSAoIChub2RlID0gZWxlbVtpKytdKSApIHtcblx0XHRcdC8vIERvIG5vdCB0cmF2ZXJzZSBjb21tZW50IG5vZGVzXG5cdFx0XHRyZXQgKz0gZ2V0VGV4dCggbm9kZSApO1xuXHRcdH1cblx0fSBlbHNlIGlmICggbm9kZVR5cGUgPT09IDEgfHwgbm9kZVR5cGUgPT09IDkgfHwgbm9kZVR5cGUgPT09IDExICkge1xuXHRcdC8vIFVzZSB0ZXh0Q29udGVudCBmb3IgZWxlbWVudHNcblx0XHQvLyBpbm5lclRleHQgdXNhZ2UgcmVtb3ZlZCBmb3IgY29uc2lzdGVuY3kgb2YgbmV3IGxpbmVzIChqUXVlcnkgIzExMTUzKVxuXHRcdGlmICggdHlwZW9mIGVsZW0udGV4dENvbnRlbnQgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS50ZXh0Q29udGVudDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gVHJhdmVyc2UgaXRzIGNoaWxkcmVuXG5cdFx0XHRmb3IgKCBlbGVtID0gZWxlbS5maXJzdENoaWxkOyBlbGVtOyBlbGVtID0gZWxlbS5uZXh0U2libGluZyApIHtcblx0XHRcdFx0cmV0ICs9IGdldFRleHQoIGVsZW0gKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSBpZiAoIG5vZGVUeXBlID09PSAzIHx8IG5vZGVUeXBlID09PSA0ICkge1xuXHRcdHJldHVybiBlbGVtLm5vZGVWYWx1ZTtcblx0fVxuXHQvLyBEbyBub3QgaW5jbHVkZSBjb21tZW50IG9yIHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb24gbm9kZXNcblxuXHRyZXR1cm4gcmV0O1xufTtcblxuRXhwciA9IFNpenpsZS5zZWxlY3RvcnMgPSB7XG5cblx0Ly8gQ2FuIGJlIGFkanVzdGVkIGJ5IHRoZSB1c2VyXG5cdGNhY2hlTGVuZ3RoOiA1MCxcblxuXHRjcmVhdGVQc2V1ZG86IG1hcmtGdW5jdGlvbixcblxuXHRtYXRjaDogbWF0Y2hFeHByLFxuXG5cdGF0dHJIYW5kbGU6IHt9LFxuXG5cdGZpbmQ6IHt9LFxuXG5cdHJlbGF0aXZlOiB7XG5cdFx0XCI+XCI6IHsgZGlyOiBcInBhcmVudE5vZGVcIiwgZmlyc3Q6IHRydWUgfSxcblx0XHRcIiBcIjogeyBkaXI6IFwicGFyZW50Tm9kZVwiIH0sXG5cdFx0XCIrXCI6IHsgZGlyOiBcInByZXZpb3VzU2libGluZ1wiLCBmaXJzdDogdHJ1ZSB9LFxuXHRcdFwiflwiOiB7IGRpcjogXCJwcmV2aW91c1NpYmxpbmdcIiB9XG5cdH0sXG5cblx0cHJlRmlsdGVyOiB7XG5cdFx0XCJBVFRSXCI6IGZ1bmN0aW9uKCBtYXRjaCApIHtcblx0XHRcdG1hdGNoWzFdID0gbWF0Y2hbMV0ucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblxuXHRcdFx0Ly8gTW92ZSB0aGUgZ2l2ZW4gdmFsdWUgdG8gbWF0Y2hbM10gd2hldGhlciBxdW90ZWQgb3IgdW5xdW90ZWRcblx0XHRcdG1hdGNoWzNdID0gKCBtYXRjaFszXSB8fCBtYXRjaFs0XSB8fCBtYXRjaFs1XSB8fCBcIlwiICkucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblxuXHRcdFx0aWYgKCBtYXRjaFsyXSA9PT0gXCJ+PVwiICkge1xuXHRcdFx0XHRtYXRjaFszXSA9IFwiIFwiICsgbWF0Y2hbM10gKyBcIiBcIjtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG1hdGNoLnNsaWNlKCAwLCA0ICk7XG5cdFx0fSxcblxuXHRcdFwiQ0hJTERcIjogZnVuY3Rpb24oIG1hdGNoICkge1xuXHRcdFx0LyogbWF0Y2hlcyBmcm9tIG1hdGNoRXhwcltcIkNISUxEXCJdXG5cdFx0XHRcdDEgdHlwZSAob25seXxudGh8Li4uKVxuXHRcdFx0XHQyIHdoYXQgKGNoaWxkfG9mLXR5cGUpXG5cdFx0XHRcdDMgYXJndW1lbnQgKGV2ZW58b2RkfFxcZCp8XFxkKm4oWystXVxcZCspP3wuLi4pXG5cdFx0XHRcdDQgeG4tY29tcG9uZW50IG9mIHhuK3kgYXJndW1lbnQgKFsrLV0/XFxkKm58KVxuXHRcdFx0XHQ1IHNpZ24gb2YgeG4tY29tcG9uZW50XG5cdFx0XHRcdDYgeCBvZiB4bi1jb21wb25lbnRcblx0XHRcdFx0NyBzaWduIG9mIHktY29tcG9uZW50XG5cdFx0XHRcdDggeSBvZiB5LWNvbXBvbmVudFxuXHRcdFx0Ki9cblx0XHRcdG1hdGNoWzFdID0gbWF0Y2hbMV0udG9Mb3dlckNhc2UoKTtcblxuXHRcdFx0aWYgKCBtYXRjaFsxXS5zbGljZSggMCwgMyApID09PSBcIm50aFwiICkge1xuXHRcdFx0XHQvLyBudGgtKiByZXF1aXJlcyBhcmd1bWVudFxuXHRcdFx0XHRpZiAoICFtYXRjaFszXSApIHtcblx0XHRcdFx0XHRTaXp6bGUuZXJyb3IoIG1hdGNoWzBdICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBudW1lcmljIHggYW5kIHkgcGFyYW1ldGVycyBmb3IgRXhwci5maWx0ZXIuQ0hJTERcblx0XHRcdFx0Ly8gcmVtZW1iZXIgdGhhdCBmYWxzZS90cnVlIGNhc3QgcmVzcGVjdGl2ZWx5IHRvIDAvMVxuXHRcdFx0XHRtYXRjaFs0XSA9ICsoIG1hdGNoWzRdID8gbWF0Y2hbNV0gKyAobWF0Y2hbNl0gfHwgMSkgOiAyICogKCBtYXRjaFszXSA9PT0gXCJldmVuXCIgfHwgbWF0Y2hbM10gPT09IFwib2RkXCIgKSApO1xuXHRcdFx0XHRtYXRjaFs1XSA9ICsoICggbWF0Y2hbN10gKyBtYXRjaFs4XSApIHx8IG1hdGNoWzNdID09PSBcIm9kZFwiICk7XG5cblx0XHRcdC8vIG90aGVyIHR5cGVzIHByb2hpYml0IGFyZ3VtZW50c1xuXHRcdFx0fSBlbHNlIGlmICggbWF0Y2hbM10gKSB7XG5cdFx0XHRcdFNpenpsZS5lcnJvciggbWF0Y2hbMF0gKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG1hdGNoO1xuXHRcdH0sXG5cblx0XHRcIlBTRVVET1wiOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cdFx0XHR2YXIgZXhjZXNzLFxuXHRcdFx0XHR1bnF1b3RlZCA9ICFtYXRjaFs2XSAmJiBtYXRjaFsyXTtcblxuXHRcdFx0aWYgKCBtYXRjaEV4cHJbXCJDSElMRFwiXS50ZXN0KCBtYXRjaFswXSApICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWNjZXB0IHF1b3RlZCBhcmd1bWVudHMgYXMtaXNcblx0XHRcdGlmICggbWF0Y2hbM10gKSB7XG5cdFx0XHRcdG1hdGNoWzJdID0gbWF0Y2hbNF0gfHwgbWF0Y2hbNV0gfHwgXCJcIjtcblxuXHRcdFx0Ly8gU3RyaXAgZXhjZXNzIGNoYXJhY3RlcnMgZnJvbSB1bnF1b3RlZCBhcmd1bWVudHNcblx0XHRcdH0gZWxzZSBpZiAoIHVucXVvdGVkICYmIHJwc2V1ZG8udGVzdCggdW5xdW90ZWQgKSAmJlxuXHRcdFx0XHQvLyBHZXQgZXhjZXNzIGZyb20gdG9rZW5pemUgKHJlY3Vyc2l2ZWx5KVxuXHRcdFx0XHQoZXhjZXNzID0gdG9rZW5pemUoIHVucXVvdGVkLCB0cnVlICkpICYmXG5cdFx0XHRcdC8vIGFkdmFuY2UgdG8gdGhlIG5leHQgY2xvc2luZyBwYXJlbnRoZXNpc1xuXHRcdFx0XHQoZXhjZXNzID0gdW5xdW90ZWQuaW5kZXhPZiggXCIpXCIsIHVucXVvdGVkLmxlbmd0aCAtIGV4Y2VzcyApIC0gdW5xdW90ZWQubGVuZ3RoKSApIHtcblxuXHRcdFx0XHQvLyBleGNlc3MgaXMgYSBuZWdhdGl2ZSBpbmRleFxuXHRcdFx0XHRtYXRjaFswXSA9IG1hdGNoWzBdLnNsaWNlKCAwLCBleGNlc3MgKTtcblx0XHRcdFx0bWF0Y2hbMl0gPSB1bnF1b3RlZC5zbGljZSggMCwgZXhjZXNzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJldHVybiBvbmx5IGNhcHR1cmVzIG5lZWRlZCBieSB0aGUgcHNldWRvIGZpbHRlciBtZXRob2QgKHR5cGUgYW5kIGFyZ3VtZW50KVxuXHRcdFx0cmV0dXJuIG1hdGNoLnNsaWNlKCAwLCAzICk7XG5cdFx0fVxuXHR9LFxuXG5cdGZpbHRlcjoge1xuXG5cdFx0XCJUQUdcIjogZnVuY3Rpb24oIG5vZGVOYW1lU2VsZWN0b3IgKSB7XG5cdFx0XHR2YXIgbm9kZU5hbWUgPSBub2RlTmFtZVNlbGVjdG9yLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICkudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiBub2RlTmFtZVNlbGVjdG9yID09PSBcIipcIiA/XG5cdFx0XHRcdGZ1bmN0aW9uKCkgeyByZXR1cm4gdHJ1ZTsgfSA6XG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdHJldHVybiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbm9kZU5hbWU7XG5cdFx0XHRcdH07XG5cdFx0fSxcblxuXHRcdFwiQ0xBU1NcIjogZnVuY3Rpb24oIGNsYXNzTmFtZSApIHtcblx0XHRcdHZhciBwYXR0ZXJuID0gY2xhc3NDYWNoZVsgY2xhc3NOYW1lICsgXCIgXCIgXTtcblxuXHRcdFx0cmV0dXJuIHBhdHRlcm4gfHxcblx0XHRcdFx0KHBhdHRlcm4gPSBuZXcgUmVnRXhwKCBcIihefFwiICsgd2hpdGVzcGFjZSArIFwiKVwiICsgY2xhc3NOYW1lICsgXCIoXCIgKyB3aGl0ZXNwYWNlICsgXCJ8JClcIiApKSAmJlxuXHRcdFx0XHRjbGFzc0NhY2hlKCBjbGFzc05hbWUsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdHJldHVybiBwYXR0ZXJuLnRlc3QoIHR5cGVvZiBlbGVtLmNsYXNzTmFtZSA9PT0gXCJzdHJpbmdcIiAmJiBlbGVtLmNsYXNzTmFtZSB8fCB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGUgIT09IFwidW5kZWZpbmVkXCIgJiYgZWxlbS5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKSB8fCBcIlwiICk7XG5cdFx0XHRcdH0pO1xuXHRcdH0sXG5cblx0XHRcIkFUVFJcIjogZnVuY3Rpb24oIG5hbWUsIG9wZXJhdG9yLCBjaGVjayApIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIHJlc3VsdCA9IFNpenpsZS5hdHRyKCBlbGVtLCBuYW1lICk7XG5cblx0XHRcdFx0aWYgKCByZXN1bHQgPT0gbnVsbCApIHtcblx0XHRcdFx0XHRyZXR1cm4gb3BlcmF0b3IgPT09IFwiIT1cIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoICFvcGVyYXRvciApIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJlc3VsdCArPSBcIlwiO1xuXG5cdFx0XHRcdHJldHVybiBvcGVyYXRvciA9PT0gXCI9XCIgPyByZXN1bHQgPT09IGNoZWNrIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCIhPVwiID8gcmVzdWx0ICE9PSBjaGVjayA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiXj1cIiA/IGNoZWNrICYmIHJlc3VsdC5pbmRleE9mKCBjaGVjayApID09PSAwIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCIqPVwiID8gY2hlY2sgJiYgcmVzdWx0LmluZGV4T2YoIGNoZWNrICkgPiAtMSA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiJD1cIiA/IGNoZWNrICYmIHJlc3VsdC5zbGljZSggLWNoZWNrLmxlbmd0aCApID09PSBjaGVjayA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwifj1cIiA/ICggXCIgXCIgKyByZXN1bHQucmVwbGFjZSggcndoaXRlc3BhY2UsIFwiIFwiICkgKyBcIiBcIiApLmluZGV4T2YoIGNoZWNrICkgPiAtMSA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwifD1cIiA/IHJlc3VsdCA9PT0gY2hlY2sgfHwgcmVzdWx0LnNsaWNlKCAwLCBjaGVjay5sZW5ndGggKyAxICkgPT09IGNoZWNrICsgXCItXCIgOlxuXHRcdFx0XHRcdGZhbHNlO1xuXHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0XCJDSElMRFwiOiBmdW5jdGlvbiggdHlwZSwgd2hhdCwgYXJndW1lbnQsIGZpcnN0LCBsYXN0ICkge1xuXHRcdFx0dmFyIHNpbXBsZSA9IHR5cGUuc2xpY2UoIDAsIDMgKSAhPT0gXCJudGhcIixcblx0XHRcdFx0Zm9yd2FyZCA9IHR5cGUuc2xpY2UoIC00ICkgIT09IFwibGFzdFwiLFxuXHRcdFx0XHRvZlR5cGUgPSB3aGF0ID09PSBcIm9mLXR5cGVcIjtcblxuXHRcdFx0cmV0dXJuIGZpcnN0ID09PSAxICYmIGxhc3QgPT09IDAgP1xuXG5cdFx0XHRcdC8vIFNob3J0Y3V0IGZvciA6bnRoLSoobilcblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0cmV0dXJuICEhZWxlbS5wYXJlbnROb2RlO1xuXHRcdFx0XHR9IDpcblxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0XHRcdHZhciBjYWNoZSwgdW5pcXVlQ2FjaGUsIG91dGVyQ2FjaGUsIG5vZGUsIG5vZGVJbmRleCwgc3RhcnQsXG5cdFx0XHRcdFx0XHRkaXIgPSBzaW1wbGUgIT09IGZvcndhcmQgPyBcIm5leHRTaWJsaW5nXCIgOiBcInByZXZpb3VzU2libGluZ1wiLFxuXHRcdFx0XHRcdFx0cGFyZW50ID0gZWxlbS5wYXJlbnROb2RlLFxuXHRcdFx0XHRcdFx0bmFtZSA9IG9mVHlwZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCksXG5cdFx0XHRcdFx0XHR1c2VDYWNoZSA9ICF4bWwgJiYgIW9mVHlwZSxcblx0XHRcdFx0XHRcdGRpZmYgPSBmYWxzZTtcblxuXHRcdFx0XHRcdGlmICggcGFyZW50ICkge1xuXG5cdFx0XHRcdFx0XHQvLyA6KGZpcnN0fGxhc3R8b25seSktKGNoaWxkfG9mLXR5cGUpXG5cdFx0XHRcdFx0XHRpZiAoIHNpbXBsZSApIHtcblx0XHRcdFx0XHRcdFx0d2hpbGUgKCBkaXIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0bm9kZSA9IGVsZW07XG5cdFx0XHRcdFx0XHRcdFx0d2hpbGUgKCAobm9kZSA9IG5vZGVbIGRpciBdKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggb2ZUeXBlID9cblx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lIDpcblx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5ub2RlVHlwZSA9PT0gMSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdC8vIFJldmVyc2UgZGlyZWN0aW9uIGZvciA6b25seS0qIChpZiB3ZSBoYXZlbid0IHlldCBkb25lIHNvKVxuXHRcdFx0XHRcdFx0XHRcdHN0YXJ0ID0gZGlyID0gdHlwZSA9PT0gXCJvbmx5XCIgJiYgIXN0YXJ0ICYmIFwibmV4dFNpYmxpbmdcIjtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0c3RhcnQgPSBbIGZvcndhcmQgPyBwYXJlbnQuZmlyc3RDaGlsZCA6IHBhcmVudC5sYXN0Q2hpbGQgXTtcblxuXHRcdFx0XHRcdFx0Ly8gbm9uLXhtbCA6bnRoLWNoaWxkKC4uLikgc3RvcmVzIGNhY2hlIGRhdGEgb24gYHBhcmVudGBcblx0XHRcdFx0XHRcdGlmICggZm9yd2FyZCAmJiB1c2VDYWNoZSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBTZWVrIGBlbGVtYCBmcm9tIGEgcHJldmlvdXNseS1jYWNoZWQgaW5kZXhcblxuXHRcdFx0XHRcdFx0XHQvLyAuLi5pbiBhIGd6aXAtZnJpZW5kbHkgd2F5XG5cdFx0XHRcdFx0XHRcdG5vZGUgPSBwYXJlbnQ7XG5cdFx0XHRcdFx0XHRcdG91dGVyQ2FjaGUgPSBub2RlWyBleHBhbmRvIF0gfHwgKG5vZGVbIGV4cGFuZG8gXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHRcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuXHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSB8fFxuXHRcdFx0XHRcdFx0XHRcdChvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0Y2FjaGUgPSB1bmlxdWVDYWNoZVsgdHlwZSBdIHx8IFtdO1xuXHRcdFx0XHRcdFx0XHRub2RlSW5kZXggPSBjYWNoZVsgMCBdID09PSBkaXJydW5zICYmIGNhY2hlWyAxIF07XG5cdFx0XHRcdFx0XHRcdGRpZmYgPSBub2RlSW5kZXggJiYgY2FjaGVbIDIgXTtcblx0XHRcdFx0XHRcdFx0bm9kZSA9IG5vZGVJbmRleCAmJiBwYXJlbnQuY2hpbGROb2Rlc1sgbm9kZUluZGV4IF07XG5cblx0XHRcdFx0XHRcdFx0d2hpbGUgKCAobm9kZSA9ICsrbm9kZUluZGV4ICYmIG5vZGUgJiYgbm9kZVsgZGlyIF0gfHxcblxuXHRcdFx0XHRcdFx0XHRcdC8vIEZhbGxiYWNrIHRvIHNlZWtpbmcgYGVsZW1gIGZyb20gdGhlIHN0YXJ0XG5cdFx0XHRcdFx0XHRcdFx0KGRpZmYgPSBub2RlSW5kZXggPSAwKSB8fCBzdGFydC5wb3AoKSkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBXaGVuIGZvdW5kLCBjYWNoZSBpbmRleGVzIG9uIGBwYXJlbnRgIGFuZCBicmVha1xuXHRcdFx0XHRcdFx0XHRcdGlmICggbm9kZS5ub2RlVHlwZSA9PT0gMSAmJiArK2RpZmYgJiYgbm9kZSA9PT0gZWxlbSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlWyB0eXBlIF0gPSBbIGRpcnJ1bnMsIG5vZGVJbmRleCwgZGlmZiBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdC8vIFVzZSBwcmV2aW91c2x5LWNhY2hlZCBlbGVtZW50IGluZGV4IGlmIGF2YWlsYWJsZVxuXHRcdFx0XHRcdFx0XHRpZiAoIHVzZUNhY2hlICkge1xuXHRcdFx0XHRcdFx0XHRcdC8vIC4uLmluIGEgZ3ppcC1mcmllbmRseSB3YXlcblx0XHRcdFx0XHRcdFx0XHRub2RlID0gZWxlbTtcblx0XHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gbm9kZVsgZXhwYW5kbyBdIHx8IChub2RlWyBleHBhbmRvIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHRcdFx0Ly8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG5cdFx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRcdChvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0XHRjYWNoZSA9IHVuaXF1ZUNhY2hlWyB0eXBlIF0gfHwgW107XG5cdFx0XHRcdFx0XHRcdFx0bm9kZUluZGV4ID0gY2FjaGVbIDAgXSA9PT0gZGlycnVucyAmJiBjYWNoZVsgMSBdO1xuXHRcdFx0XHRcdFx0XHRcdGRpZmYgPSBub2RlSW5kZXg7XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHQvLyB4bWwgOm50aC1jaGlsZCguLi4pXG5cdFx0XHRcdFx0XHRcdC8vIG9yIDpudGgtbGFzdC1jaGlsZCguLi4pIG9yIDpudGgoLWxhc3QpPy1vZi10eXBlKC4uLilcblx0XHRcdFx0XHRcdFx0aWYgKCBkaWZmID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRcdFx0XHQvLyBVc2UgdGhlIHNhbWUgbG9vcCBhcyBhYm92ZSB0byBzZWVrIGBlbGVtYCBmcm9tIHRoZSBzdGFydFxuXHRcdFx0XHRcdFx0XHRcdHdoaWxlICggKG5vZGUgPSArK25vZGVJbmRleCAmJiBub2RlICYmIG5vZGVbIGRpciBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHQoZGlmZiA9IG5vZGVJbmRleCA9IDApIHx8IHN0YXJ0LnBvcCgpKSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCAoIG9mVHlwZSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZSA6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZVR5cGUgPT09IDEgKSAmJlxuXHRcdFx0XHRcdFx0XHRcdFx0XHQrK2RpZmYgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gQ2FjaGUgdGhlIGluZGV4IG9mIGVhY2ggZW5jb3VudGVyZWQgZWxlbWVudFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHVzZUNhY2hlICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG91dGVyQ2FjaGUgPSBub2RlWyBleHBhbmRvIF0gfHwgKG5vZGVbIGV4cGFuZG8gXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0KG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlWyB0eXBlIF0gPSBbIGRpcnJ1bnMsIGRpZmYgXTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggbm9kZSA9PT0gZWxlbSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBJbmNvcnBvcmF0ZSB0aGUgb2Zmc2V0LCB0aGVuIGNoZWNrIGFnYWluc3QgY3ljbGUgc2l6ZVxuXHRcdFx0XHRcdFx0ZGlmZiAtPSBsYXN0O1xuXHRcdFx0XHRcdFx0cmV0dXJuIGRpZmYgPT09IGZpcnN0IHx8ICggZGlmZiAlIGZpcnN0ID09PSAwICYmIGRpZmYgLyBmaXJzdCA+PSAwICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRcIlBTRVVET1wiOiBmdW5jdGlvbiggcHNldWRvLCBhcmd1bWVudCApIHtcblx0XHRcdC8vIHBzZXVkby1jbGFzcyBuYW1lcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZVxuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNwc2V1ZG8tY2xhc3Nlc1xuXHRcdFx0Ly8gUHJpb3JpdGl6ZSBieSBjYXNlIHNlbnNpdGl2aXR5IGluIGNhc2UgY3VzdG9tIHBzZXVkb3MgYXJlIGFkZGVkIHdpdGggdXBwZXJjYXNlIGxldHRlcnNcblx0XHRcdC8vIFJlbWVtYmVyIHRoYXQgc2V0RmlsdGVycyBpbmhlcml0cyBmcm9tIHBzZXVkb3Ncblx0XHRcdHZhciBhcmdzLFxuXHRcdFx0XHRmbiA9IEV4cHIucHNldWRvc1sgcHNldWRvIF0gfHwgRXhwci5zZXRGaWx0ZXJzWyBwc2V1ZG8udG9Mb3dlckNhc2UoKSBdIHx8XG5cdFx0XHRcdFx0U2l6emxlLmVycm9yKCBcInVuc3VwcG9ydGVkIHBzZXVkbzogXCIgKyBwc2V1ZG8gKTtcblxuXHRcdFx0Ly8gVGhlIHVzZXIgbWF5IHVzZSBjcmVhdGVQc2V1ZG8gdG8gaW5kaWNhdGUgdGhhdFxuXHRcdFx0Ly8gYXJndW1lbnRzIGFyZSBuZWVkZWQgdG8gY3JlYXRlIHRoZSBmaWx0ZXIgZnVuY3Rpb25cblx0XHRcdC8vIGp1c3QgYXMgU2l6emxlIGRvZXNcblx0XHRcdGlmICggZm5bIGV4cGFuZG8gXSApIHtcblx0XHRcdFx0cmV0dXJuIGZuKCBhcmd1bWVudCApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBCdXQgbWFpbnRhaW4gc3VwcG9ydCBmb3Igb2xkIHNpZ25hdHVyZXNcblx0XHRcdGlmICggZm4ubGVuZ3RoID4gMSApIHtcblx0XHRcdFx0YXJncyA9IFsgcHNldWRvLCBwc2V1ZG8sIFwiXCIsIGFyZ3VtZW50IF07XG5cdFx0XHRcdHJldHVybiBFeHByLnNldEZpbHRlcnMuaGFzT3duUHJvcGVydHkoIHBzZXVkby50b0xvd2VyQ2FzZSgpICkgP1xuXHRcdFx0XHRcdG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcyApIHtcblx0XHRcdFx0XHRcdHZhciBpZHgsXG5cdFx0XHRcdFx0XHRcdG1hdGNoZWQgPSBmbiggc2VlZCwgYXJndW1lbnQgKSxcblx0XHRcdFx0XHRcdFx0aSA9IG1hdGNoZWQubGVuZ3RoO1xuXHRcdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRcdGlkeCA9IGluZGV4T2YoIHNlZWQsIG1hdGNoZWRbaV0gKTtcblx0XHRcdFx0XHRcdFx0c2VlZFsgaWR4IF0gPSAhKCBtYXRjaGVzWyBpZHggXSA9IG1hdGNoZWRbaV0gKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KSA6XG5cdFx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZm4oIGVsZW0sIDAsIGFyZ3MgKTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZm47XG5cdFx0fVxuXHR9LFxuXG5cdHBzZXVkb3M6IHtcblx0XHQvLyBQb3RlbnRpYWxseSBjb21wbGV4IHBzZXVkb3Ncblx0XHRcIm5vdFwiOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdFx0Ly8gVHJpbSB0aGUgc2VsZWN0b3IgcGFzc2VkIHRvIGNvbXBpbGVcblx0XHRcdC8vIHRvIGF2b2lkIHRyZWF0aW5nIGxlYWRpbmcgYW5kIHRyYWlsaW5nXG5cdFx0XHQvLyBzcGFjZXMgYXMgY29tYmluYXRvcnNcblx0XHRcdHZhciBpbnB1dCA9IFtdLFxuXHRcdFx0XHRyZXN1bHRzID0gW10sXG5cdFx0XHRcdG1hdGNoZXIgPSBjb21waWxlKCBzZWxlY3Rvci5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICkgKTtcblxuXHRcdFx0cmV0dXJuIG1hdGNoZXJbIGV4cGFuZG8gXSA/XG5cdFx0XHRcdG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcywgY29udGV4dCwgeG1sICkge1xuXHRcdFx0XHRcdHZhciBlbGVtLFxuXHRcdFx0XHRcdFx0dW5tYXRjaGVkID0gbWF0Y2hlciggc2VlZCwgbnVsbCwgeG1sLCBbXSApLFxuXHRcdFx0XHRcdFx0aSA9IHNlZWQubGVuZ3RoO1xuXG5cdFx0XHRcdFx0Ly8gTWF0Y2ggZWxlbWVudHMgdW5tYXRjaGVkIGJ5IGBtYXRjaGVyYFxuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0aWYgKCAoZWxlbSA9IHVubWF0Y2hlZFtpXSkgKSB7XG5cdFx0XHRcdFx0XHRcdHNlZWRbaV0gPSAhKG1hdGNoZXNbaV0gPSBlbGVtKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pIDpcblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdFx0XHRpbnB1dFswXSA9IGVsZW07XG5cdFx0XHRcdFx0bWF0Y2hlciggaW5wdXQsIG51bGwsIHhtbCwgcmVzdWx0cyApO1xuXHRcdFx0XHRcdC8vIERvbid0IGtlZXAgdGhlIGVsZW1lbnQgKGlzc3VlICMyOTkpXG5cdFx0XHRcdFx0aW5wdXRbMF0gPSBudWxsO1xuXHRcdFx0XHRcdHJldHVybiAhcmVzdWx0cy5wb3AoKTtcblx0XHRcdFx0fTtcblx0XHR9KSxcblxuXHRcdFwiaGFzXCI6IG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBTaXp6bGUoIHNlbGVjdG9yLCBlbGVtICkubGVuZ3RoID4gMDtcblx0XHRcdH07XG5cdFx0fSksXG5cblx0XHRcImNvbnRhaW5zXCI6IG1hcmtGdW5jdGlvbihmdW5jdGlvbiggdGV4dCApIHtcblx0XHRcdHRleHQgPSB0ZXh0LnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiAoIGVsZW0udGV4dENvbnRlbnQgfHwgZWxlbS5pbm5lclRleHQgfHwgZ2V0VGV4dCggZWxlbSApICkuaW5kZXhPZiggdGV4dCApID4gLTE7XG5cdFx0XHR9O1xuXHRcdH0pLFxuXG5cdFx0Ly8gXCJXaGV0aGVyIGFuIGVsZW1lbnQgaXMgcmVwcmVzZW50ZWQgYnkgYSA6bGFuZygpIHNlbGVjdG9yXG5cdFx0Ly8gaXMgYmFzZWQgc29sZWx5IG9uIHRoZSBlbGVtZW50J3MgbGFuZ3VhZ2UgdmFsdWVcblx0XHQvLyBiZWluZyBlcXVhbCB0byB0aGUgaWRlbnRpZmllciBDLFxuXHRcdC8vIG9yIGJlZ2lubmluZyB3aXRoIHRoZSBpZGVudGlmaWVyIEMgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgXCItXCIuXG5cdFx0Ly8gVGhlIG1hdGNoaW5nIG9mIEMgYWdhaW5zdCB0aGUgZWxlbWVudCdzIGxhbmd1YWdlIHZhbHVlIGlzIHBlcmZvcm1lZCBjYXNlLWluc2Vuc2l0aXZlbHkuXG5cdFx0Ly8gVGhlIGlkZW50aWZpZXIgQyBkb2VzIG5vdCBoYXZlIHRvIGJlIGEgdmFsaWQgbGFuZ3VhZ2UgbmFtZS5cIlxuXHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jbGFuZy1wc2V1ZG9cblx0XHRcImxhbmdcIjogbWFya0Z1bmN0aW9uKCBmdW5jdGlvbiggbGFuZyApIHtcblx0XHRcdC8vIGxhbmcgdmFsdWUgbXVzdCBiZSBhIHZhbGlkIGlkZW50aWZpZXJcblx0XHRcdGlmICggIXJpZGVudGlmaWVyLnRlc3QobGFuZyB8fCBcIlwiKSApIHtcblx0XHRcdFx0U2l6emxlLmVycm9yKCBcInVuc3VwcG9ydGVkIGxhbmc6IFwiICsgbGFuZyApO1xuXHRcdFx0fVxuXHRcdFx0bGFuZyA9IGxhbmcucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgZWxlbUxhbmc7XG5cdFx0XHRcdGRvIHtcblx0XHRcdFx0XHRpZiAoIChlbGVtTGFuZyA9IGRvY3VtZW50SXNIVE1MID9cblx0XHRcdFx0XHRcdGVsZW0ubGFuZyA6XG5cdFx0XHRcdFx0XHRlbGVtLmdldEF0dHJpYnV0ZShcInhtbDpsYW5nXCIpIHx8IGVsZW0uZ2V0QXR0cmlidXRlKFwibGFuZ1wiKSkgKSB7XG5cblx0XHRcdFx0XHRcdGVsZW1MYW5nID0gZWxlbUxhbmcudG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0XHRcdHJldHVybiBlbGVtTGFuZyA9PT0gbGFuZyB8fCBlbGVtTGFuZy5pbmRleE9mKCBsYW5nICsgXCItXCIgKSA9PT0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gd2hpbGUgKCAoZWxlbSA9IGVsZW0ucGFyZW50Tm9kZSkgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9O1xuXHRcdH0pLFxuXG5cdFx0Ly8gTWlzY2VsbGFuZW91c1xuXHRcdFwidGFyZ2V0XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIGhhc2ggPSB3aW5kb3cubG9jYXRpb24gJiYgd2luZG93LmxvY2F0aW9uLmhhc2g7XG5cdFx0XHRyZXR1cm4gaGFzaCAmJiBoYXNoLnNsaWNlKCAxICkgPT09IGVsZW0uaWQ7XG5cdFx0fSxcblxuXHRcdFwicm9vdFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtID09PSBkb2NFbGVtO1xuXHRcdH0sXG5cblx0XHRcImZvY3VzXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0gPT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgJiYgKCFkb2N1bWVudC5oYXNGb2N1cyB8fCBkb2N1bWVudC5oYXNGb2N1cygpKSAmJiAhIShlbGVtLnR5cGUgfHwgZWxlbS5ocmVmIHx8IH5lbGVtLnRhYkluZGV4KTtcblx0XHR9LFxuXG5cdFx0Ly8gQm9vbGVhbiBwcm9wZXJ0aWVzXG5cdFx0XCJlbmFibGVkXCI6IGNyZWF0ZURpc2FibGVkUHNldWRvKCBmYWxzZSApLFxuXHRcdFwiZGlzYWJsZWRcIjogY3JlYXRlRGlzYWJsZWRQc2V1ZG8oIHRydWUgKSxcblxuXHRcdFwiY2hlY2tlZFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdC8vIEluIENTUzMsIDpjaGVja2VkIHNob3VsZCByZXR1cm4gYm90aCBjaGVja2VkIGFuZCBzZWxlY3RlZCBlbGVtZW50c1xuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMS9SRUMtY3NzMy1zZWxlY3RvcnMtMjAxMTA5MjkvI2NoZWNrZWRcblx0XHRcdHZhciBub2RlTmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiAobm9kZU5hbWUgPT09IFwiaW5wdXRcIiAmJiAhIWVsZW0uY2hlY2tlZCkgfHwgKG5vZGVOYW1lID09PSBcIm9wdGlvblwiICYmICEhZWxlbS5zZWxlY3RlZCk7XG5cdFx0fSxcblxuXHRcdFwic2VsZWN0ZWRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHQvLyBBY2Nlc3NpbmcgdGhpcyBwcm9wZXJ0eSBtYWtlcyBzZWxlY3RlZC1ieS1kZWZhdWx0XG5cdFx0XHQvLyBvcHRpb25zIGluIFNhZmFyaSB3b3JrIHByb3Blcmx5XG5cdFx0XHRpZiAoIGVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0ZWxlbS5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBlbGVtLnNlbGVjdGVkID09PSB0cnVlO1xuXHRcdH0sXG5cblx0XHQvLyBDb250ZW50c1xuXHRcdFwiZW1wdHlcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2VtcHR5LXBzZXVkb1xuXHRcdFx0Ly8gOmVtcHR5IGlzIG5lZ2F0ZWQgYnkgZWxlbWVudCAoMSkgb3IgY29udGVudCBub2RlcyAodGV4dDogMzsgY2RhdGE6IDQ7IGVudGl0eSByZWY6IDUpLFxuXHRcdFx0Ly8gICBidXQgbm90IGJ5IG90aGVycyAoY29tbWVudDogODsgcHJvY2Vzc2luZyBpbnN0cnVjdGlvbjogNzsgZXRjLilcblx0XHRcdC8vIG5vZGVUeXBlIDwgNiB3b3JrcyBiZWNhdXNlIGF0dHJpYnV0ZXMgKDIpIGRvIG5vdCBhcHBlYXIgYXMgY2hpbGRyZW5cblx0XHRcdGZvciAoIGVsZW0gPSBlbGVtLmZpcnN0Q2hpbGQ7IGVsZW07IGVsZW0gPSBlbGVtLm5leHRTaWJsaW5nICkge1xuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPCA2ICkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSxcblxuXHRcdFwicGFyZW50XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuICFFeHByLnBzZXVkb3NbXCJlbXB0eVwiXSggZWxlbSApO1xuXHRcdH0sXG5cblx0XHQvLyBFbGVtZW50L2lucHV0IHR5cGVzXG5cdFx0XCJoZWFkZXJcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gcmhlYWRlci50ZXN0KCBlbGVtLm5vZGVOYW1lICk7XG5cdFx0fSxcblxuXHRcdFwiaW5wdXRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gcmlucHV0cy50ZXN0KCBlbGVtLm5vZGVOYW1lICk7XG5cdFx0fSxcblxuXHRcdFwiYnV0dG9uXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gbmFtZSA9PT0gXCJpbnB1dFwiICYmIGVsZW0udHlwZSA9PT0gXCJidXR0b25cIiB8fCBuYW1lID09PSBcImJ1dHRvblwiO1xuXHRcdH0sXG5cblx0XHRcInRleHRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgYXR0cjtcblx0XHRcdHJldHVybiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiaW5wdXRcIiAmJlxuXHRcdFx0XHRlbGVtLnR5cGUgPT09IFwidGV4dFwiICYmXG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUU8OFxuXHRcdFx0XHQvLyBOZXcgSFRNTDUgYXR0cmlidXRlIHZhbHVlcyAoZS5nLiwgXCJzZWFyY2hcIikgYXBwZWFyIHdpdGggZWxlbS50eXBlID09PSBcInRleHRcIlxuXHRcdFx0XHQoIChhdHRyID0gZWxlbS5nZXRBdHRyaWJ1dGUoXCJ0eXBlXCIpKSA9PSBudWxsIHx8IGF0dHIudG9Mb3dlckNhc2UoKSA9PT0gXCJ0ZXh0XCIgKTtcblx0XHR9LFxuXG5cdFx0Ly8gUG9zaXRpb24taW4tY29sbGVjdGlvblxuXHRcdFwiZmlyc3RcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBbIDAgXTtcblx0XHR9KSxcblxuXHRcdFwibGFzdFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcblx0XHRcdHJldHVybiBbIGxlbmd0aCAtIDEgXTtcblx0XHR9KSxcblxuXHRcdFwiZXFcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xuXHRcdFx0cmV0dXJuIFsgYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudCBdO1xuXHRcdH0pLFxuXG5cdFx0XCJldmVuXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoICkge1xuXHRcdFx0dmFyIGkgPSAwO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpICs9IDIgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0pLFxuXG5cdFx0XCJvZGRcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XG5cdFx0XHR2YXIgaSA9IDE7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkgKz0gMiApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSksXG5cblx0XHRcImx0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcblx0XHRcdHZhciBpID0gYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudDtcblx0XHRcdGZvciAoIDsgLS1pID49IDA7ICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9KSxcblxuXHRcdFwiZ3RcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xuXHRcdFx0dmFyIGkgPSBhcmd1bWVudCA8IDAgPyBhcmd1bWVudCArIGxlbmd0aCA6IGFyZ3VtZW50O1xuXHRcdFx0Zm9yICggOyArK2kgPCBsZW5ndGg7ICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9KVxuXHR9XG59O1xuXG5FeHByLnBzZXVkb3NbXCJudGhcIl0gPSBFeHByLnBzZXVkb3NbXCJlcVwiXTtcblxuLy8gQWRkIGJ1dHRvbi9pbnB1dCB0eXBlIHBzZXVkb3NcbmZvciAoIGkgaW4geyByYWRpbzogdHJ1ZSwgY2hlY2tib3g6IHRydWUsIGZpbGU6IHRydWUsIHBhc3N3b3JkOiB0cnVlLCBpbWFnZTogdHJ1ZSB9ICkge1xuXHRFeHByLnBzZXVkb3NbIGkgXSA9IGNyZWF0ZUlucHV0UHNldWRvKCBpICk7XG59XG5mb3IgKCBpIGluIHsgc3VibWl0OiB0cnVlLCByZXNldDogdHJ1ZSB9ICkge1xuXHRFeHByLnBzZXVkb3NbIGkgXSA9IGNyZWF0ZUJ1dHRvblBzZXVkbyggaSApO1xufVxuXG4vLyBFYXN5IEFQSSBmb3IgY3JlYXRpbmcgbmV3IHNldEZpbHRlcnNcbmZ1bmN0aW9uIHNldEZpbHRlcnMoKSB7fVxuc2V0RmlsdGVycy5wcm90b3R5cGUgPSBFeHByLmZpbHRlcnMgPSBFeHByLnBzZXVkb3M7XG5FeHByLnNldEZpbHRlcnMgPSBuZXcgc2V0RmlsdGVycygpO1xuXG50b2tlbml6ZSA9IFNpenpsZS50b2tlbml6ZSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgcGFyc2VPbmx5ICkge1xuXHR2YXIgbWF0Y2hlZCwgbWF0Y2gsIHRva2VucywgdHlwZSxcblx0XHRzb0ZhciwgZ3JvdXBzLCBwcmVGaWx0ZXJzLFxuXHRcdGNhY2hlZCA9IHRva2VuQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXTtcblxuXHRpZiAoIGNhY2hlZCApIHtcblx0XHRyZXR1cm4gcGFyc2VPbmx5ID8gMCA6IGNhY2hlZC5zbGljZSggMCApO1xuXHR9XG5cblx0c29GYXIgPSBzZWxlY3Rvcjtcblx0Z3JvdXBzID0gW107XG5cdHByZUZpbHRlcnMgPSBFeHByLnByZUZpbHRlcjtcblxuXHR3aGlsZSAoIHNvRmFyICkge1xuXG5cdFx0Ly8gQ29tbWEgYW5kIGZpcnN0IHJ1blxuXHRcdGlmICggIW1hdGNoZWQgfHwgKG1hdGNoID0gcmNvbW1hLmV4ZWMoIHNvRmFyICkpICkge1xuXHRcdFx0aWYgKCBtYXRjaCApIHtcblx0XHRcdFx0Ly8gRG9uJ3QgY29uc3VtZSB0cmFpbGluZyBjb21tYXMgYXMgdmFsaWRcblx0XHRcdFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hbMF0ubGVuZ3RoICkgfHwgc29GYXI7XG5cdFx0XHR9XG5cdFx0XHRncm91cHMucHVzaCggKHRva2VucyA9IFtdKSApO1xuXHRcdH1cblxuXHRcdG1hdGNoZWQgPSBmYWxzZTtcblxuXHRcdC8vIENvbWJpbmF0b3JzXG5cdFx0aWYgKCAobWF0Y2ggPSByY29tYmluYXRvcnMuZXhlYyggc29GYXIgKSkgKSB7XG5cdFx0XHRtYXRjaGVkID0gbWF0Y2guc2hpZnQoKTtcblx0XHRcdHRva2Vucy5wdXNoKHtcblx0XHRcdFx0dmFsdWU6IG1hdGNoZWQsXG5cdFx0XHRcdC8vIENhc3QgZGVzY2VuZGFudCBjb21iaW5hdG9ycyB0byBzcGFjZVxuXHRcdFx0XHR0eXBlOiBtYXRjaFswXS5yZXBsYWNlKCBydHJpbSwgXCIgXCIgKVxuXHRcdFx0fSk7XG5cdFx0XHRzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaGVkLmxlbmd0aCApO1xuXHRcdH1cblxuXHRcdC8vIEZpbHRlcnNcblx0XHRmb3IgKCB0eXBlIGluIEV4cHIuZmlsdGVyICkge1xuXHRcdFx0aWYgKCAobWF0Y2ggPSBtYXRjaEV4cHJbIHR5cGUgXS5leGVjKCBzb0ZhciApKSAmJiAoIXByZUZpbHRlcnNbIHR5cGUgXSB8fFxuXHRcdFx0XHQobWF0Y2ggPSBwcmVGaWx0ZXJzWyB0eXBlIF0oIG1hdGNoICkpKSApIHtcblx0XHRcdFx0bWF0Y2hlZCA9IG1hdGNoLnNoaWZ0KCk7XG5cdFx0XHRcdHRva2Vucy5wdXNoKHtcblx0XHRcdFx0XHR2YWx1ZTogbWF0Y2hlZCxcblx0XHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRcdG1hdGNoZXM6IG1hdGNoXG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaGVkLmxlbmd0aCApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggIW1hdGNoZWQgKSB7XG5cdFx0XHRicmVhaztcblx0XHR9XG5cdH1cblxuXHQvLyBSZXR1cm4gdGhlIGxlbmd0aCBvZiB0aGUgaW52YWxpZCBleGNlc3Ncblx0Ly8gaWYgd2UncmUganVzdCBwYXJzaW5nXG5cdC8vIE90aGVyd2lzZSwgdGhyb3cgYW4gZXJyb3Igb3IgcmV0dXJuIHRva2Vuc1xuXHRyZXR1cm4gcGFyc2VPbmx5ID9cblx0XHRzb0Zhci5sZW5ndGggOlxuXHRcdHNvRmFyID9cblx0XHRcdFNpenpsZS5lcnJvciggc2VsZWN0b3IgKSA6XG5cdFx0XHQvLyBDYWNoZSB0aGUgdG9rZW5zXG5cdFx0XHR0b2tlbkNhY2hlKCBzZWxlY3RvciwgZ3JvdXBzICkuc2xpY2UoIDAgKTtcbn07XG5cbmZ1bmN0aW9uIHRvU2VsZWN0b3IoIHRva2VucyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGxlbiA9IHRva2Vucy5sZW5ndGgsXG5cdFx0c2VsZWN0b3IgPSBcIlwiO1xuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRzZWxlY3RvciArPSB0b2tlbnNbaV0udmFsdWU7XG5cdH1cblx0cmV0dXJuIHNlbGVjdG9yO1xufVxuXG5mdW5jdGlvbiBhZGRDb21iaW5hdG9yKCBtYXRjaGVyLCBjb21iaW5hdG9yLCBiYXNlICkge1xuXHR2YXIgZGlyID0gY29tYmluYXRvci5kaXIsXG5cdFx0c2tpcCA9IGNvbWJpbmF0b3IubmV4dCxcblx0XHRrZXkgPSBza2lwIHx8IGRpcixcblx0XHRjaGVja05vbkVsZW1lbnRzID0gYmFzZSAmJiBrZXkgPT09IFwicGFyZW50Tm9kZVwiLFxuXHRcdGRvbmVOYW1lID0gZG9uZSsrO1xuXG5cdHJldHVybiBjb21iaW5hdG9yLmZpcnN0ID9cblx0XHQvLyBDaGVjayBhZ2FpbnN0IGNsb3Nlc3QgYW5jZXN0b3IvcHJlY2VkaW5nIGVsZW1lbnRcblx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0d2hpbGUgKCAoZWxlbSA9IGVsZW1bIGRpciBdKSApIHtcblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fSA6XG5cblx0XHQvLyBDaGVjayBhZ2FpbnN0IGFsbCBhbmNlc3Rvci9wcmVjZWRpbmcgZWxlbWVudHNcblx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0dmFyIG9sZENhY2hlLCB1bmlxdWVDYWNoZSwgb3V0ZXJDYWNoZSxcblx0XHRcdFx0bmV3Q2FjaGUgPSBbIGRpcnJ1bnMsIGRvbmVOYW1lIF07XG5cblx0XHRcdC8vIFdlIGNhbid0IHNldCBhcmJpdHJhcnkgZGF0YSBvbiBYTUwgbm9kZXMsIHNvIHRoZXkgZG9uJ3QgYmVuZWZpdCBmcm9tIGNvbWJpbmF0b3IgY2FjaGluZ1xuXHRcdFx0aWYgKCB4bWwgKSB7XG5cdFx0XHRcdHdoaWxlICggKGVsZW0gPSBlbGVtWyBkaXIgXSkgKSB7XG5cdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHdoaWxlICggKGVsZW0gPSBlbGVtWyBkaXIgXSkgKSB7XG5cdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMgKSB7XG5cdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gZWxlbVsgZXhwYW5kbyBdIHx8IChlbGVtWyBleHBhbmRvIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcblx0XHRcdFx0XHRcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuXHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBlbGVtLnVuaXF1ZUlEIF0gfHwgKG91dGVyQ2FjaGVbIGVsZW0udW5pcXVlSUQgXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0aWYgKCBza2lwICYmIHNraXAgPT09IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSApIHtcblx0XHRcdFx0XHRcdFx0ZWxlbSA9IGVsZW1bIGRpciBdIHx8IGVsZW07XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCAob2xkQ2FjaGUgPSB1bmlxdWVDYWNoZVsga2V5IF0pICYmXG5cdFx0XHRcdFx0XHRcdG9sZENhY2hlWyAwIF0gPT09IGRpcnJ1bnMgJiYgb2xkQ2FjaGVbIDEgXSA9PT0gZG9uZU5hbWUgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gQXNzaWduIHRvIG5ld0NhY2hlIHNvIHJlc3VsdHMgYmFjay1wcm9wYWdhdGUgdG8gcHJldmlvdXMgZWxlbWVudHNcblx0XHRcdFx0XHRcdFx0cmV0dXJuIChuZXdDYWNoZVsgMiBdID0gb2xkQ2FjaGVbIDIgXSk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHQvLyBSZXVzZSBuZXdjYWNoZSBzbyByZXN1bHRzIGJhY2stcHJvcGFnYXRlIHRvIHByZXZpb3VzIGVsZW1lbnRzXG5cdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlWyBrZXkgXSA9IG5ld0NhY2hlO1xuXG5cdFx0XHRcdFx0XHRcdC8vIEEgbWF0Y2ggbWVhbnMgd2UncmUgZG9uZTsgYSBmYWlsIG1lYW5zIHdlIGhhdmUgdG8ga2VlcCBjaGVja2luZ1xuXHRcdFx0XHRcdFx0XHRpZiAoIChuZXdDYWNoZVsgMiBdID0gbWF0Y2hlciggZWxlbSwgY29udGV4dCwgeG1sICkpICkge1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcbn1cblxuZnVuY3Rpb24gZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICkge1xuXHRyZXR1cm4gbWF0Y2hlcnMubGVuZ3RoID4gMSA/XG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHZhciBpID0gbWF0Y2hlcnMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggIW1hdGNoZXJzW2ldKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0gOlxuXHRcdG1hdGNoZXJzWzBdO1xufVxuXG5mdW5jdGlvbiBtdWx0aXBsZUNvbnRleHRzKCBzZWxlY3RvciwgY29udGV4dHMsIHJlc3VsdHMgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsZW4gPSBjb250ZXh0cy5sZW5ndGg7XG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFNpenpsZSggc2VsZWN0b3IsIGNvbnRleHRzW2ldLCByZXN1bHRzICk7XG5cdH1cblx0cmV0dXJuIHJlc3VsdHM7XG59XG5cbmZ1bmN0aW9uIGNvbmRlbnNlKCB1bm1hdGNoZWQsIG1hcCwgZmlsdGVyLCBjb250ZXh0LCB4bWwgKSB7XG5cdHZhciBlbGVtLFxuXHRcdG5ld1VubWF0Y2hlZCA9IFtdLFxuXHRcdGkgPSAwLFxuXHRcdGxlbiA9IHVubWF0Y2hlZC5sZW5ndGgsXG5cdFx0bWFwcGVkID0gbWFwICE9IG51bGw7XG5cblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0aWYgKCAoZWxlbSA9IHVubWF0Y2hlZFtpXSkgKSB7XG5cdFx0XHRpZiAoICFmaWx0ZXIgfHwgZmlsdGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcblx0XHRcdFx0bmV3VW5tYXRjaGVkLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0aWYgKCBtYXBwZWQgKSB7XG5cdFx0XHRcdFx0bWFwLnB1c2goIGkgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBuZXdVbm1hdGNoZWQ7XG59XG5cbmZ1bmN0aW9uIHNldE1hdGNoZXIoIHByZUZpbHRlciwgc2VsZWN0b3IsIG1hdGNoZXIsIHBvc3RGaWx0ZXIsIHBvc3RGaW5kZXIsIHBvc3RTZWxlY3RvciApIHtcblx0aWYgKCBwb3N0RmlsdGVyICYmICFwb3N0RmlsdGVyWyBleHBhbmRvIF0gKSB7XG5cdFx0cG9zdEZpbHRlciA9IHNldE1hdGNoZXIoIHBvc3RGaWx0ZXIgKTtcblx0fVxuXHRpZiAoIHBvc3RGaW5kZXIgJiYgIXBvc3RGaW5kZXJbIGV4cGFuZG8gXSApIHtcblx0XHRwb3N0RmluZGVyID0gc2V0TWF0Y2hlciggcG9zdEZpbmRlciwgcG9zdFNlbGVjdG9yICk7XG5cdH1cblx0cmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgcmVzdWx0cywgY29udGV4dCwgeG1sICkge1xuXHRcdHZhciB0ZW1wLCBpLCBlbGVtLFxuXHRcdFx0cHJlTWFwID0gW10sXG5cdFx0XHRwb3N0TWFwID0gW10sXG5cdFx0XHRwcmVleGlzdGluZyA9IHJlc3VsdHMubGVuZ3RoLFxuXG5cdFx0XHQvLyBHZXQgaW5pdGlhbCBlbGVtZW50cyBmcm9tIHNlZWQgb3IgY29udGV4dFxuXHRcdFx0ZWxlbXMgPSBzZWVkIHx8IG11bHRpcGxlQ29udGV4dHMoIHNlbGVjdG9yIHx8IFwiKlwiLCBjb250ZXh0Lm5vZGVUeXBlID8gWyBjb250ZXh0IF0gOiBjb250ZXh0LCBbXSApLFxuXG5cdFx0XHQvLyBQcmVmaWx0ZXIgdG8gZ2V0IG1hdGNoZXIgaW5wdXQsIHByZXNlcnZpbmcgYSBtYXAgZm9yIHNlZWQtcmVzdWx0cyBzeW5jaHJvbml6YXRpb25cblx0XHRcdG1hdGNoZXJJbiA9IHByZUZpbHRlciAmJiAoIHNlZWQgfHwgIXNlbGVjdG9yICkgP1xuXHRcdFx0XHRjb25kZW5zZSggZWxlbXMsIHByZU1hcCwgcHJlRmlsdGVyLCBjb250ZXh0LCB4bWwgKSA6XG5cdFx0XHRcdGVsZW1zLFxuXG5cdFx0XHRtYXRjaGVyT3V0ID0gbWF0Y2hlciA/XG5cdFx0XHRcdC8vIElmIHdlIGhhdmUgYSBwb3N0RmluZGVyLCBvciBmaWx0ZXJlZCBzZWVkLCBvciBub24tc2VlZCBwb3N0RmlsdGVyIG9yIHByZWV4aXN0aW5nIHJlc3VsdHMsXG5cdFx0XHRcdHBvc3RGaW5kZXIgfHwgKCBzZWVkID8gcHJlRmlsdGVyIDogcHJlZXhpc3RpbmcgfHwgcG9zdEZpbHRlciApID9cblxuXHRcdFx0XHRcdC8vIC4uLmludGVybWVkaWF0ZSBwcm9jZXNzaW5nIGlzIG5lY2Vzc2FyeVxuXHRcdFx0XHRcdFtdIDpcblxuXHRcdFx0XHRcdC8vIC4uLm90aGVyd2lzZSB1c2UgcmVzdWx0cyBkaXJlY3RseVxuXHRcdFx0XHRcdHJlc3VsdHMgOlxuXHRcdFx0XHRtYXRjaGVySW47XG5cblx0XHQvLyBGaW5kIHByaW1hcnkgbWF0Y2hlc1xuXHRcdGlmICggbWF0Y2hlciApIHtcblx0XHRcdG1hdGNoZXIoIG1hdGNoZXJJbiwgbWF0Y2hlck91dCwgY29udGV4dCwgeG1sICk7XG5cdFx0fVxuXG5cdFx0Ly8gQXBwbHkgcG9zdEZpbHRlclxuXHRcdGlmICggcG9zdEZpbHRlciApIHtcblx0XHRcdHRlbXAgPSBjb25kZW5zZSggbWF0Y2hlck91dCwgcG9zdE1hcCApO1xuXHRcdFx0cG9zdEZpbHRlciggdGVtcCwgW10sIGNvbnRleHQsIHhtbCApO1xuXG5cdFx0XHQvLyBVbi1tYXRjaCBmYWlsaW5nIGVsZW1lbnRzIGJ5IG1vdmluZyB0aGVtIGJhY2sgdG8gbWF0Y2hlckluXG5cdFx0XHRpID0gdGVtcC5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aWYgKCAoZWxlbSA9IHRlbXBbaV0pICkge1xuXHRcdFx0XHRcdG1hdGNoZXJPdXRbIHBvc3RNYXBbaV0gXSA9ICEobWF0Y2hlckluWyBwb3N0TWFwW2ldIF0gPSBlbGVtKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggc2VlZCApIHtcblx0XHRcdGlmICggcG9zdEZpbmRlciB8fCBwcmVGaWx0ZXIgKSB7XG5cdFx0XHRcdGlmICggcG9zdEZpbmRlciApIHtcblx0XHRcdFx0XHQvLyBHZXQgdGhlIGZpbmFsIG1hdGNoZXJPdXQgYnkgY29uZGVuc2luZyB0aGlzIGludGVybWVkaWF0ZSBpbnRvIHBvc3RGaW5kZXIgY29udGV4dHNcblx0XHRcdFx0XHR0ZW1wID0gW107XG5cdFx0XHRcdFx0aSA9IG1hdGNoZXJPdXQubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0aWYgKCAoZWxlbSA9IG1hdGNoZXJPdXRbaV0pICkge1xuXHRcdFx0XHRcdFx0XHQvLyBSZXN0b3JlIG1hdGNoZXJJbiBzaW5jZSBlbGVtIGlzIG5vdCB5ZXQgYSBmaW5hbCBtYXRjaFxuXHRcdFx0XHRcdFx0XHR0ZW1wLnB1c2goIChtYXRjaGVySW5baV0gPSBlbGVtKSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwb3N0RmluZGVyKCBudWxsLCAobWF0Y2hlck91dCA9IFtdKSwgdGVtcCwgeG1sICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBNb3ZlIG1hdGNoZWQgZWxlbWVudHMgZnJvbSBzZWVkIHRvIHJlc3VsdHMgdG8ga2VlcCB0aGVtIHN5bmNocm9uaXplZFxuXHRcdFx0XHRpID0gbWF0Y2hlck91dC5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdGlmICggKGVsZW0gPSBtYXRjaGVyT3V0W2ldKSAmJlxuXHRcdFx0XHRcdFx0KHRlbXAgPSBwb3N0RmluZGVyID8gaW5kZXhPZiggc2VlZCwgZWxlbSApIDogcHJlTWFwW2ldKSA+IC0xICkge1xuXG5cdFx0XHRcdFx0XHRzZWVkW3RlbXBdID0gIShyZXN1bHRzW3RlbXBdID0gZWxlbSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHQvLyBBZGQgZWxlbWVudHMgdG8gcmVzdWx0cywgdGhyb3VnaCBwb3N0RmluZGVyIGlmIGRlZmluZWRcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWF0Y2hlck91dCA9IGNvbmRlbnNlKFxuXHRcdFx0XHRtYXRjaGVyT3V0ID09PSByZXN1bHRzID9cblx0XHRcdFx0XHRtYXRjaGVyT3V0LnNwbGljZSggcHJlZXhpc3RpbmcsIG1hdGNoZXJPdXQubGVuZ3RoICkgOlxuXHRcdFx0XHRcdG1hdGNoZXJPdXRcblx0XHRcdCk7XG5cdFx0XHRpZiAoIHBvc3RGaW5kZXIgKSB7XG5cdFx0XHRcdHBvc3RGaW5kZXIoIG51bGwsIHJlc3VsdHMsIG1hdGNoZXJPdXQsIHhtbCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgbWF0Y2hlck91dCApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG59XG5cbmZ1bmN0aW9uIG1hdGNoZXJGcm9tVG9rZW5zKCB0b2tlbnMgKSB7XG5cdHZhciBjaGVja0NvbnRleHQsIG1hdGNoZXIsIGosXG5cdFx0bGVuID0gdG9rZW5zLmxlbmd0aCxcblx0XHRsZWFkaW5nUmVsYXRpdmUgPSBFeHByLnJlbGF0aXZlWyB0b2tlbnNbMF0udHlwZSBdLFxuXHRcdGltcGxpY2l0UmVsYXRpdmUgPSBsZWFkaW5nUmVsYXRpdmUgfHwgRXhwci5yZWxhdGl2ZVtcIiBcIl0sXG5cdFx0aSA9IGxlYWRpbmdSZWxhdGl2ZSA/IDEgOiAwLFxuXG5cdFx0Ly8gVGhlIGZvdW5kYXRpb25hbCBtYXRjaGVyIGVuc3VyZXMgdGhhdCBlbGVtZW50cyBhcmUgcmVhY2hhYmxlIGZyb20gdG9wLWxldmVsIGNvbnRleHQocylcblx0XHRtYXRjaENvbnRleHQgPSBhZGRDb21iaW5hdG9yKCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtID09PSBjaGVja0NvbnRleHQ7XG5cdFx0fSwgaW1wbGljaXRSZWxhdGl2ZSwgdHJ1ZSApLFxuXHRcdG1hdGNoQW55Q29udGV4dCA9IGFkZENvbWJpbmF0b3IoIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGluZGV4T2YoIGNoZWNrQ29udGV4dCwgZWxlbSApID4gLTE7XG5cdFx0fSwgaW1wbGljaXRSZWxhdGl2ZSwgdHJ1ZSApLFxuXHRcdG1hdGNoZXJzID0gWyBmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0dmFyIHJldCA9ICggIWxlYWRpbmdSZWxhdGl2ZSAmJiAoIHhtbCB8fCBjb250ZXh0ICE9PSBvdXRlcm1vc3RDb250ZXh0ICkgKSB8fCAoXG5cdFx0XHRcdChjaGVja0NvbnRleHQgPSBjb250ZXh0KS5ub2RlVHlwZSA/XG5cdFx0XHRcdFx0bWF0Y2hDb250ZXh0KCBlbGVtLCBjb250ZXh0LCB4bWwgKSA6XG5cdFx0XHRcdFx0bWF0Y2hBbnlDb250ZXh0KCBlbGVtLCBjb250ZXh0LCB4bWwgKSApO1xuXHRcdFx0Ly8gQXZvaWQgaGFuZ2luZyBvbnRvIGVsZW1lbnQgKGlzc3VlICMyOTkpXG5cdFx0XHRjaGVja0NvbnRleHQgPSBudWxsO1xuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9IF07XG5cblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0aWYgKCAobWF0Y2hlciA9IEV4cHIucmVsYXRpdmVbIHRva2Vuc1tpXS50eXBlIF0pICkge1xuXHRcdFx0bWF0Y2hlcnMgPSBbIGFkZENvbWJpbmF0b3IoZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICksIG1hdGNoZXIpIF07XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1hdGNoZXIgPSBFeHByLmZpbHRlclsgdG9rZW5zW2ldLnR5cGUgXS5hcHBseSggbnVsbCwgdG9rZW5zW2ldLm1hdGNoZXMgKTtcblxuXHRcdFx0Ly8gUmV0dXJuIHNwZWNpYWwgdXBvbiBzZWVpbmcgYSBwb3NpdGlvbmFsIG1hdGNoZXJcblx0XHRcdGlmICggbWF0Y2hlclsgZXhwYW5kbyBdICkge1xuXHRcdFx0XHQvLyBGaW5kIHRoZSBuZXh0IHJlbGF0aXZlIG9wZXJhdG9yIChpZiBhbnkpIGZvciBwcm9wZXIgaGFuZGxpbmdcblx0XHRcdFx0aiA9ICsraTtcblx0XHRcdFx0Zm9yICggOyBqIDwgbGVuOyBqKysgKSB7XG5cdFx0XHRcdFx0aWYgKCBFeHByLnJlbGF0aXZlWyB0b2tlbnNbal0udHlwZSBdICkge1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBzZXRNYXRjaGVyKFxuXHRcdFx0XHRcdGkgPiAxICYmIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApLFxuXHRcdFx0XHRcdGkgPiAxICYmIHRvU2VsZWN0b3IoXG5cdFx0XHRcdFx0XHQvLyBJZiB0aGUgcHJlY2VkaW5nIHRva2VuIHdhcyBhIGRlc2NlbmRhbnQgY29tYmluYXRvciwgaW5zZXJ0IGFuIGltcGxpY2l0IGFueS1lbGVtZW50IGAqYFxuXHRcdFx0XHRcdFx0dG9rZW5zLnNsaWNlKCAwLCBpIC0gMSApLmNvbmNhdCh7IHZhbHVlOiB0b2tlbnNbIGkgLSAyIF0udHlwZSA9PT0gXCIgXCIgPyBcIipcIiA6IFwiXCIgfSlcblx0XHRcdFx0XHQpLnJlcGxhY2UoIHJ0cmltLCBcIiQxXCIgKSxcblx0XHRcdFx0XHRtYXRjaGVyLFxuXHRcdFx0XHRcdGkgPCBqICYmIG1hdGNoZXJGcm9tVG9rZW5zKCB0b2tlbnMuc2xpY2UoIGksIGogKSApLFxuXHRcdFx0XHRcdGogPCBsZW4gJiYgbWF0Y2hlckZyb21Ub2tlbnMoICh0b2tlbnMgPSB0b2tlbnMuc2xpY2UoIGogKSkgKSxcblx0XHRcdFx0XHRqIDwgbGVuICYmIHRvU2VsZWN0b3IoIHRva2VucyApXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0XHRtYXRjaGVycy5wdXNoKCBtYXRjaGVyICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApO1xufVxuXG5mdW5jdGlvbiBtYXRjaGVyRnJvbUdyb3VwTWF0Y2hlcnMoIGVsZW1lbnRNYXRjaGVycywgc2V0TWF0Y2hlcnMgKSB7XG5cdHZhciBieVNldCA9IHNldE1hdGNoZXJzLmxlbmd0aCA+IDAsXG5cdFx0YnlFbGVtZW50ID0gZWxlbWVudE1hdGNoZXJzLmxlbmd0aCA+IDAsXG5cdFx0c3VwZXJNYXRjaGVyID0gZnVuY3Rpb24oIHNlZWQsIGNvbnRleHQsIHhtbCwgcmVzdWx0cywgb3V0ZXJtb3N0ICkge1xuXHRcdFx0dmFyIGVsZW0sIGosIG1hdGNoZXIsXG5cdFx0XHRcdG1hdGNoZWRDb3VudCA9IDAsXG5cdFx0XHRcdGkgPSBcIjBcIixcblx0XHRcdFx0dW5tYXRjaGVkID0gc2VlZCAmJiBbXSxcblx0XHRcdFx0c2V0TWF0Y2hlZCA9IFtdLFxuXHRcdFx0XHRjb250ZXh0QmFja3VwID0gb3V0ZXJtb3N0Q29udGV4dCxcblx0XHRcdFx0Ly8gV2UgbXVzdCBhbHdheXMgaGF2ZSBlaXRoZXIgc2VlZCBlbGVtZW50cyBvciBvdXRlcm1vc3QgY29udGV4dFxuXHRcdFx0XHRlbGVtcyA9IHNlZWQgfHwgYnlFbGVtZW50ICYmIEV4cHIuZmluZFtcIlRBR1wiXSggXCIqXCIsIG91dGVybW9zdCApLFxuXHRcdFx0XHQvLyBVc2UgaW50ZWdlciBkaXJydW5zIGlmZiB0aGlzIGlzIHRoZSBvdXRlcm1vc3QgbWF0Y2hlclxuXHRcdFx0XHRkaXJydW5zVW5pcXVlID0gKGRpcnJ1bnMgKz0gY29udGV4dEJhY2t1cCA9PSBudWxsID8gMSA6IE1hdGgucmFuZG9tKCkgfHwgMC4xKSxcblx0XHRcdFx0bGVuID0gZWxlbXMubGVuZ3RoO1xuXG5cdFx0XHRpZiAoIG91dGVybW9zdCApIHtcblx0XHRcdFx0b3V0ZXJtb3N0Q29udGV4dCA9IGNvbnRleHQgPT09IGRvY3VtZW50IHx8IGNvbnRleHQgfHwgb3V0ZXJtb3N0O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgZWxlbWVudHMgcGFzc2luZyBlbGVtZW50TWF0Y2hlcnMgZGlyZWN0bHkgdG8gcmVzdWx0c1xuXHRcdFx0Ly8gU3VwcG9ydDogSUU8OSwgU2FmYXJpXG5cdFx0XHQvLyBUb2xlcmF0ZSBOb2RlTGlzdCBwcm9wZXJ0aWVzIChJRTogXCJsZW5ndGhcIjsgU2FmYXJpOiA8bnVtYmVyPikgbWF0Y2hpbmcgZWxlbWVudHMgYnkgaWRcblx0XHRcdGZvciAoIDsgaSAhPT0gbGVuICYmIChlbGVtID0gZWxlbXNbaV0pICE9IG51bGw7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBieUVsZW1lbnQgJiYgZWxlbSApIHtcblx0XHRcdFx0XHRqID0gMDtcblx0XHRcdFx0XHRpZiAoICFjb250ZXh0ICYmIGVsZW0ub3duZXJEb2N1bWVudCAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0XHRcdFx0XHRzZXREb2N1bWVudCggZWxlbSApO1xuXHRcdFx0XHRcdFx0eG1sID0gIWRvY3VtZW50SXNIVE1MO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR3aGlsZSAoIChtYXRjaGVyID0gZWxlbWVudE1hdGNoZXJzW2orK10pICkge1xuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVyKCBlbGVtLCBjb250ZXh0IHx8IGRvY3VtZW50LCB4bWwpICkge1xuXHRcdFx0XHRcdFx0XHRyZXN1bHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggb3V0ZXJtb3N0ICkge1xuXHRcdFx0XHRcdFx0ZGlycnVucyA9IGRpcnJ1bnNVbmlxdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gVHJhY2sgdW5tYXRjaGVkIGVsZW1lbnRzIGZvciBzZXQgZmlsdGVyc1xuXHRcdFx0XHRpZiAoIGJ5U2V0ICkge1xuXHRcdFx0XHRcdC8vIFRoZXkgd2lsbCBoYXZlIGdvbmUgdGhyb3VnaCBhbGwgcG9zc2libGUgbWF0Y2hlcnNcblx0XHRcdFx0XHRpZiAoIChlbGVtID0gIW1hdGNoZXIgJiYgZWxlbSkgKSB7XG5cdFx0XHRcdFx0XHRtYXRjaGVkQ291bnQtLTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBMZW5ndGhlbiB0aGUgYXJyYXkgZm9yIGV2ZXJ5IGVsZW1lbnQsIG1hdGNoZWQgb3Igbm90XG5cdFx0XHRcdFx0aWYgKCBzZWVkICkge1xuXHRcdFx0XHRcdFx0dW5tYXRjaGVkLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gYGlgIGlzIG5vdyB0aGUgY291bnQgb2YgZWxlbWVudHMgdmlzaXRlZCBhYm92ZSwgYW5kIGFkZGluZyBpdCB0byBgbWF0Y2hlZENvdW50YFxuXHRcdFx0Ly8gbWFrZXMgdGhlIGxhdHRlciBub25uZWdhdGl2ZS5cblx0XHRcdG1hdGNoZWRDb3VudCArPSBpO1xuXG5cdFx0XHQvLyBBcHBseSBzZXQgZmlsdGVycyB0byB1bm1hdGNoZWQgZWxlbWVudHNcblx0XHRcdC8vIE5PVEU6IFRoaXMgY2FuIGJlIHNraXBwZWQgaWYgdGhlcmUgYXJlIG5vIHVubWF0Y2hlZCBlbGVtZW50cyAoaS5lLiwgYG1hdGNoZWRDb3VudGBcblx0XHRcdC8vIGVxdWFscyBgaWApLCB1bmxlc3Mgd2UgZGlkbid0IHZpc2l0IF9hbnlfIGVsZW1lbnRzIGluIHRoZSBhYm92ZSBsb29wIGJlY2F1c2Ugd2UgaGF2ZVxuXHRcdFx0Ly8gbm8gZWxlbWVudCBtYXRjaGVycyBhbmQgbm8gc2VlZC5cblx0XHRcdC8vIEluY3JlbWVudGluZyBhbiBpbml0aWFsbHktc3RyaW5nIFwiMFwiIGBpYCBhbGxvd3MgYGlgIHRvIHJlbWFpbiBhIHN0cmluZyBvbmx5IGluIHRoYXRcblx0XHRcdC8vIGNhc2UsIHdoaWNoIHdpbGwgcmVzdWx0IGluIGEgXCIwMFwiIGBtYXRjaGVkQ291bnRgIHRoYXQgZGlmZmVycyBmcm9tIGBpYCBidXQgaXMgYWxzb1xuXHRcdFx0Ly8gbnVtZXJpY2FsbHkgemVyby5cblx0XHRcdGlmICggYnlTZXQgJiYgaSAhPT0gbWF0Y2hlZENvdW50ICkge1xuXHRcdFx0XHRqID0gMDtcblx0XHRcdFx0d2hpbGUgKCAobWF0Y2hlciA9IHNldE1hdGNoZXJzW2orK10pICkge1xuXHRcdFx0XHRcdG1hdGNoZXIoIHVubWF0Y2hlZCwgc2V0TWF0Y2hlZCwgY29udGV4dCwgeG1sICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIHNlZWQgKSB7XG5cdFx0XHRcdFx0Ly8gUmVpbnRlZ3JhdGUgZWxlbWVudCBtYXRjaGVzIHRvIGVsaW1pbmF0ZSB0aGUgbmVlZCBmb3Igc29ydGluZ1xuXHRcdFx0XHRcdGlmICggbWF0Y2hlZENvdW50ID4gMCApIHtcblx0XHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0XHRpZiAoICEodW5tYXRjaGVkW2ldIHx8IHNldE1hdGNoZWRbaV0pICkge1xuXHRcdFx0XHRcdFx0XHRcdHNldE1hdGNoZWRbaV0gPSBwb3AuY2FsbCggcmVzdWx0cyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gRGlzY2FyZCBpbmRleCBwbGFjZWhvbGRlciB2YWx1ZXMgdG8gZ2V0IG9ubHkgYWN0dWFsIG1hdGNoZXNcblx0XHRcdFx0XHRzZXRNYXRjaGVkID0gY29uZGVuc2UoIHNldE1hdGNoZWQgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEFkZCBtYXRjaGVzIHRvIHJlc3VsdHNcblx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgc2V0TWF0Y2hlZCApO1xuXG5cdFx0XHRcdC8vIFNlZWRsZXNzIHNldCBtYXRjaGVzIHN1Y2NlZWRpbmcgbXVsdGlwbGUgc3VjY2Vzc2Z1bCBtYXRjaGVycyBzdGlwdWxhdGUgc29ydGluZ1xuXHRcdFx0XHRpZiAoIG91dGVybW9zdCAmJiAhc2VlZCAmJiBzZXRNYXRjaGVkLmxlbmd0aCA+IDAgJiZcblx0XHRcdFx0XHQoIG1hdGNoZWRDb3VudCArIHNldE1hdGNoZXJzLmxlbmd0aCApID4gMSApIHtcblxuXHRcdFx0XHRcdFNpenpsZS51bmlxdWVTb3J0KCByZXN1bHRzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gT3ZlcnJpZGUgbWFuaXB1bGF0aW9uIG9mIGdsb2JhbHMgYnkgbmVzdGVkIG1hdGNoZXJzXG5cdFx0XHRpZiAoIG91dGVybW9zdCApIHtcblx0XHRcdFx0ZGlycnVucyA9IGRpcnJ1bnNVbmlxdWU7XG5cdFx0XHRcdG91dGVybW9zdENvbnRleHQgPSBjb250ZXh0QmFja3VwO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdW5tYXRjaGVkO1xuXHRcdH07XG5cblx0cmV0dXJuIGJ5U2V0ID9cblx0XHRtYXJrRnVuY3Rpb24oIHN1cGVyTWF0Y2hlciApIDpcblx0XHRzdXBlck1hdGNoZXI7XG59XG5cbmNvbXBpbGUgPSBTaXp6bGUuY29tcGlsZSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgbWF0Y2ggLyogSW50ZXJuYWwgVXNlIE9ubHkgKi8gKSB7XG5cdHZhciBpLFxuXHRcdHNldE1hdGNoZXJzID0gW10sXG5cdFx0ZWxlbWVudE1hdGNoZXJzID0gW10sXG5cdFx0Y2FjaGVkID0gY29tcGlsZXJDYWNoZVsgc2VsZWN0b3IgKyBcIiBcIiBdO1xuXG5cdGlmICggIWNhY2hlZCApIHtcblx0XHQvLyBHZW5lcmF0ZSBhIGZ1bmN0aW9uIG9mIHJlY3Vyc2l2ZSBmdW5jdGlvbnMgdGhhdCBjYW4gYmUgdXNlZCB0byBjaGVjayBlYWNoIGVsZW1lbnRcblx0XHRpZiAoICFtYXRjaCApIHtcblx0XHRcdG1hdGNoID0gdG9rZW5pemUoIHNlbGVjdG9yICk7XG5cdFx0fVxuXHRcdGkgPSBtYXRjaC5sZW5ndGg7XG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRjYWNoZWQgPSBtYXRjaGVyRnJvbVRva2VucyggbWF0Y2hbaV0gKTtcblx0XHRcdGlmICggY2FjaGVkWyBleHBhbmRvIF0gKSB7XG5cdFx0XHRcdHNldE1hdGNoZXJzLnB1c2goIGNhY2hlZCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWxlbWVudE1hdGNoZXJzLnB1c2goIGNhY2hlZCApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENhY2hlIHRoZSBjb21waWxlZCBmdW5jdGlvblxuXHRcdGNhY2hlZCA9IGNvbXBpbGVyQ2FjaGUoIHNlbGVjdG9yLCBtYXRjaGVyRnJvbUdyb3VwTWF0Y2hlcnMoIGVsZW1lbnRNYXRjaGVycywgc2V0TWF0Y2hlcnMgKSApO1xuXG5cdFx0Ly8gU2F2ZSBzZWxlY3RvciBhbmQgdG9rZW5pemF0aW9uXG5cdFx0Y2FjaGVkLnNlbGVjdG9yID0gc2VsZWN0b3I7XG5cdH1cblx0cmV0dXJuIGNhY2hlZDtcbn07XG5cbi8qKlxuICogQSBsb3ctbGV2ZWwgc2VsZWN0aW9uIGZ1bmN0aW9uIHRoYXQgd29ya3Mgd2l0aCBTaXp6bGUncyBjb21waWxlZFxuICogIHNlbGVjdG9yIGZ1bmN0aW9uc1xuICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IHNlbGVjdG9yIEEgc2VsZWN0b3Igb3IgYSBwcmUtY29tcGlsZWRcbiAqICBzZWxlY3RvciBmdW5jdGlvbiBidWlsdCB3aXRoIFNpenpsZS5jb21waWxlXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGNvbnRleHRcbiAqIEBwYXJhbSB7QXJyYXl9IFtyZXN1bHRzXVxuICogQHBhcmFtIHtBcnJheX0gW3NlZWRdIEEgc2V0IG9mIGVsZW1lbnRzIHRvIG1hdGNoIGFnYWluc3RcbiAqL1xuc2VsZWN0ID0gU2l6emxlLnNlbGVjdCA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCwgcmVzdWx0cywgc2VlZCApIHtcblx0dmFyIGksIHRva2VucywgdG9rZW4sIHR5cGUsIGZpbmQsXG5cdFx0Y29tcGlsZWQgPSB0eXBlb2Ygc2VsZWN0b3IgPT09IFwiZnVuY3Rpb25cIiAmJiBzZWxlY3Rvcixcblx0XHRtYXRjaCA9ICFzZWVkICYmIHRva2VuaXplKCAoc2VsZWN0b3IgPSBjb21waWxlZC5zZWxlY3RvciB8fCBzZWxlY3RvcikgKTtcblxuXHRyZXN1bHRzID0gcmVzdWx0cyB8fCBbXTtcblxuXHQvLyBUcnkgdG8gbWluaW1pemUgb3BlcmF0aW9ucyBpZiB0aGVyZSBpcyBvbmx5IG9uZSBzZWxlY3RvciBpbiB0aGUgbGlzdCBhbmQgbm8gc2VlZFxuXHQvLyAodGhlIGxhdHRlciBvZiB3aGljaCBndWFyYW50ZWVzIHVzIGNvbnRleHQpXG5cdGlmICggbWF0Y2gubGVuZ3RoID09PSAxICkge1xuXG5cdFx0Ly8gUmVkdWNlIGNvbnRleHQgaWYgdGhlIGxlYWRpbmcgY29tcG91bmQgc2VsZWN0b3IgaXMgYW4gSURcblx0XHR0b2tlbnMgPSBtYXRjaFswXSA9IG1hdGNoWzBdLnNsaWNlKCAwICk7XG5cdFx0aWYgKCB0b2tlbnMubGVuZ3RoID4gMiAmJiAodG9rZW4gPSB0b2tlbnNbMF0pLnR5cGUgPT09IFwiSURcIiAmJlxuXHRcdFx0XHRjb250ZXh0Lm5vZGVUeXBlID09PSA5ICYmIGRvY3VtZW50SXNIVE1MICYmIEV4cHIucmVsYXRpdmVbIHRva2Vuc1sxXS50eXBlIF0gKSB7XG5cblx0XHRcdGNvbnRleHQgPSAoIEV4cHIuZmluZFtcIklEXCJdKCB0b2tlbi5tYXRjaGVzWzBdLnJlcGxhY2UocnVuZXNjYXBlLCBmdW5lc2NhcGUpLCBjb250ZXh0ICkgfHwgW10gKVswXTtcblx0XHRcdGlmICggIWNvbnRleHQgKSB7XG5cdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXG5cdFx0XHQvLyBQcmVjb21waWxlZCBtYXRjaGVycyB3aWxsIHN0aWxsIHZlcmlmeSBhbmNlc3RyeSwgc28gc3RlcCB1cCBhIGxldmVsXG5cdFx0XHR9IGVsc2UgaWYgKCBjb21waWxlZCApIHtcblx0XHRcdFx0Y29udGV4dCA9IGNvbnRleHQucGFyZW50Tm9kZTtcblx0XHRcdH1cblxuXHRcdFx0c2VsZWN0b3IgPSBzZWxlY3Rvci5zbGljZSggdG9rZW5zLnNoaWZ0KCkudmFsdWUubGVuZ3RoICk7XG5cdFx0fVxuXG5cdFx0Ly8gRmV0Y2ggYSBzZWVkIHNldCBmb3IgcmlnaHQtdG8tbGVmdCBtYXRjaGluZ1xuXHRcdGkgPSBtYXRjaEV4cHJbXCJuZWVkc0NvbnRleHRcIl0udGVzdCggc2VsZWN0b3IgKSA/IDAgOiB0b2tlbnMubGVuZ3RoO1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0dG9rZW4gPSB0b2tlbnNbaV07XG5cblx0XHRcdC8vIEFib3J0IGlmIHdlIGhpdCBhIGNvbWJpbmF0b3Jcblx0XHRcdGlmICggRXhwci5yZWxhdGl2ZVsgKHR5cGUgPSB0b2tlbi50eXBlKSBdICkge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGlmICggKGZpbmQgPSBFeHByLmZpbmRbIHR5cGUgXSkgKSB7XG5cdFx0XHRcdC8vIFNlYXJjaCwgZXhwYW5kaW5nIGNvbnRleHQgZm9yIGxlYWRpbmcgc2libGluZyBjb21iaW5hdG9yc1xuXHRcdFx0XHRpZiAoIChzZWVkID0gZmluZChcblx0XHRcdFx0XHR0b2tlbi5tYXRjaGVzWzBdLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICksXG5cdFx0XHRcdFx0cnNpYmxpbmcudGVzdCggdG9rZW5zWzBdLnR5cGUgKSAmJiB0ZXN0Q29udGV4dCggY29udGV4dC5wYXJlbnROb2RlICkgfHwgY29udGV4dFxuXHRcdFx0XHQpKSApIHtcblxuXHRcdFx0XHRcdC8vIElmIHNlZWQgaXMgZW1wdHkgb3Igbm8gdG9rZW5zIHJlbWFpbiwgd2UgY2FuIHJldHVybiBlYXJseVxuXHRcdFx0XHRcdHRva2Vucy5zcGxpY2UoIGksIDEgKTtcblx0XHRcdFx0XHRzZWxlY3RvciA9IHNlZWQubGVuZ3RoICYmIHRvU2VsZWN0b3IoIHRva2VucyApO1xuXHRcdFx0XHRcdGlmICggIXNlbGVjdG9yICkge1xuXHRcdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgc2VlZCApO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBDb21waWxlIGFuZCBleGVjdXRlIGEgZmlsdGVyaW5nIGZ1bmN0aW9uIGlmIG9uZSBpcyBub3QgcHJvdmlkZWRcblx0Ly8gUHJvdmlkZSBgbWF0Y2hgIHRvIGF2b2lkIHJldG9rZW5pemF0aW9uIGlmIHdlIG1vZGlmaWVkIHRoZSBzZWxlY3RvciBhYm92ZVxuXHQoIGNvbXBpbGVkIHx8IGNvbXBpbGUoIHNlbGVjdG9yLCBtYXRjaCApICkoXG5cdFx0c2VlZCxcblx0XHRjb250ZXh0LFxuXHRcdCFkb2N1bWVudElzSFRNTCxcblx0XHRyZXN1bHRzLFxuXHRcdCFjb250ZXh0IHx8IHJzaWJsaW5nLnRlc3QoIHNlbGVjdG9yICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8IGNvbnRleHRcblx0KTtcblx0cmV0dXJuIHJlc3VsdHM7XG59O1xuXG4vLyBPbmUtdGltZSBhc3NpZ25tZW50c1xuXG4vLyBTb3J0IHN0YWJpbGl0eVxuc3VwcG9ydC5zb3J0U3RhYmxlID0gZXhwYW5kby5zcGxpdChcIlwiKS5zb3J0KCBzb3J0T3JkZXIgKS5qb2luKFwiXCIpID09PSBleHBhbmRvO1xuXG4vLyBTdXBwb3J0OiBDaHJvbWUgMTQtMzUrXG4vLyBBbHdheXMgYXNzdW1lIGR1cGxpY2F0ZXMgaWYgdGhleSBhcmVuJ3QgcGFzc2VkIHRvIHRoZSBjb21wYXJpc29uIGZ1bmN0aW9uXG5zdXBwb3J0LmRldGVjdER1cGxpY2F0ZXMgPSAhIWhhc0R1cGxpY2F0ZTtcblxuLy8gSW5pdGlhbGl6ZSBhZ2FpbnN0IHRoZSBkZWZhdWx0IGRvY3VtZW50XG5zZXREb2N1bWVudCgpO1xuXG4vLyBTdXBwb3J0OiBXZWJraXQ8NTM3LjMyIC0gU2FmYXJpIDYuMC4zL0Nocm9tZSAyNSAoZml4ZWQgaW4gQ2hyb21lIDI3KVxuLy8gRGV0YWNoZWQgbm9kZXMgY29uZm91bmRpbmdseSBmb2xsb3cgKmVhY2ggb3RoZXIqXG5zdXBwb3J0LnNvcnREZXRhY2hlZCA9IGFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdC8vIFNob3VsZCByZXR1cm4gMSwgYnV0IHJldHVybnMgNCAoZm9sbG93aW5nKVxuXHRyZXR1cm4gZWwuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJmaWVsZHNldFwiKSApICYgMTtcbn0pO1xuXG4vLyBTdXBwb3J0OiBJRTw4XG4vLyBQcmV2ZW50IGF0dHJpYnV0ZS9wcm9wZXJ0eSBcImludGVycG9sYXRpb25cIlxuLy8gaHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9tczUzNjQyOSUyOFZTLjg1JTI5LmFzcHhcbmlmICggIWFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdGVsLmlubmVySFRNTCA9IFwiPGEgaHJlZj0nIyc+PC9hPlwiO1xuXHRyZXR1cm4gZWwuZmlyc3RDaGlsZC5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpID09PSBcIiNcIiA7XG59KSApIHtcblx0YWRkSGFuZGxlKCBcInR5cGV8aHJlZnxoZWlnaHR8d2lkdGhcIiwgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdGlmICggIWlzWE1MICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lLCBuYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwidHlwZVwiID8gMSA6IDIgKTtcblx0XHR9XG5cdH0pO1xufVxuXG4vLyBTdXBwb3J0OiBJRTw5XG4vLyBVc2UgZGVmYXVsdFZhbHVlIGluIHBsYWNlIG9mIGdldEF0dHJpYnV0ZShcInZhbHVlXCIpXG5pZiAoICFzdXBwb3J0LmF0dHJpYnV0ZXMgfHwgIWFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdGVsLmlubmVySFRNTCA9IFwiPGlucHV0Lz5cIjtcblx0ZWwuZmlyc3RDaGlsZC5zZXRBdHRyaWJ1dGUoIFwidmFsdWVcIiwgXCJcIiApO1xuXHRyZXR1cm4gZWwuZmlyc3RDaGlsZC5nZXRBdHRyaWJ1dGUoIFwidmFsdWVcIiApID09PSBcIlwiO1xufSkgKSB7XG5cdGFkZEhhbmRsZSggXCJ2YWx1ZVwiLCBmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XG5cdFx0aWYgKCAhaXNYTUwgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImlucHV0XCIgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5kZWZhdWx0VmFsdWU7XG5cdFx0fVxuXHR9KTtcbn1cblxuLy8gU3VwcG9ydDogSUU8OVxuLy8gVXNlIGdldEF0dHJpYnV0ZU5vZGUgdG8gZmV0Y2ggYm9vbGVhbnMgd2hlbiBnZXRBdHRyaWJ1dGUgbGllc1xuaWYgKCAhYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0cmV0dXJuIGVsLmdldEF0dHJpYnV0ZShcImRpc2FibGVkXCIpID09IG51bGw7XG59KSApIHtcblx0YWRkSGFuZGxlKCBib29sZWFucywgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdHZhciB2YWw7XG5cdFx0aWYgKCAhaXNYTUwgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbVsgbmFtZSBdID09PSB0cnVlID8gbmFtZS50b0xvd2VyQ2FzZSgpIDpcblx0XHRcdFx0XHQodmFsID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKCBuYW1lICkpICYmIHZhbC5zcGVjaWZpZWQgP1xuXHRcdFx0XHRcdHZhbC52YWx1ZSA6XG5cdFx0XHRcdG51bGw7XG5cdFx0fVxuXHR9KTtcbn1cblxucmV0dXJuIFNpenpsZTtcblxufSkoIHdpbmRvdyApO1xuXG5cblxualF1ZXJ5LmZpbmQgPSBTaXp6bGU7XG5qUXVlcnkuZXhwciA9IFNpenpsZS5zZWxlY3RvcnM7XG5cbi8vIERlcHJlY2F0ZWRcbmpRdWVyeS5leHByWyBcIjpcIiBdID0galF1ZXJ5LmV4cHIucHNldWRvcztcbmpRdWVyeS51bmlxdWVTb3J0ID0galF1ZXJ5LnVuaXF1ZSA9IFNpenpsZS51bmlxdWVTb3J0O1xualF1ZXJ5LnRleHQgPSBTaXp6bGUuZ2V0VGV4dDtcbmpRdWVyeS5pc1hNTERvYyA9IFNpenpsZS5pc1hNTDtcbmpRdWVyeS5jb250YWlucyA9IFNpenpsZS5jb250YWlucztcbmpRdWVyeS5lc2NhcGVTZWxlY3RvciA9IFNpenpsZS5lc2NhcGU7XG5cblxuXG5cbnZhciBkaXIgPSBmdW5jdGlvbiggZWxlbSwgZGlyLCB1bnRpbCApIHtcblx0dmFyIG1hdGNoZWQgPSBbXSxcblx0XHR0cnVuY2F0ZSA9IHVudGlsICE9PSB1bmRlZmluZWQ7XG5cblx0d2hpbGUgKCAoIGVsZW0gPSBlbGVtWyBkaXIgXSApICYmIGVsZW0ubm9kZVR5cGUgIT09IDkgKSB7XG5cdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0aWYgKCB0cnVuY2F0ZSAmJiBqUXVlcnkoIGVsZW0gKS5pcyggdW50aWwgKSApIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRtYXRjaGVkLnB1c2goIGVsZW0gKTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIG1hdGNoZWQ7XG59O1xuXG5cbnZhciBzaWJsaW5ncyA9IGZ1bmN0aW9uKCBuLCBlbGVtICkge1xuXHR2YXIgbWF0Y2hlZCA9IFtdO1xuXG5cdGZvciAoIDsgbjsgbiA9IG4ubmV4dFNpYmxpbmcgKSB7XG5cdFx0aWYgKCBuLm5vZGVUeXBlID09PSAxICYmIG4gIT09IGVsZW0gKSB7XG5cdFx0XHRtYXRjaGVkLnB1c2goIG4gKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gbWF0Y2hlZDtcbn07XG5cblxudmFyIHJuZWVkc0NvbnRleHQgPSBqUXVlcnkuZXhwci5tYXRjaC5uZWVkc0NvbnRleHQ7XG5cbnZhciByc2luZ2xlVGFnID0gKCAvXjwoW2Etel1bXlxcL1xcMD46XFx4MjBcXHRcXHJcXG5cXGZdKilbXFx4MjBcXHRcXHJcXG5cXGZdKlxcLz8+KD86PFxcL1xcMT58KSQvaSApO1xuXG5cblxudmFyIHJpc1NpbXBsZSA9IC9eLlteOiNcXFtcXC4sXSokLztcblxuLy8gSW1wbGVtZW50IHRoZSBpZGVudGljYWwgZnVuY3Rpb25hbGl0eSBmb3IgZmlsdGVyIGFuZCBub3RcbmZ1bmN0aW9uIHdpbm5vdyggZWxlbWVudHMsIHF1YWxpZmllciwgbm90ICkge1xuXHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBxdWFsaWZpZXIgKSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSwgaSApIHtcblx0XHRcdHJldHVybiAhIXF1YWxpZmllci5jYWxsKCBlbGVtLCBpLCBlbGVtICkgIT09IG5vdDtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBTaW5nbGUgZWxlbWVudFxuXHRpZiAoIHF1YWxpZmllci5ub2RlVHlwZSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiAoIGVsZW0gPT09IHF1YWxpZmllciApICE9PSBub3Q7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gQXJyYXlsaWtlIG9mIGVsZW1lbnRzIChqUXVlcnksIGFyZ3VtZW50cywgQXJyYXkpXG5cdGlmICggdHlwZW9mIHF1YWxpZmllciAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiAoIGluZGV4T2YuY2FsbCggcXVhbGlmaWVyLCBlbGVtICkgPiAtMSApICE9PSBub3Q7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gU2ltcGxlIHNlbGVjdG9yIHRoYXQgY2FuIGJlIGZpbHRlcmVkIGRpcmVjdGx5LCByZW1vdmluZyBub24tRWxlbWVudHNcblx0aWYgKCByaXNTaW1wbGUudGVzdCggcXVhbGlmaWVyICkgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5maWx0ZXIoIHF1YWxpZmllciwgZWxlbWVudHMsIG5vdCApO1xuXHR9XG5cblx0Ly8gQ29tcGxleCBzZWxlY3RvciwgY29tcGFyZSB0aGUgdHdvIHNldHMsIHJlbW92aW5nIG5vbi1FbGVtZW50c1xuXHRxdWFsaWZpZXIgPSBqUXVlcnkuZmlsdGVyKCBxdWFsaWZpZXIsIGVsZW1lbnRzICk7XG5cdHJldHVybiBqUXVlcnkuZ3JlcCggZWxlbWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiAoIGluZGV4T2YuY2FsbCggcXVhbGlmaWVyLCBlbGVtICkgPiAtMSApICE9PSBub3QgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMTtcblx0fSApO1xufVxuXG5qUXVlcnkuZmlsdGVyID0gZnVuY3Rpb24oIGV4cHIsIGVsZW1zLCBub3QgKSB7XG5cdHZhciBlbGVtID0gZWxlbXNbIDAgXTtcblxuXHRpZiAoIG5vdCApIHtcblx0XHRleHByID0gXCI6bm90KFwiICsgZXhwciArIFwiKVwiO1xuXHR9XG5cblx0aWYgKCBlbGVtcy5sZW5ndGggPT09IDEgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmZpbmQubWF0Y2hlc1NlbGVjdG9yKCBlbGVtLCBleHByICkgPyBbIGVsZW0gXSA6IFtdO1xuXHR9XG5cblx0cmV0dXJuIGpRdWVyeS5maW5kLm1hdGNoZXMoIGV4cHIsIGpRdWVyeS5ncmVwKCBlbGVtcywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGVsZW0ubm9kZVR5cGUgPT09IDE7XG5cdH0gKSApO1xufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRmaW5kOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIGksIHJldCxcblx0XHRcdGxlbiA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0c2VsZiA9IHRoaXM7XG5cblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggalF1ZXJ5KCBzZWxlY3RvciApLmZpbHRlciggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRcdFx0aWYgKCBqUXVlcnkuY29udGFpbnMoIHNlbGZbIGkgXSwgdGhpcyApICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9ICkgKTtcblx0XHR9XG5cblx0XHRyZXQgPSB0aGlzLnB1c2hTdGFjayggW10gKTtcblxuXHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRqUXVlcnkuZmluZCggc2VsZWN0b3IsIHNlbGZbIGkgXSwgcmV0ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGxlbiA+IDEgPyBqUXVlcnkudW5pcXVlU29ydCggcmV0ICkgOiByZXQ7XG5cdH0sXG5cdGZpbHRlcjogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggd2lubm93KCB0aGlzLCBzZWxlY3RvciB8fCBbXSwgZmFsc2UgKSApO1xuXHR9LFxuXHRub3Q6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHdpbm5vdyggdGhpcywgc2VsZWN0b3IgfHwgW10sIHRydWUgKSApO1xuXHR9LFxuXHRpczogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiAhIXdpbm5vdyhcblx0XHRcdHRoaXMsXG5cblx0XHRcdC8vIElmIHRoaXMgaXMgYSBwb3NpdGlvbmFsL3JlbGF0aXZlIHNlbGVjdG9yLCBjaGVjayBtZW1iZXJzaGlwIGluIHRoZSByZXR1cm5lZCBzZXRcblx0XHRcdC8vIHNvICQoXCJwOmZpcnN0XCIpLmlzKFwicDpsYXN0XCIpIHdvbid0IHJldHVybiB0cnVlIGZvciBhIGRvYyB3aXRoIHR3byBcInBcIi5cblx0XHRcdHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiAmJiBybmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9yICkgP1xuXHRcdFx0XHRqUXVlcnkoIHNlbGVjdG9yICkgOlxuXHRcdFx0XHRzZWxlY3RvciB8fCBbXSxcblx0XHRcdGZhbHNlXG5cdFx0KS5sZW5ndGg7XG5cdH1cbn0gKTtcblxuXG4vLyBJbml0aWFsaXplIGEgalF1ZXJ5IG9iamVjdFxuXG5cbi8vIEEgY2VudHJhbCByZWZlcmVuY2UgdG8gdGhlIHJvb3QgalF1ZXJ5KGRvY3VtZW50KVxudmFyIHJvb3RqUXVlcnksXG5cblx0Ly8gQSBzaW1wbGUgd2F5IHRvIGNoZWNrIGZvciBIVE1MIHN0cmluZ3Ncblx0Ly8gUHJpb3JpdGl6ZSAjaWQgb3ZlciA8dGFnPiB0byBhdm9pZCBYU1MgdmlhIGxvY2F0aW9uLmhhc2ggKCM5NTIxKVxuXHQvLyBTdHJpY3QgSFRNTCByZWNvZ25pdGlvbiAoIzExMjkwOiBtdXN0IHN0YXJ0IHdpdGggPClcblx0Ly8gU2hvcnRjdXQgc2ltcGxlICNpZCBjYXNlIGZvciBzcGVlZFxuXHRycXVpY2tFeHByID0gL14oPzpcXHMqKDxbXFx3XFxXXSs+KVtePl0qfCMoW1xcdy1dKykpJC8sXG5cblx0aW5pdCA9IGpRdWVyeS5mbi5pbml0ID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0LCByb290ICkge1xuXHRcdHZhciBtYXRjaCwgZWxlbTtcblxuXHRcdC8vIEhBTkRMRTogJChcIlwiKSwgJChudWxsKSwgJCh1bmRlZmluZWQpLCAkKGZhbHNlKVxuXHRcdGlmICggIXNlbGVjdG9yICkge1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Ly8gTWV0aG9kIGluaXQoKSBhY2NlcHRzIGFuIGFsdGVybmF0ZSByb290alF1ZXJ5XG5cdFx0Ly8gc28gbWlncmF0ZSBjYW4gc3VwcG9ydCBqUXVlcnkuc3ViIChnaC0yMTAxKVxuXHRcdHJvb3QgPSByb290IHx8IHJvb3RqUXVlcnk7XG5cblx0XHQvLyBIYW5kbGUgSFRNTCBzdHJpbmdzXG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRpZiAoIHNlbGVjdG9yWyAwIF0gPT09IFwiPFwiICYmXG5cdFx0XHRcdHNlbGVjdG9yWyBzZWxlY3Rvci5sZW5ndGggLSAxIF0gPT09IFwiPlwiICYmXG5cdFx0XHRcdHNlbGVjdG9yLmxlbmd0aCA+PSAzICkge1xuXG5cdFx0XHRcdC8vIEFzc3VtZSB0aGF0IHN0cmluZ3MgdGhhdCBzdGFydCBhbmQgZW5kIHdpdGggPD4gYXJlIEhUTUwgYW5kIHNraXAgdGhlIHJlZ2V4IGNoZWNrXG5cdFx0XHRcdG1hdGNoID0gWyBudWxsLCBzZWxlY3RvciwgbnVsbCBdO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRtYXRjaCA9IHJxdWlja0V4cHIuZXhlYyggc2VsZWN0b3IgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWF0Y2ggaHRtbCBvciBtYWtlIHN1cmUgbm8gY29udGV4dCBpcyBzcGVjaWZpZWQgZm9yICNpZFxuXHRcdFx0aWYgKCBtYXRjaCAmJiAoIG1hdGNoWyAxIF0gfHwgIWNvbnRleHQgKSApIHtcblxuXHRcdFx0XHQvLyBIQU5ETEU6ICQoaHRtbCkgLT4gJChhcnJheSlcblx0XHRcdFx0aWYgKCBtYXRjaFsgMSBdICkge1xuXHRcdFx0XHRcdGNvbnRleHQgPSBjb250ZXh0IGluc3RhbmNlb2YgalF1ZXJ5ID8gY29udGV4dFsgMCBdIDogY29udGV4dDtcblxuXHRcdFx0XHRcdC8vIE9wdGlvbiB0byBydW4gc2NyaXB0cyBpcyB0cnVlIGZvciBiYWNrLWNvbXBhdFxuXHRcdFx0XHRcdC8vIEludGVudGlvbmFsbHkgbGV0IHRoZSBlcnJvciBiZSB0aHJvd24gaWYgcGFyc2VIVE1MIGlzIG5vdCBwcmVzZW50XG5cdFx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCB0aGlzLCBqUXVlcnkucGFyc2VIVE1MKFxuXHRcdFx0XHRcdFx0bWF0Y2hbIDEgXSxcblx0XHRcdFx0XHRcdGNvbnRleHQgJiYgY29udGV4dC5ub2RlVHlwZSA/IGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0IDogZG9jdW1lbnQsXG5cdFx0XHRcdFx0XHR0cnVlXG5cdFx0XHRcdFx0KSApO1xuXG5cdFx0XHRcdFx0Ly8gSEFORExFOiAkKGh0bWwsIHByb3BzKVxuXHRcdFx0XHRcdGlmICggcnNpbmdsZVRhZy50ZXN0KCBtYXRjaFsgMSBdICkgJiYgalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGNvbnRleHQgKSApIHtcblx0XHRcdFx0XHRcdGZvciAoIG1hdGNoIGluIGNvbnRleHQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gUHJvcGVydGllcyBvZiBjb250ZXh0IGFyZSBjYWxsZWQgYXMgbWV0aG9kcyBpZiBwb3NzaWJsZVxuXHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCB0aGlzWyBtYXRjaCBdICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpc1sgbWF0Y2ggXSggY29udGV4dFsgbWF0Y2ggXSApO1xuXG5cdFx0XHRcdFx0XHRcdC8vIC4uLmFuZCBvdGhlcndpc2Ugc2V0IGFzIGF0dHJpYnV0ZXNcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLmF0dHIoIG1hdGNoLCBjb250ZXh0WyBtYXRjaCBdICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdFx0XHQvLyBIQU5ETEU6ICQoI2lkKVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGVsZW0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCggbWF0Y2hbIDIgXSApO1xuXG5cdFx0XHRcdFx0aWYgKCBlbGVtICkge1xuXG5cdFx0XHRcdFx0XHQvLyBJbmplY3QgdGhlIGVsZW1lbnQgZGlyZWN0bHkgaW50byB0aGUgalF1ZXJ5IG9iamVjdFxuXHRcdFx0XHRcdFx0dGhpc1sgMCBdID0gZWxlbTtcblx0XHRcdFx0XHRcdHRoaXMubGVuZ3RoID0gMTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblxuXHRcdFx0Ly8gSEFORExFOiAkKGV4cHIsICQoLi4uKSlcblx0XHRcdH0gZWxzZSBpZiAoICFjb250ZXh0IHx8IGNvbnRleHQuanF1ZXJ5ICkge1xuXHRcdFx0XHRyZXR1cm4gKCBjb250ZXh0IHx8IHJvb3QgKS5maW5kKCBzZWxlY3RvciApO1xuXG5cdFx0XHQvLyBIQU5ETEU6ICQoZXhwciwgY29udGV4dClcblx0XHRcdC8vICh3aGljaCBpcyBqdXN0IGVxdWl2YWxlbnQgdG86ICQoY29udGV4dCkuZmluZChleHByKVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuY29uc3RydWN0b3IoIGNvbnRleHQgKS5maW5kKCBzZWxlY3RvciApO1xuXHRcdFx0fVxuXG5cdFx0Ly8gSEFORExFOiAkKERPTUVsZW1lbnQpXG5cdFx0fSBlbHNlIGlmICggc2VsZWN0b3Iubm9kZVR5cGUgKSB7XG5cdFx0XHR0aGlzWyAwIF0gPSBzZWxlY3Rvcjtcblx0XHRcdHRoaXMubGVuZ3RoID0gMTtcblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0Ly8gSEFORExFOiAkKGZ1bmN0aW9uKVxuXHRcdC8vIFNob3J0Y3V0IGZvciBkb2N1bWVudCByZWFkeVxuXHRcdH0gZWxzZSBpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBzZWxlY3RvciApICkge1xuXHRcdFx0cmV0dXJuIHJvb3QucmVhZHkgIT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdHJvb3QucmVhZHkoIHNlbGVjdG9yICkgOlxuXG5cdFx0XHRcdC8vIEV4ZWN1dGUgaW1tZWRpYXRlbHkgaWYgcmVhZHkgaXMgbm90IHByZXNlbnRcblx0XHRcdFx0c2VsZWN0b3IoIGpRdWVyeSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBqUXVlcnkubWFrZUFycmF5KCBzZWxlY3RvciwgdGhpcyApO1xuXHR9O1xuXG4vLyBHaXZlIHRoZSBpbml0IGZ1bmN0aW9uIHRoZSBqUXVlcnkgcHJvdG90eXBlIGZvciBsYXRlciBpbnN0YW50aWF0aW9uXG5pbml0LnByb3RvdHlwZSA9IGpRdWVyeS5mbjtcblxuLy8gSW5pdGlhbGl6ZSBjZW50cmFsIHJlZmVyZW5jZVxucm9vdGpRdWVyeSA9IGpRdWVyeSggZG9jdW1lbnQgKTtcblxuXG52YXIgcnBhcmVudHNwcmV2ID0gL14oPzpwYXJlbnRzfHByZXYoPzpVbnRpbHxBbGwpKS8sXG5cblx0Ly8gTWV0aG9kcyBndWFyYW50ZWVkIHRvIHByb2R1Y2UgYSB1bmlxdWUgc2V0IHdoZW4gc3RhcnRpbmcgZnJvbSBhIHVuaXF1ZSBzZXRcblx0Z3VhcmFudGVlZFVuaXF1ZSA9IHtcblx0XHRjaGlsZHJlbjogdHJ1ZSxcblx0XHRjb250ZW50czogdHJ1ZSxcblx0XHRuZXh0OiB0cnVlLFxuXHRcdHByZXY6IHRydWVcblx0fTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRoYXM6IGZ1bmN0aW9uKCB0YXJnZXQgKSB7XG5cdFx0dmFyIHRhcmdldHMgPSBqUXVlcnkoIHRhcmdldCwgdGhpcyApLFxuXHRcdFx0bCA9IHRhcmdldHMubGVuZ3RoO1xuXG5cdFx0cmV0dXJuIHRoaXMuZmlsdGVyKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBpID0gMDtcblx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBqUXVlcnkuY29udGFpbnMoIHRoaXMsIHRhcmdldHNbIGkgXSApICkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGNsb3Nlc3Q6IGZ1bmN0aW9uKCBzZWxlY3RvcnMsIGNvbnRleHQgKSB7XG5cdFx0dmFyIGN1cixcblx0XHRcdGkgPSAwLFxuXHRcdFx0bCA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0bWF0Y2hlZCA9IFtdLFxuXHRcdFx0dGFyZ2V0cyA9IHR5cGVvZiBzZWxlY3RvcnMgIT09IFwic3RyaW5nXCIgJiYgalF1ZXJ5KCBzZWxlY3RvcnMgKTtcblxuXHRcdC8vIFBvc2l0aW9uYWwgc2VsZWN0b3JzIG5ldmVyIG1hdGNoLCBzaW5jZSB0aGVyZSdzIG5vIF9zZWxlY3Rpb25fIGNvbnRleHRcblx0XHRpZiAoICFybmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9ycyApICkge1xuXHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRmb3IgKCBjdXIgPSB0aGlzWyBpIF07IGN1ciAmJiBjdXIgIT09IGNvbnRleHQ7IGN1ciA9IGN1ci5wYXJlbnROb2RlICkge1xuXG5cdFx0XHRcdFx0Ly8gQWx3YXlzIHNraXAgZG9jdW1lbnQgZnJhZ21lbnRzXG5cdFx0XHRcdFx0aWYgKCBjdXIubm9kZVR5cGUgPCAxMSAmJiAoIHRhcmdldHMgP1xuXHRcdFx0XHRcdFx0dGFyZ2V0cy5pbmRleCggY3VyICkgPiAtMSA6XG5cblx0XHRcdFx0XHRcdC8vIERvbid0IHBhc3Mgbm9uLWVsZW1lbnRzIHRvIFNpenpsZVxuXHRcdFx0XHRcdFx0Y3VyLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRcdFx0XHRcdGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvciggY3VyLCBzZWxlY3RvcnMgKSApICkge1xuXG5cdFx0XHRcdFx0XHRtYXRjaGVkLnB1c2goIGN1ciApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBtYXRjaGVkLmxlbmd0aCA+IDEgPyBqUXVlcnkudW5pcXVlU29ydCggbWF0Y2hlZCApIDogbWF0Y2hlZCApO1xuXHR9LFxuXG5cdC8vIERldGVybWluZSB0aGUgcG9zaXRpb24gb2YgYW4gZWxlbWVudCB3aXRoaW4gdGhlIHNldFxuXHRpbmRleDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHQvLyBObyBhcmd1bWVudCwgcmV0dXJuIGluZGV4IGluIHBhcmVudFxuXHRcdGlmICggIWVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gKCB0aGlzWyAwIF0gJiYgdGhpc1sgMCBdLnBhcmVudE5vZGUgKSA/IHRoaXMuZmlyc3QoKS5wcmV2QWxsKCkubGVuZ3RoIDogLTE7XG5cdFx0fVxuXG5cdFx0Ly8gSW5kZXggaW4gc2VsZWN0b3Jcblx0XHRpZiAoIHR5cGVvZiBlbGVtID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIGluZGV4T2YuY2FsbCggalF1ZXJ5KCBlbGVtICksIHRoaXNbIDAgXSApO1xuXHRcdH1cblxuXHRcdC8vIExvY2F0ZSB0aGUgcG9zaXRpb24gb2YgdGhlIGRlc2lyZWQgZWxlbWVudFxuXHRcdHJldHVybiBpbmRleE9mLmNhbGwoIHRoaXMsXG5cblx0XHRcdC8vIElmIGl0IHJlY2VpdmVzIGEgalF1ZXJ5IG9iamVjdCwgdGhlIGZpcnN0IGVsZW1lbnQgaXMgdXNlZFxuXHRcdFx0ZWxlbS5qcXVlcnkgPyBlbGVtWyAwIF0gOiBlbGVtXG5cdFx0KTtcblx0fSxcblxuXHRhZGQ6IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soXG5cdFx0XHRqUXVlcnkudW5pcXVlU29ydChcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCB0aGlzLmdldCgpLCBqUXVlcnkoIHNlbGVjdG9yLCBjb250ZXh0ICkgKVxuXHRcdFx0KVxuXHRcdCk7XG5cdH0sXG5cblx0YWRkQmFjazogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLmFkZCggc2VsZWN0b3IgPT0gbnVsbCA/XG5cdFx0XHR0aGlzLnByZXZPYmplY3QgOiB0aGlzLnByZXZPYmplY3QuZmlsdGVyKCBzZWxlY3RvciApXG5cdFx0KTtcblx0fVxufSApO1xuXG5mdW5jdGlvbiBzaWJsaW5nKCBjdXIsIGRpciApIHtcblx0d2hpbGUgKCAoIGN1ciA9IGN1clsgZGlyIF0gKSAmJiBjdXIubm9kZVR5cGUgIT09IDEgKSB7fVxuXHRyZXR1cm4gY3VyO1xufVxuXG5qUXVlcnkuZWFjaCgge1xuXHRwYXJlbnQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cdFx0cmV0dXJuIHBhcmVudCAmJiBwYXJlbnQubm9kZVR5cGUgIT09IDExID8gcGFyZW50IDogbnVsbDtcblx0fSxcblx0cGFyZW50czogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwYXJlbnROb2RlXCIgKTtcblx0fSxcblx0cGFyZW50c1VudGlsOiBmdW5jdGlvbiggZWxlbSwgaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwYXJlbnROb2RlXCIsIHVudGlsICk7XG5cdH0sXG5cdG5leHQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5nKCBlbGVtLCBcIm5leHRTaWJsaW5nXCIgKTtcblx0fSxcblx0cHJldjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmcoIGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIgKTtcblx0fSxcblx0bmV4dEFsbDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJuZXh0U2libGluZ1wiICk7XG5cdH0sXG5cdHByZXZBbGw6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIgKTtcblx0fSxcblx0bmV4dFVudGlsOiBmdW5jdGlvbiggZWxlbSwgaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJuZXh0U2libGluZ1wiLCB1bnRpbCApO1xuXHR9LFxuXHRwcmV2VW50aWw6IGZ1bmN0aW9uKCBlbGVtLCBpLCB1bnRpbCApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiLCB1bnRpbCApO1xuXHR9LFxuXHRzaWJsaW5nczogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmdzKCAoIGVsZW0ucGFyZW50Tm9kZSB8fCB7fSApLmZpcnN0Q2hpbGQsIGVsZW0gKTtcblx0fSxcblx0Y2hpbGRyZW46IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5ncyggZWxlbS5maXJzdENoaWxkICk7XG5cdH0sXG5cdGNvbnRlbnRzOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZWxlbS5jb250ZW50RG9jdW1lbnQgfHwgalF1ZXJ5Lm1lcmdlKCBbXSwgZWxlbS5jaGlsZE5vZGVzICk7XG5cdH1cbn0sIGZ1bmN0aW9uKCBuYW1lLCBmbiApIHtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggdW50aWwsIHNlbGVjdG9yICkge1xuXHRcdHZhciBtYXRjaGVkID0galF1ZXJ5Lm1hcCggdGhpcywgZm4sIHVudGlsICk7XG5cblx0XHRpZiAoIG5hbWUuc2xpY2UoIC01ICkgIT09IFwiVW50aWxcIiApIHtcblx0XHRcdHNlbGVjdG9yID0gdW50aWw7XG5cdFx0fVxuXG5cdFx0aWYgKCBzZWxlY3RvciAmJiB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRtYXRjaGVkID0galF1ZXJ5LmZpbHRlciggc2VsZWN0b3IsIG1hdGNoZWQgKTtcblx0XHR9XG5cblx0XHRpZiAoIHRoaXMubGVuZ3RoID4gMSApIHtcblxuXHRcdFx0Ly8gUmVtb3ZlIGR1cGxpY2F0ZXNcblx0XHRcdGlmICggIWd1YXJhbnRlZWRVbmlxdWVbIG5hbWUgXSApIHtcblx0XHRcdFx0alF1ZXJ5LnVuaXF1ZVNvcnQoIG1hdGNoZWQgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmV2ZXJzZSBvcmRlciBmb3IgcGFyZW50cyogYW5kIHByZXYtZGVyaXZhdGl2ZXNcblx0XHRcdGlmICggcnBhcmVudHNwcmV2LnRlc3QoIG5hbWUgKSApIHtcblx0XHRcdFx0bWF0Y2hlZC5yZXZlcnNlKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBtYXRjaGVkICk7XG5cdH07XG59ICk7XG52YXIgcm5vdGh0bWx3aGl0ZSA9ICggL1teXFx4MjBcXHRcXHJcXG5cXGZdKy9nICk7XG5cblxuXG4vLyBDb252ZXJ0IFN0cmluZy1mb3JtYXR0ZWQgb3B0aW9ucyBpbnRvIE9iamVjdC1mb3JtYXR0ZWQgb25lc1xuZnVuY3Rpb24gY3JlYXRlT3B0aW9ucyggb3B0aW9ucyApIHtcblx0dmFyIG9iamVjdCA9IHt9O1xuXHRqUXVlcnkuZWFjaCggb3B0aW9ucy5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdLCBmdW5jdGlvbiggXywgZmxhZyApIHtcblx0XHRvYmplY3RbIGZsYWcgXSA9IHRydWU7XG5cdH0gKTtcblx0cmV0dXJuIG9iamVjdDtcbn1cblxuLypcbiAqIENyZWF0ZSBhIGNhbGxiYWNrIGxpc3QgdXNpbmcgdGhlIGZvbGxvd2luZyBwYXJhbWV0ZXJzOlxuICpcbiAqXHRvcHRpb25zOiBhbiBvcHRpb25hbCBsaXN0IG9mIHNwYWNlLXNlcGFyYXRlZCBvcHRpb25zIHRoYXQgd2lsbCBjaGFuZ2UgaG93XG4gKlx0XHRcdHRoZSBjYWxsYmFjayBsaXN0IGJlaGF2ZXMgb3IgYSBtb3JlIHRyYWRpdGlvbmFsIG9wdGlvbiBvYmplY3RcbiAqXG4gKiBCeSBkZWZhdWx0IGEgY2FsbGJhY2sgbGlzdCB3aWxsIGFjdCBsaWtlIGFuIGV2ZW50IGNhbGxiYWNrIGxpc3QgYW5kIGNhbiBiZVxuICogXCJmaXJlZFwiIG11bHRpcGxlIHRpbWVzLlxuICpcbiAqIFBvc3NpYmxlIG9wdGlvbnM6XG4gKlxuICpcdG9uY2U6XHRcdFx0d2lsbCBlbnN1cmUgdGhlIGNhbGxiYWNrIGxpc3QgY2FuIG9ubHkgYmUgZmlyZWQgb25jZSAobGlrZSBhIERlZmVycmVkKVxuICpcbiAqXHRtZW1vcnk6XHRcdFx0d2lsbCBrZWVwIHRyYWNrIG9mIHByZXZpb3VzIHZhbHVlcyBhbmQgd2lsbCBjYWxsIGFueSBjYWxsYmFjayBhZGRlZFxuICpcdFx0XHRcdFx0YWZ0ZXIgdGhlIGxpc3QgaGFzIGJlZW4gZmlyZWQgcmlnaHQgYXdheSB3aXRoIHRoZSBsYXRlc3QgXCJtZW1vcml6ZWRcIlxuICpcdFx0XHRcdFx0dmFsdWVzIChsaWtlIGEgRGVmZXJyZWQpXG4gKlxuICpcdHVuaXF1ZTpcdFx0XHR3aWxsIGVuc3VyZSBhIGNhbGxiYWNrIGNhbiBvbmx5IGJlIGFkZGVkIG9uY2UgKG5vIGR1cGxpY2F0ZSBpbiB0aGUgbGlzdClcbiAqXG4gKlx0c3RvcE9uRmFsc2U6XHRpbnRlcnJ1cHQgY2FsbGluZ3Mgd2hlbiBhIGNhbGxiYWNrIHJldHVybnMgZmFsc2VcbiAqXG4gKi9cbmpRdWVyeS5DYWxsYmFja3MgPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcblxuXHQvLyBDb252ZXJ0IG9wdGlvbnMgZnJvbSBTdHJpbmctZm9ybWF0dGVkIHRvIE9iamVjdC1mb3JtYXR0ZWQgaWYgbmVlZGVkXG5cdC8vICh3ZSBjaGVjayBpbiBjYWNoZSBmaXJzdClcblx0b3B0aW9ucyA9IHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiID9cblx0XHRjcmVhdGVPcHRpb25zKCBvcHRpb25zICkgOlxuXHRcdGpRdWVyeS5leHRlbmQoIHt9LCBvcHRpb25zICk7XG5cblx0dmFyIC8vIEZsYWcgdG8ga25vdyBpZiBsaXN0IGlzIGN1cnJlbnRseSBmaXJpbmdcblx0XHRmaXJpbmcsXG5cblx0XHQvLyBMYXN0IGZpcmUgdmFsdWUgZm9yIG5vbi1mb3JnZXR0YWJsZSBsaXN0c1xuXHRcdG1lbW9yeSxcblxuXHRcdC8vIEZsYWcgdG8ga25vdyBpZiBsaXN0IHdhcyBhbHJlYWR5IGZpcmVkXG5cdFx0ZmlyZWQsXG5cblx0XHQvLyBGbGFnIHRvIHByZXZlbnQgZmlyaW5nXG5cdFx0bG9ja2VkLFxuXG5cdFx0Ly8gQWN0dWFsIGNhbGxiYWNrIGxpc3Rcblx0XHRsaXN0ID0gW10sXG5cblx0XHQvLyBRdWV1ZSBvZiBleGVjdXRpb24gZGF0YSBmb3IgcmVwZWF0YWJsZSBsaXN0c1xuXHRcdHF1ZXVlID0gW10sXG5cblx0XHQvLyBJbmRleCBvZiBjdXJyZW50bHkgZmlyaW5nIGNhbGxiYWNrIChtb2RpZmllZCBieSBhZGQvcmVtb3ZlIGFzIG5lZWRlZClcblx0XHRmaXJpbmdJbmRleCA9IC0xLFxuXG5cdFx0Ly8gRmlyZSBjYWxsYmFja3Ncblx0XHRmaXJlID0gZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIEVuZm9yY2Ugc2luZ2xlLWZpcmluZ1xuXHRcdFx0bG9ja2VkID0gb3B0aW9ucy5vbmNlO1xuXG5cdFx0XHQvLyBFeGVjdXRlIGNhbGxiYWNrcyBmb3IgYWxsIHBlbmRpbmcgZXhlY3V0aW9ucyxcblx0XHRcdC8vIHJlc3BlY3RpbmcgZmlyaW5nSW5kZXggb3ZlcnJpZGVzIGFuZCBydW50aW1lIGNoYW5nZXNcblx0XHRcdGZpcmVkID0gZmlyaW5nID0gdHJ1ZTtcblx0XHRcdGZvciAoIDsgcXVldWUubGVuZ3RoOyBmaXJpbmdJbmRleCA9IC0xICkge1xuXHRcdFx0XHRtZW1vcnkgPSBxdWV1ZS5zaGlmdCgpO1xuXHRcdFx0XHR3aGlsZSAoICsrZmlyaW5nSW5kZXggPCBsaXN0Lmxlbmd0aCApIHtcblxuXHRcdFx0XHRcdC8vIFJ1biBjYWxsYmFjayBhbmQgY2hlY2sgZm9yIGVhcmx5IHRlcm1pbmF0aW9uXG5cdFx0XHRcdFx0aWYgKCBsaXN0WyBmaXJpbmdJbmRleCBdLmFwcGx5KCBtZW1vcnlbIDAgXSwgbWVtb3J5WyAxIF0gKSA9PT0gZmFsc2UgJiZcblx0XHRcdFx0XHRcdG9wdGlvbnMuc3RvcE9uRmFsc2UgKSB7XG5cblx0XHRcdFx0XHRcdC8vIEp1bXAgdG8gZW5kIGFuZCBmb3JnZXQgdGhlIGRhdGEgc28gLmFkZCBkb2Vzbid0IHJlLWZpcmVcblx0XHRcdFx0XHRcdGZpcmluZ0luZGV4ID0gbGlzdC5sZW5ndGg7XG5cdFx0XHRcdFx0XHRtZW1vcnkgPSBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gRm9yZ2V0IHRoZSBkYXRhIGlmIHdlJ3JlIGRvbmUgd2l0aCBpdFxuXHRcdFx0aWYgKCAhb3B0aW9ucy5tZW1vcnkgKSB7XG5cdFx0XHRcdG1lbW9yeSA9IGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHRmaXJpbmcgPSBmYWxzZTtcblxuXHRcdFx0Ly8gQ2xlYW4gdXAgaWYgd2UncmUgZG9uZSBmaXJpbmcgZm9yIGdvb2Rcblx0XHRcdGlmICggbG9ja2VkICkge1xuXG5cdFx0XHRcdC8vIEtlZXAgYW4gZW1wdHkgbGlzdCBpZiB3ZSBoYXZlIGRhdGEgZm9yIGZ1dHVyZSBhZGQgY2FsbHNcblx0XHRcdFx0aWYgKCBtZW1vcnkgKSB7XG5cdFx0XHRcdFx0bGlzdCA9IFtdO1xuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSwgdGhpcyBvYmplY3QgaXMgc3BlbnRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRsaXN0ID0gXCJcIjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvLyBBY3R1YWwgQ2FsbGJhY2tzIG9iamVjdFxuXHRcdHNlbGYgPSB7XG5cblx0XHRcdC8vIEFkZCBhIGNhbGxiYWNrIG9yIGEgY29sbGVjdGlvbiBvZiBjYWxsYmFja3MgdG8gdGhlIGxpc3Rcblx0XHRcdGFkZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggbGlzdCApIHtcblxuXHRcdFx0XHRcdC8vIElmIHdlIGhhdmUgbWVtb3J5IGZyb20gYSBwYXN0IHJ1biwgd2Ugc2hvdWxkIGZpcmUgYWZ0ZXIgYWRkaW5nXG5cdFx0XHRcdFx0aWYgKCBtZW1vcnkgJiYgIWZpcmluZyApIHtcblx0XHRcdFx0XHRcdGZpcmluZ0luZGV4ID0gbGlzdC5sZW5ndGggLSAxO1xuXHRcdFx0XHRcdFx0cXVldWUucHVzaCggbWVtb3J5ICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0KCBmdW5jdGlvbiBhZGQoIGFyZ3MgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZWFjaCggYXJncywgZnVuY3Rpb24oIF8sIGFyZyApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggYXJnICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCAhb3B0aW9ucy51bmlxdWUgfHwgIXNlbGYuaGFzKCBhcmcgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGxpc3QucHVzaCggYXJnICk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBhcmcgJiYgYXJnLmxlbmd0aCAmJiBqUXVlcnkudHlwZSggYXJnICkgIT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBJbnNwZWN0IHJlY3Vyc2l2ZWx5XG5cdFx0XHRcdFx0XHRcdFx0YWRkKCBhcmcgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdH0gKSggYXJndW1lbnRzICk7XG5cblx0XHRcdFx0XHRpZiAoIG1lbW9yeSAmJiAhZmlyaW5nICkge1xuXHRcdFx0XHRcdFx0ZmlyZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIFJlbW92ZSBhIGNhbGxiYWNrIGZyb20gdGhlIGxpc3Rcblx0XHRcdHJlbW92ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGpRdWVyeS5lYWNoKCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBfLCBhcmcgKSB7XG5cdFx0XHRcdFx0dmFyIGluZGV4O1xuXHRcdFx0XHRcdHdoaWxlICggKCBpbmRleCA9IGpRdWVyeS5pbkFycmF5KCBhcmcsIGxpc3QsIGluZGV4ICkgKSA+IC0xICkge1xuXHRcdFx0XHRcdFx0bGlzdC5zcGxpY2UoIGluZGV4LCAxICk7XG5cblx0XHRcdFx0XHRcdC8vIEhhbmRsZSBmaXJpbmcgaW5kZXhlc1xuXHRcdFx0XHRcdFx0aWYgKCBpbmRleCA8PSBmaXJpbmdJbmRleCApIHtcblx0XHRcdFx0XHRcdFx0ZmlyaW5nSW5kZXgtLTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBDaGVjayBpZiBhIGdpdmVuIGNhbGxiYWNrIGlzIGluIHRoZSBsaXN0LlxuXHRcdFx0Ly8gSWYgbm8gYXJndW1lbnQgaXMgZ2l2ZW4sIHJldHVybiB3aGV0aGVyIG9yIG5vdCBsaXN0IGhhcyBjYWxsYmFja3MgYXR0YWNoZWQuXG5cdFx0XHRoYXM6IGZ1bmN0aW9uKCBmbiApIHtcblx0XHRcdFx0cmV0dXJuIGZuID9cblx0XHRcdFx0XHRqUXVlcnkuaW5BcnJheSggZm4sIGxpc3QgKSA+IC0xIDpcblx0XHRcdFx0XHRsaXN0Lmxlbmd0aCA+IDA7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBSZW1vdmUgYWxsIGNhbGxiYWNrcyBmcm9tIHRoZSBsaXN0XG5cdFx0XHRlbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggbGlzdCApIHtcblx0XHRcdFx0XHRsaXN0ID0gW107XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBEaXNhYmxlIC5maXJlIGFuZCAuYWRkXG5cdFx0XHQvLyBBYm9ydCBhbnkgY3VycmVudC9wZW5kaW5nIGV4ZWN1dGlvbnNcblx0XHRcdC8vIENsZWFyIGFsbCBjYWxsYmFja3MgYW5kIHZhbHVlc1xuXHRcdFx0ZGlzYWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGxvY2tlZCA9IHF1ZXVlID0gW107XG5cdFx0XHRcdGxpc3QgPSBtZW1vcnkgPSBcIlwiO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cdFx0XHRkaXNhYmxlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhbGlzdDtcblx0XHRcdH0sXG5cblx0XHRcdC8vIERpc2FibGUgLmZpcmVcblx0XHRcdC8vIEFsc28gZGlzYWJsZSAuYWRkIHVubGVzcyB3ZSBoYXZlIG1lbW9yeSAoc2luY2UgaXQgd291bGQgaGF2ZSBubyBlZmZlY3QpXG5cdFx0XHQvLyBBYm9ydCBhbnkgcGVuZGluZyBleGVjdXRpb25zXG5cdFx0XHRsb2NrOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0bG9ja2VkID0gcXVldWUgPSBbXTtcblx0XHRcdFx0aWYgKCAhbWVtb3J5ICYmICFmaXJpbmcgKSB7XG5cdFx0XHRcdFx0bGlzdCA9IG1lbW9yeSA9IFwiXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXHRcdFx0bG9ja2VkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICEhbG9ja2VkO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQ2FsbCBhbGwgY2FsbGJhY2tzIHdpdGggdGhlIGdpdmVuIGNvbnRleHQgYW5kIGFyZ3VtZW50c1xuXHRcdFx0ZmlyZVdpdGg6IGZ1bmN0aW9uKCBjb250ZXh0LCBhcmdzICkge1xuXHRcdFx0XHRpZiAoICFsb2NrZWQgKSB7XG5cdFx0XHRcdFx0YXJncyA9IGFyZ3MgfHwgW107XG5cdFx0XHRcdFx0YXJncyA9IFsgY29udGV4dCwgYXJncy5zbGljZSA/IGFyZ3Muc2xpY2UoKSA6IGFyZ3MgXTtcblx0XHRcdFx0XHRxdWV1ZS5wdXNoKCBhcmdzICk7XG5cdFx0XHRcdFx0aWYgKCAhZmlyaW5nICkge1xuXHRcdFx0XHRcdFx0ZmlyZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIENhbGwgYWxsIHRoZSBjYWxsYmFja3Mgd2l0aCB0aGUgZ2l2ZW4gYXJndW1lbnRzXG5cdFx0XHRmaXJlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0c2VsZi5maXJlV2l0aCggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gVG8ga25vdyBpZiB0aGUgY2FsbGJhY2tzIGhhdmUgYWxyZWFkeSBiZWVuIGNhbGxlZCBhdCBsZWFzdCBvbmNlXG5cdFx0XHRmaXJlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhIWZpcmVkO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0cmV0dXJuIHNlbGY7XG59O1xuXG5cbmZ1bmN0aW9uIElkZW50aXR5KCB2ICkge1xuXHRyZXR1cm4gdjtcbn1cbmZ1bmN0aW9uIFRocm93ZXIoIGV4ICkge1xuXHR0aHJvdyBleDtcbn1cblxuZnVuY3Rpb24gYWRvcHRWYWx1ZSggdmFsdWUsIHJlc29sdmUsIHJlamVjdCApIHtcblx0dmFyIG1ldGhvZDtcblxuXHR0cnkge1xuXG5cdFx0Ly8gQ2hlY2sgZm9yIHByb21pc2UgYXNwZWN0IGZpcnN0IHRvIHByaXZpbGVnZSBzeW5jaHJvbm91cyBiZWhhdmlvclxuXHRcdGlmICggdmFsdWUgJiYgalF1ZXJ5LmlzRnVuY3Rpb24oICggbWV0aG9kID0gdmFsdWUucHJvbWlzZSApICkgKSB7XG5cdFx0XHRtZXRob2QuY2FsbCggdmFsdWUgKS5kb25lKCByZXNvbHZlICkuZmFpbCggcmVqZWN0ICk7XG5cblx0XHQvLyBPdGhlciB0aGVuYWJsZXNcblx0XHR9IGVsc2UgaWYgKCB2YWx1ZSAmJiBqUXVlcnkuaXNGdW5jdGlvbiggKCBtZXRob2QgPSB2YWx1ZS50aGVuICkgKSApIHtcblx0XHRcdG1ldGhvZC5jYWxsKCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0ICk7XG5cblx0XHQvLyBPdGhlciBub24tdGhlbmFibGVzXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAgb25seVxuXHRcdFx0Ly8gU3RyaWN0IG1vZGUgZnVuY3Rpb25zIGludm9rZWQgd2l0aG91dCAuY2FsbC8uYXBwbHkgZ2V0IGdsb2JhbC1vYmplY3QgY29udGV4dFxuXHRcdFx0cmVzb2x2ZS5jYWxsKCB1bmRlZmluZWQsIHZhbHVlICk7XG5cdFx0fVxuXG5cdC8vIEZvciBQcm9taXNlcy9BKywgY29udmVydCBleGNlcHRpb25zIGludG8gcmVqZWN0aW9uc1xuXHQvLyBTaW5jZSBqUXVlcnkud2hlbiBkb2Vzbid0IHVud3JhcCB0aGVuYWJsZXMsIHdlIGNhbiBza2lwIHRoZSBleHRyYSBjaGVja3MgYXBwZWFyaW5nIGluXG5cdC8vIERlZmVycmVkI3RoZW4gdG8gY29uZGl0aW9uYWxseSBzdXBwcmVzcyByZWplY3Rpb24uXG5cdH0gY2F0Y2ggKCB2YWx1ZSApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIG9ubHlcblx0XHQvLyBTdHJpY3QgbW9kZSBmdW5jdGlvbnMgaW52b2tlZCB3aXRob3V0IC5jYWxsLy5hcHBseSBnZXQgZ2xvYmFsLW9iamVjdCBjb250ZXh0XG5cdFx0cmVqZWN0LmNhbGwoIHVuZGVmaW5lZCwgdmFsdWUgKTtcblx0fVxufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0RGVmZXJyZWQ6IGZ1bmN0aW9uKCBmdW5jICkge1xuXHRcdHZhciB0dXBsZXMgPSBbXG5cblx0XHRcdFx0Ly8gYWN0aW9uLCBhZGQgbGlzdGVuZXIsIGNhbGxiYWNrcyxcblx0XHRcdFx0Ly8gLi4uIC50aGVuIGhhbmRsZXJzLCBhcmd1bWVudCBpbmRleCwgW2ZpbmFsIHN0YXRlXVxuXHRcdFx0XHRbIFwibm90aWZ5XCIsIFwicHJvZ3Jlc3NcIiwgalF1ZXJ5LkNhbGxiYWNrcyggXCJtZW1vcnlcIiApLFxuXHRcdFx0XHRcdGpRdWVyeS5DYWxsYmFja3MoIFwibWVtb3J5XCIgKSwgMiBdLFxuXHRcdFx0XHRbIFwicmVzb2x2ZVwiLCBcImRvbmVcIiwgalF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksXG5cdFx0XHRcdFx0alF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksIDAsIFwicmVzb2x2ZWRcIiBdLFxuXHRcdFx0XHRbIFwicmVqZWN0XCIsIFwiZmFpbFwiLCBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSxcblx0XHRcdFx0XHRqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSwgMSwgXCJyZWplY3RlZFwiIF1cblx0XHRcdF0sXG5cdFx0XHRzdGF0ZSA9IFwicGVuZGluZ1wiLFxuXHRcdFx0cHJvbWlzZSA9IHtcblx0XHRcdFx0c3RhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiBzdGF0ZTtcblx0XHRcdFx0fSxcblx0XHRcdFx0YWx3YXlzOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5kb25lKCBhcmd1bWVudHMgKS5mYWlsKCBhcmd1bWVudHMgKTtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblx0XHRcdFx0XCJjYXRjaFwiOiBmdW5jdGlvbiggZm4gKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHByb21pc2UudGhlbiggbnVsbCwgZm4gKTtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBLZWVwIHBpcGUgZm9yIGJhY2stY29tcGF0XG5cdFx0XHRcdHBpcGU6IGZ1bmN0aW9uKCAvKiBmbkRvbmUsIGZuRmFpbCwgZm5Qcm9ncmVzcyAqLyApIHtcblx0XHRcdFx0XHR2YXIgZm5zID0gYXJndW1lbnRzO1xuXG5cdFx0XHRcdFx0cmV0dXJuIGpRdWVyeS5EZWZlcnJlZCggZnVuY3Rpb24oIG5ld0RlZmVyICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5LmVhY2goIHR1cGxlcywgZnVuY3Rpb24oIGksIHR1cGxlICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIE1hcCB0dXBsZXMgKHByb2dyZXNzLCBkb25lLCBmYWlsKSB0byBhcmd1bWVudHMgKGRvbmUsIGZhaWwsIHByb2dyZXNzKVxuXHRcdFx0XHRcdFx0XHR2YXIgZm4gPSBqUXVlcnkuaXNGdW5jdGlvbiggZm5zWyB0dXBsZVsgNCBdIF0gKSAmJiBmbnNbIHR1cGxlWyA0IF0gXTtcblxuXHRcdFx0XHRcdFx0XHQvLyBkZWZlcnJlZC5wcm9ncmVzcyhmdW5jdGlvbigpIHsgYmluZCB0byBuZXdEZWZlciBvciBuZXdEZWZlci5ub3RpZnkgfSlcblx0XHRcdFx0XHRcdFx0Ly8gZGVmZXJyZWQuZG9uZShmdW5jdGlvbigpIHsgYmluZCB0byBuZXdEZWZlciBvciBuZXdEZWZlci5yZXNvbHZlIH0pXG5cdFx0XHRcdFx0XHRcdC8vIGRlZmVycmVkLmZhaWwoZnVuY3Rpb24oKSB7IGJpbmQgdG8gbmV3RGVmZXIgb3IgbmV3RGVmZXIucmVqZWN0IH0pXG5cdFx0XHRcdFx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMSBdIF0oIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdHZhciByZXR1cm5lZCA9IGZuICYmIGZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIHJldHVybmVkICYmIGpRdWVyeS5pc0Z1bmN0aW9uKCByZXR1cm5lZC5wcm9taXNlICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZC5wcm9taXNlKClcblx0XHRcdFx0XHRcdFx0XHRcdFx0LnByb2dyZXNzKCBuZXdEZWZlci5ub3RpZnkgKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQuZG9uZSggbmV3RGVmZXIucmVzb2x2ZSApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5mYWlsKCBuZXdEZWZlci5yZWplY3QgKTtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXJbIHR1cGxlWyAwIF0gKyBcIldpdGhcIiBdKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0aGlzLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRmbiA/IFsgcmV0dXJuZWQgXSA6IGFyZ3VtZW50c1xuXHRcdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdGZucyA9IG51bGw7XG5cdFx0XHRcdFx0fSApLnByb21pc2UoKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0dGhlbjogZnVuY3Rpb24oIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkLCBvblByb2dyZXNzICkge1xuXHRcdFx0XHRcdHZhciBtYXhEZXB0aCA9IDA7XG5cdFx0XHRcdFx0ZnVuY3Rpb24gcmVzb2x2ZSggZGVwdGgsIGRlZmVycmVkLCBoYW5kbGVyLCBzcGVjaWFsICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHR2YXIgdGhhdCA9IHRoaXMsXG5cdFx0XHRcdFx0XHRcdFx0YXJncyA9IGFyZ3VtZW50cyxcblx0XHRcdFx0XHRcdFx0XHRtaWdodFRocm93ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR2YXIgcmV0dXJuZWQsIHRoZW47XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjMuMy4zXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC01OVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gSWdub3JlIGRvdWJsZS1yZXNvbHV0aW9uIGF0dGVtcHRzXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGRlcHRoIDwgbWF4RGVwdGggKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQgPSBoYW5kbGVyLmFwcGx5KCB0aGF0LCBhcmdzICk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjFcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTQ4XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHJldHVybmVkID09PSBkZWZlcnJlZC5wcm9taXNlKCkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoIFwiVGhlbmFibGUgc2VsZi1yZXNvbHV0aW9uXCIgKTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbnMgMi4zLjMuMSwgMy41XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC01NFxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNzVcblx0XHRcdFx0XHRcdFx0XHRcdC8vIFJldHJpZXZlIGB0aGVuYCBvbmx5IG9uY2Vcblx0XHRcdFx0XHRcdFx0XHRcdHRoZW4gPSByZXR1cm5lZCAmJlxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjRcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNjRcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBjaGVjayBvYmplY3RzIGFuZCBmdW5jdGlvbnMgZm9yIHRoZW5hYmlsaXR5XG5cdFx0XHRcdFx0XHRcdFx0XHRcdCggdHlwZW9mIHJldHVybmVkID09PSBcIm9iamVjdFwiIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZW9mIHJldHVybmVkID09PSBcImZ1bmN0aW9uXCIgKSAmJlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZC50aGVuO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBIYW5kbGUgYSByZXR1cm5lZCB0aGVuYWJsZVxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggdGhlbiApICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFNwZWNpYWwgcHJvY2Vzc29ycyAobm90aWZ5KSBqdXN0IHdhaXQgZm9yIHJlc29sdXRpb25cblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBzcGVjaWFsICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoZW4uY2FsbChcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBJZGVudGl0eSwgc3BlY2lhbCApLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBUaHJvd2VyLCBzcGVjaWFsIClcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE5vcm1hbCBwcm9jZXNzb3JzIChyZXNvbHZlKSBhbHNvIGhvb2sgaW50byBwcm9ncmVzc1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gLi4uYW5kIGRpc3JlZ2FyZCBvbGRlciByZXNvbHV0aW9uIHZhbHVlc1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG1heERlcHRoKys7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0aGVuLmNhbGwoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgSWRlbnRpdHksIHNwZWNpYWwgKSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgVGhyb3dlciwgc3BlY2lhbCApLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBJZGVudGl0eSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBIYW5kbGUgYWxsIG90aGVyIHJldHVybmVkIHZhbHVlc1xuXHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBPbmx5IHN1YnN0aXR1dGUgaGFuZGxlcnMgcGFzcyBvbiBjb250ZXh0XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGFuZCBtdWx0aXBsZSB2YWx1ZXMgKG5vbi1zcGVjIGJlaGF2aW9yKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGhhbmRsZXIgIT09IElkZW50aXR5ICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoYXQgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YXJncyA9IFsgcmV0dXJuZWQgXTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFByb2Nlc3MgdGhlIHZhbHVlKHMpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIERlZmF1bHQgcHJvY2VzcyBpcyByZXNvbHZlXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCggc3BlY2lhbCB8fCBkZWZlcnJlZC5yZXNvbHZlV2l0aCApKCB0aGF0LCBhcmdzICk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fSxcblxuXHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgbm9ybWFsIHByb2Nlc3NvcnMgKHJlc29sdmUpIGNhdGNoIGFuZCByZWplY3QgZXhjZXB0aW9uc1xuXHRcdFx0XHRcdFx0XHRcdHByb2Nlc3MgPSBzcGVjaWFsID9cblx0XHRcdFx0XHRcdFx0XHRcdG1pZ2h0VGhyb3cgOlxuXHRcdFx0XHRcdFx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bWlnaHRUaHJvdygpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggalF1ZXJ5LkRlZmVycmVkLmV4Y2VwdGlvbkhvb2sgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuRGVmZXJyZWQuZXhjZXB0aW9uSG9vayggZSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cHJvY2Vzcy5zdGFja1RyYWNlICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuMy4zLjQuMVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTYxXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gSWdub3JlIHBvc3QtcmVzb2x1dGlvbiBleGNlcHRpb25zXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBkZXB0aCArIDEgPj0gbWF4RGVwdGggKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgc3Vic3RpdHV0ZSBoYW5kbGVycyBwYXNzIG9uIGNvbnRleHRcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGFuZCBtdWx0aXBsZSB2YWx1ZXMgKG5vbi1zcGVjIGJlaGF2aW9yKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBoYW5kbGVyICE9PSBUaHJvd2VyICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0aGF0ID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRhcmdzID0gWyBlIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGRlZmVycmVkLnJlamVjdFdpdGgoIHRoYXQsIGFyZ3MgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuMy4zLjFcblx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNTdcblx0XHRcdFx0XHRcdFx0Ly8gUmUtcmVzb2x2ZSBwcm9taXNlcyBpbW1lZGlhdGVseSB0byBkb2RnZSBmYWxzZSByZWplY3Rpb24gZnJvbVxuXHRcdFx0XHRcdFx0XHQvLyBzdWJzZXF1ZW50IGVycm9yc1xuXHRcdFx0XHRcdFx0XHRpZiAoIGRlcHRoICkge1xuXHRcdFx0XHRcdFx0XHRcdHByb2Nlc3MoKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIENhbGwgYW4gb3B0aW9uYWwgaG9vayB0byByZWNvcmQgdGhlIHN0YWNrLCBpbiBjYXNlIG9mIGV4Y2VwdGlvblxuXHRcdFx0XHRcdFx0XHRcdC8vIHNpbmNlIGl0J3Mgb3RoZXJ3aXNlIGxvc3Qgd2hlbiBleGVjdXRpb24gZ29lcyBhc3luY1xuXHRcdFx0XHRcdFx0XHRcdGlmICggalF1ZXJ5LkRlZmVycmVkLmdldFN0YWNrSG9vayApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHByb2Nlc3Muc3RhY2tUcmFjZSA9IGpRdWVyeS5EZWZlcnJlZC5nZXRTdGFja0hvb2soKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0d2luZG93LnNldFRpbWVvdXQoIHByb2Nlc3MgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4galF1ZXJ5LkRlZmVycmVkKCBmdW5jdGlvbiggbmV3RGVmZXIgKSB7XG5cblx0XHRcdFx0XHRcdC8vIHByb2dyZXNzX2hhbmRsZXJzLmFkZCggLi4uIClcblx0XHRcdFx0XHRcdHR1cGxlc1sgMCBdWyAzIF0uYWRkKFxuXHRcdFx0XHRcdFx0XHRyZXNvbHZlKFxuXHRcdFx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXIsXG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LmlzRnVuY3Rpb24oIG9uUHJvZ3Jlc3MgKSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRvblByb2dyZXNzIDpcblx0XHRcdFx0XHRcdFx0XHRcdElkZW50aXR5LFxuXHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyLm5vdGlmeVdpdGhcblx0XHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0Ly8gZnVsZmlsbGVkX2hhbmRsZXJzLmFkZCggLi4uIClcblx0XHRcdFx0XHRcdHR1cGxlc1sgMSBdWyAzIF0uYWRkKFxuXHRcdFx0XHRcdFx0XHRyZXNvbHZlKFxuXHRcdFx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXIsXG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LmlzRnVuY3Rpb24oIG9uRnVsZmlsbGVkICkgP1xuXHRcdFx0XHRcdFx0XHRcdFx0b25GdWxmaWxsZWQgOlxuXHRcdFx0XHRcdFx0XHRcdFx0SWRlbnRpdHlcblx0XHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0Ly8gcmVqZWN0ZWRfaGFuZGxlcnMuYWRkKCAuLi4gKVxuXHRcdFx0XHRcdFx0dHVwbGVzWyAyIF1bIDMgXS5hZGQoXG5cdFx0XHRcdFx0XHRcdHJlc29sdmUoXG5cdFx0XHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlcixcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuaXNGdW5jdGlvbiggb25SZWplY3RlZCApID9cblx0XHRcdFx0XHRcdFx0XHRcdG9uUmVqZWN0ZWQgOlxuXHRcdFx0XHRcdFx0XHRcdFx0VGhyb3dlclxuXHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdH0gKS5wcm9taXNlKCk7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gR2V0IGEgcHJvbWlzZSBmb3IgdGhpcyBkZWZlcnJlZFxuXHRcdFx0XHQvLyBJZiBvYmogaXMgcHJvdmlkZWQsIHRoZSBwcm9taXNlIGFzcGVjdCBpcyBhZGRlZCB0byB0aGUgb2JqZWN0XG5cdFx0XHRcdHByb21pc2U6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9iaiAhPSBudWxsID8galF1ZXJ5LmV4dGVuZCggb2JqLCBwcm9taXNlICkgOiBwcm9taXNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0ZGVmZXJyZWQgPSB7fTtcblxuXHRcdC8vIEFkZCBsaXN0LXNwZWNpZmljIG1ldGhvZHNcblx0XHRqUXVlcnkuZWFjaCggdHVwbGVzLCBmdW5jdGlvbiggaSwgdHVwbGUgKSB7XG5cdFx0XHR2YXIgbGlzdCA9IHR1cGxlWyAyIF0sXG5cdFx0XHRcdHN0YXRlU3RyaW5nID0gdHVwbGVbIDUgXTtcblxuXHRcdFx0Ly8gcHJvbWlzZS5wcm9ncmVzcyA9IGxpc3QuYWRkXG5cdFx0XHQvLyBwcm9taXNlLmRvbmUgPSBsaXN0LmFkZFxuXHRcdFx0Ly8gcHJvbWlzZS5mYWlsID0gbGlzdC5hZGRcblx0XHRcdHByb21pc2VbIHR1cGxlWyAxIF0gXSA9IGxpc3QuYWRkO1xuXG5cdFx0XHQvLyBIYW5kbGUgc3RhdGVcblx0XHRcdGlmICggc3RhdGVTdHJpbmcgKSB7XG5cdFx0XHRcdGxpc3QuYWRkKFxuXHRcdFx0XHRcdGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdFx0XHQvLyBzdGF0ZSA9IFwicmVzb2x2ZWRcIiAoaS5lLiwgZnVsZmlsbGVkKVxuXHRcdFx0XHRcdFx0Ly8gc3RhdGUgPSBcInJlamVjdGVkXCJcblx0XHRcdFx0XHRcdHN0YXRlID0gc3RhdGVTdHJpbmc7XG5cdFx0XHRcdFx0fSxcblxuXHRcdFx0XHRcdC8vIHJlamVjdGVkX2NhbGxiYWNrcy5kaXNhYmxlXG5cdFx0XHRcdFx0Ly8gZnVsZmlsbGVkX2NhbGxiYWNrcy5kaXNhYmxlXG5cdFx0XHRcdFx0dHVwbGVzWyAzIC0gaSBdWyAyIF0uZGlzYWJsZSxcblxuXHRcdFx0XHRcdC8vIHByb2dyZXNzX2NhbGxiYWNrcy5sb2NrXG5cdFx0XHRcdFx0dHVwbGVzWyAwIF1bIDIgXS5sb2NrXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIHByb2dyZXNzX2hhbmRsZXJzLmZpcmVcblx0XHRcdC8vIGZ1bGZpbGxlZF9oYW5kbGVycy5maXJlXG5cdFx0XHQvLyByZWplY3RlZF9oYW5kbGVycy5maXJlXG5cdFx0XHRsaXN0LmFkZCggdHVwbGVbIDMgXS5maXJlICk7XG5cblx0XHRcdC8vIGRlZmVycmVkLm5vdGlmeSA9IGZ1bmN0aW9uKCkgeyBkZWZlcnJlZC5ub3RpZnlXaXRoKC4uLikgfVxuXHRcdFx0Ly8gZGVmZXJyZWQucmVzb2x2ZSA9IGZ1bmN0aW9uKCkgeyBkZWZlcnJlZC5yZXNvbHZlV2l0aCguLi4pIH1cblx0XHRcdC8vIGRlZmVycmVkLnJlamVjdCA9IGZ1bmN0aW9uKCkgeyBkZWZlcnJlZC5yZWplY3RXaXRoKC4uLikgfVxuXHRcdFx0ZGVmZXJyZWRbIHR1cGxlWyAwIF0gXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDAgXSArIFwiV2l0aFwiIF0oIHRoaXMgPT09IGRlZmVycmVkID8gdW5kZWZpbmVkIDogdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fTtcblxuXHRcdFx0Ly8gZGVmZXJyZWQubm90aWZ5V2l0aCA9IGxpc3QuZmlyZVdpdGhcblx0XHRcdC8vIGRlZmVycmVkLnJlc29sdmVXaXRoID0gbGlzdC5maXJlV2l0aFxuXHRcdFx0Ly8gZGVmZXJyZWQucmVqZWN0V2l0aCA9IGxpc3QuZmlyZVdpdGhcblx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMCBdICsgXCJXaXRoXCIgXSA9IGxpc3QuZmlyZVdpdGg7XG5cdFx0fSApO1xuXG5cdFx0Ly8gTWFrZSB0aGUgZGVmZXJyZWQgYSBwcm9taXNlXG5cdFx0cHJvbWlzZS5wcm9taXNlKCBkZWZlcnJlZCApO1xuXG5cdFx0Ly8gQ2FsbCBnaXZlbiBmdW5jIGlmIGFueVxuXHRcdGlmICggZnVuYyApIHtcblx0XHRcdGZ1bmMuY2FsbCggZGVmZXJyZWQsIGRlZmVycmVkICk7XG5cdFx0fVxuXG5cdFx0Ly8gQWxsIGRvbmUhXG5cdFx0cmV0dXJuIGRlZmVycmVkO1xuXHR9LFxuXG5cdC8vIERlZmVycmVkIGhlbHBlclxuXHR3aGVuOiBmdW5jdGlvbiggc2luZ2xlVmFsdWUgKSB7XG5cdFx0dmFyXG5cblx0XHRcdC8vIGNvdW50IG9mIHVuY29tcGxldGVkIHN1Ym9yZGluYXRlc1xuXHRcdFx0cmVtYWluaW5nID0gYXJndW1lbnRzLmxlbmd0aCxcblxuXHRcdFx0Ly8gY291bnQgb2YgdW5wcm9jZXNzZWQgYXJndW1lbnRzXG5cdFx0XHRpID0gcmVtYWluaW5nLFxuXG5cdFx0XHQvLyBzdWJvcmRpbmF0ZSBmdWxmaWxsbWVudCBkYXRhXG5cdFx0XHRyZXNvbHZlQ29udGV4dHMgPSBBcnJheSggaSApLFxuXHRcdFx0cmVzb2x2ZVZhbHVlcyA9IHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApLFxuXG5cdFx0XHQvLyB0aGUgbWFzdGVyIERlZmVycmVkXG5cdFx0XHRtYXN0ZXIgPSBqUXVlcnkuRGVmZXJyZWQoKSxcblxuXHRcdFx0Ly8gc3Vib3JkaW5hdGUgY2FsbGJhY2sgZmFjdG9yeVxuXHRcdFx0dXBkYXRlRnVuYyA9IGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHRcdHJlc29sdmVDb250ZXh0c1sgaSBdID0gdGhpcztcblx0XHRcdFx0XHRyZXNvbHZlVmFsdWVzWyBpIF0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApIDogdmFsdWU7XG5cdFx0XHRcdFx0aWYgKCAhKCAtLXJlbWFpbmluZyApICkge1xuXHRcdFx0XHRcdFx0bWFzdGVyLnJlc29sdmVXaXRoKCByZXNvbHZlQ29udGV4dHMsIHJlc29sdmVWYWx1ZXMgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXG5cdFx0Ly8gU2luZ2xlLSBhbmQgZW1wdHkgYXJndW1lbnRzIGFyZSBhZG9wdGVkIGxpa2UgUHJvbWlzZS5yZXNvbHZlXG5cdFx0aWYgKCByZW1haW5pbmcgPD0gMSApIHtcblx0XHRcdGFkb3B0VmFsdWUoIHNpbmdsZVZhbHVlLCBtYXN0ZXIuZG9uZSggdXBkYXRlRnVuYyggaSApICkucmVzb2x2ZSwgbWFzdGVyLnJlamVjdCApO1xuXG5cdFx0XHQvLyBVc2UgLnRoZW4oKSB0byB1bndyYXAgc2Vjb25kYXJ5IHRoZW5hYmxlcyAoY2YuIGdoLTMwMDApXG5cdFx0XHRpZiAoIG1hc3Rlci5zdGF0ZSgpID09PSBcInBlbmRpbmdcIiB8fFxuXHRcdFx0XHRqUXVlcnkuaXNGdW5jdGlvbiggcmVzb2x2ZVZhbHVlc1sgaSBdICYmIHJlc29sdmVWYWx1ZXNbIGkgXS50aGVuICkgKSB7XG5cblx0XHRcdFx0cmV0dXJuIG1hc3Rlci50aGVuKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gTXVsdGlwbGUgYXJndW1lbnRzIGFyZSBhZ2dyZWdhdGVkIGxpa2UgUHJvbWlzZS5hbGwgYXJyYXkgZWxlbWVudHNcblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdGFkb3B0VmFsdWUoIHJlc29sdmVWYWx1ZXNbIGkgXSwgdXBkYXRlRnVuYyggaSApLCBtYXN0ZXIucmVqZWN0ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1hc3Rlci5wcm9taXNlKCk7XG5cdH1cbn0gKTtcblxuXG4vLyBUaGVzZSB1c3VhbGx5IGluZGljYXRlIGEgcHJvZ3JhbW1lciBtaXN0YWtlIGR1cmluZyBkZXZlbG9wbWVudCxcbi8vIHdhcm4gYWJvdXQgdGhlbSBBU0FQIHJhdGhlciB0aGFuIHN3YWxsb3dpbmcgdGhlbSBieSBkZWZhdWx0LlxudmFyIHJlcnJvck5hbWVzID0gL14oRXZhbHxJbnRlcm5hbHxSYW5nZXxSZWZlcmVuY2V8U3ludGF4fFR5cGV8VVJJKUVycm9yJC87XG5cbmpRdWVyeS5EZWZlcnJlZC5leGNlcHRpb25Ib29rID0gZnVuY3Rpb24oIGVycm9yLCBzdGFjayApIHtcblxuXHQvLyBTdXBwb3J0OiBJRSA4IC0gOSBvbmx5XG5cdC8vIENvbnNvbGUgZXhpc3RzIHdoZW4gZGV2IHRvb2xzIGFyZSBvcGVuLCB3aGljaCBjYW4gaGFwcGVuIGF0IGFueSB0aW1lXG5cdGlmICggd2luZG93LmNvbnNvbGUgJiYgd2luZG93LmNvbnNvbGUud2FybiAmJiBlcnJvciAmJiByZXJyb3JOYW1lcy50ZXN0KCBlcnJvci5uYW1lICkgKSB7XG5cdFx0d2luZG93LmNvbnNvbGUud2FybiggXCJqUXVlcnkuRGVmZXJyZWQgZXhjZXB0aW9uOiBcIiArIGVycm9yLm1lc3NhZ2UsIGVycm9yLnN0YWNrLCBzdGFjayApO1xuXHR9XG59O1xuXG5cblxuXG5qUXVlcnkucmVhZHlFeGNlcHRpb24gPSBmdW5jdGlvbiggZXJyb3IgKSB7XG5cdHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHR0aHJvdyBlcnJvcjtcblx0fSApO1xufTtcblxuXG5cblxuLy8gVGhlIGRlZmVycmVkIHVzZWQgb24gRE9NIHJlYWR5XG52YXIgcmVhZHlMaXN0ID0galF1ZXJ5LkRlZmVycmVkKCk7XG5cbmpRdWVyeS5mbi5yZWFkeSA9IGZ1bmN0aW9uKCBmbiApIHtcblxuXHRyZWFkeUxpc3Rcblx0XHQudGhlbiggZm4gKVxuXG5cdFx0Ly8gV3JhcCBqUXVlcnkucmVhZHlFeGNlcHRpb24gaW4gYSBmdW5jdGlvbiBzbyB0aGF0IHRoZSBsb29rdXBcblx0XHQvLyBoYXBwZW5zIGF0IHRoZSB0aW1lIG9mIGVycm9yIGhhbmRsaW5nIGluc3RlYWQgb2YgY2FsbGJhY2tcblx0XHQvLyByZWdpc3RyYXRpb24uXG5cdFx0LmNhdGNoKCBmdW5jdGlvbiggZXJyb3IgKSB7XG5cdFx0XHRqUXVlcnkucmVhZHlFeGNlcHRpb24oIGVycm9yICk7XG5cdFx0fSApO1xuXG5cdHJldHVybiB0aGlzO1xufTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdC8vIElzIHRoZSBET00gcmVhZHkgdG8gYmUgdXNlZD8gU2V0IHRvIHRydWUgb25jZSBpdCBvY2N1cnMuXG5cdGlzUmVhZHk6IGZhbHNlLFxuXG5cdC8vIEEgY291bnRlciB0byB0cmFjayBob3cgbWFueSBpdGVtcyB0byB3YWl0IGZvciBiZWZvcmVcblx0Ly8gdGhlIHJlYWR5IGV2ZW50IGZpcmVzLiBTZWUgIzY3ODFcblx0cmVhZHlXYWl0OiAxLFxuXG5cdC8vIEhvbGQgKG9yIHJlbGVhc2UpIHRoZSByZWFkeSBldmVudFxuXHRob2xkUmVhZHk6IGZ1bmN0aW9uKCBob2xkICkge1xuXHRcdGlmICggaG9sZCApIHtcblx0XHRcdGpRdWVyeS5yZWFkeVdhaXQrKztcblx0XHR9IGVsc2Uge1xuXHRcdFx0alF1ZXJ5LnJlYWR5KCB0cnVlICk7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIEhhbmRsZSB3aGVuIHRoZSBET00gaXMgcmVhZHlcblx0cmVhZHk6IGZ1bmN0aW9uKCB3YWl0ICkge1xuXG5cdFx0Ly8gQWJvcnQgaWYgdGhlcmUgYXJlIHBlbmRpbmcgaG9sZHMgb3Igd2UncmUgYWxyZWFkeSByZWFkeVxuXHRcdGlmICggd2FpdCA9PT0gdHJ1ZSA/IC0talF1ZXJ5LnJlYWR5V2FpdCA6IGpRdWVyeS5pc1JlYWR5ICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIFJlbWVtYmVyIHRoYXQgdGhlIERPTSBpcyByZWFkeVxuXHRcdGpRdWVyeS5pc1JlYWR5ID0gdHJ1ZTtcblxuXHRcdC8vIElmIGEgbm9ybWFsIERPTSBSZWFkeSBldmVudCBmaXJlZCwgZGVjcmVtZW50LCBhbmQgd2FpdCBpZiBuZWVkIGJlXG5cdFx0aWYgKCB3YWl0ICE9PSB0cnVlICYmIC0talF1ZXJ5LnJlYWR5V2FpdCA+IDAgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gSWYgdGhlcmUgYXJlIGZ1bmN0aW9ucyBib3VuZCwgdG8gZXhlY3V0ZVxuXHRcdHJlYWR5TGlzdC5yZXNvbHZlV2l0aCggZG9jdW1lbnQsIFsgalF1ZXJ5IF0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkucmVhZHkudGhlbiA9IHJlYWR5TGlzdC50aGVuO1xuXG4vLyBUaGUgcmVhZHkgZXZlbnQgaGFuZGxlciBhbmQgc2VsZiBjbGVhbnVwIG1ldGhvZFxuZnVuY3Rpb24gY29tcGxldGVkKCkge1xuXHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCBcIkRPTUNvbnRlbnRMb2FkZWRcIiwgY29tcGxldGVkICk7XG5cdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCBcImxvYWRcIiwgY29tcGxldGVkICk7XG5cdGpRdWVyeS5yZWFkeSgpO1xufVxuXG4vLyBDYXRjaCBjYXNlcyB3aGVyZSAkKGRvY3VtZW50KS5yZWFkeSgpIGlzIGNhbGxlZFxuLy8gYWZ0ZXIgdGhlIGJyb3dzZXIgZXZlbnQgaGFzIGFscmVhZHkgb2NjdXJyZWQuXG4vLyBTdXBwb3J0OiBJRSA8PTkgLSAxMCBvbmx5XG4vLyBPbGRlciBJRSBzb21ldGltZXMgc2lnbmFscyBcImludGVyYWN0aXZlXCIgdG9vIHNvb25cbmlmICggZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gXCJjb21wbGV0ZVwiIHx8XG5cdCggZG9jdW1lbnQucmVhZHlTdGF0ZSAhPT0gXCJsb2FkaW5nXCIgJiYgIWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5kb1Njcm9sbCApICkge1xuXG5cdC8vIEhhbmRsZSBpdCBhc3luY2hyb25vdXNseSB0byBhbGxvdyBzY3JpcHRzIHRoZSBvcHBvcnR1bml0eSB0byBkZWxheSByZWFkeVxuXHR3aW5kb3cuc2V0VGltZW91dCggalF1ZXJ5LnJlYWR5ICk7XG5cbn0gZWxzZSB7XG5cblx0Ly8gVXNlIHRoZSBoYW5keSBldmVudCBjYWxsYmFja1xuXHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCBcIkRPTUNvbnRlbnRMb2FkZWRcIiwgY29tcGxldGVkICk7XG5cblx0Ly8gQSBmYWxsYmFjayB0byB3aW5kb3cub25sb2FkLCB0aGF0IHdpbGwgYWx3YXlzIHdvcmtcblx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoIFwibG9hZFwiLCBjb21wbGV0ZWQgKTtcbn1cblxuXG5cblxuLy8gTXVsdGlmdW5jdGlvbmFsIG1ldGhvZCB0byBnZXQgYW5kIHNldCB2YWx1ZXMgb2YgYSBjb2xsZWN0aW9uXG4vLyBUaGUgdmFsdWUvcyBjYW4gb3B0aW9uYWxseSBiZSBleGVjdXRlZCBpZiBpdCdzIGEgZnVuY3Rpb25cbnZhciBhY2Nlc3MgPSBmdW5jdGlvbiggZWxlbXMsIGZuLCBrZXksIHZhbHVlLCBjaGFpbmFibGUsIGVtcHR5R2V0LCByYXcgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsZW4gPSBlbGVtcy5sZW5ndGgsXG5cdFx0YnVsayA9IGtleSA9PSBudWxsO1xuXG5cdC8vIFNldHMgbWFueSB2YWx1ZXNcblx0aWYgKCBqUXVlcnkudHlwZSgga2V5ICkgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0Y2hhaW5hYmxlID0gdHJ1ZTtcblx0XHRmb3IgKCBpIGluIGtleSApIHtcblx0XHRcdGFjY2VzcyggZWxlbXMsIGZuLCBpLCBrZXlbIGkgXSwgdHJ1ZSwgZW1wdHlHZXQsIHJhdyApO1xuXHRcdH1cblxuXHQvLyBTZXRzIG9uZSB2YWx1ZVxuXHR9IGVsc2UgaWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdGNoYWluYWJsZSA9IHRydWU7XG5cblx0XHRpZiAoICFqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJhdyA9IHRydWU7XG5cdFx0fVxuXG5cdFx0aWYgKCBidWxrICkge1xuXG5cdFx0XHQvLyBCdWxrIG9wZXJhdGlvbnMgcnVuIGFnYWluc3QgdGhlIGVudGlyZSBzZXRcblx0XHRcdGlmICggcmF3ICkge1xuXHRcdFx0XHRmbi5jYWxsKCBlbGVtcywgdmFsdWUgKTtcblx0XHRcdFx0Zm4gPSBudWxsO1xuXG5cdFx0XHQvLyAuLi5leGNlcHQgd2hlbiBleGVjdXRpbmcgZnVuY3Rpb24gdmFsdWVzXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRidWxrID0gZm47XG5cdFx0XHRcdGZuID0gZnVuY3Rpb24oIGVsZW0sIGtleSwgdmFsdWUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGJ1bGsuY2FsbCggalF1ZXJ5KCBlbGVtICksIHZhbHVlICk7XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCBmbiApIHtcblx0XHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRmbihcblx0XHRcdFx0XHRlbGVtc1sgaSBdLCBrZXksIHJhdyA/XG5cdFx0XHRcdFx0dmFsdWUgOlxuXHRcdFx0XHRcdHZhbHVlLmNhbGwoIGVsZW1zWyBpIF0sIGksIGZuKCBlbGVtc1sgaSBdLCBrZXkgKSApXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0aWYgKCBjaGFpbmFibGUgKSB7XG5cdFx0cmV0dXJuIGVsZW1zO1xuXHR9XG5cblx0Ly8gR2V0c1xuXHRpZiAoIGJ1bGsgKSB7XG5cdFx0cmV0dXJuIGZuLmNhbGwoIGVsZW1zICk7XG5cdH1cblxuXHRyZXR1cm4gbGVuID8gZm4oIGVsZW1zWyAwIF0sIGtleSApIDogZW1wdHlHZXQ7XG59O1xudmFyIGFjY2VwdERhdGEgPSBmdW5jdGlvbiggb3duZXIgKSB7XG5cblx0Ly8gQWNjZXB0cyBvbmx5OlxuXHQvLyAgLSBOb2RlXG5cdC8vICAgIC0gTm9kZS5FTEVNRU5UX05PREVcblx0Ly8gICAgLSBOb2RlLkRPQ1VNRU5UX05PREVcblx0Ly8gIC0gT2JqZWN0XG5cdC8vICAgIC0gQW55XG5cdHJldHVybiBvd25lci5ub2RlVHlwZSA9PT0gMSB8fCBvd25lci5ub2RlVHlwZSA9PT0gOSB8fCAhKCArb3duZXIubm9kZVR5cGUgKTtcbn07XG5cblxuXG5cbmZ1bmN0aW9uIERhdGEoKSB7XG5cdHRoaXMuZXhwYW5kbyA9IGpRdWVyeS5leHBhbmRvICsgRGF0YS51aWQrKztcbn1cblxuRGF0YS51aWQgPSAxO1xuXG5EYXRhLnByb3RvdHlwZSA9IHtcblxuXHRjYWNoZTogZnVuY3Rpb24oIG93bmVyICkge1xuXG5cdFx0Ly8gQ2hlY2sgaWYgdGhlIG93bmVyIG9iamVjdCBhbHJlYWR5IGhhcyBhIGNhY2hlXG5cdFx0dmFyIHZhbHVlID0gb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXG5cdFx0Ly8gSWYgbm90LCBjcmVhdGUgb25lXG5cdFx0aWYgKCAhdmFsdWUgKSB7XG5cdFx0XHR2YWx1ZSA9IHt9O1xuXG5cdFx0XHQvLyBXZSBjYW4gYWNjZXB0IGRhdGEgZm9yIG5vbi1lbGVtZW50IG5vZGVzIGluIG1vZGVybiBicm93c2Vycyxcblx0XHRcdC8vIGJ1dCB3ZSBzaG91bGQgbm90LCBzZWUgIzgzMzUuXG5cdFx0XHQvLyBBbHdheXMgcmV0dXJuIGFuIGVtcHR5IG9iamVjdC5cblx0XHRcdGlmICggYWNjZXB0RGF0YSggb3duZXIgKSApIHtcblxuXHRcdFx0XHQvLyBJZiBpdCBpcyBhIG5vZGUgdW5saWtlbHkgdG8gYmUgc3RyaW5naWZ5LWVkIG9yIGxvb3BlZCBvdmVyXG5cdFx0XHRcdC8vIHVzZSBwbGFpbiBhc3NpZ25tZW50XG5cdFx0XHRcdGlmICggb3duZXIubm9kZVR5cGUgKSB7XG5cdFx0XHRcdFx0b3duZXJbIHRoaXMuZXhwYW5kbyBdID0gdmFsdWU7XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIHNlY3VyZSBpdCBpbiBhIG5vbi1lbnVtZXJhYmxlIHByb3BlcnR5XG5cdFx0XHRcdC8vIGNvbmZpZ3VyYWJsZSBtdXN0IGJlIHRydWUgdG8gYWxsb3cgdGhlIHByb3BlcnR5IHRvIGJlXG5cdFx0XHRcdC8vIGRlbGV0ZWQgd2hlbiBkYXRhIGlzIHJlbW92ZWRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIG93bmVyLCB0aGlzLmV4cGFuZG8sIHtcblx0XHRcdFx0XHRcdHZhbHVlOiB2YWx1ZSxcblx0XHRcdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB2YWx1ZTtcblx0fSxcblx0c2V0OiBmdW5jdGlvbiggb3duZXIsIGRhdGEsIHZhbHVlICkge1xuXHRcdHZhciBwcm9wLFxuXHRcdFx0Y2FjaGUgPSB0aGlzLmNhY2hlKCBvd25lciApO1xuXG5cdFx0Ly8gSGFuZGxlOiBbIG93bmVyLCBrZXksIHZhbHVlIF0gYXJnc1xuXHRcdC8vIEFsd2F5cyB1c2UgY2FtZWxDYXNlIGtleSAoZ2gtMjI1Nylcblx0XHRpZiAoIHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0Y2FjaGVbIGpRdWVyeS5jYW1lbENhc2UoIGRhdGEgKSBdID0gdmFsdWU7XG5cblx0XHQvLyBIYW5kbGU6IFsgb3duZXIsIHsgcHJvcGVydGllcyB9IF0gYXJnc1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIENvcHkgdGhlIHByb3BlcnRpZXMgb25lLWJ5LW9uZSB0byB0aGUgY2FjaGUgb2JqZWN0XG5cdFx0XHRmb3IgKCBwcm9wIGluIGRhdGEgKSB7XG5cdFx0XHRcdGNhY2hlWyBqUXVlcnkuY2FtZWxDYXNlKCBwcm9wICkgXSA9IGRhdGFbIHByb3AgXTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGNhY2hlO1xuXHR9LFxuXHRnZXQ6IGZ1bmN0aW9uKCBvd25lciwga2V5ICkge1xuXHRcdHJldHVybiBrZXkgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHR0aGlzLmNhY2hlKCBvd25lciApIDpcblxuXHRcdFx0Ly8gQWx3YXlzIHVzZSBjYW1lbENhc2Uga2V5IChnaC0yMjU3KVxuXHRcdFx0b3duZXJbIHRoaXMuZXhwYW5kbyBdICYmIG93bmVyWyB0aGlzLmV4cGFuZG8gXVsgalF1ZXJ5LmNhbWVsQ2FzZSgga2V5ICkgXTtcblx0fSxcblx0YWNjZXNzOiBmdW5jdGlvbiggb3duZXIsIGtleSwgdmFsdWUgKSB7XG5cblx0XHQvLyBJbiBjYXNlcyB3aGVyZSBlaXRoZXI6XG5cdFx0Ly9cblx0XHQvLyAgIDEuIE5vIGtleSB3YXMgc3BlY2lmaWVkXG5cdFx0Ly8gICAyLiBBIHN0cmluZyBrZXkgd2FzIHNwZWNpZmllZCwgYnV0IG5vIHZhbHVlIHByb3ZpZGVkXG5cdFx0Ly9cblx0XHQvLyBUYWtlIHRoZSBcInJlYWRcIiBwYXRoIGFuZCBhbGxvdyB0aGUgZ2V0IG1ldGhvZCB0byBkZXRlcm1pbmVcblx0XHQvLyB3aGljaCB2YWx1ZSB0byByZXR1cm4sIHJlc3BlY3RpdmVseSBlaXRoZXI6XG5cdFx0Ly9cblx0XHQvLyAgIDEuIFRoZSBlbnRpcmUgY2FjaGUgb2JqZWN0XG5cdFx0Ly8gICAyLiBUaGUgZGF0YSBzdG9yZWQgYXQgdGhlIGtleVxuXHRcdC8vXG5cdFx0aWYgKCBrZXkgPT09IHVuZGVmaW5lZCB8fFxuXHRcdFx0XHQoICgga2V5ICYmIHR5cGVvZiBrZXkgPT09IFwic3RyaW5nXCIgKSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkICkgKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLmdldCggb3duZXIsIGtleSApO1xuXHRcdH1cblxuXHRcdC8vIFdoZW4gdGhlIGtleSBpcyBub3QgYSBzdHJpbmcsIG9yIGJvdGggYSBrZXkgYW5kIHZhbHVlXG5cdFx0Ly8gYXJlIHNwZWNpZmllZCwgc2V0IG9yIGV4dGVuZCAoZXhpc3Rpbmcgb2JqZWN0cykgd2l0aCBlaXRoZXI6XG5cdFx0Ly9cblx0XHQvLyAgIDEuIEFuIG9iamVjdCBvZiBwcm9wZXJ0aWVzXG5cdFx0Ly8gICAyLiBBIGtleSBhbmQgdmFsdWVcblx0XHQvL1xuXHRcdHRoaXMuc2V0KCBvd25lciwga2V5LCB2YWx1ZSApO1xuXG5cdFx0Ly8gU2luY2UgdGhlIFwic2V0XCIgcGF0aCBjYW4gaGF2ZSB0d28gcG9zc2libGUgZW50cnkgcG9pbnRzXG5cdFx0Ly8gcmV0dXJuIHRoZSBleHBlY3RlZCBkYXRhIGJhc2VkIG9uIHdoaWNoIHBhdGggd2FzIHRha2VuWypdXG5cdFx0cmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgPyB2YWx1ZSA6IGtleTtcblx0fSxcblx0cmVtb3ZlOiBmdW5jdGlvbiggb3duZXIsIGtleSApIHtcblx0XHR2YXIgaSxcblx0XHRcdGNhY2hlID0gb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXG5cdFx0aWYgKCBjYWNoZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICgga2V5ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdC8vIFN1cHBvcnQgYXJyYXkgb3Igc3BhY2Ugc2VwYXJhdGVkIHN0cmluZyBvZiBrZXlzXG5cdFx0XHRpZiAoIGpRdWVyeS5pc0FycmF5KCBrZXkgKSApIHtcblxuXHRcdFx0XHQvLyBJZiBrZXkgaXMgYW4gYXJyYXkgb2Yga2V5cy4uLlxuXHRcdFx0XHQvLyBXZSBhbHdheXMgc2V0IGNhbWVsQ2FzZSBrZXlzLCBzbyByZW1vdmUgdGhhdC5cblx0XHRcdFx0a2V5ID0ga2V5Lm1hcCggalF1ZXJ5LmNhbWVsQ2FzZSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0a2V5ID0galF1ZXJ5LmNhbWVsQ2FzZSgga2V5ICk7XG5cblx0XHRcdFx0Ly8gSWYgYSBrZXkgd2l0aCB0aGUgc3BhY2VzIGV4aXN0cywgdXNlIGl0LlxuXHRcdFx0XHQvLyBPdGhlcndpc2UsIGNyZWF0ZSBhbiBhcnJheSBieSBtYXRjaGluZyBub24td2hpdGVzcGFjZVxuXHRcdFx0XHRrZXkgPSBrZXkgaW4gY2FjaGUgP1xuXHRcdFx0XHRcdFsga2V5IF0gOlxuXHRcdFx0XHRcdCgga2V5Lm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW10gKTtcblx0XHRcdH1cblxuXHRcdFx0aSA9IGtleS5sZW5ndGg7XG5cblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRkZWxldGUgY2FjaGVbIGtleVsgaSBdIF07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUmVtb3ZlIHRoZSBleHBhbmRvIGlmIHRoZXJlJ3Mgbm8gbW9yZSBkYXRhXG5cdFx0aWYgKCBrZXkgPT09IHVuZGVmaW5lZCB8fCBqUXVlcnkuaXNFbXB0eU9iamVjdCggY2FjaGUgKSApIHtcblxuXHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lIDw9MzUgLSA0NVxuXHRcdFx0Ly8gV2Via2l0ICYgQmxpbmsgcGVyZm9ybWFuY2Ugc3VmZmVycyB3aGVuIGRlbGV0aW5nIHByb3BlcnRpZXNcblx0XHRcdC8vIGZyb20gRE9NIG5vZGVzLCBzbyBzZXQgdG8gdW5kZWZpbmVkIGluc3RlYWRcblx0XHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTM3ODYwNyAoYnVnIHJlc3RyaWN0ZWQpXG5cdFx0XHRpZiAoIG93bmVyLm5vZGVUeXBlICkge1xuXHRcdFx0XHRvd25lclsgdGhpcy5leHBhbmRvIF0gPSB1bmRlZmluZWQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkZWxldGUgb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblx0aGFzRGF0YTogZnVuY3Rpb24oIG93bmVyICkge1xuXHRcdHZhciBjYWNoZSA9IG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblx0XHRyZXR1cm4gY2FjaGUgIT09IHVuZGVmaW5lZCAmJiAhalF1ZXJ5LmlzRW1wdHlPYmplY3QoIGNhY2hlICk7XG5cdH1cbn07XG52YXIgZGF0YVByaXYgPSBuZXcgRGF0YSgpO1xuXG52YXIgZGF0YVVzZXIgPSBuZXcgRGF0YSgpO1xuXG5cblxuLy9cdEltcGxlbWVudGF0aW9uIFN1bW1hcnlcbi8vXG4vL1x0MS4gRW5mb3JjZSBBUEkgc3VyZmFjZSBhbmQgc2VtYW50aWMgY29tcGF0aWJpbGl0eSB3aXRoIDEuOS54IGJyYW5jaFxuLy9cdDIuIEltcHJvdmUgdGhlIG1vZHVsZSdzIG1haW50YWluYWJpbGl0eSBieSByZWR1Y2luZyB0aGUgc3RvcmFnZVxuLy9cdFx0cGF0aHMgdG8gYSBzaW5nbGUgbWVjaGFuaXNtLlxuLy9cdDMuIFVzZSB0aGUgc2FtZSBzaW5nbGUgbWVjaGFuaXNtIHRvIHN1cHBvcnQgXCJwcml2YXRlXCIgYW5kIFwidXNlclwiIGRhdGEuXG4vL1x0NC4gX05ldmVyXyBleHBvc2UgXCJwcml2YXRlXCIgZGF0YSB0byB1c2VyIGNvZGUgKFRPRE86IERyb3AgX2RhdGEsIF9yZW1vdmVEYXRhKVxuLy9cdDUuIEF2b2lkIGV4cG9zaW5nIGltcGxlbWVudGF0aW9uIGRldGFpbHMgb24gdXNlciBvYmplY3RzIChlZy4gZXhwYW5kbyBwcm9wZXJ0aWVzKVxuLy9cdDYuIFByb3ZpZGUgYSBjbGVhciBwYXRoIGZvciBpbXBsZW1lbnRhdGlvbiB1cGdyYWRlIHRvIFdlYWtNYXAgaW4gMjAxNFxuXG52YXIgcmJyYWNlID0gL14oPzpcXHtbXFx3XFxXXSpcXH18XFxbW1xcd1xcV10qXFxdKSQvLFxuXHRybXVsdGlEYXNoID0gL1tBLVpdL2c7XG5cbmZ1bmN0aW9uIGdldERhdGEoIGRhdGEgKSB7XG5cdGlmICggZGF0YSA9PT0gXCJ0cnVlXCIgKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHRpZiAoIGRhdGEgPT09IFwiZmFsc2VcIiApIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRpZiAoIGRhdGEgPT09IFwibnVsbFwiICkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0Ly8gT25seSBjb252ZXJ0IHRvIGEgbnVtYmVyIGlmIGl0IGRvZXNuJ3QgY2hhbmdlIHRoZSBzdHJpbmdcblx0aWYgKCBkYXRhID09PSArZGF0YSArIFwiXCIgKSB7XG5cdFx0cmV0dXJuICtkYXRhO1xuXHR9XG5cblx0aWYgKCByYnJhY2UudGVzdCggZGF0YSApICkge1xuXHRcdHJldHVybiBKU09OLnBhcnNlKCBkYXRhICk7XG5cdH1cblxuXHRyZXR1cm4gZGF0YTtcbn1cblxuZnVuY3Rpb24gZGF0YUF0dHIoIGVsZW0sIGtleSwgZGF0YSApIHtcblx0dmFyIG5hbWU7XG5cblx0Ly8gSWYgbm90aGluZyB3YXMgZm91bmQgaW50ZXJuYWxseSwgdHJ5IHRvIGZldGNoIGFueVxuXHQvLyBkYXRhIGZyb20gdGhlIEhUTUw1IGRhdGEtKiBhdHRyaWJ1dGVcblx0aWYgKCBkYXRhID09PSB1bmRlZmluZWQgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRuYW1lID0gXCJkYXRhLVwiICsga2V5LnJlcGxhY2UoIHJtdWx0aURhc2gsIFwiLSQmXCIgKS50b0xvd2VyQ2FzZSgpO1xuXHRcdGRhdGEgPSBlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSApO1xuXG5cdFx0aWYgKCB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGRhdGEgPSBnZXREYXRhKCBkYXRhICk7XG5cdFx0XHR9IGNhdGNoICggZSApIHt9XG5cblx0XHRcdC8vIE1ha2Ugc3VyZSB3ZSBzZXQgdGhlIGRhdGEgc28gaXQgaXNuJ3QgY2hhbmdlZCBsYXRlclxuXHRcdFx0ZGF0YVVzZXIuc2V0KCBlbGVtLCBrZXksIGRhdGEgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGF0YSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGRhdGE7XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0aGFzRGF0YTogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRhdGFVc2VyLmhhc0RhdGEoIGVsZW0gKSB8fCBkYXRhUHJpdi5oYXNEYXRhKCBlbGVtICk7XG5cdH0sXG5cblx0ZGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGRhdGEgKSB7XG5cdFx0cmV0dXJuIGRhdGFVc2VyLmFjY2VzcyggZWxlbSwgbmFtZSwgZGF0YSApO1xuXHR9LFxuXG5cdHJlbW92ZURhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHRcdGRhdGFVc2VyLnJlbW92ZSggZWxlbSwgbmFtZSApO1xuXHR9LFxuXG5cdC8vIFRPRE86IE5vdyB0aGF0IGFsbCBjYWxscyB0byBfZGF0YSBhbmQgX3JlbW92ZURhdGEgaGF2ZSBiZWVuIHJlcGxhY2VkXG5cdC8vIHdpdGggZGlyZWN0IGNhbGxzIHRvIGRhdGFQcml2IG1ldGhvZHMsIHRoZXNlIGNhbiBiZSBkZXByZWNhdGVkLlxuXHRfZGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGRhdGEgKSB7XG5cdFx0cmV0dXJuIGRhdGFQcml2LmFjY2VzcyggZWxlbSwgbmFtZSwgZGF0YSApO1xuXHR9LFxuXG5cdF9yZW1vdmVEYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIG5hbWUgKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGRhdGE6IGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xuXHRcdHZhciBpLCBuYW1lLCBkYXRhLFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXSxcblx0XHRcdGF0dHJzID0gZWxlbSAmJiBlbGVtLmF0dHJpYnV0ZXM7XG5cblx0XHQvLyBHZXRzIGFsbCB2YWx1ZXNcblx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0aWYgKCB0aGlzLmxlbmd0aCApIHtcblx0XHRcdFx0ZGF0YSA9IGRhdGFVc2VyLmdldCggZWxlbSApO1xuXG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAhZGF0YVByaXYuZ2V0KCBlbGVtLCBcImhhc0RhdGFBdHRyc1wiICkgKSB7XG5cdFx0XHRcdFx0aSA9IGF0dHJzLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgMTEgb25seVxuXHRcdFx0XHRcdFx0Ly8gVGhlIGF0dHJzIGVsZW1lbnRzIGNhbiBiZSBudWxsICgjMTQ4OTQpXG5cdFx0XHRcdFx0XHRpZiAoIGF0dHJzWyBpIF0gKSB7XG5cdFx0XHRcdFx0XHRcdG5hbWUgPSBhdHRyc1sgaSBdLm5hbWU7XG5cdFx0XHRcdFx0XHRcdGlmICggbmFtZS5pbmRleE9mKCBcImRhdGEtXCIgKSA9PT0gMCApIHtcblx0XHRcdFx0XHRcdFx0XHRuYW1lID0galF1ZXJ5LmNhbWVsQ2FzZSggbmFtZS5zbGljZSggNSApICk7XG5cdFx0XHRcdFx0XHRcdFx0ZGF0YUF0dHIoIGVsZW0sIG5hbWUsIGRhdGFbIG5hbWUgXSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGRhdGFQcml2LnNldCggZWxlbSwgXCJoYXNEYXRhQXR0cnNcIiwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBkYXRhO1xuXHRcdH1cblxuXHRcdC8vIFNldHMgbXVsdGlwbGUgdmFsdWVzXG5cdFx0aWYgKCB0eXBlb2Yga2V5ID09PSBcIm9iamVjdFwiICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGRhdGFVc2VyLnNldCggdGhpcywga2V5ICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0dmFyIGRhdGE7XG5cblx0XHRcdC8vIFRoZSBjYWxsaW5nIGpRdWVyeSBvYmplY3QgKGVsZW1lbnQgbWF0Y2hlcykgaXMgbm90IGVtcHR5XG5cdFx0XHQvLyAoYW5kIHRoZXJlZm9yZSBoYXMgYW4gZWxlbWVudCBhcHBlYXJzIGF0IHRoaXNbIDAgXSkgYW5kIHRoZVxuXHRcdFx0Ly8gYHZhbHVlYCBwYXJhbWV0ZXIgd2FzIG5vdCB1bmRlZmluZWQuIEFuIGVtcHR5IGpRdWVyeSBvYmplY3Rcblx0XHRcdC8vIHdpbGwgcmVzdWx0IGluIGB1bmRlZmluZWRgIGZvciBlbGVtID0gdGhpc1sgMCBdIHdoaWNoIHdpbGxcblx0XHRcdC8vIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhbiBhdHRlbXB0IHRvIHJlYWQgYSBkYXRhIGNhY2hlIGlzIG1hZGUuXG5cdFx0XHRpZiAoIGVsZW0gJiYgdmFsdWUgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHQvLyBBdHRlbXB0IHRvIGdldCBkYXRhIGZyb20gdGhlIGNhY2hlXG5cdFx0XHRcdC8vIFRoZSBrZXkgd2lsbCBhbHdheXMgYmUgY2FtZWxDYXNlZCBpbiBEYXRhXG5cdFx0XHRcdGRhdGEgPSBkYXRhVXNlci5nZXQoIGVsZW0sIGtleSApO1xuXHRcdFx0XHRpZiAoIGRhdGEgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gZGF0YTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEF0dGVtcHQgdG8gXCJkaXNjb3ZlclwiIHRoZSBkYXRhIGluXG5cdFx0XHRcdC8vIEhUTUw1IGN1c3RvbSBkYXRhLSogYXR0cnNcblx0XHRcdFx0ZGF0YSA9IGRhdGFBdHRyKCBlbGVtLCBrZXkgKTtcblx0XHRcdFx0aWYgKCBkYXRhICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBXZSB0cmllZCByZWFsbHkgaGFyZCwgYnV0IHRoZSBkYXRhIGRvZXNuJ3QgZXhpc3QuXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2V0IHRoZSBkYXRhLi4uXG5cdFx0XHR0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdC8vIFdlIGFsd2F5cyBzdG9yZSB0aGUgY2FtZWxDYXNlZCBrZXlcblx0XHRcdFx0ZGF0YVVzZXIuc2V0KCB0aGlzLCBrZXksIHZhbHVlICk7XG5cdFx0XHR9ICk7XG5cdFx0fSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxLCBudWxsLCB0cnVlICk7XG5cdH0sXG5cblx0cmVtb3ZlRGF0YTogZnVuY3Rpb24oIGtleSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGRhdGFVc2VyLnJlbW92ZSggdGhpcywga2V5ICk7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cblxualF1ZXJ5LmV4dGVuZCgge1xuXHRxdWV1ZTogZnVuY3Rpb24oIGVsZW0sIHR5cGUsIGRhdGEgKSB7XG5cdFx0dmFyIHF1ZXVlO1xuXG5cdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0dHlwZSA9ICggdHlwZSB8fCBcImZ4XCIgKSArIFwicXVldWVcIjtcblx0XHRcdHF1ZXVlID0gZGF0YVByaXYuZ2V0KCBlbGVtLCB0eXBlICk7XG5cblx0XHRcdC8vIFNwZWVkIHVwIGRlcXVldWUgYnkgZ2V0dGluZyBvdXQgcXVpY2tseSBpZiB0aGlzIGlzIGp1c3QgYSBsb29rdXBcblx0XHRcdGlmICggZGF0YSApIHtcblx0XHRcdFx0aWYgKCAhcXVldWUgfHwgalF1ZXJ5LmlzQXJyYXkoIGRhdGEgKSApIHtcblx0XHRcdFx0XHRxdWV1ZSA9IGRhdGFQcml2LmFjY2VzcyggZWxlbSwgdHlwZSwgalF1ZXJ5Lm1ha2VBcnJheSggZGF0YSApICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cXVldWUucHVzaCggZGF0YSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcXVldWUgfHwgW107XG5cdFx0fVxuXHR9LFxuXG5cdGRlcXVldWU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlICkge1xuXHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRcdHZhciBxdWV1ZSA9IGpRdWVyeS5xdWV1ZSggZWxlbSwgdHlwZSApLFxuXHRcdFx0c3RhcnRMZW5ndGggPSBxdWV1ZS5sZW5ndGgsXG5cdFx0XHRmbiA9IHF1ZXVlLnNoaWZ0KCksXG5cdFx0XHRob29rcyA9IGpRdWVyeS5fcXVldWVIb29rcyggZWxlbSwgdHlwZSApLFxuXHRcdFx0bmV4dCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRqUXVlcnkuZGVxdWV1ZSggZWxlbSwgdHlwZSApO1xuXHRcdFx0fTtcblxuXHRcdC8vIElmIHRoZSBmeCBxdWV1ZSBpcyBkZXF1ZXVlZCwgYWx3YXlzIHJlbW92ZSB0aGUgcHJvZ3Jlc3Mgc2VudGluZWxcblx0XHRpZiAoIGZuID09PSBcImlucHJvZ3Jlc3NcIiApIHtcblx0XHRcdGZuID0gcXVldWUuc2hpZnQoKTtcblx0XHRcdHN0YXJ0TGVuZ3RoLS07XG5cdFx0fVxuXG5cdFx0aWYgKCBmbiApIHtcblxuXHRcdFx0Ly8gQWRkIGEgcHJvZ3Jlc3Mgc2VudGluZWwgdG8gcHJldmVudCB0aGUgZnggcXVldWUgZnJvbSBiZWluZ1xuXHRcdFx0Ly8gYXV0b21hdGljYWxseSBkZXF1ZXVlZFxuXHRcdFx0aWYgKCB0eXBlID09PSBcImZ4XCIgKSB7XG5cdFx0XHRcdHF1ZXVlLnVuc2hpZnQoIFwiaW5wcm9ncmVzc1wiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENsZWFyIHVwIHRoZSBsYXN0IHF1ZXVlIHN0b3AgZnVuY3Rpb25cblx0XHRcdGRlbGV0ZSBob29rcy5zdG9wO1xuXHRcdFx0Zm4uY2FsbCggZWxlbSwgbmV4dCwgaG9va3MgKTtcblx0XHR9XG5cblx0XHRpZiAoICFzdGFydExlbmd0aCAmJiBob29rcyApIHtcblx0XHRcdGhvb2tzLmVtcHR5LmZpcmUoKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gTm90IHB1YmxpYyAtIGdlbmVyYXRlIGEgcXVldWVIb29rcyBvYmplY3QsIG9yIHJldHVybiB0aGUgY3VycmVudCBvbmVcblx0X3F1ZXVlSG9va3M6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlICkge1xuXHRcdHZhciBrZXkgPSB0eXBlICsgXCJxdWV1ZUhvb2tzXCI7XG5cdFx0cmV0dXJuIGRhdGFQcml2LmdldCggZWxlbSwga2V5ICkgfHwgZGF0YVByaXYuYWNjZXNzKCBlbGVtLCBrZXksIHtcblx0XHRcdGVtcHR5OiBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKS5hZGQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIFsgdHlwZSArIFwicXVldWVcIiwga2V5IF0gKTtcblx0XHRcdH0gKVxuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHF1ZXVlOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcblx0XHR2YXIgc2V0dGVyID0gMjtcblxuXHRcdGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRkYXRhID0gdHlwZTtcblx0XHRcdHR5cGUgPSBcImZ4XCI7XG5cdFx0XHRzZXR0ZXItLTtcblx0XHR9XG5cblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPCBzZXR0ZXIgKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LnF1ZXVlKCB0aGlzWyAwIF0sIHR5cGUgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZGF0YSA9PT0gdW5kZWZpbmVkID9cblx0XHRcdHRoaXMgOlxuXHRcdFx0dGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHF1ZXVlID0galF1ZXJ5LnF1ZXVlKCB0aGlzLCB0eXBlLCBkYXRhICk7XG5cblx0XHRcdFx0Ly8gRW5zdXJlIGEgaG9va3MgZm9yIHRoaXMgcXVldWVcblx0XHRcdFx0alF1ZXJ5Ll9xdWV1ZUhvb2tzKCB0aGlzLCB0eXBlICk7XG5cblx0XHRcdFx0aWYgKCB0eXBlID09PSBcImZ4XCIgJiYgcXVldWVbIDAgXSAhPT0gXCJpbnByb2dyZXNzXCIgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHR9LFxuXHRkZXF1ZXVlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG5cdFx0fSApO1xuXHR9LFxuXHRjbGVhclF1ZXVlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRyZXR1cm4gdGhpcy5xdWV1ZSggdHlwZSB8fCBcImZ4XCIsIFtdICk7XG5cdH0sXG5cblx0Ly8gR2V0IGEgcHJvbWlzZSByZXNvbHZlZCB3aGVuIHF1ZXVlcyBvZiBhIGNlcnRhaW4gdHlwZVxuXHQvLyBhcmUgZW1wdGllZCAoZnggaXMgdGhlIHR5cGUgYnkgZGVmYXVsdClcblx0cHJvbWlzZTogZnVuY3Rpb24oIHR5cGUsIG9iaiApIHtcblx0XHR2YXIgdG1wLFxuXHRcdFx0Y291bnQgPSAxLFxuXHRcdFx0ZGVmZXIgPSBqUXVlcnkuRGVmZXJyZWQoKSxcblx0XHRcdGVsZW1lbnRzID0gdGhpcyxcblx0XHRcdGkgPSB0aGlzLmxlbmd0aCxcblx0XHRcdHJlc29sdmUgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCAhKCAtLWNvdW50ICkgKSB7XG5cdFx0XHRcdFx0ZGVmZXIucmVzb2x2ZVdpdGgoIGVsZW1lbnRzLCBbIGVsZW1lbnRzIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRvYmogPSB0eXBlO1xuXHRcdFx0dHlwZSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHR0bXAgPSBkYXRhUHJpdi5nZXQoIGVsZW1lbnRzWyBpIF0sIHR5cGUgKyBcInF1ZXVlSG9va3NcIiApO1xuXHRcdFx0aWYgKCB0bXAgJiYgdG1wLmVtcHR5ICkge1xuXHRcdFx0XHRjb3VudCsrO1xuXHRcdFx0XHR0bXAuZW1wdHkuYWRkKCByZXNvbHZlICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJlc29sdmUoKTtcblx0XHRyZXR1cm4gZGVmZXIucHJvbWlzZSggb2JqICk7XG5cdH1cbn0gKTtcbnZhciBwbnVtID0gKCAvWystXT8oPzpcXGQqXFwufClcXGQrKD86W2VFXVsrLV0/XFxkK3wpLyApLnNvdXJjZTtcblxudmFyIHJjc3NOdW0gPSBuZXcgUmVnRXhwKCBcIl4oPzooWystXSk9fCkoXCIgKyBwbnVtICsgXCIpKFthLXolXSopJFwiLCBcImlcIiApO1xuXG5cbnZhciBjc3NFeHBhbmQgPSBbIFwiVG9wXCIsIFwiUmlnaHRcIiwgXCJCb3R0b21cIiwgXCJMZWZ0XCIgXTtcblxudmFyIGlzSGlkZGVuV2l0aGluVHJlZSA9IGZ1bmN0aW9uKCBlbGVtLCBlbCApIHtcblxuXHRcdC8vIGlzSGlkZGVuV2l0aGluVHJlZSBtaWdodCBiZSBjYWxsZWQgZnJvbSBqUXVlcnkjZmlsdGVyIGZ1bmN0aW9uO1xuXHRcdC8vIGluIHRoYXQgY2FzZSwgZWxlbWVudCB3aWxsIGJlIHNlY29uZCBhcmd1bWVudFxuXHRcdGVsZW0gPSBlbCB8fCBlbGVtO1xuXG5cdFx0Ly8gSW5saW5lIHN0eWxlIHRydW1wcyBhbGxcblx0XHRyZXR1cm4gZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIm5vbmVcIiB8fFxuXHRcdFx0ZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIlwiICYmXG5cblx0XHRcdC8vIE90aGVyd2lzZSwgY2hlY2sgY29tcHV0ZWQgc3R5bGVcblx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD00MyAtIDQ1XG5cdFx0XHQvLyBEaXNjb25uZWN0ZWQgZWxlbWVudHMgY2FuIGhhdmUgY29tcHV0ZWQgZGlzcGxheTogbm9uZSwgc28gZmlyc3QgY29uZmlybSB0aGF0IGVsZW0gaXNcblx0XHRcdC8vIGluIHRoZSBkb2N1bWVudC5cblx0XHRcdGpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICkgJiZcblxuXHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKSA9PT0gXCJub25lXCI7XG5cdH07XG5cbnZhciBzd2FwID0gZnVuY3Rpb24oIGVsZW0sIG9wdGlvbnMsIGNhbGxiYWNrLCBhcmdzICkge1xuXHR2YXIgcmV0LCBuYW1lLFxuXHRcdG9sZCA9IHt9O1xuXG5cdC8vIFJlbWVtYmVyIHRoZSBvbGQgdmFsdWVzLCBhbmQgaW5zZXJ0IHRoZSBuZXcgb25lc1xuXHRmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG5cdFx0b2xkWyBuYW1lIF0gPSBlbGVtLnN0eWxlWyBuYW1lIF07XG5cdFx0ZWxlbS5zdHlsZVsgbmFtZSBdID0gb3B0aW9uc1sgbmFtZSBdO1xuXHR9XG5cblx0cmV0ID0gY2FsbGJhY2suYXBwbHkoIGVsZW0sIGFyZ3MgfHwgW10gKTtcblxuXHQvLyBSZXZlcnQgdGhlIG9sZCB2YWx1ZXNcblx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuXHRcdGVsZW0uc3R5bGVbIG5hbWUgXSA9IG9sZFsgbmFtZSBdO1xuXHR9XG5cblx0cmV0dXJuIHJldDtcbn07XG5cblxuXG5cbmZ1bmN0aW9uIGFkanVzdENTUyggZWxlbSwgcHJvcCwgdmFsdWVQYXJ0cywgdHdlZW4gKSB7XG5cdHZhciBhZGp1c3RlZCxcblx0XHRzY2FsZSA9IDEsXG5cdFx0bWF4SXRlcmF0aW9ucyA9IDIwLFxuXHRcdGN1cnJlbnRWYWx1ZSA9IHR3ZWVuID9cblx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdHdlZW4uY3VyKCk7XG5cdFx0XHR9IDpcblx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4galF1ZXJ5LmNzcyggZWxlbSwgcHJvcCwgXCJcIiApO1xuXHRcdFx0fSxcblx0XHRpbml0aWFsID0gY3VycmVudFZhbHVlKCksXG5cdFx0dW5pdCA9IHZhbHVlUGFydHMgJiYgdmFsdWVQYXJ0c1sgMyBdIHx8ICggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdID8gXCJcIiA6IFwicHhcIiApLFxuXG5cdFx0Ly8gU3RhcnRpbmcgdmFsdWUgY29tcHV0YXRpb24gaXMgcmVxdWlyZWQgZm9yIHBvdGVudGlhbCB1bml0IG1pc21hdGNoZXNcblx0XHRpbml0aWFsSW5Vbml0ID0gKCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gfHwgdW5pdCAhPT0gXCJweFwiICYmICtpbml0aWFsICkgJiZcblx0XHRcdHJjc3NOdW0uZXhlYyggalF1ZXJ5LmNzcyggZWxlbSwgcHJvcCApICk7XG5cblx0aWYgKCBpbml0aWFsSW5Vbml0ICYmIGluaXRpYWxJblVuaXRbIDMgXSAhPT0gdW5pdCApIHtcblxuXHRcdC8vIFRydXN0IHVuaXRzIHJlcG9ydGVkIGJ5IGpRdWVyeS5jc3Ncblx0XHR1bml0ID0gdW5pdCB8fCBpbml0aWFsSW5Vbml0WyAzIF07XG5cblx0XHQvLyBNYWtlIHN1cmUgd2UgdXBkYXRlIHRoZSB0d2VlbiBwcm9wZXJ0aWVzIGxhdGVyIG9uXG5cdFx0dmFsdWVQYXJ0cyA9IHZhbHVlUGFydHMgfHwgW107XG5cblx0XHQvLyBJdGVyYXRpdmVseSBhcHByb3hpbWF0ZSBmcm9tIGEgbm9uemVybyBzdGFydGluZyBwb2ludFxuXHRcdGluaXRpYWxJblVuaXQgPSAraW5pdGlhbCB8fCAxO1xuXG5cdFx0ZG8ge1xuXG5cdFx0XHQvLyBJZiBwcmV2aW91cyBpdGVyYXRpb24gemVyb2VkIG91dCwgZG91YmxlIHVudGlsIHdlIGdldCAqc29tZXRoaW5nKi5cblx0XHRcdC8vIFVzZSBzdHJpbmcgZm9yIGRvdWJsaW5nIHNvIHdlIGRvbid0IGFjY2lkZW50YWxseSBzZWUgc2NhbGUgYXMgdW5jaGFuZ2VkIGJlbG93XG5cdFx0XHRzY2FsZSA9IHNjYWxlIHx8IFwiLjVcIjtcblxuXHRcdFx0Ly8gQWRqdXN0IGFuZCBhcHBseVxuXHRcdFx0aW5pdGlhbEluVW5pdCA9IGluaXRpYWxJblVuaXQgLyBzY2FsZTtcblx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCwgaW5pdGlhbEluVW5pdCArIHVuaXQgKTtcblxuXHRcdC8vIFVwZGF0ZSBzY2FsZSwgdG9sZXJhdGluZyB6ZXJvIG9yIE5hTiBmcm9tIHR3ZWVuLmN1cigpXG5cdFx0Ly8gQnJlYWsgdGhlIGxvb3AgaWYgc2NhbGUgaXMgdW5jaGFuZ2VkIG9yIHBlcmZlY3QsIG9yIGlmIHdlJ3ZlIGp1c3QgaGFkIGVub3VnaC5cblx0XHR9IHdoaWxlIChcblx0XHRcdHNjYWxlICE9PSAoIHNjYWxlID0gY3VycmVudFZhbHVlKCkgLyBpbml0aWFsICkgJiYgc2NhbGUgIT09IDEgJiYgLS1tYXhJdGVyYXRpb25zXG5cdFx0KTtcblx0fVxuXG5cdGlmICggdmFsdWVQYXJ0cyApIHtcblx0XHRpbml0aWFsSW5Vbml0ID0gK2luaXRpYWxJblVuaXQgfHwgK2luaXRpYWwgfHwgMDtcblxuXHRcdC8vIEFwcGx5IHJlbGF0aXZlIG9mZnNldCAoKz0vLT0pIGlmIHNwZWNpZmllZFxuXHRcdGFkanVzdGVkID0gdmFsdWVQYXJ0c1sgMSBdID9cblx0XHRcdGluaXRpYWxJblVuaXQgKyAoIHZhbHVlUGFydHNbIDEgXSArIDEgKSAqIHZhbHVlUGFydHNbIDIgXSA6XG5cdFx0XHQrdmFsdWVQYXJ0c1sgMiBdO1xuXHRcdGlmICggdHdlZW4gKSB7XG5cdFx0XHR0d2Vlbi51bml0ID0gdW5pdDtcblx0XHRcdHR3ZWVuLnN0YXJ0ID0gaW5pdGlhbEluVW5pdDtcblx0XHRcdHR3ZWVuLmVuZCA9IGFkanVzdGVkO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gYWRqdXN0ZWQ7XG59XG5cblxudmFyIGRlZmF1bHREaXNwbGF5TWFwID0ge307XG5cbmZ1bmN0aW9uIGdldERlZmF1bHREaXNwbGF5KCBlbGVtICkge1xuXHR2YXIgdGVtcCxcblx0XHRkb2MgPSBlbGVtLm93bmVyRG9jdW1lbnQsXG5cdFx0bm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lLFxuXHRcdGRpc3BsYXkgPSBkZWZhdWx0RGlzcGxheU1hcFsgbm9kZU5hbWUgXTtcblxuXHRpZiAoIGRpc3BsYXkgKSB7XG5cdFx0cmV0dXJuIGRpc3BsYXk7XG5cdH1cblxuXHR0ZW1wID0gZG9jLmJvZHkuYXBwZW5kQ2hpbGQoIGRvYy5jcmVhdGVFbGVtZW50KCBub2RlTmFtZSApICk7XG5cdGRpc3BsYXkgPSBqUXVlcnkuY3NzKCB0ZW1wLCBcImRpc3BsYXlcIiApO1xuXG5cdHRlbXAucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggdGVtcCApO1xuXG5cdGlmICggZGlzcGxheSA9PT0gXCJub25lXCIgKSB7XG5cdFx0ZGlzcGxheSA9IFwiYmxvY2tcIjtcblx0fVxuXHRkZWZhdWx0RGlzcGxheU1hcFsgbm9kZU5hbWUgXSA9IGRpc3BsYXk7XG5cblx0cmV0dXJuIGRpc3BsYXk7XG59XG5cbmZ1bmN0aW9uIHNob3dIaWRlKCBlbGVtZW50cywgc2hvdyApIHtcblx0dmFyIGRpc3BsYXksIGVsZW0sXG5cdFx0dmFsdWVzID0gW10sXG5cdFx0aW5kZXggPSAwLFxuXHRcdGxlbmd0aCA9IGVsZW1lbnRzLmxlbmd0aDtcblxuXHQvLyBEZXRlcm1pbmUgbmV3IGRpc3BsYXkgdmFsdWUgZm9yIGVsZW1lbnRzIHRoYXQgbmVlZCB0byBjaGFuZ2Vcblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRlbGVtID0gZWxlbWVudHNbIGluZGV4IF07XG5cdFx0aWYgKCAhZWxlbS5zdHlsZSApIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGRpc3BsYXkgPSBlbGVtLnN0eWxlLmRpc3BsYXk7XG5cdFx0aWYgKCBzaG93ICkge1xuXG5cdFx0XHQvLyBTaW5jZSB3ZSBmb3JjZSB2aXNpYmlsaXR5IHVwb24gY2FzY2FkZS1oaWRkZW4gZWxlbWVudHMsIGFuIGltbWVkaWF0ZSAoYW5kIHNsb3cpXG5cdFx0XHQvLyBjaGVjayBpcyByZXF1aXJlZCBpbiB0aGlzIGZpcnN0IGxvb3AgdW5sZXNzIHdlIGhhdmUgYSBub25lbXB0eSBkaXNwbGF5IHZhbHVlIChlaXRoZXJcblx0XHRcdC8vIGlubGluZSBvciBhYm91dC10by1iZS1yZXN0b3JlZClcblx0XHRcdGlmICggZGlzcGxheSA9PT0gXCJub25lXCIgKSB7XG5cdFx0XHRcdHZhbHVlc1sgaW5kZXggXSA9IGRhdGFQcml2LmdldCggZWxlbSwgXCJkaXNwbGF5XCIgKSB8fCBudWxsO1xuXHRcdFx0XHRpZiAoICF2YWx1ZXNbIGluZGV4IF0gKSB7XG5cdFx0XHRcdFx0ZWxlbS5zdHlsZS5kaXNwbGF5ID0gXCJcIjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKCBlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwiXCIgJiYgaXNIaWRkZW5XaXRoaW5UcmVlKCBlbGVtICkgKSB7XG5cdFx0XHRcdHZhbHVlc1sgaW5kZXggXSA9IGdldERlZmF1bHREaXNwbGF5KCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmICggZGlzcGxheSAhPT0gXCJub25lXCIgKSB7XG5cdFx0XHRcdHZhbHVlc1sgaW5kZXggXSA9IFwibm9uZVwiO1xuXG5cdFx0XHRcdC8vIFJlbWVtYmVyIHdoYXQgd2UncmUgb3ZlcndyaXRpbmdcblx0XHRcdFx0ZGF0YVByaXYuc2V0KCBlbGVtLCBcImRpc3BsYXlcIiwgZGlzcGxheSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFNldCB0aGUgZGlzcGxheSBvZiB0aGUgZWxlbWVudHMgaW4gYSBzZWNvbmQgbG9vcCB0byBhdm9pZCBjb25zdGFudCByZWZsb3dcblx0Zm9yICggaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRpZiAoIHZhbHVlc1sgaW5kZXggXSAhPSBudWxsICkge1xuXHRcdFx0ZWxlbWVudHNbIGluZGV4IF0uc3R5bGUuZGlzcGxheSA9IHZhbHVlc1sgaW5kZXggXTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZWxlbWVudHM7XG59XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0c2hvdzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHNob3dIaWRlKCB0aGlzLCB0cnVlICk7XG5cdH0sXG5cdGhpZGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBzaG93SGlkZSggdGhpcyApO1xuXHR9LFxuXHR0b2dnbGU6IGZ1bmN0aW9uKCBzdGF0ZSApIHtcblx0XHRpZiAoIHR5cGVvZiBzdGF0ZSA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0XHRyZXR1cm4gc3RhdGUgPyB0aGlzLnNob3coKSA6IHRoaXMuaGlkZSgpO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBpc0hpZGRlbldpdGhpblRyZWUoIHRoaXMgKSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkuc2hvdygpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkuaGlkZSgpO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fVxufSApO1xudmFyIHJjaGVja2FibGVUeXBlID0gKCAvXig/OmNoZWNrYm94fHJhZGlvKSQvaSApO1xuXG52YXIgcnRhZ05hbWUgPSAoIC88KFthLXpdW15cXC9cXDA+XFx4MjBcXHRcXHJcXG5cXGZdKykvaSApO1xuXG52YXIgcnNjcmlwdFR5cGUgPSAoIC9eJHxcXC8oPzpqYXZhfGVjbWEpc2NyaXB0L2kgKTtcblxuXG5cbi8vIFdlIGhhdmUgdG8gY2xvc2UgdGhlc2UgdGFncyB0byBzdXBwb3J0IFhIVE1MICgjMTMyMDApXG52YXIgd3JhcE1hcCA9IHtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHRvcHRpb246IFsgMSwgXCI8c2VsZWN0IG11bHRpcGxlPSdtdWx0aXBsZSc+XCIsIFwiPC9zZWxlY3Q+XCIgXSxcblxuXHQvLyBYSFRNTCBwYXJzZXJzIGRvIG5vdCBtYWdpY2FsbHkgaW5zZXJ0IGVsZW1lbnRzIGluIHRoZVxuXHQvLyBzYW1lIHdheSB0aGF0IHRhZyBzb3VwIHBhcnNlcnMgZG8uIFNvIHdlIGNhbm5vdCBzaG9ydGVuXG5cdC8vIHRoaXMgYnkgb21pdHRpbmcgPHRib2R5PiBvciBvdGhlciByZXF1aXJlZCBlbGVtZW50cy5cblx0dGhlYWQ6IFsgMSwgXCI8dGFibGU+XCIsIFwiPC90YWJsZT5cIiBdLFxuXHRjb2w6IFsgMiwgXCI8dGFibGU+PGNvbGdyb3VwPlwiLCBcIjwvY29sZ3JvdXA+PC90YWJsZT5cIiBdLFxuXHR0cjogWyAyLCBcIjx0YWJsZT48dGJvZHk+XCIsIFwiPC90Ym9keT48L3RhYmxlPlwiIF0sXG5cdHRkOiBbIDMsIFwiPHRhYmxlPjx0Ym9keT48dHI+XCIsIFwiPC90cj48L3Rib2R5PjwvdGFibGU+XCIgXSxcblxuXHRfZGVmYXVsdDogWyAwLCBcIlwiLCBcIlwiIF1cbn07XG5cbi8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG53cmFwTWFwLm9wdGdyb3VwID0gd3JhcE1hcC5vcHRpb247XG5cbndyYXBNYXAudGJvZHkgPSB3cmFwTWFwLnRmb290ID0gd3JhcE1hcC5jb2xncm91cCA9IHdyYXBNYXAuY2FwdGlvbiA9IHdyYXBNYXAudGhlYWQ7XG53cmFwTWFwLnRoID0gd3JhcE1hcC50ZDtcblxuXG5mdW5jdGlvbiBnZXRBbGwoIGNvbnRleHQsIHRhZyApIHtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG5cdC8vIFVzZSB0eXBlb2YgdG8gYXZvaWQgemVyby1hcmd1bWVudCBtZXRob2QgaW52b2NhdGlvbiBvbiBob3N0IG9iamVjdHMgKCMxNTE1MSlcblx0dmFyIHJldDtcblxuXHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdHJldCA9IGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHRhZyB8fCBcIipcIiApO1xuXG5cdH0gZWxzZSBpZiAoIHR5cGVvZiBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwgIT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0cmV0ID0gY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCB0YWcgfHwgXCIqXCIgKTtcblxuXHR9IGVsc2Uge1xuXHRcdHJldCA9IFtdO1xuXHR9XG5cblx0aWYgKCB0YWcgPT09IHVuZGVmaW5lZCB8fCB0YWcgJiYgalF1ZXJ5Lm5vZGVOYW1lKCBjb250ZXh0LCB0YWcgKSApIHtcblx0XHRyZXR1cm4galF1ZXJ5Lm1lcmdlKCBbIGNvbnRleHQgXSwgcmV0ICk7XG5cdH1cblxuXHRyZXR1cm4gcmV0O1xufVxuXG5cbi8vIE1hcmsgc2NyaXB0cyBhcyBoYXZpbmcgYWxyZWFkeSBiZWVuIGV2YWx1YXRlZFxuZnVuY3Rpb24gc2V0R2xvYmFsRXZhbCggZWxlbXMsIHJlZkVsZW1lbnRzICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bCA9IGVsZW1zLmxlbmd0aDtcblxuXHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0ZGF0YVByaXYuc2V0KFxuXHRcdFx0ZWxlbXNbIGkgXSxcblx0XHRcdFwiZ2xvYmFsRXZhbFwiLFxuXHRcdFx0IXJlZkVsZW1lbnRzIHx8IGRhdGFQcml2LmdldCggcmVmRWxlbWVudHNbIGkgXSwgXCJnbG9iYWxFdmFsXCIgKVxuXHRcdCk7XG5cdH1cbn1cblxuXG52YXIgcmh0bWwgPSAvPHwmIz9cXHcrOy87XG5cbmZ1bmN0aW9uIGJ1aWxkRnJhZ21lbnQoIGVsZW1zLCBjb250ZXh0LCBzY3JpcHRzLCBzZWxlY3Rpb24sIGlnbm9yZWQgKSB7XG5cdHZhciBlbGVtLCB0bXAsIHRhZywgd3JhcCwgY29udGFpbnMsIGosXG5cdFx0ZnJhZ21lbnQgPSBjb250ZXh0LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxcblx0XHRub2RlcyA9IFtdLFxuXHRcdGkgPSAwLFxuXHRcdGwgPSBlbGVtcy5sZW5ndGg7XG5cblx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdGVsZW0gPSBlbGVtc1sgaSBdO1xuXG5cdFx0aWYgKCBlbGVtIHx8IGVsZW0gPT09IDAgKSB7XG5cblx0XHRcdC8vIEFkZCBub2RlcyBkaXJlY3RseVxuXHRcdFx0aWYgKCBqUXVlcnkudHlwZSggZWxlbSApID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHRcdFx0XHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggbm9kZXMsIGVsZW0ubm9kZVR5cGUgPyBbIGVsZW0gXSA6IGVsZW0gKTtcblxuXHRcdFx0Ly8gQ29udmVydCBub24taHRtbCBpbnRvIGEgdGV4dCBub2RlXG5cdFx0XHR9IGVsc2UgaWYgKCAhcmh0bWwudGVzdCggZWxlbSApICkge1xuXHRcdFx0XHRub2Rlcy5wdXNoKCBjb250ZXh0LmNyZWF0ZVRleHROb2RlKCBlbGVtICkgKTtcblxuXHRcdFx0Ly8gQ29udmVydCBodG1sIGludG8gRE9NIG5vZGVzXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0bXAgPSB0bXAgfHwgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGNvbnRleHQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApICk7XG5cblx0XHRcdFx0Ly8gRGVzZXJpYWxpemUgYSBzdGFuZGFyZCByZXByZXNlbnRhdGlvblxuXHRcdFx0XHR0YWcgPSAoIHJ0YWdOYW1lLmV4ZWMoIGVsZW0gKSB8fCBbIFwiXCIsIFwiXCIgXSApWyAxIF0udG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0d3JhcCA9IHdyYXBNYXBbIHRhZyBdIHx8IHdyYXBNYXAuX2RlZmF1bHQ7XG5cdFx0XHRcdHRtcC5pbm5lckhUTUwgPSB3cmFwWyAxIF0gKyBqUXVlcnkuaHRtbFByZWZpbHRlciggZWxlbSApICsgd3JhcFsgMiBdO1xuXG5cdFx0XHRcdC8vIERlc2NlbmQgdGhyb3VnaCB3cmFwcGVycyB0byB0aGUgcmlnaHQgY29udGVudFxuXHRcdFx0XHRqID0gd3JhcFsgMCBdO1xuXHRcdFx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdFx0XHR0bXAgPSB0bXAubGFzdENoaWxkO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdFx0XHRcdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCBub2RlcywgdG1wLmNoaWxkTm9kZXMgKTtcblxuXHRcdFx0XHQvLyBSZW1lbWJlciB0aGUgdG9wLWxldmVsIGNvbnRhaW5lclxuXHRcdFx0XHR0bXAgPSBmcmFnbWVudC5maXJzdENoaWxkO1xuXG5cdFx0XHRcdC8vIEVuc3VyZSB0aGUgY3JlYXRlZCBub2RlcyBhcmUgb3JwaGFuZWQgKCMxMjM5Milcblx0XHRcdFx0dG1wLnRleHRDb250ZW50ID0gXCJcIjtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBSZW1vdmUgd3JhcHBlciBmcm9tIGZyYWdtZW50XG5cdGZyYWdtZW50LnRleHRDb250ZW50ID0gXCJcIjtcblxuXHRpID0gMDtcblx0d2hpbGUgKCAoIGVsZW0gPSBub2Rlc1sgaSsrIF0gKSApIHtcblxuXHRcdC8vIFNraXAgZWxlbWVudHMgYWxyZWFkeSBpbiB0aGUgY29udGV4dCBjb2xsZWN0aW9uICh0cmFjLTQwODcpXG5cdFx0aWYgKCBzZWxlY3Rpb24gJiYgalF1ZXJ5LmluQXJyYXkoIGVsZW0sIHNlbGVjdGlvbiApID4gLTEgKSB7XG5cdFx0XHRpZiAoIGlnbm9yZWQgKSB7XG5cdFx0XHRcdGlnbm9yZWQucHVzaCggZWxlbSApO1xuXHRcdFx0fVxuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0Y29udGFpbnMgPSBqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApO1xuXG5cdFx0Ly8gQXBwZW5kIHRvIGZyYWdtZW50XG5cdFx0dG1wID0gZ2V0QWxsKCBmcmFnbWVudC5hcHBlbmRDaGlsZCggZWxlbSApLCBcInNjcmlwdFwiICk7XG5cblx0XHQvLyBQcmVzZXJ2ZSBzY3JpcHQgZXZhbHVhdGlvbiBoaXN0b3J5XG5cdFx0aWYgKCBjb250YWlucyApIHtcblx0XHRcdHNldEdsb2JhbEV2YWwoIHRtcCApO1xuXHRcdH1cblxuXHRcdC8vIENhcHR1cmUgZXhlY3V0YWJsZXNcblx0XHRpZiAoIHNjcmlwdHMgKSB7XG5cdFx0XHRqID0gMDtcblx0XHRcdHdoaWxlICggKCBlbGVtID0gdG1wWyBqKysgXSApICkge1xuXHRcdFx0XHRpZiAoIHJzY3JpcHRUeXBlLnRlc3QoIGVsZW0udHlwZSB8fCBcIlwiICkgKSB7XG5cdFx0XHRcdFx0c2NyaXB0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZnJhZ21lbnQ7XG59XG5cblxuKCBmdW5jdGlvbigpIHtcblx0dmFyIGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLFxuXHRcdGRpdiA9IGZyYWdtZW50LmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICkgKSxcblx0XHRpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApO1xuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIC0gNC4zIG9ubHlcblx0Ly8gQ2hlY2sgc3RhdGUgbG9zdCBpZiB0aGUgbmFtZSBpcyBzZXQgKCMxMTIxNylcblx0Ly8gU3VwcG9ydDogV2luZG93cyBXZWIgQXBwcyAoV1dBKVxuXHQvLyBgbmFtZWAgYW5kIGB0eXBlYCBtdXN0IHVzZSAuc2V0QXR0cmlidXRlIGZvciBXV0EgKCMxNDkwMSlcblx0aW5wdXQuc2V0QXR0cmlidXRlKCBcInR5cGVcIiwgXCJyYWRpb1wiICk7XG5cdGlucHV0LnNldEF0dHJpYnV0ZSggXCJjaGVja2VkXCIsIFwiY2hlY2tlZFwiICk7XG5cdGlucHV0LnNldEF0dHJpYnV0ZSggXCJuYW1lXCIsIFwidFwiICk7XG5cblx0ZGl2LmFwcGVuZENoaWxkKCBpbnB1dCApO1xuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjEgb25seVxuXHQvLyBPbGRlciBXZWJLaXQgZG9lc24ndCBjbG9uZSBjaGVja2VkIHN0YXRlIGNvcnJlY3RseSBpbiBmcmFnbWVudHNcblx0c3VwcG9ydC5jaGVja0Nsb25lID0gZGl2LmNsb25lTm9kZSggdHJ1ZSApLmNsb25lTm9kZSggdHJ1ZSApLmxhc3RDaGlsZC5jaGVja2VkO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHQvLyBNYWtlIHN1cmUgdGV4dGFyZWEgKGFuZCBjaGVja2JveCkgZGVmYXVsdFZhbHVlIGlzIHByb3Blcmx5IGNsb25lZFxuXHRkaXYuaW5uZXJIVE1MID0gXCI8dGV4dGFyZWE+eDwvdGV4dGFyZWE+XCI7XG5cdHN1cHBvcnQubm9DbG9uZUNoZWNrZWQgPSAhIWRpdi5jbG9uZU5vZGUoIHRydWUgKS5sYXN0Q2hpbGQuZGVmYXVsdFZhbHVlO1xufSApKCk7XG52YXIgZG9jdW1lbnRFbGVtZW50ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG5cblxudmFyXG5cdHJrZXlFdmVudCA9IC9ea2V5Lyxcblx0cm1vdXNlRXZlbnQgPSAvXig/Om1vdXNlfHBvaW50ZXJ8Y29udGV4dG1lbnV8ZHJhZ3xkcm9wKXxjbGljay8sXG5cdHJ0eXBlbmFtZXNwYWNlID0gL14oW14uXSopKD86XFwuKC4rKXwpLztcblxuZnVuY3Rpb24gcmV0dXJuVHJ1ZSgpIHtcblx0cmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHJldHVybkZhbHNlKCkge1xuXHRyZXR1cm4gZmFsc2U7XG59XG5cbi8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG4vLyBTZWUgIzEzMzkzIGZvciBtb3JlIGluZm9cbmZ1bmN0aW9uIHNhZmVBY3RpdmVFbGVtZW50KCkge1xuXHR0cnkge1xuXHRcdHJldHVybiBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuXHR9IGNhdGNoICggZXJyICkgeyB9XG59XG5cbmZ1bmN0aW9uIG9uKCBlbGVtLCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuLCBvbmUgKSB7XG5cdHZhciBvcmlnRm4sIHR5cGU7XG5cblx0Ly8gVHlwZXMgY2FuIGJlIGEgbWFwIG9mIHR5cGVzL2hhbmRsZXJzXG5cdGlmICggdHlwZW9mIHR5cGVzID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0Ly8gKCB0eXBlcy1PYmplY3QsIHNlbGVjdG9yLCBkYXRhIClcblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiApIHtcblxuXHRcdFx0Ly8gKCB0eXBlcy1PYmplY3QsIGRhdGEgKVxuXHRcdFx0ZGF0YSA9IGRhdGEgfHwgc2VsZWN0b3I7XG5cdFx0XHRzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0Zm9yICggdHlwZSBpbiB0eXBlcyApIHtcblx0XHRcdG9uKCBlbGVtLCB0eXBlLCBzZWxlY3RvciwgZGF0YSwgdHlwZXNbIHR5cGUgXSwgb25lICk7XG5cdFx0fVxuXHRcdHJldHVybiBlbGVtO1xuXHR9XG5cblx0aWYgKCBkYXRhID09IG51bGwgJiYgZm4gPT0gbnVsbCApIHtcblxuXHRcdC8vICggdHlwZXMsIGZuIClcblx0XHRmbiA9IHNlbGVjdG9yO1xuXHRcdGRhdGEgPSBzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0fSBlbHNlIGlmICggZm4gPT0gbnVsbCApIHtcblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblxuXHRcdFx0Ly8gKCB0eXBlcywgc2VsZWN0b3IsIGZuIClcblx0XHRcdGZuID0gZGF0YTtcblx0XHRcdGRhdGEgPSB1bmRlZmluZWQ7XG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gKCB0eXBlcywgZGF0YSwgZm4gKVxuXHRcdFx0Zm4gPSBkYXRhO1xuXHRcdFx0ZGF0YSA9IHNlbGVjdG9yO1xuXHRcdFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHR9XG5cdGlmICggZm4gPT09IGZhbHNlICkge1xuXHRcdGZuID0gcmV0dXJuRmFsc2U7XG5cdH0gZWxzZSBpZiAoICFmbiApIHtcblx0XHRyZXR1cm4gZWxlbTtcblx0fVxuXG5cdGlmICggb25lID09PSAxICkge1xuXHRcdG9yaWdGbiA9IGZuO1xuXHRcdGZuID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuXG5cdFx0XHQvLyBDYW4gdXNlIGFuIGVtcHR5IHNldCwgc2luY2UgZXZlbnQgY29udGFpbnMgdGhlIGluZm9cblx0XHRcdGpRdWVyeSgpLm9mZiggZXZlbnQgKTtcblx0XHRcdHJldHVybiBvcmlnRm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdH07XG5cblx0XHQvLyBVc2Ugc2FtZSBndWlkIHNvIGNhbGxlciBjYW4gcmVtb3ZlIHVzaW5nIG9yaWdGblxuXHRcdGZuLmd1aWQgPSBvcmlnRm4uZ3VpZCB8fCAoIG9yaWdGbi5ndWlkID0galF1ZXJ5Lmd1aWQrKyApO1xuXHR9XG5cdHJldHVybiBlbGVtLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdGpRdWVyeS5ldmVudC5hZGQoIHRoaXMsIHR5cGVzLCBmbiwgZGF0YSwgc2VsZWN0b3IgKTtcblx0fSApO1xufVxuXG4vKlxuICogSGVscGVyIGZ1bmN0aW9ucyBmb3IgbWFuYWdpbmcgZXZlbnRzIC0tIG5vdCBwYXJ0IG9mIHRoZSBwdWJsaWMgaW50ZXJmYWNlLlxuICogUHJvcHMgdG8gRGVhbiBFZHdhcmRzJyBhZGRFdmVudCBsaWJyYXJ5IGZvciBtYW55IG9mIHRoZSBpZGVhcy5cbiAqL1xualF1ZXJ5LmV2ZW50ID0ge1xuXG5cdGdsb2JhbDoge30sXG5cblx0YWRkOiBmdW5jdGlvbiggZWxlbSwgdHlwZXMsIGhhbmRsZXIsIGRhdGEsIHNlbGVjdG9yICkge1xuXG5cdFx0dmFyIGhhbmRsZU9iakluLCBldmVudEhhbmRsZSwgdG1wLFxuXHRcdFx0ZXZlbnRzLCB0LCBoYW5kbGVPYmosXG5cdFx0XHRzcGVjaWFsLCBoYW5kbGVycywgdHlwZSwgbmFtZXNwYWNlcywgb3JpZ1R5cGUsXG5cdFx0XHRlbGVtRGF0YSA9IGRhdGFQcml2LmdldCggZWxlbSApO1xuXG5cdFx0Ly8gRG9uJ3QgYXR0YWNoIGV2ZW50cyB0byBub0RhdGEgb3IgdGV4dC9jb21tZW50IG5vZGVzIChidXQgYWxsb3cgcGxhaW4gb2JqZWN0cylcblx0XHRpZiAoICFlbGVtRGF0YSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBDYWxsZXIgY2FuIHBhc3MgaW4gYW4gb2JqZWN0IG9mIGN1c3RvbSBkYXRhIGluIGxpZXUgb2YgdGhlIGhhbmRsZXJcblx0XHRpZiAoIGhhbmRsZXIuaGFuZGxlciApIHtcblx0XHRcdGhhbmRsZU9iakluID0gaGFuZGxlcjtcblx0XHRcdGhhbmRsZXIgPSBoYW5kbGVPYmpJbi5oYW5kbGVyO1xuXHRcdFx0c2VsZWN0b3IgPSBoYW5kbGVPYmpJbi5zZWxlY3Rvcjtcblx0XHR9XG5cblx0XHQvLyBFbnN1cmUgdGhhdCBpbnZhbGlkIHNlbGVjdG9ycyB0aHJvdyBleGNlcHRpb25zIGF0IGF0dGFjaCB0aW1lXG5cdFx0Ly8gRXZhbHVhdGUgYWdhaW5zdCBkb2N1bWVudEVsZW1lbnQgaW4gY2FzZSBlbGVtIGlzIGEgbm9uLWVsZW1lbnQgbm9kZSAoZS5nLiwgZG9jdW1lbnQpXG5cdFx0aWYgKCBzZWxlY3RvciApIHtcblx0XHRcdGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvciggZG9jdW1lbnRFbGVtZW50LCBzZWxlY3RvciApO1xuXHRcdH1cblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBoYW5kbGVyIGhhcyBhIHVuaXF1ZSBJRCwgdXNlZCB0byBmaW5kL3JlbW92ZSBpdCBsYXRlclxuXHRcdGlmICggIWhhbmRsZXIuZ3VpZCApIHtcblx0XHRcdGhhbmRsZXIuZ3VpZCA9IGpRdWVyeS5ndWlkKys7XG5cdFx0fVxuXG5cdFx0Ly8gSW5pdCB0aGUgZWxlbWVudCdzIGV2ZW50IHN0cnVjdHVyZSBhbmQgbWFpbiBoYW5kbGVyLCBpZiB0aGlzIGlzIHRoZSBmaXJzdFxuXHRcdGlmICggISggZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzICkgKSB7XG5cdFx0XHRldmVudHMgPSBlbGVtRGF0YS5ldmVudHMgPSB7fTtcblx0XHR9XG5cdFx0aWYgKCAhKCBldmVudEhhbmRsZSA9IGVsZW1EYXRhLmhhbmRsZSApICkge1xuXHRcdFx0ZXZlbnRIYW5kbGUgPSBlbGVtRGF0YS5oYW5kbGUgPSBmdW5jdGlvbiggZSApIHtcblxuXHRcdFx0XHQvLyBEaXNjYXJkIHRoZSBzZWNvbmQgZXZlbnQgb2YgYSBqUXVlcnkuZXZlbnQudHJpZ2dlcigpIGFuZFxuXHRcdFx0XHQvLyB3aGVuIGFuIGV2ZW50IGlzIGNhbGxlZCBhZnRlciBhIHBhZ2UgaGFzIHVubG9hZGVkXG5cdFx0XHRcdHJldHVybiB0eXBlb2YgalF1ZXJ5ICE9PSBcInVuZGVmaW5lZFwiICYmIGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgIT09IGUudHlwZSA/XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LmRpc3BhdGNoLmFwcGx5KCBlbGVtLCBhcmd1bWVudHMgKSA6IHVuZGVmaW5lZDtcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0Ly8gSGFuZGxlIG11bHRpcGxlIGV2ZW50cyBzZXBhcmF0ZWQgYnkgYSBzcGFjZVxuXHRcdHR5cGVzID0gKCB0eXBlcyB8fCBcIlwiICkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbIFwiXCIgXTtcblx0XHR0ID0gdHlwZXMubGVuZ3RoO1xuXHRcdHdoaWxlICggdC0tICkge1xuXHRcdFx0dG1wID0gcnR5cGVuYW1lc3BhY2UuZXhlYyggdHlwZXNbIHQgXSApIHx8IFtdO1xuXHRcdFx0dHlwZSA9IG9yaWdUeXBlID0gdG1wWyAxIF07XG5cdFx0XHRuYW1lc3BhY2VzID0gKCB0bXBbIDIgXSB8fCBcIlwiICkuc3BsaXQoIFwiLlwiICkuc29ydCgpO1xuXG5cdFx0XHQvLyBUaGVyZSAqbXVzdCogYmUgYSB0eXBlLCBubyBhdHRhY2hpbmcgbmFtZXNwYWNlLW9ubHkgaGFuZGxlcnNcblx0XHRcdGlmICggIXR5cGUgKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBldmVudCBjaGFuZ2VzIGl0cyB0eXBlLCB1c2UgdGhlIHNwZWNpYWwgZXZlbnQgaGFuZGxlcnMgZm9yIHRoZSBjaGFuZ2VkIHR5cGVcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXG5cdFx0XHQvLyBJZiBzZWxlY3RvciBkZWZpbmVkLCBkZXRlcm1pbmUgc3BlY2lhbCBldmVudCBhcGkgdHlwZSwgb3RoZXJ3aXNlIGdpdmVuIHR5cGVcblx0XHRcdHR5cGUgPSAoIHNlbGVjdG9yID8gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgOiBzcGVjaWFsLmJpbmRUeXBlICkgfHwgdHlwZTtcblxuXHRcdFx0Ly8gVXBkYXRlIHNwZWNpYWwgYmFzZWQgb24gbmV3bHkgcmVzZXQgdHlwZVxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cblx0XHRcdC8vIGhhbmRsZU9iaiBpcyBwYXNzZWQgdG8gYWxsIGV2ZW50IGhhbmRsZXJzXG5cdFx0XHRoYW5kbGVPYmogPSBqUXVlcnkuZXh0ZW5kKCB7XG5cdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdG9yaWdUeXBlOiBvcmlnVHlwZSxcblx0XHRcdFx0ZGF0YTogZGF0YSxcblx0XHRcdFx0aGFuZGxlcjogaGFuZGxlcixcblx0XHRcdFx0Z3VpZDogaGFuZGxlci5ndWlkLFxuXHRcdFx0XHRzZWxlY3Rvcjogc2VsZWN0b3IsXG5cdFx0XHRcdG5lZWRzQ29udGV4dDogc2VsZWN0b3IgJiYgalF1ZXJ5LmV4cHIubWF0Y2gubmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9yICksXG5cdFx0XHRcdG5hbWVzcGFjZTogbmFtZXNwYWNlcy5qb2luKCBcIi5cIiApXG5cdFx0XHR9LCBoYW5kbGVPYmpJbiApO1xuXG5cdFx0XHQvLyBJbml0IHRoZSBldmVudCBoYW5kbGVyIHF1ZXVlIGlmIHdlJ3JlIHRoZSBmaXJzdFxuXHRcdFx0aWYgKCAhKCBoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdICkgKSB7XG5cdFx0XHRcdGhhbmRsZXJzID0gZXZlbnRzWyB0eXBlIF0gPSBbXTtcblx0XHRcdFx0aGFuZGxlcnMuZGVsZWdhdGVDb3VudCA9IDA7XG5cblx0XHRcdFx0Ly8gT25seSB1c2UgYWRkRXZlbnRMaXN0ZW5lciBpZiB0aGUgc3BlY2lhbCBldmVudHMgaGFuZGxlciByZXR1cm5zIGZhbHNlXG5cdFx0XHRcdGlmICggIXNwZWNpYWwuc2V0dXAgfHxcblx0XHRcdFx0XHRzcGVjaWFsLnNldHVwLmNhbGwoIGVsZW0sIGRhdGEsIG5hbWVzcGFjZXMsIGV2ZW50SGFuZGxlICkgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdFx0aWYgKCBlbGVtLmFkZEV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLmFkZEV2ZW50TGlzdGVuZXIoIHR5cGUsIGV2ZW50SGFuZGxlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICggc3BlY2lhbC5hZGQgKSB7XG5cdFx0XHRcdHNwZWNpYWwuYWRkLmNhbGwoIGVsZW0sIGhhbmRsZU9iaiApO1xuXG5cdFx0XHRcdGlmICggIWhhbmRsZU9iai5oYW5kbGVyLmd1aWQgKSB7XG5cdFx0XHRcdFx0aGFuZGxlT2JqLmhhbmRsZXIuZ3VpZCA9IGhhbmRsZXIuZ3VpZDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgdG8gdGhlIGVsZW1lbnQncyBoYW5kbGVyIGxpc3QsIGRlbGVnYXRlcyBpbiBmcm9udFxuXHRcdFx0aWYgKCBzZWxlY3RvciApIHtcblx0XHRcdFx0aGFuZGxlcnMuc3BsaWNlKCBoYW5kbGVycy5kZWxlZ2F0ZUNvdW50KyssIDAsIGhhbmRsZU9iaiApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aGFuZGxlcnMucHVzaCggaGFuZGxlT2JqICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEtlZXAgdHJhY2sgb2Ygd2hpY2ggZXZlbnRzIGhhdmUgZXZlciBiZWVuIHVzZWQsIGZvciBldmVudCBvcHRpbWl6YXRpb25cblx0XHRcdGpRdWVyeS5ldmVudC5nbG9iYWxbIHR5cGUgXSA9IHRydWU7XG5cdFx0fVxuXG5cdH0sXG5cblx0Ly8gRGV0YWNoIGFuIGV2ZW50IG9yIHNldCBvZiBldmVudHMgZnJvbSBhbiBlbGVtZW50XG5cdHJlbW92ZTogZnVuY3Rpb24oIGVsZW0sIHR5cGVzLCBoYW5kbGVyLCBzZWxlY3RvciwgbWFwcGVkVHlwZXMgKSB7XG5cblx0XHR2YXIgaiwgb3JpZ0NvdW50LCB0bXAsXG5cdFx0XHRldmVudHMsIHQsIGhhbmRsZU9iaixcblx0XHRcdHNwZWNpYWwsIGhhbmRsZXJzLCB0eXBlLCBuYW1lc3BhY2VzLCBvcmlnVHlwZSxcblx0XHRcdGVsZW1EYXRhID0gZGF0YVByaXYuaGFzRGF0YSggZWxlbSApICYmIGRhdGFQcml2LmdldCggZWxlbSApO1xuXG5cdFx0aWYgKCAhZWxlbURhdGEgfHwgISggZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzICkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gT25jZSBmb3IgZWFjaCB0eXBlLm5hbWVzcGFjZSBpbiB0eXBlczsgdHlwZSBtYXkgYmUgb21pdHRlZFxuXHRcdHR5cGVzID0gKCB0eXBlcyB8fCBcIlwiICkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbIFwiXCIgXTtcblx0XHR0ID0gdHlwZXMubGVuZ3RoO1xuXHRcdHdoaWxlICggdC0tICkge1xuXHRcdFx0dG1wID0gcnR5cGVuYW1lc3BhY2UuZXhlYyggdHlwZXNbIHQgXSApIHx8IFtdO1xuXHRcdFx0dHlwZSA9IG9yaWdUeXBlID0gdG1wWyAxIF07XG5cdFx0XHRuYW1lc3BhY2VzID0gKCB0bXBbIDIgXSB8fCBcIlwiICkuc3BsaXQoIFwiLlwiICkuc29ydCgpO1xuXG5cdFx0XHQvLyBVbmJpbmQgYWxsIGV2ZW50cyAob24gdGhpcyBuYW1lc3BhY2UsIGlmIHByb3ZpZGVkKSBmb3IgdGhlIGVsZW1lbnRcblx0XHRcdGlmICggIXR5cGUgKSB7XG5cdFx0XHRcdGZvciAoIHR5cGUgaW4gZXZlbnRzICkge1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5yZW1vdmUoIGVsZW0sIHR5cGUgKyB0eXBlc1sgdCBdLCBoYW5kbGVyLCBzZWxlY3RvciwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblx0XHRcdHR5cGUgPSAoIHNlbGVjdG9yID8gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgOiBzcGVjaWFsLmJpbmRUeXBlICkgfHwgdHlwZTtcblx0XHRcdGhhbmRsZXJzID0gZXZlbnRzWyB0eXBlIF0gfHwgW107XG5cdFx0XHR0bXAgPSB0bXBbIDIgXSAmJlxuXHRcdFx0XHRuZXcgUmVnRXhwKCBcIihefFxcXFwuKVwiICsgbmFtZXNwYWNlcy5qb2luKCBcIlxcXFwuKD86LipcXFxcLnwpXCIgKSArIFwiKFxcXFwufCQpXCIgKTtcblxuXHRcdFx0Ly8gUmVtb3ZlIG1hdGNoaW5nIGV2ZW50c1xuXHRcdFx0b3JpZ0NvdW50ID0gaiA9IGhhbmRsZXJzLmxlbmd0aDtcblx0XHRcdHdoaWxlICggai0tICkge1xuXHRcdFx0XHRoYW5kbGVPYmogPSBoYW5kbGVyc1sgaiBdO1xuXG5cdFx0XHRcdGlmICggKCBtYXBwZWRUeXBlcyB8fCBvcmlnVHlwZSA9PT0gaGFuZGxlT2JqLm9yaWdUeXBlICkgJiZcblx0XHRcdFx0XHQoICFoYW5kbGVyIHx8IGhhbmRsZXIuZ3VpZCA9PT0gaGFuZGxlT2JqLmd1aWQgKSAmJlxuXHRcdFx0XHRcdCggIXRtcCB8fCB0bXAudGVzdCggaGFuZGxlT2JqLm5hbWVzcGFjZSApICkgJiZcblx0XHRcdFx0XHQoICFzZWxlY3RvciB8fCBzZWxlY3RvciA9PT0gaGFuZGxlT2JqLnNlbGVjdG9yIHx8XG5cdFx0XHRcdFx0XHRzZWxlY3RvciA9PT0gXCIqKlwiICYmIGhhbmRsZU9iai5zZWxlY3RvciApICkge1xuXHRcdFx0XHRcdGhhbmRsZXJzLnNwbGljZSggaiwgMSApO1xuXG5cdFx0XHRcdFx0aWYgKCBoYW5kbGVPYmouc2VsZWN0b3IgKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVycy5kZWxlZ2F0ZUNvdW50LS07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggc3BlY2lhbC5yZW1vdmUgKSB7XG5cdFx0XHRcdFx0XHRzcGVjaWFsLnJlbW92ZS5jYWxsKCBlbGVtLCBoYW5kbGVPYmogKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gUmVtb3ZlIGdlbmVyaWMgZXZlbnQgaGFuZGxlciBpZiB3ZSByZW1vdmVkIHNvbWV0aGluZyBhbmQgbm8gbW9yZSBoYW5kbGVycyBleGlzdFxuXHRcdFx0Ly8gKGF2b2lkcyBwb3RlbnRpYWwgZm9yIGVuZGxlc3MgcmVjdXJzaW9uIGR1cmluZyByZW1vdmFsIG9mIHNwZWNpYWwgZXZlbnQgaGFuZGxlcnMpXG5cdFx0XHRpZiAoIG9yaWdDb3VudCAmJiAhaGFuZGxlcnMubGVuZ3RoICkge1xuXHRcdFx0XHRpZiAoICFzcGVjaWFsLnRlYXJkb3duIHx8XG5cdFx0XHRcdFx0c3BlY2lhbC50ZWFyZG93bi5jYWxsKCBlbGVtLCBuYW1lc3BhY2VzLCBlbGVtRGF0YS5oYW5kbGUgKSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0XHRqUXVlcnkucmVtb3ZlRXZlbnQoIGVsZW0sIHR5cGUsIGVsZW1EYXRhLmhhbmRsZSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGVsZXRlIGV2ZW50c1sgdHlwZSBdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFJlbW92ZSBkYXRhIGFuZCB0aGUgZXhwYW5kbyBpZiBpdCdzIG5vIGxvbmdlciB1c2VkXG5cdFx0aWYgKCBqUXVlcnkuaXNFbXB0eU9iamVjdCggZXZlbnRzICkgKSB7XG5cdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIFwiaGFuZGxlIGV2ZW50c1wiICk7XG5cdFx0fVxuXHR9LFxuXG5cdGRpc3BhdGNoOiBmdW5jdGlvbiggbmF0aXZlRXZlbnQgKSB7XG5cblx0XHQvLyBNYWtlIGEgd3JpdGFibGUgalF1ZXJ5LkV2ZW50IGZyb20gdGhlIG5hdGl2ZSBldmVudCBvYmplY3Rcblx0XHR2YXIgZXZlbnQgPSBqUXVlcnkuZXZlbnQuZml4KCBuYXRpdmVFdmVudCApO1xuXG5cdFx0dmFyIGksIGosIHJldCwgbWF0Y2hlZCwgaGFuZGxlT2JqLCBoYW5kbGVyUXVldWUsXG5cdFx0XHRhcmdzID0gbmV3IEFycmF5KCBhcmd1bWVudHMubGVuZ3RoICksXG5cdFx0XHRoYW5kbGVycyA9ICggZGF0YVByaXYuZ2V0KCB0aGlzLCBcImV2ZW50c1wiICkgfHwge30gKVsgZXZlbnQudHlwZSBdIHx8IFtdLFxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyBldmVudC50eXBlIF0gfHwge307XG5cblx0XHQvLyBVc2UgdGhlIGZpeC1lZCBqUXVlcnkuRXZlbnQgcmF0aGVyIHRoYW4gdGhlIChyZWFkLW9ubHkpIG5hdGl2ZSBldmVudFxuXHRcdGFyZ3NbIDAgXSA9IGV2ZW50O1xuXG5cdFx0Zm9yICggaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRhcmdzWyBpIF0gPSBhcmd1bWVudHNbIGkgXTtcblx0XHR9XG5cblx0XHRldmVudC5kZWxlZ2F0ZVRhcmdldCA9IHRoaXM7XG5cblx0XHQvLyBDYWxsIHRoZSBwcmVEaXNwYXRjaCBob29rIGZvciB0aGUgbWFwcGVkIHR5cGUsIGFuZCBsZXQgaXQgYmFpbCBpZiBkZXNpcmVkXG5cdFx0aWYgKCBzcGVjaWFsLnByZURpc3BhdGNoICYmIHNwZWNpYWwucHJlRGlzcGF0Y2guY2FsbCggdGhpcywgZXZlbnQgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZXJtaW5lIGhhbmRsZXJzXG5cdFx0aGFuZGxlclF1ZXVlID0galF1ZXJ5LmV2ZW50LmhhbmRsZXJzLmNhbGwoIHRoaXMsIGV2ZW50LCBoYW5kbGVycyApO1xuXG5cdFx0Ly8gUnVuIGRlbGVnYXRlcyBmaXJzdDsgdGhleSBtYXkgd2FudCB0byBzdG9wIHByb3BhZ2F0aW9uIGJlbmVhdGggdXNcblx0XHRpID0gMDtcblx0XHR3aGlsZSAoICggbWF0Y2hlZCA9IGhhbmRsZXJRdWV1ZVsgaSsrIF0gKSAmJiAhZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblx0XHRcdGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBtYXRjaGVkLmVsZW07XG5cblx0XHRcdGogPSAwO1xuXHRcdFx0d2hpbGUgKCAoIGhhbmRsZU9iaiA9IG1hdGNoZWQuaGFuZGxlcnNbIGorKyBdICkgJiZcblx0XHRcdFx0IWV2ZW50LmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cblx0XHRcdFx0Ly8gVHJpZ2dlcmVkIGV2ZW50IG11c3QgZWl0aGVyIDEpIGhhdmUgbm8gbmFtZXNwYWNlLCBvciAyKSBoYXZlIG5hbWVzcGFjZShzKVxuXHRcdFx0XHQvLyBhIHN1YnNldCBvciBlcXVhbCB0byB0aG9zZSBpbiB0aGUgYm91bmQgZXZlbnQgKGJvdGggY2FuIGhhdmUgbm8gbmFtZXNwYWNlKS5cblx0XHRcdFx0aWYgKCAhZXZlbnQucm5hbWVzcGFjZSB8fCBldmVudC5ybmFtZXNwYWNlLnRlc3QoIGhhbmRsZU9iai5uYW1lc3BhY2UgKSApIHtcblxuXHRcdFx0XHRcdGV2ZW50LmhhbmRsZU9iaiA9IGhhbmRsZU9iajtcblx0XHRcdFx0XHRldmVudC5kYXRhID0gaGFuZGxlT2JqLmRhdGE7XG5cblx0XHRcdFx0XHRyZXQgPSAoICggalF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGhhbmRsZU9iai5vcmlnVHlwZSBdIHx8IHt9ICkuaGFuZGxlIHx8XG5cdFx0XHRcdFx0XHRoYW5kbGVPYmouaGFuZGxlciApLmFwcGx5KCBtYXRjaGVkLmVsZW0sIGFyZ3MgKTtcblxuXHRcdFx0XHRcdGlmICggcmV0ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRpZiAoICggZXZlbnQucmVzdWx0ID0gcmV0ICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdFx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWxsIHRoZSBwb3N0RGlzcGF0Y2ggaG9vayBmb3IgdGhlIG1hcHBlZCB0eXBlXG5cdFx0aWYgKCBzcGVjaWFsLnBvc3REaXNwYXRjaCApIHtcblx0XHRcdHNwZWNpYWwucG9zdERpc3BhdGNoLmNhbGwoIHRoaXMsIGV2ZW50ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50LnJlc3VsdDtcblx0fSxcblxuXHRoYW5kbGVyczogZnVuY3Rpb24oIGV2ZW50LCBoYW5kbGVycyApIHtcblx0XHR2YXIgaSwgaGFuZGxlT2JqLCBzZWwsIG1hdGNoZWRIYW5kbGVycywgbWF0Y2hlZFNlbGVjdG9ycyxcblx0XHRcdGhhbmRsZXJRdWV1ZSA9IFtdLFxuXHRcdFx0ZGVsZWdhdGVDb3VudCA9IGhhbmRsZXJzLmRlbGVnYXRlQ291bnQsXG5cdFx0XHRjdXIgPSBldmVudC50YXJnZXQ7XG5cblx0XHQvLyBGaW5kIGRlbGVnYXRlIGhhbmRsZXJzXG5cdFx0aWYgKCBkZWxlZ2F0ZUNvdW50ICYmXG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OVxuXHRcdFx0Ly8gQmxhY2staG9sZSBTVkcgPHVzZT4gaW5zdGFuY2UgdHJlZXMgKHRyYWMtMTMxODApXG5cdFx0XHRjdXIubm9kZVR5cGUgJiZcblxuXHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveCA8PTQyXG5cdFx0XHQvLyBTdXBwcmVzcyBzcGVjLXZpb2xhdGluZyBjbGlja3MgaW5kaWNhdGluZyBhIG5vbi1wcmltYXJ5IHBvaW50ZXIgYnV0dG9uICh0cmFjLTM4NjEpXG5cdFx0XHQvLyBodHRwczovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNldmVudC10eXBlLWNsaWNrXG5cdFx0XHQvLyBTdXBwb3J0OiBJRSAxMSBvbmx5XG5cdFx0XHQvLyAuLi5idXQgbm90IGFycm93IGtleSBcImNsaWNrc1wiIG9mIHJhZGlvIGlucHV0cywgd2hpY2ggY2FuIGhhdmUgYGJ1dHRvbmAgLTEgKGdoLTIzNDMpXG5cdFx0XHQhKCBldmVudC50eXBlID09PSBcImNsaWNrXCIgJiYgZXZlbnQuYnV0dG9uID49IDEgKSApIHtcblxuXHRcdFx0Zm9yICggOyBjdXIgIT09IHRoaXM7IGN1ciA9IGN1ci5wYXJlbnROb2RlIHx8IHRoaXMgKSB7XG5cblx0XHRcdFx0Ly8gRG9uJ3QgY2hlY2sgbm9uLWVsZW1lbnRzICgjMTMyMDgpXG5cdFx0XHRcdC8vIERvbid0IHByb2Nlc3MgY2xpY2tzIG9uIGRpc2FibGVkIGVsZW1lbnRzICgjNjkxMSwgIzgxNjUsICMxMTM4MiwgIzExNzY0KVxuXHRcdFx0XHRpZiAoIGN1ci5ub2RlVHlwZSA9PT0gMSAmJiAhKCBldmVudC50eXBlID09PSBcImNsaWNrXCIgJiYgY3VyLmRpc2FibGVkID09PSB0cnVlICkgKSB7XG5cdFx0XHRcdFx0bWF0Y2hlZEhhbmRsZXJzID0gW107XG5cdFx0XHRcdFx0bWF0Y2hlZFNlbGVjdG9ycyA9IHt9O1xuXHRcdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgZGVsZWdhdGVDb3VudDsgaSsrICkge1xuXHRcdFx0XHRcdFx0aGFuZGxlT2JqID0gaGFuZGxlcnNbIGkgXTtcblxuXHRcdFx0XHRcdFx0Ly8gRG9uJ3QgY29uZmxpY3Qgd2l0aCBPYmplY3QucHJvdG90eXBlIHByb3BlcnRpZXMgKCMxMzIwMylcblx0XHRcdFx0XHRcdHNlbCA9IGhhbmRsZU9iai5zZWxlY3RvciArIFwiIFwiO1xuXG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZWRTZWxlY3RvcnNbIHNlbCBdID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRcdG1hdGNoZWRTZWxlY3RvcnNbIHNlbCBdID0gaGFuZGxlT2JqLm5lZWRzQ29udGV4dCA/XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5KCBzZWwsIHRoaXMgKS5pbmRleCggY3VyICkgPiAtMSA6XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LmZpbmQoIHNlbCwgdGhpcywgbnVsbCwgWyBjdXIgXSApLmxlbmd0aDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlZFNlbGVjdG9yc1sgc2VsIF0gKSB7XG5cdFx0XHRcdFx0XHRcdG1hdGNoZWRIYW5kbGVycy5wdXNoKCBoYW5kbGVPYmogKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBtYXRjaGVkSGFuZGxlcnMubGVuZ3RoICkge1xuXHRcdFx0XHRcdFx0aGFuZGxlclF1ZXVlLnB1c2goIHsgZWxlbTogY3VyLCBoYW5kbGVyczogbWF0Y2hlZEhhbmRsZXJzIH0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBBZGQgdGhlIHJlbWFpbmluZyAoZGlyZWN0bHktYm91bmQpIGhhbmRsZXJzXG5cdFx0Y3VyID0gdGhpcztcblx0XHRpZiAoIGRlbGVnYXRlQ291bnQgPCBoYW5kbGVycy5sZW5ndGggKSB7XG5cdFx0XHRoYW5kbGVyUXVldWUucHVzaCggeyBlbGVtOiBjdXIsIGhhbmRsZXJzOiBoYW5kbGVycy5zbGljZSggZGVsZWdhdGVDb3VudCApIH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gaGFuZGxlclF1ZXVlO1xuXHR9LFxuXG5cdGFkZFByb3A6IGZ1bmN0aW9uKCBuYW1lLCBob29rICkge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggalF1ZXJ5LkV2ZW50LnByb3RvdHlwZSwgbmFtZSwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblxuXHRcdFx0Z2V0OiBqUXVlcnkuaXNGdW5jdGlvbiggaG9vayApID9cblx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYgKCB0aGlzLm9yaWdpbmFsRXZlbnQgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBob29rKCB0aGlzLm9yaWdpbmFsRXZlbnQgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gOlxuXHRcdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoIHRoaXMub3JpZ2luYWxFdmVudCApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMub3JpZ2luYWxFdmVudFsgbmFtZSBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblxuXHRcdFx0c2V0OiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcywgbmFtZSwge1xuXHRcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdHdyaXRhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdHZhbHVlOiB2YWx1ZVxuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGZpeDogZnVuY3Rpb24oIG9yaWdpbmFsRXZlbnQgKSB7XG5cdFx0cmV0dXJuIG9yaWdpbmFsRXZlbnRbIGpRdWVyeS5leHBhbmRvIF0gP1xuXHRcdFx0b3JpZ2luYWxFdmVudCA6XG5cdFx0XHRuZXcgalF1ZXJ5LkV2ZW50KCBvcmlnaW5hbEV2ZW50ICk7XG5cdH0sXG5cblx0c3BlY2lhbDoge1xuXHRcdGxvYWQ6IHtcblxuXHRcdFx0Ly8gUHJldmVudCB0cmlnZ2VyZWQgaW1hZ2UubG9hZCBldmVudHMgZnJvbSBidWJibGluZyB0byB3aW5kb3cubG9hZFxuXHRcdFx0bm9CdWJibGU6IHRydWVcblx0XHR9LFxuXHRcdGZvY3VzOiB7XG5cblx0XHRcdC8vIEZpcmUgbmF0aXZlIGV2ZW50IGlmIHBvc3NpYmxlIHNvIGJsdXIvZm9jdXMgc2VxdWVuY2UgaXMgY29ycmVjdFxuXHRcdFx0dHJpZ2dlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggdGhpcyAhPT0gc2FmZUFjdGl2ZUVsZW1lbnQoKSAmJiB0aGlzLmZvY3VzICkge1xuXHRcdFx0XHRcdHRoaXMuZm9jdXMoKTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRkZWxlZ2F0ZVR5cGU6IFwiZm9jdXNpblwiXG5cdFx0fSxcblx0XHRibHVyOiB7XG5cdFx0XHR0cmlnZ2VyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCB0aGlzID09PSBzYWZlQWN0aXZlRWxlbWVudCgpICYmIHRoaXMuYmx1ciApIHtcblx0XHRcdFx0XHR0aGlzLmJsdXIoKTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRkZWxlZ2F0ZVR5cGU6IFwiZm9jdXNvdXRcIlxuXHRcdH0sXG5cdFx0Y2xpY2s6IHtcblxuXHRcdFx0Ly8gRm9yIGNoZWNrYm94LCBmaXJlIG5hdGl2ZSBldmVudCBzbyBjaGVja2VkIHN0YXRlIHdpbGwgYmUgcmlnaHRcblx0XHRcdHRyaWdnZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIHRoaXMudHlwZSA9PT0gXCJjaGVja2JveFwiICYmIHRoaXMuY2xpY2sgJiYgalF1ZXJ5Lm5vZGVOYW1lKCB0aGlzLCBcImlucHV0XCIgKSApIHtcblx0XHRcdFx0XHR0aGlzLmNsaWNrKCk7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBGb3IgY3Jvc3MtYnJvd3NlciBjb25zaXN0ZW5jeSwgZG9uJ3QgZmlyZSBuYXRpdmUgLmNsaWNrKCkgb24gbGlua3Ncblx0XHRcdF9kZWZhdWx0OiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdHJldHVybiBqUXVlcnkubm9kZU5hbWUoIGV2ZW50LnRhcmdldCwgXCJhXCIgKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0YmVmb3JldW5sb2FkOiB7XG5cdFx0XHRwb3N0RGlzcGF0Y2g6IGZ1bmN0aW9uKCBldmVudCApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDIwK1xuXHRcdFx0XHQvLyBGaXJlZm94IGRvZXNuJ3QgYWxlcnQgaWYgdGhlIHJldHVyblZhbHVlIGZpZWxkIGlzIG5vdCBzZXQuXG5cdFx0XHRcdGlmICggZXZlbnQucmVzdWx0ICE9PSB1bmRlZmluZWQgJiYgZXZlbnQub3JpZ2luYWxFdmVudCApIHtcblx0XHRcdFx0XHRldmVudC5vcmlnaW5hbEV2ZW50LnJldHVyblZhbHVlID0gZXZlbnQucmVzdWx0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59O1xuXG5qUXVlcnkucmVtb3ZlRXZlbnQgPSBmdW5jdGlvbiggZWxlbSwgdHlwZSwgaGFuZGxlICkge1xuXG5cdC8vIFRoaXMgXCJpZlwiIGlzIG5lZWRlZCBmb3IgcGxhaW4gb2JqZWN0c1xuXHRpZiAoIGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lciApIHtcblx0XHRlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIoIHR5cGUsIGhhbmRsZSApO1xuXHR9XG59O1xuXG5qUXVlcnkuRXZlbnQgPSBmdW5jdGlvbiggc3JjLCBwcm9wcyApIHtcblxuXHQvLyBBbGxvdyBpbnN0YW50aWF0aW9uIHdpdGhvdXQgdGhlICduZXcnIGtleXdvcmRcblx0aWYgKCAhKCB0aGlzIGluc3RhbmNlb2YgalF1ZXJ5LkV2ZW50ICkgKSB7XG5cdFx0cmV0dXJuIG5ldyBqUXVlcnkuRXZlbnQoIHNyYywgcHJvcHMgKTtcblx0fVxuXG5cdC8vIEV2ZW50IG9iamVjdFxuXHRpZiAoIHNyYyAmJiBzcmMudHlwZSApIHtcblx0XHR0aGlzLm9yaWdpbmFsRXZlbnQgPSBzcmM7XG5cdFx0dGhpcy50eXBlID0gc3JjLnR5cGU7XG5cblx0XHQvLyBFdmVudHMgYnViYmxpbmcgdXAgdGhlIGRvY3VtZW50IG1heSBoYXZlIGJlZW4gbWFya2VkIGFzIHByZXZlbnRlZFxuXHRcdC8vIGJ5IGEgaGFuZGxlciBsb3dlciBkb3duIHRoZSB0cmVlOyByZWZsZWN0IHRoZSBjb3JyZWN0IHZhbHVlLlxuXHRcdHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gc3JjLmRlZmF1bHRQcmV2ZW50ZWQgfHxcblx0XHRcdFx0c3JjLmRlZmF1bHRQcmV2ZW50ZWQgPT09IHVuZGVmaW5lZCAmJlxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD0yLjMgb25seVxuXHRcdFx0XHRzcmMucmV0dXJuVmFsdWUgPT09IGZhbHNlID9cblx0XHRcdHJldHVyblRydWUgOlxuXHRcdFx0cmV0dXJuRmFsc2U7XG5cblx0XHQvLyBDcmVhdGUgdGFyZ2V0IHByb3BlcnRpZXNcblx0XHQvLyBTdXBwb3J0OiBTYWZhcmkgPD02IC0gNyBvbmx5XG5cdFx0Ly8gVGFyZ2V0IHNob3VsZCBub3QgYmUgYSB0ZXh0IG5vZGUgKCM1MDQsICMxMzE0Mylcblx0XHR0aGlzLnRhcmdldCA9ICggc3JjLnRhcmdldCAmJiBzcmMudGFyZ2V0Lm5vZGVUeXBlID09PSAzICkgP1xuXHRcdFx0c3JjLnRhcmdldC5wYXJlbnROb2RlIDpcblx0XHRcdHNyYy50YXJnZXQ7XG5cblx0XHR0aGlzLmN1cnJlbnRUYXJnZXQgPSBzcmMuY3VycmVudFRhcmdldDtcblx0XHR0aGlzLnJlbGF0ZWRUYXJnZXQgPSBzcmMucmVsYXRlZFRhcmdldDtcblxuXHQvLyBFdmVudCB0eXBlXG5cdH0gZWxzZSB7XG5cdFx0dGhpcy50eXBlID0gc3JjO1xuXHR9XG5cblx0Ly8gUHV0IGV4cGxpY2l0bHkgcHJvdmlkZWQgcHJvcGVydGllcyBvbnRvIHRoZSBldmVudCBvYmplY3Rcblx0aWYgKCBwcm9wcyApIHtcblx0XHRqUXVlcnkuZXh0ZW5kKCB0aGlzLCBwcm9wcyApO1xuXHR9XG5cblx0Ly8gQ3JlYXRlIGEgdGltZXN0YW1wIGlmIGluY29taW5nIGV2ZW50IGRvZXNuJ3QgaGF2ZSBvbmVcblx0dGhpcy50aW1lU3RhbXAgPSBzcmMgJiYgc3JjLnRpbWVTdGFtcCB8fCBqUXVlcnkubm93KCk7XG5cblx0Ly8gTWFyayBpdCBhcyBmaXhlZFxuXHR0aGlzWyBqUXVlcnkuZXhwYW5kbyBdID0gdHJ1ZTtcbn07XG5cbi8vIGpRdWVyeS5FdmVudCBpcyBiYXNlZCBvbiBET00zIEV2ZW50cyBhcyBzcGVjaWZpZWQgYnkgdGhlIEVDTUFTY3JpcHQgTGFuZ3VhZ2UgQmluZGluZ1xuLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSLzIwMDMvV0QtRE9NLUxldmVsLTMtRXZlbnRzLTIwMDMwMzMxL2VjbWEtc2NyaXB0LWJpbmRpbmcuaHRtbFxualF1ZXJ5LkV2ZW50LnByb3RvdHlwZSA9IHtcblx0Y29uc3RydWN0b3I6IGpRdWVyeS5FdmVudCxcblx0aXNEZWZhdWx0UHJldmVudGVkOiByZXR1cm5GYWxzZSxcblx0aXNQcm9wYWdhdGlvblN0b3BwZWQ6IHJldHVybkZhbHNlLFxuXHRpc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZDogcmV0dXJuRmFsc2UsXG5cdGlzU2ltdWxhdGVkOiBmYWxzZSxcblxuXHRwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cblx0XHR0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IHJldHVyblRydWU7XG5cblx0XHRpZiAoIGUgJiYgIXRoaXMuaXNTaW11bGF0ZWQgKSB7XG5cdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0fVxuXHR9LFxuXHRzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG5cdFx0dGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG5cblx0XHRpZiAoIGUgJiYgIXRoaXMuaXNTaW11bGF0ZWQgKSB7XG5cdFx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdH1cblx0fSxcblx0c3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuXHRcdHRoaXMuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5UcnVlO1xuXG5cdFx0aWYgKCBlICYmICF0aGlzLmlzU2ltdWxhdGVkICkge1xuXHRcdFx0ZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcblx0XHR9XG5cblx0XHR0aGlzLnN0b3BQcm9wYWdhdGlvbigpO1xuXHR9XG59O1xuXG4vLyBJbmNsdWRlcyBhbGwgY29tbW9uIGV2ZW50IHByb3BzIGluY2x1ZGluZyBLZXlFdmVudCBhbmQgTW91c2VFdmVudCBzcGVjaWZpYyBwcm9wc1xualF1ZXJ5LmVhY2goIHtcblx0YWx0S2V5OiB0cnVlLFxuXHRidWJibGVzOiB0cnVlLFxuXHRjYW5jZWxhYmxlOiB0cnVlLFxuXHRjaGFuZ2VkVG91Y2hlczogdHJ1ZSxcblx0Y3RybEtleTogdHJ1ZSxcblx0ZGV0YWlsOiB0cnVlLFxuXHRldmVudFBoYXNlOiB0cnVlLFxuXHRtZXRhS2V5OiB0cnVlLFxuXHRwYWdlWDogdHJ1ZSxcblx0cGFnZVk6IHRydWUsXG5cdHNoaWZ0S2V5OiB0cnVlLFxuXHR2aWV3OiB0cnVlLFxuXHRcImNoYXJcIjogdHJ1ZSxcblx0Y2hhckNvZGU6IHRydWUsXG5cdGtleTogdHJ1ZSxcblx0a2V5Q29kZTogdHJ1ZSxcblx0YnV0dG9uOiB0cnVlLFxuXHRidXR0b25zOiB0cnVlLFxuXHRjbGllbnRYOiB0cnVlLFxuXHRjbGllbnRZOiB0cnVlLFxuXHRvZmZzZXRYOiB0cnVlLFxuXHRvZmZzZXRZOiB0cnVlLFxuXHRwb2ludGVySWQ6IHRydWUsXG5cdHBvaW50ZXJUeXBlOiB0cnVlLFxuXHRzY3JlZW5YOiB0cnVlLFxuXHRzY3JlZW5ZOiB0cnVlLFxuXHR0YXJnZXRUb3VjaGVzOiB0cnVlLFxuXHR0b0VsZW1lbnQ6IHRydWUsXG5cdHRvdWNoZXM6IHRydWUsXG5cblx0d2hpY2g6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHR2YXIgYnV0dG9uID0gZXZlbnQuYnV0dG9uO1xuXG5cdFx0Ly8gQWRkIHdoaWNoIGZvciBrZXkgZXZlbnRzXG5cdFx0aWYgKCBldmVudC53aGljaCA9PSBudWxsICYmIHJrZXlFdmVudC50ZXN0KCBldmVudC50eXBlICkgKSB7XG5cdFx0XHRyZXR1cm4gZXZlbnQuY2hhckNvZGUgIT0gbnVsbCA/IGV2ZW50LmNoYXJDb2RlIDogZXZlbnQua2V5Q29kZTtcblx0XHR9XG5cblx0XHQvLyBBZGQgd2hpY2ggZm9yIGNsaWNrOiAxID09PSBsZWZ0OyAyID09PSBtaWRkbGU7IDMgPT09IHJpZ2h0XG5cdFx0aWYgKCAhZXZlbnQud2hpY2ggJiYgYnV0dG9uICE9PSB1bmRlZmluZWQgJiYgcm1vdXNlRXZlbnQudGVzdCggZXZlbnQudHlwZSApICkge1xuXHRcdFx0aWYgKCBidXR0b24gJiAxICkge1xuXHRcdFx0XHRyZXR1cm4gMTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBidXR0b24gJiAyICkge1xuXHRcdFx0XHRyZXR1cm4gMztcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBidXR0b24gJiA0ICkge1xuXHRcdFx0XHRyZXR1cm4gMjtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50LndoaWNoO1xuXHR9XG59LCBqUXVlcnkuZXZlbnQuYWRkUHJvcCApO1xuXG4vLyBDcmVhdGUgbW91c2VlbnRlci9sZWF2ZSBldmVudHMgdXNpbmcgbW91c2VvdmVyL291dCBhbmQgZXZlbnQtdGltZSBjaGVja3Ncbi8vIHNvIHRoYXQgZXZlbnQgZGVsZWdhdGlvbiB3b3JrcyBpbiBqUXVlcnkuXG4vLyBEbyB0aGUgc2FtZSBmb3IgcG9pbnRlcmVudGVyL3BvaW50ZXJsZWF2ZSBhbmQgcG9pbnRlcm92ZXIvcG9pbnRlcm91dFxuLy9cbi8vIFN1cHBvcnQ6IFNhZmFyaSA3IG9ubHlcbi8vIFNhZmFyaSBzZW5kcyBtb3VzZWVudGVyIHRvbyBvZnRlbjsgc2VlOlxuLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NDcwMjU4XG4vLyBmb3IgdGhlIGRlc2NyaXB0aW9uIG9mIHRoZSBidWcgKGl0IGV4aXN0ZWQgaW4gb2xkZXIgQ2hyb21lIHZlcnNpb25zIGFzIHdlbGwpLlxualF1ZXJ5LmVhY2goIHtcblx0bW91c2VlbnRlcjogXCJtb3VzZW92ZXJcIixcblx0bW91c2VsZWF2ZTogXCJtb3VzZW91dFwiLFxuXHRwb2ludGVyZW50ZXI6IFwicG9pbnRlcm92ZXJcIixcblx0cG9pbnRlcmxlYXZlOiBcInBvaW50ZXJvdXRcIlxufSwgZnVuY3Rpb24oIG9yaWcsIGZpeCApIHtcblx0alF1ZXJ5LmV2ZW50LnNwZWNpYWxbIG9yaWcgXSA9IHtcblx0XHRkZWxlZ2F0ZVR5cGU6IGZpeCxcblx0XHRiaW5kVHlwZTogZml4LFxuXG5cdFx0aGFuZGxlOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHR2YXIgcmV0LFxuXHRcdFx0XHR0YXJnZXQgPSB0aGlzLFxuXHRcdFx0XHRyZWxhdGVkID0gZXZlbnQucmVsYXRlZFRhcmdldCxcblx0XHRcdFx0aGFuZGxlT2JqID0gZXZlbnQuaGFuZGxlT2JqO1xuXG5cdFx0XHQvLyBGb3IgbW91c2VlbnRlci9sZWF2ZSBjYWxsIHRoZSBoYW5kbGVyIGlmIHJlbGF0ZWQgaXMgb3V0c2lkZSB0aGUgdGFyZ2V0LlxuXHRcdFx0Ly8gTkI6IE5vIHJlbGF0ZWRUYXJnZXQgaWYgdGhlIG1vdXNlIGxlZnQvZW50ZXJlZCB0aGUgYnJvd3NlciB3aW5kb3dcblx0XHRcdGlmICggIXJlbGF0ZWQgfHwgKCByZWxhdGVkICE9PSB0YXJnZXQgJiYgIWpRdWVyeS5jb250YWlucyggdGFyZ2V0LCByZWxhdGVkICkgKSApIHtcblx0XHRcdFx0ZXZlbnQudHlwZSA9IGhhbmRsZU9iai5vcmlnVHlwZTtcblx0XHRcdFx0cmV0ID0gaGFuZGxlT2JqLmhhbmRsZXIuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRldmVudC50eXBlID0gZml4O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9XG5cdH07XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblxuXHRvbjogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIG9uKCB0aGlzLCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICk7XG5cdH0sXG5cdG9uZTogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIG9uKCB0aGlzLCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuLCAxICk7XG5cdH0sXG5cdG9mZjogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZm4gKSB7XG5cdFx0dmFyIGhhbmRsZU9iaiwgdHlwZTtcblx0XHRpZiAoIHR5cGVzICYmIHR5cGVzLnByZXZlbnREZWZhdWx0ICYmIHR5cGVzLmhhbmRsZU9iaiApIHtcblxuXHRcdFx0Ly8gKCBldmVudCApICBkaXNwYXRjaGVkIGpRdWVyeS5FdmVudFxuXHRcdFx0aGFuZGxlT2JqID0gdHlwZXMuaGFuZGxlT2JqO1xuXHRcdFx0alF1ZXJ5KCB0eXBlcy5kZWxlZ2F0ZVRhcmdldCApLm9mZihcblx0XHRcdFx0aGFuZGxlT2JqLm5hbWVzcGFjZSA/XG5cdFx0XHRcdFx0aGFuZGxlT2JqLm9yaWdUeXBlICsgXCIuXCIgKyBoYW5kbGVPYmoubmFtZXNwYWNlIDpcblx0XHRcdFx0XHRoYW5kbGVPYmoub3JpZ1R5cGUsXG5cdFx0XHRcdGhhbmRsZU9iai5zZWxlY3Rvcixcblx0XHRcdFx0aGFuZGxlT2JqLmhhbmRsZXJcblx0XHRcdCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0aWYgKCB0eXBlb2YgdHlwZXMgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMtb2JqZWN0IFssIHNlbGVjdG9yXSApXG5cdFx0XHRmb3IgKCB0eXBlIGluIHR5cGVzICkge1xuXHRcdFx0XHR0aGlzLm9mZiggdHlwZSwgc2VsZWN0b3IsIHR5cGVzWyB0eXBlIF0gKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHRpZiAoIHNlbGVjdG9yID09PSBmYWxzZSB8fCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwiZnVuY3Rpb25cIiApIHtcblxuXHRcdFx0Ly8gKCB0eXBlcyBbLCBmbl0gKVxuXHRcdFx0Zm4gPSBzZWxlY3Rvcjtcblx0XHRcdHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRpZiAoIGZuID09PSBmYWxzZSApIHtcblx0XHRcdGZuID0gcmV0dXJuRmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggdGhpcywgdHlwZXMsIGZuLCBzZWxlY3RvciApO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5cbnZhclxuXG5cdC8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cblxuXHQvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2VzbGludC9lc2xpbnQvaXNzdWVzLzMyMjlcblx0cnhodG1sVGFnID0gLzwoPyFhcmVhfGJyfGNvbHxlbWJlZHxocnxpbWd8aW5wdXR8bGlua3xtZXRhfHBhcmFtKSgoW2Etel1bXlxcL1xcMD5cXHgyMFxcdFxcclxcblxcZl0qKVtePl0qKVxcLz4vZ2ksXG5cblx0LyogZXNsaW50LWVuYWJsZSAqL1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9MTAgLSAxMSwgRWRnZSAxMiAtIDEzXG5cdC8vIEluIElFL0VkZ2UgdXNpbmcgcmVnZXggZ3JvdXBzIGhlcmUgY2F1c2VzIHNldmVyZSBzbG93ZG93bnMuXG5cdC8vIFNlZSBodHRwczovL2Nvbm5lY3QubWljcm9zb2Z0LmNvbS9JRS9mZWVkYmFjay9kZXRhaWxzLzE3MzY1MTIvXG5cdHJub0lubmVyaHRtbCA9IC88c2NyaXB0fDxzdHlsZXw8bGluay9pLFxuXG5cdC8vIGNoZWNrZWQ9XCJjaGVja2VkXCIgb3IgY2hlY2tlZFxuXHRyY2hlY2tlZCA9IC9jaGVja2VkXFxzKig/OltePV18PVxccyouY2hlY2tlZC4pL2ksXG5cdHJzY3JpcHRUeXBlTWFza2VkID0gL150cnVlXFwvKC4qKS8sXG5cdHJjbGVhblNjcmlwdCA9IC9eXFxzKjwhKD86XFxbQ0RBVEFcXFt8LS0pfCg/OlxcXVxcXXwtLSk+XFxzKiQvZztcblxuZnVuY3Rpb24gbWFuaXB1bGF0aW9uVGFyZ2V0KCBlbGVtLCBjb250ZW50ICkge1xuXHRpZiAoIGpRdWVyeS5ub2RlTmFtZSggZWxlbSwgXCJ0YWJsZVwiICkgJiZcblx0XHRqUXVlcnkubm9kZU5hbWUoIGNvbnRlbnQubm9kZVR5cGUgIT09IDExID8gY29udGVudCA6IGNvbnRlbnQuZmlyc3RDaGlsZCwgXCJ0clwiICkgKSB7XG5cblx0XHRyZXR1cm4gZWxlbS5nZXRFbGVtZW50c0J5VGFnTmFtZSggXCJ0Ym9keVwiIClbIDAgXSB8fCBlbGVtO1xuXHR9XG5cblx0cmV0dXJuIGVsZW07XG59XG5cbi8vIFJlcGxhY2UvcmVzdG9yZSB0aGUgdHlwZSBhdHRyaWJ1dGUgb2Ygc2NyaXB0IGVsZW1lbnRzIGZvciBzYWZlIERPTSBtYW5pcHVsYXRpb25cbmZ1bmN0aW9uIGRpc2FibGVTY3JpcHQoIGVsZW0gKSB7XG5cdGVsZW0udHlwZSA9ICggZWxlbS5nZXRBdHRyaWJ1dGUoIFwidHlwZVwiICkgIT09IG51bGwgKSArIFwiL1wiICsgZWxlbS50eXBlO1xuXHRyZXR1cm4gZWxlbTtcbn1cbmZ1bmN0aW9uIHJlc3RvcmVTY3JpcHQoIGVsZW0gKSB7XG5cdHZhciBtYXRjaCA9IHJzY3JpcHRUeXBlTWFza2VkLmV4ZWMoIGVsZW0udHlwZSApO1xuXG5cdGlmICggbWF0Y2ggKSB7XG5cdFx0ZWxlbS50eXBlID0gbWF0Y2hbIDEgXTtcblx0fSBlbHNlIHtcblx0XHRlbGVtLnJlbW92ZUF0dHJpYnV0ZSggXCJ0eXBlXCIgKTtcblx0fVxuXG5cdHJldHVybiBlbGVtO1xufVxuXG5mdW5jdGlvbiBjbG9uZUNvcHlFdmVudCggc3JjLCBkZXN0ICkge1xuXHR2YXIgaSwgbCwgdHlwZSwgcGRhdGFPbGQsIHBkYXRhQ3VyLCB1ZGF0YU9sZCwgdWRhdGFDdXIsIGV2ZW50cztcblxuXHRpZiAoIGRlc3Qubm9kZVR5cGUgIT09IDEgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gMS4gQ29weSBwcml2YXRlIGRhdGE6IGV2ZW50cywgaGFuZGxlcnMsIGV0Yy5cblx0aWYgKCBkYXRhUHJpdi5oYXNEYXRhKCBzcmMgKSApIHtcblx0XHRwZGF0YU9sZCA9IGRhdGFQcml2LmFjY2Vzcyggc3JjICk7XG5cdFx0cGRhdGFDdXIgPSBkYXRhUHJpdi5zZXQoIGRlc3QsIHBkYXRhT2xkICk7XG5cdFx0ZXZlbnRzID0gcGRhdGFPbGQuZXZlbnRzO1xuXG5cdFx0aWYgKCBldmVudHMgKSB7XG5cdFx0XHRkZWxldGUgcGRhdGFDdXIuaGFuZGxlO1xuXHRcdFx0cGRhdGFDdXIuZXZlbnRzID0ge307XG5cblx0XHRcdGZvciAoIHR5cGUgaW4gZXZlbnRzICkge1xuXHRcdFx0XHRmb3IgKCBpID0gMCwgbCA9IGV2ZW50c1sgdHlwZSBdLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQuYWRkKCBkZXN0LCB0eXBlLCBldmVudHNbIHR5cGUgXVsgaSBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyAyLiBDb3B5IHVzZXIgZGF0YVxuXHRpZiAoIGRhdGFVc2VyLmhhc0RhdGEoIHNyYyApICkge1xuXHRcdHVkYXRhT2xkID0gZGF0YVVzZXIuYWNjZXNzKCBzcmMgKTtcblx0XHR1ZGF0YUN1ciA9IGpRdWVyeS5leHRlbmQoIHt9LCB1ZGF0YU9sZCApO1xuXG5cdFx0ZGF0YVVzZXIuc2V0KCBkZXN0LCB1ZGF0YUN1ciApO1xuXHR9XG59XG5cbi8vIEZpeCBJRSBidWdzLCBzZWUgc3VwcG9ydCB0ZXN0c1xuZnVuY3Rpb24gZml4SW5wdXQoIHNyYywgZGVzdCApIHtcblx0dmFyIG5vZGVOYW1lID0gZGVzdC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXG5cdC8vIEZhaWxzIHRvIHBlcnNpc3QgdGhlIGNoZWNrZWQgc3RhdGUgb2YgYSBjbG9uZWQgY2hlY2tib3ggb3IgcmFkaW8gYnV0dG9uLlxuXHRpZiAoIG5vZGVOYW1lID09PSBcImlucHV0XCIgJiYgcmNoZWNrYWJsZVR5cGUudGVzdCggc3JjLnR5cGUgKSApIHtcblx0XHRkZXN0LmNoZWNrZWQgPSBzcmMuY2hlY2tlZDtcblxuXHQvLyBGYWlscyB0byByZXR1cm4gdGhlIHNlbGVjdGVkIG9wdGlvbiB0byB0aGUgZGVmYXVsdCBzZWxlY3RlZCBzdGF0ZSB3aGVuIGNsb25pbmcgb3B0aW9uc1xuXHR9IGVsc2UgaWYgKCBub2RlTmFtZSA9PT0gXCJpbnB1dFwiIHx8IG5vZGVOYW1lID09PSBcInRleHRhcmVhXCIgKSB7XG5cdFx0ZGVzdC5kZWZhdWx0VmFsdWUgPSBzcmMuZGVmYXVsdFZhbHVlO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGRvbU1hbmlwKCBjb2xsZWN0aW9uLCBhcmdzLCBjYWxsYmFjaywgaWdub3JlZCApIHtcblxuXHQvLyBGbGF0dGVuIGFueSBuZXN0ZWQgYXJyYXlzXG5cdGFyZ3MgPSBjb25jYXQuYXBwbHkoIFtdLCBhcmdzICk7XG5cblx0dmFyIGZyYWdtZW50LCBmaXJzdCwgc2NyaXB0cywgaGFzU2NyaXB0cywgbm9kZSwgZG9jLFxuXHRcdGkgPSAwLFxuXHRcdGwgPSBjb2xsZWN0aW9uLmxlbmd0aCxcblx0XHRpTm9DbG9uZSA9IGwgLSAxLFxuXHRcdHZhbHVlID0gYXJnc1sgMCBdLFxuXHRcdGlzRnVuY3Rpb24gPSBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKTtcblxuXHQvLyBXZSBjYW4ndCBjbG9uZU5vZGUgZnJhZ21lbnRzIHRoYXQgY29udGFpbiBjaGVja2VkLCBpbiBXZWJLaXRcblx0aWYgKCBpc0Z1bmN0aW9uIHx8XG5cdFx0XHQoIGwgPiAxICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJlxuXHRcdFx0XHQhc3VwcG9ydC5jaGVja0Nsb25lICYmIHJjaGVja2VkLnRlc3QoIHZhbHVlICkgKSApIHtcblx0XHRyZXR1cm4gY29sbGVjdGlvbi5lYWNoKCBmdW5jdGlvbiggaW5kZXggKSB7XG5cdFx0XHR2YXIgc2VsZiA9IGNvbGxlY3Rpb24uZXEoIGluZGV4ICk7XG5cdFx0XHRpZiAoIGlzRnVuY3Rpb24gKSB7XG5cdFx0XHRcdGFyZ3NbIDAgXSA9IHZhbHVlLmNhbGwoIHRoaXMsIGluZGV4LCBzZWxmLmh0bWwoKSApO1xuXHRcdFx0fVxuXHRcdFx0ZG9tTWFuaXAoIHNlbGYsIGFyZ3MsIGNhbGxiYWNrLCBpZ25vcmVkICk7XG5cdFx0fSApO1xuXHR9XG5cblx0aWYgKCBsICkge1xuXHRcdGZyYWdtZW50ID0gYnVpbGRGcmFnbWVudCggYXJncywgY29sbGVjdGlvblsgMCBdLm93bmVyRG9jdW1lbnQsIGZhbHNlLCBjb2xsZWN0aW9uLCBpZ25vcmVkICk7XG5cdFx0Zmlyc3QgPSBmcmFnbWVudC5maXJzdENoaWxkO1xuXG5cdFx0aWYgKCBmcmFnbWVudC5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMSApIHtcblx0XHRcdGZyYWdtZW50ID0gZmlyc3Q7XG5cdFx0fVxuXG5cdFx0Ly8gUmVxdWlyZSBlaXRoZXIgbmV3IGNvbnRlbnQgb3IgYW4gaW50ZXJlc3QgaW4gaWdub3JlZCBlbGVtZW50cyB0byBpbnZva2UgdGhlIGNhbGxiYWNrXG5cdFx0aWYgKCBmaXJzdCB8fCBpZ25vcmVkICkge1xuXHRcdFx0c2NyaXB0cyA9IGpRdWVyeS5tYXAoIGdldEFsbCggZnJhZ21lbnQsIFwic2NyaXB0XCIgKSwgZGlzYWJsZVNjcmlwdCApO1xuXHRcdFx0aGFzU2NyaXB0cyA9IHNjcmlwdHMubGVuZ3RoO1xuXG5cdFx0XHQvLyBVc2UgdGhlIG9yaWdpbmFsIGZyYWdtZW50IGZvciB0aGUgbGFzdCBpdGVtXG5cdFx0XHQvLyBpbnN0ZWFkIG9mIHRoZSBmaXJzdCBiZWNhdXNlIGl0IGNhbiBlbmQgdXBcblx0XHRcdC8vIGJlaW5nIGVtcHRpZWQgaW5jb3JyZWN0bHkgaW4gY2VydGFpbiBzaXR1YXRpb25zICgjODA3MCkuXG5cdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdG5vZGUgPSBmcmFnbWVudDtcblxuXHRcdFx0XHRpZiAoIGkgIT09IGlOb0Nsb25lICkge1xuXHRcdFx0XHRcdG5vZGUgPSBqUXVlcnkuY2xvbmUoIG5vZGUsIHRydWUsIHRydWUgKTtcblxuXHRcdFx0XHRcdC8vIEtlZXAgcmVmZXJlbmNlcyB0byBjbG9uZWQgc2NyaXB0cyBmb3IgbGF0ZXIgcmVzdG9yYXRpb25cblx0XHRcdFx0XHRpZiAoIGhhc1NjcmlwdHMgKSB7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHRcdFx0XHRcdFx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCBzY3JpcHRzLCBnZXRBbGwoIG5vZGUsIFwic2NyaXB0XCIgKSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNhbGxiYWNrLmNhbGwoIGNvbGxlY3Rpb25bIGkgXSwgbm9kZSwgaSApO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGhhc1NjcmlwdHMgKSB7XG5cdFx0XHRcdGRvYyA9IHNjcmlwdHNbIHNjcmlwdHMubGVuZ3RoIC0gMSBdLm93bmVyRG9jdW1lbnQ7XG5cblx0XHRcdFx0Ly8gUmVlbmFibGUgc2NyaXB0c1xuXHRcdFx0XHRqUXVlcnkubWFwKCBzY3JpcHRzLCByZXN0b3JlU2NyaXB0ICk7XG5cblx0XHRcdFx0Ly8gRXZhbHVhdGUgZXhlY3V0YWJsZSBzY3JpcHRzIG9uIGZpcnN0IGRvY3VtZW50IGluc2VydGlvblxuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGhhc1NjcmlwdHM7IGkrKyApIHtcblx0XHRcdFx0XHRub2RlID0gc2NyaXB0c1sgaSBdO1xuXHRcdFx0XHRcdGlmICggcnNjcmlwdFR5cGUudGVzdCggbm9kZS50eXBlIHx8IFwiXCIgKSAmJlxuXHRcdFx0XHRcdFx0IWRhdGFQcml2LmFjY2Vzcyggbm9kZSwgXCJnbG9iYWxFdmFsXCIgKSAmJlxuXHRcdFx0XHRcdFx0alF1ZXJ5LmNvbnRhaW5zKCBkb2MsIG5vZGUgKSApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCBub2RlLnNyYyApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBPcHRpb25hbCBBSkFYIGRlcGVuZGVuY3ksIGJ1dCB3b24ndCBydW4gc2NyaXB0cyBpZiBub3QgcHJlc2VudFxuXHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5fZXZhbFVybCApIHtcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuX2V2YWxVcmwoIG5vZGUuc3JjICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdERPTUV2YWwoIG5vZGUudGV4dENvbnRlbnQucmVwbGFjZSggcmNsZWFuU2NyaXB0LCBcIlwiICksIGRvYyApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBjb2xsZWN0aW9uO1xufVxuXG5mdW5jdGlvbiByZW1vdmUoIGVsZW0sIHNlbGVjdG9yLCBrZWVwRGF0YSApIHtcblx0dmFyIG5vZGUsXG5cdFx0bm9kZXMgPSBzZWxlY3RvciA/IGpRdWVyeS5maWx0ZXIoIHNlbGVjdG9yLCBlbGVtICkgOiBlbGVtLFxuXHRcdGkgPSAwO1xuXG5cdGZvciAoIDsgKCBub2RlID0gbm9kZXNbIGkgXSApICE9IG51bGw7IGkrKyApIHtcblx0XHRpZiAoICFrZWVwRGF0YSAmJiBub2RlLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCBub2RlICkgKTtcblx0XHR9XG5cblx0XHRpZiAoIG5vZGUucGFyZW50Tm9kZSApIHtcblx0XHRcdGlmICgga2VlcERhdGEgJiYgalF1ZXJ5LmNvbnRhaW5zKCBub2RlLm93bmVyRG9jdW1lbnQsIG5vZGUgKSApIHtcblx0XHRcdFx0c2V0R2xvYmFsRXZhbCggZ2V0QWxsKCBub2RlLCBcInNjcmlwdFwiICkgKTtcblx0XHRcdH1cblx0XHRcdG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggbm9kZSApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBlbGVtO1xufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdGh0bWxQcmVmaWx0ZXI6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdHJldHVybiBodG1sLnJlcGxhY2UoIHJ4aHRtbFRhZywgXCI8JDE+PC8kMj5cIiApO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbiggZWxlbSwgZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKSB7XG5cdFx0dmFyIGksIGwsIHNyY0VsZW1lbnRzLCBkZXN0RWxlbWVudHMsXG5cdFx0XHRjbG9uZSA9IGVsZW0uY2xvbmVOb2RlKCB0cnVlICksXG5cdFx0XHRpblBhZ2UgPSBqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApO1xuXG5cdFx0Ly8gRml4IElFIGNsb25pbmcgaXNzdWVzXG5cdFx0aWYgKCAhc3VwcG9ydC5ub0Nsb25lQ2hlY2tlZCAmJiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgZWxlbS5ub2RlVHlwZSA9PT0gMTEgKSAmJlxuXHRcdFx0XHQhalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICkgKSB7XG5cblx0XHRcdC8vIFdlIGVzY2hldyBTaXp6bGUgaGVyZSBmb3IgcGVyZm9ybWFuY2UgcmVhc29uczogaHR0cHM6Ly9qc3BlcmYuY29tL2dldGFsbC12cy1zaXp6bGUvMlxuXHRcdFx0ZGVzdEVsZW1lbnRzID0gZ2V0QWxsKCBjbG9uZSApO1xuXHRcdFx0c3JjRWxlbWVudHMgPSBnZXRBbGwoIGVsZW0gKTtcblxuXHRcdFx0Zm9yICggaSA9IDAsIGwgPSBzcmNFbGVtZW50cy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdGZpeElucHV0KCBzcmNFbGVtZW50c1sgaSBdLCBkZXN0RWxlbWVudHNbIGkgXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENvcHkgdGhlIGV2ZW50cyBmcm9tIHRoZSBvcmlnaW5hbCB0byB0aGUgY2xvbmVcblx0XHRpZiAoIGRhdGFBbmRFdmVudHMgKSB7XG5cdFx0XHRpZiAoIGRlZXBEYXRhQW5kRXZlbnRzICkge1xuXHRcdFx0XHRzcmNFbGVtZW50cyA9IHNyY0VsZW1lbnRzIHx8IGdldEFsbCggZWxlbSApO1xuXHRcdFx0XHRkZXN0RWxlbWVudHMgPSBkZXN0RWxlbWVudHMgfHwgZ2V0QWxsKCBjbG9uZSApO1xuXG5cdFx0XHRcdGZvciAoIGkgPSAwLCBsID0gc3JjRWxlbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdGNsb25lQ29weUV2ZW50KCBzcmNFbGVtZW50c1sgaSBdLCBkZXN0RWxlbWVudHNbIGkgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjbG9uZUNvcHlFdmVudCggZWxlbSwgY2xvbmUgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBQcmVzZXJ2ZSBzY3JpcHQgZXZhbHVhdGlvbiBoaXN0b3J5XG5cdFx0ZGVzdEVsZW1lbnRzID0gZ2V0QWxsKCBjbG9uZSwgXCJzY3JpcHRcIiApO1xuXHRcdGlmICggZGVzdEVsZW1lbnRzLmxlbmd0aCA+IDAgKSB7XG5cdFx0XHRzZXRHbG9iYWxFdmFsKCBkZXN0RWxlbWVudHMsICFpblBhZ2UgJiYgZ2V0QWxsKCBlbGVtLCBcInNjcmlwdFwiICkgKTtcblx0XHR9XG5cblx0XHQvLyBSZXR1cm4gdGhlIGNsb25lZCBzZXRcblx0XHRyZXR1cm4gY2xvbmU7XG5cdH0sXG5cblx0Y2xlYW5EYXRhOiBmdW5jdGlvbiggZWxlbXMgKSB7XG5cdFx0dmFyIGRhdGEsIGVsZW0sIHR5cGUsXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWwsXG5cdFx0XHRpID0gMDtcblxuXHRcdGZvciAoIDsgKCBlbGVtID0gZWxlbXNbIGkgXSApICE9PSB1bmRlZmluZWQ7IGkrKyApIHtcblx0XHRcdGlmICggYWNjZXB0RGF0YSggZWxlbSApICkge1xuXHRcdFx0XHRpZiAoICggZGF0YSA9IGVsZW1bIGRhdGFQcml2LmV4cGFuZG8gXSApICkge1xuXHRcdFx0XHRcdGlmICggZGF0YS5ldmVudHMgKSB7XG5cdFx0XHRcdFx0XHRmb3IgKCB0eXBlIGluIGRhdGEuZXZlbnRzICkge1xuXHRcdFx0XHRcdFx0XHRpZiAoIHNwZWNpYWxbIHR5cGUgXSApIHtcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuZXZlbnQucmVtb3ZlKCBlbGVtLCB0eXBlICk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gVGhpcyBpcyBhIHNob3J0Y3V0IHRvIGF2b2lkIGpRdWVyeS5ldmVudC5yZW1vdmUncyBvdmVyaGVhZFxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5yZW1vdmVFdmVudCggZWxlbSwgdHlwZSwgZGF0YS5oYW5kbGUgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZSA8PTM1IC0gNDUrXG5cdFx0XHRcdFx0Ly8gQXNzaWduIHVuZGVmaW5lZCBpbnN0ZWFkIG9mIHVzaW5nIGRlbGV0ZSwgc2VlIERhdGEjcmVtb3ZlXG5cdFx0XHRcdFx0ZWxlbVsgZGF0YVByaXYuZXhwYW5kbyBdID0gdW5kZWZpbmVkO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggZWxlbVsgZGF0YVVzZXIuZXhwYW5kbyBdICkge1xuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lIDw9MzUgLSA0NStcblx0XHRcdFx0XHQvLyBBc3NpZ24gdW5kZWZpbmVkIGluc3RlYWQgb2YgdXNpbmcgZGVsZXRlLCBzZWUgRGF0YSNyZW1vdmVcblx0XHRcdFx0XHRlbGVtWyBkYXRhVXNlci5leHBhbmRvIF0gPSB1bmRlZmluZWQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRkZXRhY2g6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gcmVtb3ZlKCB0aGlzLCBzZWxlY3RvciwgdHJ1ZSApO1xuXHR9LFxuXG5cdHJlbW92ZTogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiByZW1vdmUoIHRoaXMsIHNlbGVjdG9yICk7XG5cdH0sXG5cblx0dGV4dDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID9cblx0XHRcdFx0alF1ZXJ5LnRleHQoIHRoaXMgKSA6XG5cdFx0XHRcdHRoaXMuZW1wdHkoKS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0XHRcdHRoaXMudGV4dENvbnRlbnQgPSB2YWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHR9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCApO1xuXHR9LFxuXG5cdGFwcGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdHZhciB0YXJnZXQgPSBtYW5pcHVsYXRpb25UYXJnZXQoIHRoaXMsIGVsZW0gKTtcblx0XHRcdFx0dGFyZ2V0LmFwcGVuZENoaWxkKCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdHByZXBlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHR2YXIgdGFyZ2V0ID0gbWFuaXB1bGF0aW9uVGFyZ2V0KCB0aGlzLCBlbGVtICk7XG5cdFx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoIGVsZW0sIHRhcmdldC5maXJzdENoaWxkICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGJlZm9yZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoIGVsZW0sIHRoaXMgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0YWZ0ZXI6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5wYXJlbnROb2RlICkge1xuXHRcdFx0XHR0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0aGlzLm5leHRTaWJsaW5nICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGVtcHR5OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZWxlbSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Zm9yICggOyAoIGVsZW0gPSB0aGlzWyBpIF0gKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cblx0XHRcdFx0Ly8gUHJldmVudCBtZW1vcnkgbGVha3Ncblx0XHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCBlbGVtLCBmYWxzZSApICk7XG5cblx0XHRcdFx0Ly8gUmVtb3ZlIGFueSByZW1haW5pbmcgbm9kZXNcblx0XHRcdFx0ZWxlbS50ZXh0Q29udGVudCA9IFwiXCI7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcblx0XHRkYXRhQW5kRXZlbnRzID0gZGF0YUFuZEV2ZW50cyA9PSBudWxsID8gZmFsc2UgOiBkYXRhQW5kRXZlbnRzO1xuXHRcdGRlZXBEYXRhQW5kRXZlbnRzID0gZGVlcERhdGFBbmRFdmVudHMgPT0gbnVsbCA/IGRhdGFBbmRFdmVudHMgOiBkZWVwRGF0YUFuZEV2ZW50cztcblxuXHRcdHJldHVybiB0aGlzLm1hcCggZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LmNsb25lKCB0aGlzLCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyApO1xuXHRcdH0gKTtcblx0fSxcblxuXHRodG1sOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0dmFyIGVsZW0gPSB0aGlzWyAwIF0gfHwge30sXG5cdFx0XHRcdGkgPSAwLFxuXHRcdFx0XHRsID0gdGhpcy5sZW5ndGg7XG5cblx0XHRcdGlmICggdmFsdWUgPT09IHVuZGVmaW5lZCAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRyZXR1cm4gZWxlbS5pbm5lckhUTUw7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNlZSBpZiB3ZSBjYW4gdGFrZSBhIHNob3J0Y3V0IGFuZCBqdXN0IHVzZSBpbm5lckhUTUxcblx0XHRcdGlmICggdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmICFybm9Jbm5lcmh0bWwudGVzdCggdmFsdWUgKSAmJlxuXHRcdFx0XHQhd3JhcE1hcFsgKCBydGFnTmFtZS5leGVjKCB2YWx1ZSApIHx8IFsgXCJcIiwgXCJcIiBdIClbIDEgXS50b0xvd2VyQ2FzZSgpIF0gKSB7XG5cblx0XHRcdFx0dmFsdWUgPSBqUXVlcnkuaHRtbFByZWZpbHRlciggdmFsdWUgKTtcblxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRcdGVsZW0gPSB0aGlzWyBpIF0gfHwge307XG5cblx0XHRcdFx0XHRcdC8vIFJlbW92ZSBlbGVtZW50IG5vZGVzIGFuZCBwcmV2ZW50IG1lbW9yeSBsZWFrc1xuXHRcdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIGVsZW0sIGZhbHNlICkgKTtcblx0XHRcdFx0XHRcdFx0ZWxlbS5pbm5lckhUTUwgPSB2YWx1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRlbGVtID0gMDtcblxuXHRcdFx0XHQvLyBJZiB1c2luZyBpbm5lckhUTUwgdGhyb3dzIGFuIGV4Y2VwdGlvbiwgdXNlIHRoZSBmYWxsYmFjayBtZXRob2Rcblx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHRcdHRoaXMuZW1wdHkoKS5hcHBlbmQoIHZhbHVlICk7XG5cdFx0XHR9XG5cdFx0fSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggKTtcblx0fSxcblxuXHRyZXBsYWNlV2l0aDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGlnbm9yZWQgPSBbXTtcblxuXHRcdC8vIE1ha2UgdGhlIGNoYW5nZXMsIHJlcGxhY2luZyBlYWNoIG5vbi1pZ25vcmVkIGNvbnRleHQgZWxlbWVudCB3aXRoIHRoZSBuZXcgY29udGVudFxuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudE5vZGU7XG5cblx0XHRcdGlmICggalF1ZXJ5LmluQXJyYXkoIHRoaXMsIGlnbm9yZWQgKSA8IDAgKSB7XG5cdFx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggdGhpcyApICk7XG5cdFx0XHRcdGlmICggcGFyZW50ICkge1xuXHRcdFx0XHRcdHBhcmVudC5yZXBsYWNlQ2hpbGQoIGVsZW0sIHRoaXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0Ly8gRm9yY2UgY2FsbGJhY2sgaW52b2NhdGlvblxuXHRcdH0sIGlnbm9yZWQgKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCgge1xuXHRhcHBlbmRUbzogXCJhcHBlbmRcIixcblx0cHJlcGVuZFRvOiBcInByZXBlbmRcIixcblx0aW5zZXJ0QmVmb3JlOiBcImJlZm9yZVwiLFxuXHRpbnNlcnRBZnRlcjogXCJhZnRlclwiLFxuXHRyZXBsYWNlQWxsOiBcInJlcGxhY2VXaXRoXCJcbn0sIGZ1bmN0aW9uKCBuYW1lLCBvcmlnaW5hbCApIHtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIGVsZW1zLFxuXHRcdFx0cmV0ID0gW10sXG5cdFx0XHRpbnNlcnQgPSBqUXVlcnkoIHNlbGVjdG9yICksXG5cdFx0XHRsYXN0ID0gaW5zZXJ0Lmxlbmd0aCAtIDEsXG5cdFx0XHRpID0gMDtcblxuXHRcdGZvciAoIDsgaSA8PSBsYXN0OyBpKysgKSB7XG5cdFx0XHRlbGVtcyA9IGkgPT09IGxhc3QgPyB0aGlzIDogdGhpcy5jbG9uZSggdHJ1ZSApO1xuXHRcdFx0alF1ZXJ5KCBpbnNlcnRbIGkgXSApWyBvcmlnaW5hbCBdKCBlbGVtcyApO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcblx0XHRcdC8vIC5nZXQoKSBiZWNhdXNlIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0XHRcdHB1c2guYXBwbHkoIHJldCwgZWxlbXMuZ2V0KCkgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHJldCApO1xuXHR9O1xufSApO1xudmFyIHJtYXJnaW4gPSAoIC9ebWFyZ2luLyApO1xuXG52YXIgcm51bW5vbnB4ID0gbmV3IFJlZ0V4cCggXCJeKFwiICsgcG51bSArIFwiKSg/IXB4KVthLXolXSskXCIsIFwiaVwiICk7XG5cbnZhciBnZXRTdHlsZXMgPSBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seSwgRmlyZWZveCA8PTMwICgjMTUwOTgsICMxNDE1MClcblx0XHQvLyBJRSB0aHJvd3Mgb24gZWxlbWVudHMgY3JlYXRlZCBpbiBwb3B1cHNcblx0XHQvLyBGRiBtZWFud2hpbGUgdGhyb3dzIG9uIGZyYW1lIGVsZW1lbnRzIHRocm91Z2ggXCJkZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlXCJcblx0XHR2YXIgdmlldyA9IGVsZW0ub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcblxuXHRcdGlmICggIXZpZXcgfHwgIXZpZXcub3BlbmVyICkge1xuXHRcdFx0dmlldyA9IHdpbmRvdztcblx0XHR9XG5cblx0XHRyZXR1cm4gdmlldy5nZXRDb21wdXRlZFN0eWxlKCBlbGVtICk7XG5cdH07XG5cblxuXG4oIGZ1bmN0aW9uKCkge1xuXG5cdC8vIEV4ZWN1dGluZyBib3RoIHBpeGVsUG9zaXRpb24gJiBib3hTaXppbmdSZWxpYWJsZSB0ZXN0cyByZXF1aXJlIG9ubHkgb25lIGxheW91dFxuXHQvLyBzbyB0aGV5J3JlIGV4ZWN1dGVkIGF0IHRoZSBzYW1lIHRpbWUgdG8gc2F2ZSB0aGUgc2Vjb25kIGNvbXB1dGF0aW9uLlxuXHRmdW5jdGlvbiBjb21wdXRlU3R5bGVUZXN0cygpIHtcblxuXHRcdC8vIFRoaXMgaXMgYSBzaW5nbGV0b24sIHdlIG5lZWQgdG8gZXhlY3V0ZSBpdCBvbmx5IG9uY2Vcblx0XHRpZiAoICFkaXYgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0ZGl2LnN0eWxlLmNzc1RleHQgPVxuXHRcdFx0XCJib3gtc2l6aW5nOmJvcmRlci1ib3g7XCIgK1xuXHRcdFx0XCJwb3NpdGlvbjpyZWxhdGl2ZTtkaXNwbGF5OmJsb2NrO1wiICtcblx0XHRcdFwibWFyZ2luOmF1dG87Ym9yZGVyOjFweDtwYWRkaW5nOjFweDtcIiArXG5cdFx0XHRcInRvcDoxJTt3aWR0aDo1MCVcIjtcblx0XHRkaXYuaW5uZXJIVE1MID0gXCJcIjtcblx0XHRkb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoIGNvbnRhaW5lciApO1xuXG5cdFx0dmFyIGRpdlN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoIGRpdiApO1xuXHRcdHBpeGVsUG9zaXRpb25WYWwgPSBkaXZTdHlsZS50b3AgIT09IFwiMSVcIjtcblxuXHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIC0gNC4zIG9ubHksIEZpcmVmb3ggPD0zIC0gNDRcblx0XHRyZWxpYWJsZU1hcmdpbkxlZnRWYWwgPSBkaXZTdHlsZS5tYXJnaW5MZWZ0ID09PSBcIjJweFwiO1xuXHRcdGJveFNpemluZ1JlbGlhYmxlVmFsID0gZGl2U3R5bGUud2lkdGggPT09IFwiNHB4XCI7XG5cblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCAtIDQuMyBvbmx5XG5cdFx0Ly8gU29tZSBzdHlsZXMgY29tZSBiYWNrIHdpdGggcGVyY2VudGFnZSB2YWx1ZXMsIGV2ZW4gdGhvdWdoIHRoZXkgc2hvdWxkbid0XG5cdFx0ZGl2LnN0eWxlLm1hcmdpblJpZ2h0ID0gXCI1MCVcIjtcblx0XHRwaXhlbE1hcmdpblJpZ2h0VmFsID0gZGl2U3R5bGUubWFyZ2luUmlnaHQgPT09IFwiNHB4XCI7XG5cblx0XHRkb2N1bWVudEVsZW1lbnQucmVtb3ZlQ2hpbGQoIGNvbnRhaW5lciApO1xuXG5cdFx0Ly8gTnVsbGlmeSB0aGUgZGl2IHNvIGl0IHdvdWxkbid0IGJlIHN0b3JlZCBpbiB0aGUgbWVtb3J5IGFuZFxuXHRcdC8vIGl0IHdpbGwgYWxzbyBiZSBhIHNpZ24gdGhhdCBjaGVja3MgYWxyZWFkeSBwZXJmb3JtZWRcblx0XHRkaXYgPSBudWxsO1xuXHR9XG5cblx0dmFyIHBpeGVsUG9zaXRpb25WYWwsIGJveFNpemluZ1JlbGlhYmxlVmFsLCBwaXhlbE1hcmdpblJpZ2h0VmFsLCByZWxpYWJsZU1hcmdpbkxlZnRWYWwsXG5cdFx0Y29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApLFxuXHRcdGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKTtcblxuXHQvLyBGaW5pc2ggZWFybHkgaW4gbGltaXRlZCAobm9uLWJyb3dzZXIpIGVudmlyb25tZW50c1xuXHRpZiAoICFkaXYuc3R5bGUgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxuXHQvLyBTdHlsZSBvZiBjbG9uZWQgZWxlbWVudCBhZmZlY3RzIHNvdXJjZSBlbGVtZW50IGNsb25lZCAoIzg5MDgpXG5cdGRpdi5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9IFwiY29udGVudC1ib3hcIjtcblx0ZGl2LmNsb25lTm9kZSggdHJ1ZSApLnN0eWxlLmJhY2tncm91bmRDbGlwID0gXCJcIjtcblx0c3VwcG9ydC5jbGVhckNsb25lU3R5bGUgPSBkaXYuc3R5bGUuYmFja2dyb3VuZENsaXAgPT09IFwiY29udGVudC1ib3hcIjtcblxuXHRjb250YWluZXIuc3R5bGUuY3NzVGV4dCA9IFwiYm9yZGVyOjA7d2lkdGg6OHB4O2hlaWdodDowO3RvcDowO2xlZnQ6LTk5OTlweDtcIiArXG5cdFx0XCJwYWRkaW5nOjA7bWFyZ2luLXRvcDoxcHg7cG9zaXRpb246YWJzb2x1dGVcIjtcblx0Y29udGFpbmVyLmFwcGVuZENoaWxkKCBkaXYgKTtcblxuXHRqUXVlcnkuZXh0ZW5kKCBzdXBwb3J0LCB7XG5cdFx0cGl4ZWxQb3NpdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0cmV0dXJuIHBpeGVsUG9zaXRpb25WYWw7XG5cdFx0fSxcblx0XHRib3hTaXppbmdSZWxpYWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0cmV0dXJuIGJveFNpemluZ1JlbGlhYmxlVmFsO1xuXHRcdH0sXG5cdFx0cGl4ZWxNYXJnaW5SaWdodDogZnVuY3Rpb24oKSB7XG5cdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0cmV0dXJuIHBpeGVsTWFyZ2luUmlnaHRWYWw7XG5cdFx0fSxcblx0XHRyZWxpYWJsZU1hcmdpbkxlZnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiByZWxpYWJsZU1hcmdpbkxlZnRWYWw7XG5cdFx0fVxuXHR9ICk7XG59ICkoKTtcblxuXG5mdW5jdGlvbiBjdXJDU1MoIGVsZW0sIG5hbWUsIGNvbXB1dGVkICkge1xuXHR2YXIgd2lkdGgsIG1pbldpZHRoLCBtYXhXaWR0aCwgcmV0LFxuXHRcdHN0eWxlID0gZWxlbS5zdHlsZTtcblxuXHRjb21wdXRlZCA9IGNvbXB1dGVkIHx8IGdldFN0eWxlcyggZWxlbSApO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdC8vIGdldFByb3BlcnR5VmFsdWUgaXMgb25seSBuZWVkZWQgZm9yIC5jc3MoJ2ZpbHRlcicpICgjMTI1MzcpXG5cdGlmICggY29tcHV0ZWQgKSB7XG5cdFx0cmV0ID0gY29tcHV0ZWQuZ2V0UHJvcGVydHlWYWx1ZSggbmFtZSApIHx8IGNvbXB1dGVkWyBuYW1lIF07XG5cblx0XHRpZiAoIHJldCA9PT0gXCJcIiAmJiAhalF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKSApIHtcblx0XHRcdHJldCA9IGpRdWVyeS5zdHlsZSggZWxlbSwgbmFtZSApO1xuXHRcdH1cblxuXHRcdC8vIEEgdHJpYnV0ZSB0byB0aGUgXCJhd2Vzb21lIGhhY2sgYnkgRGVhbiBFZHdhcmRzXCJcblx0XHQvLyBBbmRyb2lkIEJyb3dzZXIgcmV0dXJucyBwZXJjZW50YWdlIGZvciBzb21lIHZhbHVlcyxcblx0XHQvLyBidXQgd2lkdGggc2VlbXMgdG8gYmUgcmVsaWFibHkgcGl4ZWxzLlxuXHRcdC8vIFRoaXMgaXMgYWdhaW5zdCB0aGUgQ1NTT00gZHJhZnQgc3BlYzpcblx0XHQvLyBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3Nzb20vI3Jlc29sdmVkLXZhbHVlc1xuXHRcdGlmICggIXN1cHBvcnQucGl4ZWxNYXJnaW5SaWdodCgpICYmIHJudW1ub25weC50ZXN0KCByZXQgKSAmJiBybWFyZ2luLnRlc3QoIG5hbWUgKSApIHtcblxuXHRcdFx0Ly8gUmVtZW1iZXIgdGhlIG9yaWdpbmFsIHZhbHVlc1xuXHRcdFx0d2lkdGggPSBzdHlsZS53aWR0aDtcblx0XHRcdG1pbldpZHRoID0gc3R5bGUubWluV2lkdGg7XG5cdFx0XHRtYXhXaWR0aCA9IHN0eWxlLm1heFdpZHRoO1xuXG5cdFx0XHQvLyBQdXQgaW4gdGhlIG5ldyB2YWx1ZXMgdG8gZ2V0IGEgY29tcHV0ZWQgdmFsdWUgb3V0XG5cdFx0XHRzdHlsZS5taW5XaWR0aCA9IHN0eWxlLm1heFdpZHRoID0gc3R5bGUud2lkdGggPSByZXQ7XG5cdFx0XHRyZXQgPSBjb21wdXRlZC53aWR0aDtcblxuXHRcdFx0Ly8gUmV2ZXJ0IHRoZSBjaGFuZ2VkIHZhbHVlc1xuXHRcdFx0c3R5bGUud2lkdGggPSB3aWR0aDtcblx0XHRcdHN0eWxlLm1pbldpZHRoID0gbWluV2lkdGg7XG5cdFx0XHRzdHlsZS5tYXhXaWR0aCA9IG1heFdpZHRoO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiByZXQgIT09IHVuZGVmaW5lZCA/XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG5cdFx0Ly8gSUUgcmV0dXJucyB6SW5kZXggdmFsdWUgYXMgYW4gaW50ZWdlci5cblx0XHRyZXQgKyBcIlwiIDpcblx0XHRyZXQ7XG59XG5cblxuZnVuY3Rpb24gYWRkR2V0SG9va0lmKCBjb25kaXRpb25GbiwgaG9va0ZuICkge1xuXG5cdC8vIERlZmluZSB0aGUgaG9vaywgd2UnbGwgY2hlY2sgb24gdGhlIGZpcnN0IHJ1biBpZiBpdCdzIHJlYWxseSBuZWVkZWQuXG5cdHJldHVybiB7XG5cdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggY29uZGl0aW9uRm4oKSApIHtcblxuXHRcdFx0XHQvLyBIb29rIG5vdCBuZWVkZWQgKG9yIGl0J3Mgbm90IHBvc3NpYmxlIHRvIHVzZSBpdCBkdWVcblx0XHRcdFx0Ly8gdG8gbWlzc2luZyBkZXBlbmRlbmN5KSwgcmVtb3ZlIGl0LlxuXHRcdFx0XHRkZWxldGUgdGhpcy5nZXQ7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSG9vayBuZWVkZWQ7IHJlZGVmaW5lIGl0IHNvIHRoYXQgdGhlIHN1cHBvcnQgdGVzdCBpcyBub3QgZXhlY3V0ZWQgYWdhaW4uXG5cdFx0XHRyZXR1cm4gKCB0aGlzLmdldCA9IGhvb2tGbiApLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHR9XG5cdH07XG59XG5cblxudmFyXG5cblx0Ly8gU3dhcHBhYmxlIGlmIGRpc3BsYXkgaXMgbm9uZSBvciBzdGFydHMgd2l0aCB0YWJsZVxuXHQvLyBleGNlcHQgXCJ0YWJsZVwiLCBcInRhYmxlLWNlbGxcIiwgb3IgXCJ0YWJsZS1jYXB0aW9uXCJcblx0Ly8gU2VlIGhlcmUgZm9yIGRpc3BsYXkgdmFsdWVzOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0NTUy9kaXNwbGF5XG5cdHJkaXNwbGF5c3dhcCA9IC9eKG5vbmV8dGFibGUoPyEtY1tlYV0pLispLyxcblx0Y3NzU2hvdyA9IHsgcG9zaXRpb246IFwiYWJzb2x1dGVcIiwgdmlzaWJpbGl0eTogXCJoaWRkZW5cIiwgZGlzcGxheTogXCJibG9ja1wiIH0sXG5cdGNzc05vcm1hbFRyYW5zZm9ybSA9IHtcblx0XHRsZXR0ZXJTcGFjaW5nOiBcIjBcIixcblx0XHRmb250V2VpZ2h0OiBcIjQwMFwiXG5cdH0sXG5cblx0Y3NzUHJlZml4ZXMgPSBbIFwiV2Via2l0XCIsIFwiTW96XCIsIFwibXNcIiBdLFxuXHRlbXB0eVN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApLnN0eWxlO1xuXG4vLyBSZXR1cm4gYSBjc3MgcHJvcGVydHkgbWFwcGVkIHRvIGEgcG90ZW50aWFsbHkgdmVuZG9yIHByZWZpeGVkIHByb3BlcnR5XG5mdW5jdGlvbiB2ZW5kb3JQcm9wTmFtZSggbmFtZSApIHtcblxuXHQvLyBTaG9ydGN1dCBmb3IgbmFtZXMgdGhhdCBhcmUgbm90IHZlbmRvciBwcmVmaXhlZFxuXHRpZiAoIG5hbWUgaW4gZW1wdHlTdHlsZSApIHtcblx0XHRyZXR1cm4gbmFtZTtcblx0fVxuXG5cdC8vIENoZWNrIGZvciB2ZW5kb3IgcHJlZml4ZWQgbmFtZXNcblx0dmFyIGNhcE5hbWUgPSBuYW1lWyAwIF0udG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoIDEgKSxcblx0XHRpID0gY3NzUHJlZml4ZXMubGVuZ3RoO1xuXG5cdHdoaWxlICggaS0tICkge1xuXHRcdG5hbWUgPSBjc3NQcmVmaXhlc1sgaSBdICsgY2FwTmFtZTtcblx0XHRpZiAoIG5hbWUgaW4gZW1wdHlTdHlsZSApIHtcblx0XHRcdHJldHVybiBuYW1lO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBzZXRQb3NpdGl2ZU51bWJlciggZWxlbSwgdmFsdWUsIHN1YnRyYWN0ICkge1xuXG5cdC8vIEFueSByZWxhdGl2ZSAoKy8tKSB2YWx1ZXMgaGF2ZSBhbHJlYWR5IGJlZW5cblx0Ly8gbm9ybWFsaXplZCBhdCB0aGlzIHBvaW50XG5cdHZhciBtYXRjaGVzID0gcmNzc051bS5leGVjKCB2YWx1ZSApO1xuXHRyZXR1cm4gbWF0Y2hlcyA/XG5cblx0XHQvLyBHdWFyZCBhZ2FpbnN0IHVuZGVmaW5lZCBcInN1YnRyYWN0XCIsIGUuZy4sIHdoZW4gdXNlZCBhcyBpbiBjc3NIb29rc1xuXHRcdE1hdGgubWF4KCAwLCBtYXRjaGVzWyAyIF0gLSAoIHN1YnRyYWN0IHx8IDAgKSApICsgKCBtYXRjaGVzWyAzIF0gfHwgXCJweFwiICkgOlxuXHRcdHZhbHVlO1xufVxuXG5mdW5jdGlvbiBhdWdtZW50V2lkdGhPckhlaWdodCggZWxlbSwgbmFtZSwgZXh0cmEsIGlzQm9yZGVyQm94LCBzdHlsZXMgKSB7XG5cdHZhciBpLFxuXHRcdHZhbCA9IDA7XG5cblx0Ly8gSWYgd2UgYWxyZWFkeSBoYXZlIHRoZSByaWdodCBtZWFzdXJlbWVudCwgYXZvaWQgYXVnbWVudGF0aW9uXG5cdGlmICggZXh0cmEgPT09ICggaXNCb3JkZXJCb3ggPyBcImJvcmRlclwiIDogXCJjb250ZW50XCIgKSApIHtcblx0XHRpID0gNDtcblxuXHQvLyBPdGhlcndpc2UgaW5pdGlhbGl6ZSBmb3IgaG9yaXpvbnRhbCBvciB2ZXJ0aWNhbCBwcm9wZXJ0aWVzXG5cdH0gZWxzZSB7XG5cdFx0aSA9IG5hbWUgPT09IFwid2lkdGhcIiA/IDEgOiAwO1xuXHR9XG5cblx0Zm9yICggOyBpIDwgNDsgaSArPSAyICkge1xuXG5cdFx0Ly8gQm90aCBib3ggbW9kZWxzIGV4Y2x1ZGUgbWFyZ2luLCBzbyBhZGQgaXQgaWYgd2Ugd2FudCBpdFxuXHRcdGlmICggZXh0cmEgPT09IFwibWFyZ2luXCIgKSB7XG5cdFx0XHR2YWwgKz0galF1ZXJ5LmNzcyggZWxlbSwgZXh0cmEgKyBjc3NFeHBhbmRbIGkgXSwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBpc0JvcmRlckJveCApIHtcblxuXHRcdFx0Ly8gYm9yZGVyLWJveCBpbmNsdWRlcyBwYWRkaW5nLCBzbyByZW1vdmUgaXQgaWYgd2Ugd2FudCBjb250ZW50XG5cdFx0XHRpZiAoIGV4dHJhID09PSBcImNvbnRlbnRcIiApIHtcblx0XHRcdFx0dmFsIC09IGpRdWVyeS5jc3MoIGVsZW0sIFwicGFkZGluZ1wiICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBdCB0aGlzIHBvaW50LCBleHRyYSBpc24ndCBib3JkZXIgbm9yIG1hcmdpbiwgc28gcmVtb3ZlIGJvcmRlclxuXHRcdFx0aWYgKCBleHRyYSAhPT0gXCJtYXJnaW5cIiApIHtcblx0XHRcdFx0dmFsIC09IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm9yZGVyXCIgKyBjc3NFeHBhbmRbIGkgXSArIFwiV2lkdGhcIiwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gQXQgdGhpcyBwb2ludCwgZXh0cmEgaXNuJ3QgY29udGVudCwgc28gYWRkIHBhZGRpbmdcblx0XHRcdHZhbCArPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBhZGRpbmdcIiArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblxuXHRcdFx0Ly8gQXQgdGhpcyBwb2ludCwgZXh0cmEgaXNuJ3QgY29udGVudCBub3IgcGFkZGluZywgc28gYWRkIGJvcmRlclxuXHRcdFx0aWYgKCBleHRyYSAhPT0gXCJwYWRkaW5nXCIgKSB7XG5cdFx0XHRcdHZhbCArPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJvcmRlclwiICsgY3NzRXhwYW5kWyBpIF0gKyBcIldpZHRoXCIsIHRydWUsIHN0eWxlcyApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB2YWw7XG59XG5cbmZ1bmN0aW9uIGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIG5hbWUsIGV4dHJhICkge1xuXG5cdC8vIFN0YXJ0IHdpdGggb2Zmc2V0IHByb3BlcnR5LCB3aGljaCBpcyBlcXVpdmFsZW50IHRvIHRoZSBib3JkZXItYm94IHZhbHVlXG5cdHZhciB2YWwsXG5cdFx0dmFsdWVJc0JvcmRlckJveCA9IHRydWUsXG5cdFx0c3R5bGVzID0gZ2V0U3R5bGVzKCBlbGVtICksXG5cdFx0aXNCb3JkZXJCb3ggPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJveFNpemluZ1wiLCBmYWxzZSwgc3R5bGVzICkgPT09IFwiYm9yZGVyLWJveFwiO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHQvLyBSdW5uaW5nIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBvbiBhIGRpc2Nvbm5lY3RlZCBub2RlXG5cdC8vIGluIElFIHRocm93cyBhbiBlcnJvci5cblx0aWYgKCBlbGVtLmdldENsaWVudFJlY3RzKCkubGVuZ3RoICkge1xuXHRcdHZhbCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClbIG5hbWUgXTtcblx0fVxuXG5cdC8vIFNvbWUgbm9uLWh0bWwgZWxlbWVudHMgcmV0dXJuIHVuZGVmaW5lZCBmb3Igb2Zmc2V0V2lkdGgsIHNvIGNoZWNrIGZvciBudWxsL3VuZGVmaW5lZFxuXHQvLyBzdmcgLSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02NDkyODVcblx0Ly8gTWF0aE1MIC0gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NDkxNjY4XG5cdGlmICggdmFsIDw9IDAgfHwgdmFsID09IG51bGwgKSB7XG5cblx0XHQvLyBGYWxsIGJhY2sgdG8gY29tcHV0ZWQgdGhlbiB1bmNvbXB1dGVkIGNzcyBpZiBuZWNlc3Nhcnlcblx0XHR2YWwgPSBjdXJDU1MoIGVsZW0sIG5hbWUsIHN0eWxlcyApO1xuXHRcdGlmICggdmFsIDwgMCB8fCB2YWwgPT0gbnVsbCApIHtcblx0XHRcdHZhbCA9IGVsZW0uc3R5bGVbIG5hbWUgXTtcblx0XHR9XG5cblx0XHQvLyBDb21wdXRlZCB1bml0IGlzIG5vdCBwaXhlbHMuIFN0b3AgaGVyZSBhbmQgcmV0dXJuLlxuXHRcdGlmICggcm51bW5vbnB4LnRlc3QoIHZhbCApICkge1xuXHRcdFx0cmV0dXJuIHZhbDtcblx0XHR9XG5cblx0XHQvLyBDaGVjayBmb3Igc3R5bGUgaW4gY2FzZSBhIGJyb3dzZXIgd2hpY2ggcmV0dXJucyB1bnJlbGlhYmxlIHZhbHVlc1xuXHRcdC8vIGZvciBnZXRDb21wdXRlZFN0eWxlIHNpbGVudGx5IGZhbGxzIGJhY2sgdG8gdGhlIHJlbGlhYmxlIGVsZW0uc3R5bGVcblx0XHR2YWx1ZUlzQm9yZGVyQm94ID0gaXNCb3JkZXJCb3ggJiZcblx0XHRcdCggc3VwcG9ydC5ib3hTaXppbmdSZWxpYWJsZSgpIHx8IHZhbCA9PT0gZWxlbS5zdHlsZVsgbmFtZSBdICk7XG5cblx0XHQvLyBOb3JtYWxpemUgXCJcIiwgYXV0bywgYW5kIHByZXBhcmUgZm9yIGV4dHJhXG5cdFx0dmFsID0gcGFyc2VGbG9hdCggdmFsICkgfHwgMDtcblx0fVxuXG5cdC8vIFVzZSB0aGUgYWN0aXZlIGJveC1zaXppbmcgbW9kZWwgdG8gYWRkL3N1YnRyYWN0IGlycmVsZXZhbnQgc3R5bGVzXG5cdHJldHVybiAoIHZhbCArXG5cdFx0YXVnbWVudFdpZHRoT3JIZWlnaHQoXG5cdFx0XHRlbGVtLFxuXHRcdFx0bmFtZSxcblx0XHRcdGV4dHJhIHx8ICggaXNCb3JkZXJCb3ggPyBcImJvcmRlclwiIDogXCJjb250ZW50XCIgKSxcblx0XHRcdHZhbHVlSXNCb3JkZXJCb3gsXG5cdFx0XHRzdHlsZXNcblx0XHQpXG5cdCkgKyBcInB4XCI7XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHQvLyBBZGQgaW4gc3R5bGUgcHJvcGVydHkgaG9va3MgZm9yIG92ZXJyaWRpbmcgdGhlIGRlZmF1bHRcblx0Ly8gYmVoYXZpb3Igb2YgZ2V0dGluZyBhbmQgc2V0dGluZyBhIHN0eWxlIHByb3BlcnR5XG5cdGNzc0hvb2tzOiB7XG5cdFx0b3BhY2l0eToge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG5cdFx0XHRcdGlmICggY29tcHV0ZWQgKSB7XG5cblx0XHRcdFx0XHQvLyBXZSBzaG91bGQgYWx3YXlzIGdldCBhIG51bWJlciBiYWNrIGZyb20gb3BhY2l0eVxuXHRcdFx0XHRcdHZhciByZXQgPSBjdXJDU1MoIGVsZW0sIFwib3BhY2l0eVwiICk7XG5cdFx0XHRcdFx0cmV0dXJuIHJldCA9PT0gXCJcIiA/IFwiMVwiIDogcmV0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8vIERvbid0IGF1dG9tYXRpY2FsbHkgYWRkIFwicHhcIiB0byB0aGVzZSBwb3NzaWJseS11bml0bGVzcyBwcm9wZXJ0aWVzXG5cdGNzc051bWJlcjoge1xuXHRcdFwiYW5pbWF0aW9uSXRlcmF0aW9uQ291bnRcIjogdHJ1ZSxcblx0XHRcImNvbHVtbkNvdW50XCI6IHRydWUsXG5cdFx0XCJmaWxsT3BhY2l0eVwiOiB0cnVlLFxuXHRcdFwiZmxleEdyb3dcIjogdHJ1ZSxcblx0XHRcImZsZXhTaHJpbmtcIjogdHJ1ZSxcblx0XHRcImZvbnRXZWlnaHRcIjogdHJ1ZSxcblx0XHRcImxpbmVIZWlnaHRcIjogdHJ1ZSxcblx0XHRcIm9wYWNpdHlcIjogdHJ1ZSxcblx0XHRcIm9yZGVyXCI6IHRydWUsXG5cdFx0XCJvcnBoYW5zXCI6IHRydWUsXG5cdFx0XCJ3aWRvd3NcIjogdHJ1ZSxcblx0XHRcInpJbmRleFwiOiB0cnVlLFxuXHRcdFwiem9vbVwiOiB0cnVlXG5cdH0sXG5cblx0Ly8gQWRkIGluIHByb3BlcnRpZXMgd2hvc2UgbmFtZXMgeW91IHdpc2ggdG8gZml4IGJlZm9yZVxuXHQvLyBzZXR0aW5nIG9yIGdldHRpbmcgdGhlIHZhbHVlXG5cdGNzc1Byb3BzOiB7XG5cdFx0XCJmbG9hdFwiOiBcImNzc0Zsb2F0XCJcblx0fSxcblxuXHQvLyBHZXQgYW5kIHNldCB0aGUgc3R5bGUgcHJvcGVydHkgb24gYSBET00gTm9kZVxuXHRzdHlsZTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlLCBleHRyYSApIHtcblxuXHRcdC8vIERvbid0IHNldCBzdHlsZXMgb24gdGV4dCBhbmQgY29tbWVudCBub2Rlc1xuXHRcdGlmICggIWVsZW0gfHwgZWxlbS5ub2RlVHlwZSA9PT0gMyB8fCBlbGVtLm5vZGVUeXBlID09PSA4IHx8ICFlbGVtLnN0eWxlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZVxuXHRcdHZhciByZXQsIHR5cGUsIGhvb2tzLFxuXHRcdFx0b3JpZ05hbWUgPSBqUXVlcnkuY2FtZWxDYXNlKCBuYW1lICksXG5cdFx0XHRzdHlsZSA9IGVsZW0uc3R5bGU7XG5cblx0XHRuYW1lID0galF1ZXJ5LmNzc1Byb3BzWyBvcmlnTmFtZSBdIHx8XG5cdFx0XHQoIGpRdWVyeS5jc3NQcm9wc1sgb3JpZ05hbWUgXSA9IHZlbmRvclByb3BOYW1lKCBvcmlnTmFtZSApIHx8IG9yaWdOYW1lICk7XG5cblx0XHQvLyBHZXRzIGhvb2sgZm9yIHRoZSBwcmVmaXhlZCB2ZXJzaW9uLCB0aGVuIHVucHJlZml4ZWQgdmVyc2lvblxuXHRcdGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF0gfHwgalF1ZXJ5LmNzc0hvb2tzWyBvcmlnTmFtZSBdO1xuXG5cdFx0Ly8gQ2hlY2sgaWYgd2UncmUgc2V0dGluZyBhIHZhbHVlXG5cdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dHlwZSA9IHR5cGVvZiB2YWx1ZTtcblxuXHRcdFx0Ly8gQ29udmVydCBcIis9XCIgb3IgXCItPVwiIHRvIHJlbGF0aXZlIG51bWJlcnMgKCM3MzQ1KVxuXHRcdFx0aWYgKCB0eXBlID09PSBcInN0cmluZ1wiICYmICggcmV0ID0gcmNzc051bS5leGVjKCB2YWx1ZSApICkgJiYgcmV0WyAxIF0gKSB7XG5cdFx0XHRcdHZhbHVlID0gYWRqdXN0Q1NTKCBlbGVtLCBuYW1lLCByZXQgKTtcblxuXHRcdFx0XHQvLyBGaXhlcyBidWcgIzkyMzdcblx0XHRcdFx0dHlwZSA9IFwibnVtYmVyXCI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE1ha2Ugc3VyZSB0aGF0IG51bGwgYW5kIE5hTiB2YWx1ZXMgYXJlbid0IHNldCAoIzcxMTYpXG5cdFx0XHRpZiAoIHZhbHVlID09IG51bGwgfHwgdmFsdWUgIT09IHZhbHVlICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIGEgbnVtYmVyIHdhcyBwYXNzZWQgaW4sIGFkZCB0aGUgdW5pdCAoZXhjZXB0IGZvciBjZXJ0YWluIENTUyBwcm9wZXJ0aWVzKVxuXHRcdFx0aWYgKCB0eXBlID09PSBcIm51bWJlclwiICkge1xuXHRcdFx0XHR2YWx1ZSArPSByZXQgJiYgcmV0WyAzIF0gfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBvcmlnTmFtZSBdID8gXCJcIiA6IFwicHhcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBiYWNrZ3JvdW5kLSogcHJvcHMgYWZmZWN0IG9yaWdpbmFsIGNsb25lJ3MgdmFsdWVzXG5cdFx0XHRpZiAoICFzdXBwb3J0LmNsZWFyQ2xvbmVTdHlsZSAmJiB2YWx1ZSA9PT0gXCJcIiAmJiBuYW1lLmluZGV4T2YoIFwiYmFja2dyb3VuZFwiICkgPT09IDAgKSB7XG5cdFx0XHRcdHN0eWxlWyBuYW1lIF0gPSBcImluaGVyaXRcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCwgdXNlIHRoYXQgdmFsdWUsIG90aGVyd2lzZSBqdXN0IHNldCB0aGUgc3BlY2lmaWVkIHZhbHVlXG5cdFx0XHRpZiAoICFob29rcyB8fCAhKCBcInNldFwiIGluIGhvb2tzICkgfHxcblx0XHRcdFx0KCB2YWx1ZSA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIGV4dHJhICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHN0eWxlWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQgZ2V0IHRoZSBub24tY29tcHV0ZWQgdmFsdWUgZnJvbSB0aGVyZVxuXHRcdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdCggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBmYWxzZSwgZXh0cmEgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIGp1c3QgZ2V0IHRoZSB2YWx1ZSBmcm9tIHRoZSBzdHlsZSBvYmplY3Rcblx0XHRcdHJldHVybiBzdHlsZVsgbmFtZSBdO1xuXHRcdH1cblx0fSxcblxuXHRjc3M6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBleHRyYSwgc3R5bGVzICkge1xuXHRcdHZhciB2YWwsIG51bSwgaG9va3MsXG5cdFx0XHRvcmlnTmFtZSA9IGpRdWVyeS5jYW1lbENhc2UoIG5hbWUgKTtcblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZVxuXHRcdG5hbWUgPSBqUXVlcnkuY3NzUHJvcHNbIG9yaWdOYW1lIF0gfHxcblx0XHRcdCggalF1ZXJ5LmNzc1Byb3BzWyBvcmlnTmFtZSBdID0gdmVuZG9yUHJvcE5hbWUoIG9yaWdOYW1lICkgfHwgb3JpZ05hbWUgKTtcblxuXHRcdC8vIFRyeSBwcmVmaXhlZCBuYW1lIGZvbGxvd2VkIGJ5IHRoZSB1bnByZWZpeGVkIG5hbWVcblx0XHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdIHx8IGpRdWVyeS5jc3NIb29rc1sgb3JpZ05hbWUgXTtcblxuXHRcdC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQgZ2V0IHRoZSBjb21wdXRlZCB2YWx1ZSBmcm9tIHRoZXJlXG5cdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICkge1xuXHRcdFx0dmFsID0gaG9va3MuZ2V0KCBlbGVtLCB0cnVlLCBleHRyYSApO1xuXHRcdH1cblxuXHRcdC8vIE90aGVyd2lzZSwgaWYgYSB3YXkgdG8gZ2V0IHRoZSBjb21wdXRlZCB2YWx1ZSBleGlzdHMsIHVzZSB0aGF0XG5cdFx0aWYgKCB2YWwgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHZhbCA9IGN1ckNTUyggZWxlbSwgbmFtZSwgc3R5bGVzICk7XG5cdFx0fVxuXG5cdFx0Ly8gQ29udmVydCBcIm5vcm1hbFwiIHRvIGNvbXB1dGVkIHZhbHVlXG5cdFx0aWYgKCB2YWwgPT09IFwibm9ybWFsXCIgJiYgbmFtZSBpbiBjc3NOb3JtYWxUcmFuc2Zvcm0gKSB7XG5cdFx0XHR2YWwgPSBjc3NOb3JtYWxUcmFuc2Zvcm1bIG5hbWUgXTtcblx0XHR9XG5cblx0XHQvLyBNYWtlIG51bWVyaWMgaWYgZm9yY2VkIG9yIGEgcXVhbGlmaWVyIHdhcyBwcm92aWRlZCBhbmQgdmFsIGxvb2tzIG51bWVyaWNcblx0XHRpZiAoIGV4dHJhID09PSBcIlwiIHx8IGV4dHJhICkge1xuXHRcdFx0bnVtID0gcGFyc2VGbG9hdCggdmFsICk7XG5cdFx0XHRyZXR1cm4gZXh0cmEgPT09IHRydWUgfHwgaXNGaW5pdGUoIG51bSApID8gbnVtIHx8IDAgOiB2YWw7XG5cdFx0fVxuXHRcdHJldHVybiB2YWw7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goIFsgXCJoZWlnaHRcIiwgXCJ3aWR0aFwiIF0sIGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSA9IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCwgZXh0cmEgKSB7XG5cdFx0XHRpZiAoIGNvbXB1dGVkICkge1xuXG5cdFx0XHRcdC8vIENlcnRhaW4gZWxlbWVudHMgY2FuIGhhdmUgZGltZW5zaW9uIGluZm8gaWYgd2UgaW52aXNpYmx5IHNob3cgdGhlbVxuXHRcdFx0XHQvLyBidXQgaXQgbXVzdCBoYXZlIGEgY3VycmVudCBkaXNwbGF5IHN0eWxlIHRoYXQgd291bGQgYmVuZWZpdFxuXHRcdFx0XHRyZXR1cm4gcmRpc3BsYXlzd2FwLnRlc3QoIGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICkgKSAmJlxuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogU2FmYXJpIDgrXG5cdFx0XHRcdFx0Ly8gVGFibGUgY29sdW1ucyBpbiBTYWZhcmkgaGF2ZSBub24temVybyBvZmZzZXRXaWR0aCAmIHplcm9cblx0XHRcdFx0XHQvLyBnZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCB1bmxlc3MgZGlzcGxheSBpcyBjaGFuZ2VkLlxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHRcdFx0XHRcdC8vIFJ1bm5pbmcgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IG9uIGEgZGlzY29ubmVjdGVkIG5vZGVcblx0XHRcdFx0XHQvLyBpbiBJRSB0aHJvd3MgYW4gZXJyb3IuXG5cdFx0XHRcdFx0KCAhZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCB8fCAhZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCApID9cblx0XHRcdFx0XHRcdHN3YXAoIGVsZW0sIGNzc1Nob3csIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gZ2V0V2lkdGhPckhlaWdodCggZWxlbSwgbmFtZSwgZXh0cmEgKTtcblx0XHRcdFx0XHRcdH0gKSA6XG5cdFx0XHRcdFx0XHRnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBuYW1lLCBleHRyYSApO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSwgZXh0cmEgKSB7XG5cdFx0XHR2YXIgbWF0Y2hlcyxcblx0XHRcdFx0c3R5bGVzID0gZXh0cmEgJiYgZ2V0U3R5bGVzKCBlbGVtICksXG5cdFx0XHRcdHN1YnRyYWN0ID0gZXh0cmEgJiYgYXVnbWVudFdpZHRoT3JIZWlnaHQoXG5cdFx0XHRcdFx0ZWxlbSxcblx0XHRcdFx0XHRuYW1lLFxuXHRcdFx0XHRcdGV4dHJhLFxuXHRcdFx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIFwiYm94U2l6aW5nXCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXCJib3JkZXItYm94XCIsXG5cdFx0XHRcdFx0c3R5bGVzXG5cdFx0XHRcdCk7XG5cblx0XHRcdC8vIENvbnZlcnQgdG8gcGl4ZWxzIGlmIHZhbHVlIGFkanVzdG1lbnQgaXMgbmVlZGVkXG5cdFx0XHRpZiAoIHN1YnRyYWN0ICYmICggbWF0Y2hlcyA9IHJjc3NOdW0uZXhlYyggdmFsdWUgKSApICYmXG5cdFx0XHRcdCggbWF0Y2hlc1sgMyBdIHx8IFwicHhcIiApICE9PSBcInB4XCIgKSB7XG5cblx0XHRcdFx0ZWxlbS5zdHlsZVsgbmFtZSBdID0gdmFsdWU7XG5cdFx0XHRcdHZhbHVlID0galF1ZXJ5LmNzcyggZWxlbSwgbmFtZSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gc2V0UG9zaXRpdmVOdW1iZXIoIGVsZW0sIHZhbHVlLCBzdWJ0cmFjdCApO1xuXHRcdH1cblx0fTtcbn0gKTtcblxualF1ZXJ5LmNzc0hvb2tzLm1hcmdpbkxlZnQgPSBhZGRHZXRIb29rSWYoIHN1cHBvcnQucmVsaWFibGVNYXJnaW5MZWZ0LFxuXHRmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG5cdFx0aWYgKCBjb21wdXRlZCApIHtcblx0XHRcdHJldHVybiAoIHBhcnNlRmxvYXQoIGN1ckNTUyggZWxlbSwgXCJtYXJnaW5MZWZ0XCIgKSApIHx8XG5cdFx0XHRcdGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCAtXG5cdFx0XHRcdFx0c3dhcCggZWxlbSwgeyBtYXJnaW5MZWZ0OiAwIH0sIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdDtcblx0XHRcdFx0XHR9IClcblx0XHRcdFx0KSArIFwicHhcIjtcblx0XHR9XG5cdH1cbik7XG5cbi8vIFRoZXNlIGhvb2tzIGFyZSB1c2VkIGJ5IGFuaW1hdGUgdG8gZXhwYW5kIHByb3BlcnRpZXNcbmpRdWVyeS5lYWNoKCB7XG5cdG1hcmdpbjogXCJcIixcblx0cGFkZGluZzogXCJcIixcblx0Ym9yZGVyOiBcIldpZHRoXCJcbn0sIGZ1bmN0aW9uKCBwcmVmaXgsIHN1ZmZpeCApIHtcblx0alF1ZXJ5LmNzc0hvb2tzWyBwcmVmaXggKyBzdWZmaXggXSA9IHtcblx0XHRleHBhbmQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHZhciBpID0gMCxcblx0XHRcdFx0ZXhwYW5kZWQgPSB7fSxcblxuXHRcdFx0XHQvLyBBc3N1bWVzIGEgc2luZ2xlIG51bWJlciBpZiBub3QgYSBzdHJpbmdcblx0XHRcdFx0cGFydHMgPSB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgPyB2YWx1ZS5zcGxpdCggXCIgXCIgKSA6IFsgdmFsdWUgXTtcblxuXHRcdFx0Zm9yICggOyBpIDwgNDsgaSsrICkge1xuXHRcdFx0XHRleHBhbmRlZFsgcHJlZml4ICsgY3NzRXhwYW5kWyBpIF0gKyBzdWZmaXggXSA9XG5cdFx0XHRcdFx0cGFydHNbIGkgXSB8fCBwYXJ0c1sgaSAtIDIgXSB8fCBwYXJ0c1sgMCBdO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZXhwYW5kZWQ7XG5cdFx0fVxuXHR9O1xuXG5cdGlmICggIXJtYXJnaW4udGVzdCggcHJlZml4ICkgKSB7XG5cdFx0alF1ZXJ5LmNzc0hvb2tzWyBwcmVmaXggKyBzdWZmaXggXS5zZXQgPSBzZXRQb3NpdGl2ZU51bWJlcjtcblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGNzczogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcblx0XHRcdHZhciBzdHlsZXMsIGxlbixcblx0XHRcdFx0bWFwID0ge30sXG5cdFx0XHRcdGkgPSAwO1xuXG5cdFx0XHRpZiAoIGpRdWVyeS5pc0FycmF5KCBuYW1lICkgKSB7XG5cdFx0XHRcdHN0eWxlcyA9IGdldFN0eWxlcyggZWxlbSApO1xuXHRcdFx0XHRsZW4gPSBuYW1lLmxlbmd0aDtcblxuXHRcdFx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0XHRtYXBbIG5hbWVbIGkgXSBdID0galF1ZXJ5LmNzcyggZWxlbSwgbmFtZVsgaSBdLCBmYWxzZSwgc3R5bGVzICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gbWFwO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgbmFtZSwgdmFsdWUgKSA6XG5cdFx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIG5hbWUgKTtcblx0XHR9LCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcblx0fVxufSApO1xuXG5cbmZ1bmN0aW9uIFR3ZWVuKCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZyApIHtcblx0cmV0dXJuIG5ldyBUd2Vlbi5wcm90b3R5cGUuaW5pdCggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcgKTtcbn1cbmpRdWVyeS5Ud2VlbiA9IFR3ZWVuO1xuXG5Ud2Vlbi5wcm90b3R5cGUgPSB7XG5cdGNvbnN0cnVjdG9yOiBUd2Vlbixcblx0aW5pdDogZnVuY3Rpb24oIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nLCB1bml0ICkge1xuXHRcdHRoaXMuZWxlbSA9IGVsZW07XG5cdFx0dGhpcy5wcm9wID0gcHJvcDtcblx0XHR0aGlzLmVhc2luZyA9IGVhc2luZyB8fCBqUXVlcnkuZWFzaW5nLl9kZWZhdWx0O1xuXHRcdHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cdFx0dGhpcy5zdGFydCA9IHRoaXMubm93ID0gdGhpcy5jdXIoKTtcblx0XHR0aGlzLmVuZCA9IGVuZDtcblx0XHR0aGlzLnVuaXQgPSB1bml0IHx8ICggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdID8gXCJcIiA6IFwicHhcIiApO1xuXHR9LFxuXHRjdXI6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBob29rcyA9IFR3ZWVuLnByb3BIb29rc1sgdGhpcy5wcm9wIF07XG5cblx0XHRyZXR1cm4gaG9va3MgJiYgaG9va3MuZ2V0ID9cblx0XHRcdGhvb2tzLmdldCggdGhpcyApIDpcblx0XHRcdFR3ZWVuLnByb3BIb29rcy5fZGVmYXVsdC5nZXQoIHRoaXMgKTtcblx0fSxcblx0cnVuOiBmdW5jdGlvbiggcGVyY2VudCApIHtcblx0XHR2YXIgZWFzZWQsXG5cdFx0XHRob29rcyA9IFR3ZWVuLnByb3BIb29rc1sgdGhpcy5wcm9wIF07XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5kdXJhdGlvbiApIHtcblx0XHRcdHRoaXMucG9zID0gZWFzZWQgPSBqUXVlcnkuZWFzaW5nWyB0aGlzLmVhc2luZyBdKFxuXHRcdFx0XHRwZXJjZW50LCB0aGlzLm9wdGlvbnMuZHVyYXRpb24gKiBwZXJjZW50LCAwLCAxLCB0aGlzLm9wdGlvbnMuZHVyYXRpb25cblx0XHRcdCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMucG9zID0gZWFzZWQgPSBwZXJjZW50O1xuXHRcdH1cblx0XHR0aGlzLm5vdyA9ICggdGhpcy5lbmQgLSB0aGlzLnN0YXJ0ICkgKiBlYXNlZCArIHRoaXMuc3RhcnQ7XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5zdGVwICkge1xuXHRcdFx0dGhpcy5vcHRpb25zLnN0ZXAuY2FsbCggdGhpcy5lbGVtLCB0aGlzLm5vdywgdGhpcyApO1xuXHRcdH1cblxuXHRcdGlmICggaG9va3MgJiYgaG9va3Muc2V0ICkge1xuXHRcdFx0aG9va3Muc2V0KCB0aGlzICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdFR3ZWVuLnByb3BIb29rcy5fZGVmYXVsdC5zZXQoIHRoaXMgKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn07XG5cblR3ZWVuLnByb3RvdHlwZS5pbml0LnByb3RvdHlwZSA9IFR3ZWVuLnByb3RvdHlwZTtcblxuVHdlZW4ucHJvcEhvb2tzID0ge1xuXHRfZGVmYXVsdDoge1xuXHRcdGdldDogZnVuY3Rpb24oIHR3ZWVuICkge1xuXHRcdFx0dmFyIHJlc3VsdDtcblxuXHRcdFx0Ly8gVXNlIGEgcHJvcGVydHkgb24gdGhlIGVsZW1lbnQgZGlyZWN0bHkgd2hlbiBpdCBpcyBub3QgYSBET00gZWxlbWVudCxcblx0XHRcdC8vIG9yIHdoZW4gdGhlcmUgaXMgbm8gbWF0Y2hpbmcgc3R5bGUgcHJvcGVydHkgdGhhdCBleGlzdHMuXG5cdFx0XHRpZiAoIHR3ZWVuLmVsZW0ubm9kZVR5cGUgIT09IDEgfHxcblx0XHRcdFx0dHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdICE9IG51bGwgJiYgdHdlZW4uZWxlbS5zdHlsZVsgdHdlZW4ucHJvcCBdID09IG51bGwgKSB7XG5cdFx0XHRcdHJldHVybiB0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF07XG5cdFx0XHR9XG5cblx0XHRcdC8vIFBhc3NpbmcgYW4gZW1wdHkgc3RyaW5nIGFzIGEgM3JkIHBhcmFtZXRlciB0byAuY3NzIHdpbGwgYXV0b21hdGljYWxseVxuXHRcdFx0Ly8gYXR0ZW1wdCBhIHBhcnNlRmxvYXQgYW5kIGZhbGxiYWNrIHRvIGEgc3RyaW5nIGlmIHRoZSBwYXJzZSBmYWlscy5cblx0XHRcdC8vIFNpbXBsZSB2YWx1ZXMgc3VjaCBhcyBcIjEwcHhcIiBhcmUgcGFyc2VkIHRvIEZsb2F0O1xuXHRcdFx0Ly8gY29tcGxleCB2YWx1ZXMgc3VjaCBhcyBcInJvdGF0ZSgxcmFkKVwiIGFyZSByZXR1cm5lZCBhcy1pcy5cblx0XHRcdHJlc3VsdCA9IGpRdWVyeS5jc3MoIHR3ZWVuLmVsZW0sIHR3ZWVuLnByb3AsIFwiXCIgKTtcblxuXHRcdFx0Ly8gRW1wdHkgc3RyaW5ncywgbnVsbCwgdW5kZWZpbmVkIGFuZCBcImF1dG9cIiBhcmUgY29udmVydGVkIHRvIDAuXG5cdFx0XHRyZXR1cm4gIXJlc3VsdCB8fCByZXN1bHQgPT09IFwiYXV0b1wiID8gMCA6IHJlc3VsdDtcblx0XHR9LFxuXHRcdHNldDogZnVuY3Rpb24oIHR3ZWVuICkge1xuXG5cdFx0XHQvLyBVc2Ugc3RlcCBob29rIGZvciBiYWNrIGNvbXBhdC5cblx0XHRcdC8vIFVzZSBjc3NIb29rIGlmIGl0cyB0aGVyZS5cblx0XHRcdC8vIFVzZSAuc3R5bGUgaWYgYXZhaWxhYmxlIGFuZCB1c2UgcGxhaW4gcHJvcGVydGllcyB3aGVyZSBhdmFpbGFibGUuXG5cdFx0XHRpZiAoIGpRdWVyeS5meC5zdGVwWyB0d2Vlbi5wcm9wIF0gKSB7XG5cdFx0XHRcdGpRdWVyeS5meC5zdGVwWyB0d2Vlbi5wcm9wIF0oIHR3ZWVuICk7XG5cdFx0XHR9IGVsc2UgaWYgKCB0d2Vlbi5lbGVtLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRcdCggdHdlZW4uZWxlbS5zdHlsZVsgalF1ZXJ5LmNzc1Byb3BzWyB0d2Vlbi5wcm9wIF0gXSAhPSBudWxsIHx8XG5cdFx0XHRcdFx0alF1ZXJ5LmNzc0hvb2tzWyB0d2Vlbi5wcm9wIF0gKSApIHtcblx0XHRcdFx0alF1ZXJ5LnN0eWxlKCB0d2Vlbi5lbGVtLCB0d2Vlbi5wcm9wLCB0d2Vlbi5ub3cgKyB0d2Vlbi51bml0ICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gPSB0d2Vlbi5ub3c7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59O1xuXG4vLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuLy8gUGFuaWMgYmFzZWQgYXBwcm9hY2ggdG8gc2V0dGluZyB0aGluZ3Mgb24gZGlzY29ubmVjdGVkIG5vZGVzXG5Ud2Vlbi5wcm9wSG9va3Muc2Nyb2xsVG9wID0gVHdlZW4ucHJvcEhvb2tzLnNjcm9sbExlZnQgPSB7XG5cdHNldDogZnVuY3Rpb24oIHR3ZWVuICkge1xuXHRcdGlmICggdHdlZW4uZWxlbS5ub2RlVHlwZSAmJiB0d2Vlbi5lbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHR0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gPSB0d2Vlbi5ub3c7XG5cdFx0fVxuXHR9XG59O1xuXG5qUXVlcnkuZWFzaW5nID0ge1xuXHRsaW5lYXI6IGZ1bmN0aW9uKCBwICkge1xuXHRcdHJldHVybiBwO1xuXHR9LFxuXHRzd2luZzogZnVuY3Rpb24oIHAgKSB7XG5cdFx0cmV0dXJuIDAuNSAtIE1hdGguY29zKCBwICogTWF0aC5QSSApIC8gMjtcblx0fSxcblx0X2RlZmF1bHQ6IFwic3dpbmdcIlxufTtcblxualF1ZXJ5LmZ4ID0gVHdlZW4ucHJvdG90eXBlLmluaXQ7XG5cbi8vIEJhY2sgY29tcGF0IDwxLjggZXh0ZW5zaW9uIHBvaW50XG5qUXVlcnkuZnguc3RlcCA9IHt9O1xuXG5cblxuXG52YXJcblx0ZnhOb3csIHRpbWVySWQsXG5cdHJmeHR5cGVzID0gL14oPzp0b2dnbGV8c2hvd3xoaWRlKSQvLFxuXHRycnVuID0gL3F1ZXVlSG9va3MkLztcblxuZnVuY3Rpb24gcmFmKCkge1xuXHRpZiAoIHRpbWVySWQgKSB7XG5cdFx0d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSggcmFmICk7XG5cdFx0alF1ZXJ5LmZ4LnRpY2soKTtcblx0fVxufVxuXG4vLyBBbmltYXRpb25zIGNyZWF0ZWQgc3luY2hyb25vdXNseSB3aWxsIHJ1biBzeW5jaHJvbm91c2x5XG5mdW5jdGlvbiBjcmVhdGVGeE5vdygpIHtcblx0d2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdGZ4Tm93ID0gdW5kZWZpbmVkO1xuXHR9ICk7XG5cdHJldHVybiAoIGZ4Tm93ID0galF1ZXJ5Lm5vdygpICk7XG59XG5cbi8vIEdlbmVyYXRlIHBhcmFtZXRlcnMgdG8gY3JlYXRlIGEgc3RhbmRhcmQgYW5pbWF0aW9uXG5mdW5jdGlvbiBnZW5GeCggdHlwZSwgaW5jbHVkZVdpZHRoICkge1xuXHR2YXIgd2hpY2gsXG5cdFx0aSA9IDAsXG5cdFx0YXR0cnMgPSB7IGhlaWdodDogdHlwZSB9O1xuXG5cdC8vIElmIHdlIGluY2x1ZGUgd2lkdGgsIHN0ZXAgdmFsdWUgaXMgMSB0byBkbyBhbGwgY3NzRXhwYW5kIHZhbHVlcyxcblx0Ly8gb3RoZXJ3aXNlIHN0ZXAgdmFsdWUgaXMgMiB0byBza2lwIG92ZXIgTGVmdCBhbmQgUmlnaHRcblx0aW5jbHVkZVdpZHRoID0gaW5jbHVkZVdpZHRoID8gMSA6IDA7XG5cdGZvciAoIDsgaSA8IDQ7IGkgKz0gMiAtIGluY2x1ZGVXaWR0aCApIHtcblx0XHR3aGljaCA9IGNzc0V4cGFuZFsgaSBdO1xuXHRcdGF0dHJzWyBcIm1hcmdpblwiICsgd2hpY2ggXSA9IGF0dHJzWyBcInBhZGRpbmdcIiArIHdoaWNoIF0gPSB0eXBlO1xuXHR9XG5cblx0aWYgKCBpbmNsdWRlV2lkdGggKSB7XG5cdFx0YXR0cnMub3BhY2l0eSA9IGF0dHJzLndpZHRoID0gdHlwZTtcblx0fVxuXG5cdHJldHVybiBhdHRycztcbn1cblxuZnVuY3Rpb24gY3JlYXRlVHdlZW4oIHZhbHVlLCBwcm9wLCBhbmltYXRpb24gKSB7XG5cdHZhciB0d2Vlbixcblx0XHRjb2xsZWN0aW9uID0gKCBBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXSB8fCBbXSApLmNvbmNhdCggQW5pbWF0aW9uLnR3ZWVuZXJzWyBcIipcIiBdICksXG5cdFx0aW5kZXggPSAwLFxuXHRcdGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoO1xuXHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdGlmICggKCB0d2VlbiA9IGNvbGxlY3Rpb25bIGluZGV4IF0uY2FsbCggYW5pbWF0aW9uLCBwcm9wLCB2YWx1ZSApICkgKSB7XG5cblx0XHRcdC8vIFdlJ3JlIGRvbmUgd2l0aCB0aGlzIHByb3BlcnR5XG5cdFx0XHRyZXR1cm4gdHdlZW47XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRQcmVmaWx0ZXIoIGVsZW0sIHByb3BzLCBvcHRzICkge1xuXHR2YXIgcHJvcCwgdmFsdWUsIHRvZ2dsZSwgaG9va3MsIG9sZGZpcmUsIHByb3BUd2VlbiwgcmVzdG9yZURpc3BsYXksIGRpc3BsYXksXG5cdFx0aXNCb3ggPSBcIndpZHRoXCIgaW4gcHJvcHMgfHwgXCJoZWlnaHRcIiBpbiBwcm9wcyxcblx0XHRhbmltID0gdGhpcyxcblx0XHRvcmlnID0ge30sXG5cdFx0c3R5bGUgPSBlbGVtLnN0eWxlLFxuXHRcdGhpZGRlbiA9IGVsZW0ubm9kZVR5cGUgJiYgaXNIaWRkZW5XaXRoaW5UcmVlKCBlbGVtICksXG5cdFx0ZGF0YVNob3cgPSBkYXRhUHJpdi5nZXQoIGVsZW0sIFwiZnhzaG93XCIgKTtcblxuXHQvLyBRdWV1ZS1za2lwcGluZyBhbmltYXRpb25zIGhpamFjayB0aGUgZnggaG9va3Ncblx0aWYgKCAhb3B0cy5xdWV1ZSApIHtcblx0XHRob29rcyA9IGpRdWVyeS5fcXVldWVIb29rcyggZWxlbSwgXCJmeFwiICk7XG5cdFx0aWYgKCBob29rcy51bnF1ZXVlZCA9PSBudWxsICkge1xuXHRcdFx0aG9va3MudW5xdWV1ZWQgPSAwO1xuXHRcdFx0b2xkZmlyZSA9IGhvb2tzLmVtcHR5LmZpcmU7XG5cdFx0XHRob29rcy5lbXB0eS5maXJlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggIWhvb2tzLnVucXVldWVkICkge1xuXHRcdFx0XHRcdG9sZGZpcmUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9XG5cdFx0aG9va3MudW5xdWV1ZWQrKztcblxuXHRcdGFuaW0uYWx3YXlzKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gRW5zdXJlIHRoZSBjb21wbGV0ZSBoYW5kbGVyIGlzIGNhbGxlZCBiZWZvcmUgdGhpcyBjb21wbGV0ZXNcblx0XHRcdGFuaW0uYWx3YXlzKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0aG9va3MudW5xdWV1ZWQtLTtcblx0XHRcdFx0aWYgKCAhalF1ZXJ5LnF1ZXVlKCBlbGVtLCBcImZ4XCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdFx0aG9va3MuZW1wdHkuZmlyZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gRGV0ZWN0IHNob3cvaGlkZSBhbmltYXRpb25zXG5cdGZvciAoIHByb3AgaW4gcHJvcHMgKSB7XG5cdFx0dmFsdWUgPSBwcm9wc1sgcHJvcCBdO1xuXHRcdGlmICggcmZ4dHlwZXMudGVzdCggdmFsdWUgKSApIHtcblx0XHRcdGRlbGV0ZSBwcm9wc1sgcHJvcCBdO1xuXHRcdFx0dG9nZ2xlID0gdG9nZ2xlIHx8IHZhbHVlID09PSBcInRvZ2dsZVwiO1xuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gKCBoaWRkZW4gPyBcImhpZGVcIiA6IFwic2hvd1wiICkgKSB7XG5cblx0XHRcdFx0Ly8gUHJldGVuZCB0byBiZSBoaWRkZW4gaWYgdGhpcyBpcyBhIFwic2hvd1wiIGFuZFxuXHRcdFx0XHQvLyB0aGVyZSBpcyBzdGlsbCBkYXRhIGZyb20gYSBzdG9wcGVkIHNob3cvaGlkZVxuXHRcdFx0XHRpZiAoIHZhbHVlID09PSBcInNob3dcIiAmJiBkYXRhU2hvdyAmJiBkYXRhU2hvd1sgcHJvcCBdICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0aGlkZGVuID0gdHJ1ZTtcblxuXHRcdFx0XHQvLyBJZ25vcmUgYWxsIG90aGVyIG5vLW9wIHNob3cvaGlkZSBkYXRhXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdG9yaWdbIHByb3AgXSA9IGRhdGFTaG93ICYmIGRhdGFTaG93WyBwcm9wIF0gfHwgalF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQmFpbCBvdXQgaWYgdGhpcyBpcyBhIG5vLW9wIGxpa2UgLmhpZGUoKS5oaWRlKClcblx0cHJvcFR3ZWVuID0gIWpRdWVyeS5pc0VtcHR5T2JqZWN0KCBwcm9wcyApO1xuXHRpZiAoICFwcm9wVHdlZW4gJiYgalF1ZXJ5LmlzRW1wdHlPYmplY3QoIG9yaWcgKSApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBSZXN0cmljdCBcIm92ZXJmbG93XCIgYW5kIFwiZGlzcGxheVwiIHN0eWxlcyBkdXJpbmcgYm94IGFuaW1hdGlvbnNcblx0aWYgKCBpc0JveCAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEsIEVkZ2UgMTIgLSAxM1xuXHRcdC8vIFJlY29yZCBhbGwgMyBvdmVyZmxvdyBhdHRyaWJ1dGVzIGJlY2F1c2UgSUUgZG9lcyBub3QgaW5mZXIgdGhlIHNob3J0aGFuZFxuXHRcdC8vIGZyb20gaWRlbnRpY2FsbHktdmFsdWVkIG92ZXJmbG93WCBhbmQgb3ZlcmZsb3dZXG5cdFx0b3B0cy5vdmVyZmxvdyA9IFsgc3R5bGUub3ZlcmZsb3csIHN0eWxlLm92ZXJmbG93WCwgc3R5bGUub3ZlcmZsb3dZIF07XG5cblx0XHQvLyBJZGVudGlmeSBhIGRpc3BsYXkgdHlwZSwgcHJlZmVycmluZyBvbGQgc2hvdy9oaWRlIGRhdGEgb3ZlciB0aGUgQ1NTIGNhc2NhZGVcblx0XHRyZXN0b3JlRGlzcGxheSA9IGRhdGFTaG93ICYmIGRhdGFTaG93LmRpc3BsYXk7XG5cdFx0aWYgKCByZXN0b3JlRGlzcGxheSA9PSBudWxsICkge1xuXHRcdFx0cmVzdG9yZURpc3BsYXkgPSBkYXRhUHJpdi5nZXQoIGVsZW0sIFwiZGlzcGxheVwiICk7XG5cdFx0fVxuXHRcdGRpc3BsYXkgPSBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApO1xuXHRcdGlmICggZGlzcGxheSA9PT0gXCJub25lXCIgKSB7XG5cdFx0XHRpZiAoIHJlc3RvcmVEaXNwbGF5ICkge1xuXHRcdFx0XHRkaXNwbGF5ID0gcmVzdG9yZURpc3BsYXk7XG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIEdldCBub25lbXB0eSB2YWx1ZShzKSBieSB0ZW1wb3JhcmlseSBmb3JjaW5nIHZpc2liaWxpdHlcblx0XHRcdFx0c2hvd0hpZGUoIFsgZWxlbSBdLCB0cnVlICk7XG5cdFx0XHRcdHJlc3RvcmVEaXNwbGF5ID0gZWxlbS5zdHlsZS5kaXNwbGF5IHx8IHJlc3RvcmVEaXNwbGF5O1xuXHRcdFx0XHRkaXNwbGF5ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKTtcblx0XHRcdFx0c2hvd0hpZGUoIFsgZWxlbSBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQW5pbWF0ZSBpbmxpbmUgZWxlbWVudHMgYXMgaW5saW5lLWJsb2NrXG5cdFx0aWYgKCBkaXNwbGF5ID09PSBcImlubGluZVwiIHx8IGRpc3BsYXkgPT09IFwiaW5saW5lLWJsb2NrXCIgJiYgcmVzdG9yZURpc3BsYXkgIT0gbnVsbCApIHtcblx0XHRcdGlmICggalF1ZXJ5LmNzcyggZWxlbSwgXCJmbG9hdFwiICkgPT09IFwibm9uZVwiICkge1xuXG5cdFx0XHRcdC8vIFJlc3RvcmUgdGhlIG9yaWdpbmFsIGRpc3BsYXkgdmFsdWUgYXQgdGhlIGVuZCBvZiBwdXJlIHNob3cvaGlkZSBhbmltYXRpb25zXG5cdFx0XHRcdGlmICggIXByb3BUd2VlbiApIHtcblx0XHRcdFx0XHRhbmltLmRvbmUoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0c3R5bGUuZGlzcGxheSA9IHJlc3RvcmVEaXNwbGF5O1xuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRpZiAoIHJlc3RvcmVEaXNwbGF5ID09IG51bGwgKSB7XG5cdFx0XHRcdFx0XHRkaXNwbGF5ID0gc3R5bGUuZGlzcGxheTtcblx0XHRcdFx0XHRcdHJlc3RvcmVEaXNwbGF5ID0gZGlzcGxheSA9PT0gXCJub25lXCIgPyBcIlwiIDogZGlzcGxheTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0c3R5bGUuZGlzcGxheSA9IFwiaW5saW5lLWJsb2NrXCI7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0aWYgKCBvcHRzLm92ZXJmbG93ICkge1xuXHRcdHN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIjtcblx0XHRhbmltLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cdFx0XHRzdHlsZS5vdmVyZmxvdyA9IG9wdHMub3ZlcmZsb3dbIDAgXTtcblx0XHRcdHN0eWxlLm92ZXJmbG93WCA9IG9wdHMub3ZlcmZsb3dbIDEgXTtcblx0XHRcdHN0eWxlLm92ZXJmbG93WSA9IG9wdHMub3ZlcmZsb3dbIDIgXTtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBJbXBsZW1lbnQgc2hvdy9oaWRlIGFuaW1hdGlvbnNcblx0cHJvcFR3ZWVuID0gZmFsc2U7XG5cdGZvciAoIHByb3AgaW4gb3JpZyApIHtcblxuXHRcdC8vIEdlbmVyYWwgc2hvdy9oaWRlIHNldHVwIGZvciB0aGlzIGVsZW1lbnQgYW5pbWF0aW9uXG5cdFx0aWYgKCAhcHJvcFR3ZWVuICkge1xuXHRcdFx0aWYgKCBkYXRhU2hvdyApIHtcblx0XHRcdFx0aWYgKCBcImhpZGRlblwiIGluIGRhdGFTaG93ICkge1xuXHRcdFx0XHRcdGhpZGRlbiA9IGRhdGFTaG93LmhpZGRlbjtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGF0YVNob3cgPSBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIFwiZnhzaG93XCIsIHsgZGlzcGxheTogcmVzdG9yZURpc3BsYXkgfSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdG9yZSBoaWRkZW4vdmlzaWJsZSBmb3IgdG9nZ2xlIHNvIGAuc3RvcCgpLnRvZ2dsZSgpYCBcInJldmVyc2VzXCJcblx0XHRcdGlmICggdG9nZ2xlICkge1xuXHRcdFx0XHRkYXRhU2hvdy5oaWRkZW4gPSAhaGlkZGVuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTaG93IGVsZW1lbnRzIGJlZm9yZSBhbmltYXRpbmcgdGhlbVxuXHRcdFx0aWYgKCBoaWRkZW4gKSB7XG5cdFx0XHRcdHNob3dIaWRlKCBbIGVsZW0gXSwgdHJ1ZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvKiBlc2xpbnQtZGlzYWJsZSBuby1sb29wLWZ1bmMgKi9cblxuXHRcdFx0YW5pbS5kb25lKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0LyogZXNsaW50LWVuYWJsZSBuby1sb29wLWZ1bmMgKi9cblxuXHRcdFx0XHQvLyBUaGUgZmluYWwgc3RlcCBvZiBhIFwiaGlkZVwiIGFuaW1hdGlvbiBpcyBhY3R1YWxseSBoaWRpbmcgdGhlIGVsZW1lbnRcblx0XHRcdFx0aWYgKCAhaGlkZGVuICkge1xuXHRcdFx0XHRcdHNob3dIaWRlKCBbIGVsZW0gXSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgXCJmeHNob3dcIiApO1xuXHRcdFx0XHRmb3IgKCBwcm9wIGluIG9yaWcgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wLCBvcmlnWyBwcm9wIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdC8vIFBlci1wcm9wZXJ0eSBzZXR1cFxuXHRcdHByb3BUd2VlbiA9IGNyZWF0ZVR3ZWVuKCBoaWRkZW4gPyBkYXRhU2hvd1sgcHJvcCBdIDogMCwgcHJvcCwgYW5pbSApO1xuXHRcdGlmICggISggcHJvcCBpbiBkYXRhU2hvdyApICkge1xuXHRcdFx0ZGF0YVNob3dbIHByb3AgXSA9IHByb3BUd2Vlbi5zdGFydDtcblx0XHRcdGlmICggaGlkZGVuICkge1xuXHRcdFx0XHRwcm9wVHdlZW4uZW5kID0gcHJvcFR3ZWVuLnN0YXJ0O1xuXHRcdFx0XHRwcm9wVHdlZW4uc3RhcnQgPSAwO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBwcm9wRmlsdGVyKCBwcm9wcywgc3BlY2lhbEVhc2luZyApIHtcblx0dmFyIGluZGV4LCBuYW1lLCBlYXNpbmcsIHZhbHVlLCBob29rcztcblxuXHQvLyBjYW1lbENhc2UsIHNwZWNpYWxFYXNpbmcgYW5kIGV4cGFuZCBjc3NIb29rIHBhc3Ncblx0Zm9yICggaW5kZXggaW4gcHJvcHMgKSB7XG5cdFx0bmFtZSA9IGpRdWVyeS5jYW1lbENhc2UoIGluZGV4ICk7XG5cdFx0ZWFzaW5nID0gc3BlY2lhbEVhc2luZ1sgbmFtZSBdO1xuXHRcdHZhbHVlID0gcHJvcHNbIGluZGV4IF07XG5cdFx0aWYgKCBqUXVlcnkuaXNBcnJheSggdmFsdWUgKSApIHtcblx0XHRcdGVhc2luZyA9IHZhbHVlWyAxIF07XG5cdFx0XHR2YWx1ZSA9IHByb3BzWyBpbmRleCBdID0gdmFsdWVbIDAgXTtcblx0XHR9XG5cblx0XHRpZiAoIGluZGV4ICE9PSBuYW1lICkge1xuXHRcdFx0cHJvcHNbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0ZGVsZXRlIHByb3BzWyBpbmRleCBdO1xuXHRcdH1cblxuXHRcdGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF07XG5cdFx0aWYgKCBob29rcyAmJiBcImV4cGFuZFwiIGluIGhvb2tzICkge1xuXHRcdFx0dmFsdWUgPSBob29rcy5leHBhbmQoIHZhbHVlICk7XG5cdFx0XHRkZWxldGUgcHJvcHNbIG5hbWUgXTtcblxuXHRcdFx0Ly8gTm90IHF1aXRlICQuZXh0ZW5kLCB0aGlzIHdvbid0IG92ZXJ3cml0ZSBleGlzdGluZyBrZXlzLlxuXHRcdFx0Ly8gUmV1c2luZyAnaW5kZXgnIGJlY2F1c2Ugd2UgaGF2ZSB0aGUgY29ycmVjdCBcIm5hbWVcIlxuXHRcdFx0Zm9yICggaW5kZXggaW4gdmFsdWUgKSB7XG5cdFx0XHRcdGlmICggISggaW5kZXggaW4gcHJvcHMgKSApIHtcblx0XHRcdFx0XHRwcm9wc1sgaW5kZXggXSA9IHZhbHVlWyBpbmRleCBdO1xuXHRcdFx0XHRcdHNwZWNpYWxFYXNpbmdbIGluZGV4IF0gPSBlYXNpbmc7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0c3BlY2lhbEVhc2luZ1sgbmFtZSBdID0gZWFzaW5nO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBBbmltYXRpb24oIGVsZW0sIHByb3BlcnRpZXMsIG9wdGlvbnMgKSB7XG5cdHZhciByZXN1bHQsXG5cdFx0c3RvcHBlZCxcblx0XHRpbmRleCA9IDAsXG5cdFx0bGVuZ3RoID0gQW5pbWF0aW9uLnByZWZpbHRlcnMubGVuZ3RoLFxuXHRcdGRlZmVycmVkID0galF1ZXJ5LkRlZmVycmVkKCkuYWx3YXlzKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gRG9uJ3QgbWF0Y2ggZWxlbSBpbiB0aGUgOmFuaW1hdGVkIHNlbGVjdG9yXG5cdFx0XHRkZWxldGUgdGljay5lbGVtO1xuXHRcdH0gKSxcblx0XHR0aWNrID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIHN0b3BwZWQgKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdHZhciBjdXJyZW50VGltZSA9IGZ4Tm93IHx8IGNyZWF0ZUZ4Tm93KCksXG5cdFx0XHRcdHJlbWFpbmluZyA9IE1hdGgubWF4KCAwLCBhbmltYXRpb24uc3RhcnRUaW1lICsgYW5pbWF0aW9uLmR1cmF0aW9uIC0gY3VycmVudFRpbWUgKSxcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDIuMyBvbmx5XG5cdFx0XHRcdC8vIEFyY2hhaWMgY3Jhc2ggYnVnIHdvbid0IGFsbG93IHVzIHRvIHVzZSBgMSAtICggMC41IHx8IDAgKWAgKCMxMjQ5Nylcblx0XHRcdFx0dGVtcCA9IHJlbWFpbmluZyAvIGFuaW1hdGlvbi5kdXJhdGlvbiB8fCAwLFxuXHRcdFx0XHRwZXJjZW50ID0gMSAtIHRlbXAsXG5cdFx0XHRcdGluZGV4ID0gMCxcblx0XHRcdFx0bGVuZ3RoID0gYW5pbWF0aW9uLnR3ZWVucy5sZW5ndGg7XG5cblx0XHRcdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0XHRcdGFuaW1hdGlvbi50d2VlbnNbIGluZGV4IF0ucnVuKCBwZXJjZW50ICk7XG5cdFx0XHR9XG5cblx0XHRcdGRlZmVycmVkLm5vdGlmeVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBwZXJjZW50LCByZW1haW5pbmcgXSApO1xuXG5cdFx0XHRpZiAoIHBlcmNlbnQgPCAxICYmIGxlbmd0aCApIHtcblx0XHRcdFx0cmV0dXJuIHJlbWFpbmluZztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiBdICk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGFuaW1hdGlvbiA9IGRlZmVycmVkLnByb21pc2UoIHtcblx0XHRcdGVsZW06IGVsZW0sXG5cdFx0XHRwcm9wczogalF1ZXJ5LmV4dGVuZCgge30sIHByb3BlcnRpZXMgKSxcblx0XHRcdG9wdHM6IGpRdWVyeS5leHRlbmQoIHRydWUsIHtcblx0XHRcdFx0c3BlY2lhbEVhc2luZzoge30sXG5cdFx0XHRcdGVhc2luZzogalF1ZXJ5LmVhc2luZy5fZGVmYXVsdFxuXHRcdFx0fSwgb3B0aW9ucyApLFxuXHRcdFx0b3JpZ2luYWxQcm9wZXJ0aWVzOiBwcm9wZXJ0aWVzLFxuXHRcdFx0b3JpZ2luYWxPcHRpb25zOiBvcHRpb25zLFxuXHRcdFx0c3RhcnRUaW1lOiBmeE5vdyB8fCBjcmVhdGVGeE5vdygpLFxuXHRcdFx0ZHVyYXRpb246IG9wdGlvbnMuZHVyYXRpb24sXG5cdFx0XHR0d2VlbnM6IFtdLFxuXHRcdFx0Y3JlYXRlVHdlZW46IGZ1bmN0aW9uKCBwcm9wLCBlbmQgKSB7XG5cdFx0XHRcdHZhciB0d2VlbiA9IGpRdWVyeS5Ud2VlbiggZWxlbSwgYW5pbWF0aW9uLm9wdHMsIHByb3AsIGVuZCxcblx0XHRcdFx0XHRcdGFuaW1hdGlvbi5vcHRzLnNwZWNpYWxFYXNpbmdbIHByb3AgXSB8fCBhbmltYXRpb24ub3B0cy5lYXNpbmcgKTtcblx0XHRcdFx0YW5pbWF0aW9uLnR3ZWVucy5wdXNoKCB0d2VlbiApO1xuXHRcdFx0XHRyZXR1cm4gdHdlZW47XG5cdFx0XHR9LFxuXHRcdFx0c3RvcDogZnVuY3Rpb24oIGdvdG9FbmQgKSB7XG5cdFx0XHRcdHZhciBpbmRleCA9IDAsXG5cblx0XHRcdFx0XHQvLyBJZiB3ZSBhcmUgZ29pbmcgdG8gdGhlIGVuZCwgd2Ugd2FudCB0byBydW4gYWxsIHRoZSB0d2VlbnNcblx0XHRcdFx0XHQvLyBvdGhlcndpc2Ugd2Ugc2tpcCB0aGlzIHBhcnRcblx0XHRcdFx0XHRsZW5ndGggPSBnb3RvRW5kID8gYW5pbWF0aW9uLnR3ZWVucy5sZW5ndGggOiAwO1xuXHRcdFx0XHRpZiAoIHN0b3BwZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblx0XHRcdFx0c3RvcHBlZCA9IHRydWU7XG5cdFx0XHRcdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0XHRcdFx0YW5pbWF0aW9uLnR3ZWVuc1sgaW5kZXggXS5ydW4oIDEgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJlc29sdmUgd2hlbiB3ZSBwbGF5ZWQgdGhlIGxhc3QgZnJhbWU7IG90aGVyd2lzZSwgcmVqZWN0XG5cdFx0XHRcdGlmICggZ290b0VuZCApIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgMSwgMCBdICk7XG5cdFx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBnb3RvRW5kIF0gKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5yZWplY3RXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgZ290b0VuZCBdICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9XG5cdFx0fSApLFxuXHRcdHByb3BzID0gYW5pbWF0aW9uLnByb3BzO1xuXG5cdHByb3BGaWx0ZXIoIHByb3BzLCBhbmltYXRpb24ub3B0cy5zcGVjaWFsRWFzaW5nICk7XG5cblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRyZXN1bHQgPSBBbmltYXRpb24ucHJlZmlsdGVyc1sgaW5kZXggXS5jYWxsKCBhbmltYXRpb24sIGVsZW0sIHByb3BzLCBhbmltYXRpb24ub3B0cyApO1xuXHRcdGlmICggcmVzdWx0ICkge1xuXHRcdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggcmVzdWx0LnN0b3AgKSApIHtcblx0XHRcdFx0alF1ZXJ5Ll9xdWV1ZUhvb2tzKCBhbmltYXRpb24uZWxlbSwgYW5pbWF0aW9uLm9wdHMucXVldWUgKS5zdG9wID1cblx0XHRcdFx0XHRqUXVlcnkucHJveHkoIHJlc3VsdC5zdG9wLCByZXN1bHQgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fVxuXHR9XG5cblx0alF1ZXJ5Lm1hcCggcHJvcHMsIGNyZWF0ZVR3ZWVuLCBhbmltYXRpb24gKTtcblxuXHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBhbmltYXRpb24ub3B0cy5zdGFydCApICkge1xuXHRcdGFuaW1hdGlvbi5vcHRzLnN0YXJ0LmNhbGwoIGVsZW0sIGFuaW1hdGlvbiApO1xuXHR9XG5cblx0alF1ZXJ5LmZ4LnRpbWVyKFxuXHRcdGpRdWVyeS5leHRlbmQoIHRpY2ssIHtcblx0XHRcdGVsZW06IGVsZW0sXG5cdFx0XHRhbmltOiBhbmltYXRpb24sXG5cdFx0XHRxdWV1ZTogYW5pbWF0aW9uLm9wdHMucXVldWVcblx0XHR9IClcblx0KTtcblxuXHQvLyBhdHRhY2ggY2FsbGJhY2tzIGZyb20gb3B0aW9uc1xuXHRyZXR1cm4gYW5pbWF0aW9uLnByb2dyZXNzKCBhbmltYXRpb24ub3B0cy5wcm9ncmVzcyApXG5cdFx0LmRvbmUoIGFuaW1hdGlvbi5vcHRzLmRvbmUsIGFuaW1hdGlvbi5vcHRzLmNvbXBsZXRlIClcblx0XHQuZmFpbCggYW5pbWF0aW9uLm9wdHMuZmFpbCApXG5cdFx0LmFsd2F5cyggYW5pbWF0aW9uLm9wdHMuYWx3YXlzICk7XG59XG5cbmpRdWVyeS5BbmltYXRpb24gPSBqUXVlcnkuZXh0ZW5kKCBBbmltYXRpb24sIHtcblxuXHR0d2VlbmVyczoge1xuXHRcdFwiKlwiOiBbIGZ1bmN0aW9uKCBwcm9wLCB2YWx1ZSApIHtcblx0XHRcdHZhciB0d2VlbiA9IHRoaXMuY3JlYXRlVHdlZW4oIHByb3AsIHZhbHVlICk7XG5cdFx0XHRhZGp1c3RDU1MoIHR3ZWVuLmVsZW0sIHByb3AsIHJjc3NOdW0uZXhlYyggdmFsdWUgKSwgdHdlZW4gKTtcblx0XHRcdHJldHVybiB0d2Vlbjtcblx0XHR9IF1cblx0fSxcblxuXHR0d2VlbmVyOiBmdW5jdGlvbiggcHJvcHMsIGNhbGxiYWNrICkge1xuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHByb3BzICkgKSB7XG5cdFx0XHRjYWxsYmFjayA9IHByb3BzO1xuXHRcdFx0cHJvcHMgPSBbIFwiKlwiIF07XG5cdFx0fSBlbHNlIHtcblx0XHRcdHByb3BzID0gcHJvcHMubWF0Y2goIHJub3RodG1sd2hpdGUgKTtcblx0XHR9XG5cblx0XHR2YXIgcHJvcCxcblx0XHRcdGluZGV4ID0gMCxcblx0XHRcdGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuXHRcdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0XHRwcm9wID0gcHJvcHNbIGluZGV4IF07XG5cdFx0XHRBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXSA9IEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdIHx8IFtdO1xuXHRcdFx0QW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0udW5zaGlmdCggY2FsbGJhY2sgKTtcblx0XHR9XG5cdH0sXG5cblx0cHJlZmlsdGVyczogWyBkZWZhdWx0UHJlZmlsdGVyIF0sXG5cblx0cHJlZmlsdGVyOiBmdW5jdGlvbiggY2FsbGJhY2ssIHByZXBlbmQgKSB7XG5cdFx0aWYgKCBwcmVwZW5kICkge1xuXHRcdFx0QW5pbWF0aW9uLnByZWZpbHRlcnMudW5zaGlmdCggY2FsbGJhY2sgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0QW5pbWF0aW9uLnByZWZpbHRlcnMucHVzaCggY2FsbGJhY2sgKTtcblx0XHR9XG5cdH1cbn0gKTtcblxualF1ZXJ5LnNwZWVkID0gZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGZuICkge1xuXHR2YXIgb3B0ID0gc3BlZWQgJiYgdHlwZW9mIHNwZWVkID09PSBcIm9iamVjdFwiID8galF1ZXJ5LmV4dGVuZCgge30sIHNwZWVkICkgOiB7XG5cdFx0Y29tcGxldGU6IGZuIHx8ICFmbiAmJiBlYXNpbmcgfHxcblx0XHRcdGpRdWVyeS5pc0Z1bmN0aW9uKCBzcGVlZCApICYmIHNwZWVkLFxuXHRcdGR1cmF0aW9uOiBzcGVlZCxcblx0XHRlYXNpbmc6IGZuICYmIGVhc2luZyB8fCBlYXNpbmcgJiYgIWpRdWVyeS5pc0Z1bmN0aW9uKCBlYXNpbmcgKSAmJiBlYXNpbmdcblx0fTtcblxuXHQvLyBHbyB0byB0aGUgZW5kIHN0YXRlIGlmIGZ4IGFyZSBvZmYgb3IgaWYgZG9jdW1lbnQgaXMgaGlkZGVuXG5cdGlmICggalF1ZXJ5LmZ4Lm9mZiB8fCBkb2N1bWVudC5oaWRkZW4gKSB7XG5cdFx0b3B0LmR1cmF0aW9uID0gMDtcblxuXHR9IGVsc2Uge1xuXHRcdGlmICggdHlwZW9mIG9wdC5kdXJhdGlvbiAhPT0gXCJudW1iZXJcIiApIHtcblx0XHRcdGlmICggb3B0LmR1cmF0aW9uIGluIGpRdWVyeS5meC5zcGVlZHMgKSB7XG5cdFx0XHRcdG9wdC5kdXJhdGlvbiA9IGpRdWVyeS5meC5zcGVlZHNbIG9wdC5kdXJhdGlvbiBdO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvcHQuZHVyYXRpb24gPSBqUXVlcnkuZnguc3BlZWRzLl9kZWZhdWx0O1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIE5vcm1hbGl6ZSBvcHQucXVldWUgLSB0cnVlL3VuZGVmaW5lZC9udWxsIC0+IFwiZnhcIlxuXHRpZiAoIG9wdC5xdWV1ZSA9PSBudWxsIHx8IG9wdC5xdWV1ZSA9PT0gdHJ1ZSApIHtcblx0XHRvcHQucXVldWUgPSBcImZ4XCI7XG5cdH1cblxuXHQvLyBRdWV1ZWluZ1xuXHRvcHQub2xkID0gb3B0LmNvbXBsZXRlO1xuXG5cdG9wdC5jb21wbGV0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIG9wdC5vbGQgKSApIHtcblx0XHRcdG9wdC5vbGQuY2FsbCggdGhpcyApO1xuXHRcdH1cblxuXHRcdGlmICggb3B0LnF1ZXVlICkge1xuXHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIG9wdC5xdWV1ZSApO1xuXHRcdH1cblx0fTtcblxuXHRyZXR1cm4gb3B0O1xufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRmYWRlVG86IGZ1bmN0aW9uKCBzcGVlZCwgdG8sIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cblx0XHQvLyBTaG93IGFueSBoaWRkZW4gZWxlbWVudHMgYWZ0ZXIgc2V0dGluZyBvcGFjaXR5IHRvIDBcblx0XHRyZXR1cm4gdGhpcy5maWx0ZXIoIGlzSGlkZGVuV2l0aGluVHJlZSApLmNzcyggXCJvcGFjaXR5XCIsIDAgKS5zaG93KClcblxuXHRcdFx0Ly8gQW5pbWF0ZSB0byB0aGUgdmFsdWUgc3BlY2lmaWVkXG5cdFx0XHQuZW5kKCkuYW5pbWF0ZSggeyBvcGFjaXR5OiB0byB9LCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xuXHR9LFxuXHRhbmltYXRlOiBmdW5jdGlvbiggcHJvcCwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdFx0dmFyIGVtcHR5ID0galF1ZXJ5LmlzRW1wdHlPYmplY3QoIHByb3AgKSxcblx0XHRcdG9wdGFsbCA9IGpRdWVyeS5zcGVlZCggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSxcblx0XHRcdGRvQW5pbWF0aW9uID0gZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0Ly8gT3BlcmF0ZSBvbiBhIGNvcHkgb2YgcHJvcCBzbyBwZXItcHJvcGVydHkgZWFzaW5nIHdvbid0IGJlIGxvc3Rcblx0XHRcdFx0dmFyIGFuaW0gPSBBbmltYXRpb24oIHRoaXMsIGpRdWVyeS5leHRlbmQoIHt9LCBwcm9wICksIG9wdGFsbCApO1xuXG5cdFx0XHRcdC8vIEVtcHR5IGFuaW1hdGlvbnMsIG9yIGZpbmlzaGluZyByZXNvbHZlcyBpbW1lZGlhdGVseVxuXHRcdFx0XHRpZiAoIGVtcHR5IHx8IGRhdGFQcml2LmdldCggdGhpcywgXCJmaW5pc2hcIiApICkge1xuXHRcdFx0XHRcdGFuaW0uc3RvcCggdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdFx0ZG9BbmltYXRpb24uZmluaXNoID0gZG9BbmltYXRpb247XG5cblx0XHRyZXR1cm4gZW1wdHkgfHwgb3B0YWxsLnF1ZXVlID09PSBmYWxzZSA/XG5cdFx0XHR0aGlzLmVhY2goIGRvQW5pbWF0aW9uICkgOlxuXHRcdFx0dGhpcy5xdWV1ZSggb3B0YWxsLnF1ZXVlLCBkb0FuaW1hdGlvbiApO1xuXHR9LFxuXHRzdG9wOiBmdW5jdGlvbiggdHlwZSwgY2xlYXJRdWV1ZSwgZ290b0VuZCApIHtcblx0XHR2YXIgc3RvcFF1ZXVlID0gZnVuY3Rpb24oIGhvb2tzICkge1xuXHRcdFx0dmFyIHN0b3AgPSBob29rcy5zdG9wO1xuXHRcdFx0ZGVsZXRlIGhvb2tzLnN0b3A7XG5cdFx0XHRzdG9wKCBnb3RvRW5kICk7XG5cdFx0fTtcblxuXHRcdGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRnb3RvRW5kID0gY2xlYXJRdWV1ZTtcblx0XHRcdGNsZWFyUXVldWUgPSB0eXBlO1xuXHRcdFx0dHlwZSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0aWYgKCBjbGVhclF1ZXVlICYmIHR5cGUgIT09IGZhbHNlICkge1xuXHRcdFx0dGhpcy5xdWV1ZSggdHlwZSB8fCBcImZ4XCIsIFtdICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgZGVxdWV1ZSA9IHRydWUsXG5cdFx0XHRcdGluZGV4ID0gdHlwZSAhPSBudWxsICYmIHR5cGUgKyBcInF1ZXVlSG9va3NcIixcblx0XHRcdFx0dGltZXJzID0galF1ZXJ5LnRpbWVycyxcblx0XHRcdFx0ZGF0YSA9IGRhdGFQcml2LmdldCggdGhpcyApO1xuXG5cdFx0XHRpZiAoIGluZGV4ICkge1xuXHRcdFx0XHRpZiAoIGRhdGFbIGluZGV4IF0gJiYgZGF0YVsgaW5kZXggXS5zdG9wICkge1xuXHRcdFx0XHRcdHN0b3BRdWV1ZSggZGF0YVsgaW5kZXggXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRmb3IgKCBpbmRleCBpbiBkYXRhICkge1xuXHRcdFx0XHRcdGlmICggZGF0YVsgaW5kZXggXSAmJiBkYXRhWyBpbmRleCBdLnN0b3AgJiYgcnJ1bi50ZXN0KCBpbmRleCApICkge1xuXHRcdFx0XHRcdFx0c3RvcFF1ZXVlKCBkYXRhWyBpbmRleCBdICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGZvciAoIGluZGV4ID0gdGltZXJzLmxlbmd0aDsgaW5kZXgtLTsgKSB7XG5cdFx0XHRcdGlmICggdGltZXJzWyBpbmRleCBdLmVsZW0gPT09IHRoaXMgJiZcblx0XHRcdFx0XHQoIHR5cGUgPT0gbnVsbCB8fCB0aW1lcnNbIGluZGV4IF0ucXVldWUgPT09IHR5cGUgKSApIHtcblxuXHRcdFx0XHRcdHRpbWVyc1sgaW5kZXggXS5hbmltLnN0b3AoIGdvdG9FbmQgKTtcblx0XHRcdFx0XHRkZXF1ZXVlID0gZmFsc2U7XG5cdFx0XHRcdFx0dGltZXJzLnNwbGljZSggaW5kZXgsIDEgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdGFydCB0aGUgbmV4dCBpbiB0aGUgcXVldWUgaWYgdGhlIGxhc3Qgc3RlcCB3YXNuJ3QgZm9yY2VkLlxuXHRcdFx0Ly8gVGltZXJzIGN1cnJlbnRseSB3aWxsIGNhbGwgdGhlaXIgY29tcGxldGUgY2FsbGJhY2tzLCB3aGljaFxuXHRcdFx0Ly8gd2lsbCBkZXF1ZXVlIGJ1dCBvbmx5IGlmIHRoZXkgd2VyZSBnb3RvRW5kLlxuXHRcdFx0aWYgKCBkZXF1ZXVlIHx8ICFnb3RvRW5kICkge1xuXHRcdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgdHlwZSApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblx0ZmluaXNoOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRpZiAoIHR5cGUgIT09IGZhbHNlICkge1xuXHRcdFx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBpbmRleCxcblx0XHRcdFx0ZGF0YSA9IGRhdGFQcml2LmdldCggdGhpcyApLFxuXHRcdFx0XHRxdWV1ZSA9IGRhdGFbIHR5cGUgKyBcInF1ZXVlXCIgXSxcblx0XHRcdFx0aG9va3MgPSBkYXRhWyB0eXBlICsgXCJxdWV1ZUhvb2tzXCIgXSxcblx0XHRcdFx0dGltZXJzID0galF1ZXJ5LnRpbWVycyxcblx0XHRcdFx0bGVuZ3RoID0gcXVldWUgPyBxdWV1ZS5sZW5ndGggOiAwO1xuXG5cdFx0XHQvLyBFbmFibGUgZmluaXNoaW5nIGZsYWcgb24gcHJpdmF0ZSBkYXRhXG5cdFx0XHRkYXRhLmZpbmlzaCA9IHRydWU7XG5cblx0XHRcdC8vIEVtcHR5IHRoZSBxdWV1ZSBmaXJzdFxuXHRcdFx0alF1ZXJ5LnF1ZXVlKCB0aGlzLCB0eXBlLCBbXSApO1xuXG5cdFx0XHRpZiAoIGhvb2tzICYmIGhvb2tzLnN0b3AgKSB7XG5cdFx0XHRcdGhvb2tzLnN0b3AuY2FsbCggdGhpcywgdHJ1ZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBMb29rIGZvciBhbnkgYWN0aXZlIGFuaW1hdGlvbnMsIGFuZCBmaW5pc2ggdGhlbVxuXHRcdFx0Zm9yICggaW5kZXggPSB0aW1lcnMubGVuZ3RoOyBpbmRleC0tOyApIHtcblx0XHRcdFx0aWYgKCB0aW1lcnNbIGluZGV4IF0uZWxlbSA9PT0gdGhpcyAmJiB0aW1lcnNbIGluZGV4IF0ucXVldWUgPT09IHR5cGUgKSB7XG5cdFx0XHRcdFx0dGltZXJzWyBpbmRleCBdLmFuaW0uc3RvcCggdHJ1ZSApO1xuXHRcdFx0XHRcdHRpbWVycy5zcGxpY2UoIGluZGV4LCAxICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gTG9vayBmb3IgYW55IGFuaW1hdGlvbnMgaW4gdGhlIG9sZCBxdWV1ZSBhbmQgZmluaXNoIHRoZW1cblx0XHRcdGZvciAoIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0XHRcdGlmICggcXVldWVbIGluZGV4IF0gJiYgcXVldWVbIGluZGV4IF0uZmluaXNoICkge1xuXHRcdFx0XHRcdHF1ZXVlWyBpbmRleCBdLmZpbmlzaC5jYWxsKCB0aGlzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gVHVybiBvZmYgZmluaXNoaW5nIGZsYWdcblx0XHRcdGRlbGV0ZSBkYXRhLmZpbmlzaDtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goIFsgXCJ0b2dnbGVcIiwgXCJzaG93XCIsIFwiaGlkZVwiIF0sIGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXHR2YXIgY3NzRm4gPSBqUXVlcnkuZm5bIG5hbWUgXTtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHNwZWVkID09IG51bGwgfHwgdHlwZW9mIHNwZWVkID09PSBcImJvb2xlYW5cIiA/XG5cdFx0XHRjc3NGbi5hcHBseSggdGhpcywgYXJndW1lbnRzICkgOlxuXHRcdFx0dGhpcy5hbmltYXRlKCBnZW5GeCggbmFtZSwgdHJ1ZSApLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xuXHR9O1xufSApO1xuXG4vLyBHZW5lcmF0ZSBzaG9ydGN1dHMgZm9yIGN1c3RvbSBhbmltYXRpb25zXG5qUXVlcnkuZWFjaCgge1xuXHRzbGlkZURvd246IGdlbkZ4KCBcInNob3dcIiApLFxuXHRzbGlkZVVwOiBnZW5GeCggXCJoaWRlXCIgKSxcblx0c2xpZGVUb2dnbGU6IGdlbkZ4KCBcInRvZ2dsZVwiICksXG5cdGZhZGVJbjogeyBvcGFjaXR5OiBcInNob3dcIiB9LFxuXHRmYWRlT3V0OiB7IG9wYWNpdHk6IFwiaGlkZVwiIH0sXG5cdGZhZGVUb2dnbGU6IHsgb3BhY2l0eTogXCJ0b2dnbGVcIiB9XG59LCBmdW5jdGlvbiggbmFtZSwgcHJvcHMgKSB7XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiB0aGlzLmFuaW1hdGUoIHByb3BzLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xuXHR9O1xufSApO1xuXG5qUXVlcnkudGltZXJzID0gW107XG5qUXVlcnkuZngudGljayA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgdGltZXIsXG5cdFx0aSA9IDAsXG5cdFx0dGltZXJzID0galF1ZXJ5LnRpbWVycztcblxuXHRmeE5vdyA9IGpRdWVyeS5ub3coKTtcblxuXHRmb3IgKCA7IGkgPCB0aW1lcnMubGVuZ3RoOyBpKysgKSB7XG5cdFx0dGltZXIgPSB0aW1lcnNbIGkgXTtcblxuXHRcdC8vIENoZWNrcyB0aGUgdGltZXIgaGFzIG5vdCBhbHJlYWR5IGJlZW4gcmVtb3ZlZFxuXHRcdGlmICggIXRpbWVyKCkgJiYgdGltZXJzWyBpIF0gPT09IHRpbWVyICkge1xuXHRcdFx0dGltZXJzLnNwbGljZSggaS0tLCAxICk7XG5cdFx0fVxuXHR9XG5cblx0aWYgKCAhdGltZXJzLmxlbmd0aCApIHtcblx0XHRqUXVlcnkuZnguc3RvcCgpO1xuXHR9XG5cdGZ4Tm93ID0gdW5kZWZpbmVkO1xufTtcblxualF1ZXJ5LmZ4LnRpbWVyID0gZnVuY3Rpb24oIHRpbWVyICkge1xuXHRqUXVlcnkudGltZXJzLnB1c2goIHRpbWVyICk7XG5cdGlmICggdGltZXIoKSApIHtcblx0XHRqUXVlcnkuZnguc3RhcnQoKTtcblx0fSBlbHNlIHtcblx0XHRqUXVlcnkudGltZXJzLnBvcCgpO1xuXHR9XG59O1xuXG5qUXVlcnkuZnguaW50ZXJ2YWwgPSAxMztcbmpRdWVyeS5meC5zdGFydCA9IGZ1bmN0aW9uKCkge1xuXHRpZiAoICF0aW1lcklkICkge1xuXHRcdHRpbWVySWQgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID9cblx0XHRcdHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoIHJhZiApIDpcblx0XHRcdHdpbmRvdy5zZXRJbnRlcnZhbCggalF1ZXJ5LmZ4LnRpY2ssIGpRdWVyeS5meC5pbnRlcnZhbCApO1xuXHR9XG59O1xuXG5qUXVlcnkuZnguc3RvcCA9IGZ1bmN0aW9uKCkge1xuXHRpZiAoIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSApIHtcblx0XHR3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUoIHRpbWVySWQgKTtcblx0fSBlbHNlIHtcblx0XHR3aW5kb3cuY2xlYXJJbnRlcnZhbCggdGltZXJJZCApO1xuXHR9XG5cblx0dGltZXJJZCA9IG51bGw7XG59O1xuXG5qUXVlcnkuZnguc3BlZWRzID0ge1xuXHRzbG93OiA2MDAsXG5cdGZhc3Q6IDIwMCxcblxuXHQvLyBEZWZhdWx0IHNwZWVkXG5cdF9kZWZhdWx0OiA0MDBcbn07XG5cblxuLy8gQmFzZWQgb2ZmIG9mIHRoZSBwbHVnaW4gYnkgQ2xpbnQgSGVsZmVycywgd2l0aCBwZXJtaXNzaW9uLlxuLy8gaHR0cHM6Ly93ZWIuYXJjaGl2ZS5vcmcvd2ViLzIwMTAwMzI0MDE0NzQ3L2h0dHA6Ly9ibGluZHNpZ25hbHMuY29tL2luZGV4LnBocC8yMDA5LzA3L2pxdWVyeS1kZWxheS9cbmpRdWVyeS5mbi5kZWxheSA9IGZ1bmN0aW9uKCB0aW1lLCB0eXBlICkge1xuXHR0aW1lID0galF1ZXJ5LmZ4ID8galF1ZXJ5LmZ4LnNwZWVkc1sgdGltZSBdIHx8IHRpbWUgOiB0aW1lO1xuXHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cblx0cmV0dXJuIHRoaXMucXVldWUoIHR5cGUsIGZ1bmN0aW9uKCBuZXh0LCBob29rcyApIHtcblx0XHR2YXIgdGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KCBuZXh0LCB0aW1lICk7XG5cdFx0aG9va3Muc3RvcCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0d2luZG93LmNsZWFyVGltZW91dCggdGltZW91dCApO1xuXHRcdH07XG5cdH0gKTtcbn07XG5cblxuKCBmdW5jdGlvbigpIHtcblx0dmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICksXG5cdFx0c2VsZWN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJzZWxlY3RcIiApLFxuXHRcdG9wdCA9IHNlbGVjdC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJvcHRpb25cIiApICk7XG5cblx0aW5wdXQudHlwZSA9IFwiY2hlY2tib3hcIjtcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4zIG9ubHlcblx0Ly8gRGVmYXVsdCB2YWx1ZSBmb3IgYSBjaGVja2JveCBzaG91bGQgYmUgXCJvblwiXG5cdHN1cHBvcnQuY2hlY2tPbiA9IGlucHV0LnZhbHVlICE9PSBcIlwiO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHQvLyBNdXN0IGFjY2VzcyBzZWxlY3RlZEluZGV4IHRvIG1ha2UgZGVmYXVsdCBvcHRpb25zIHNlbGVjdFxuXHRzdXBwb3J0Lm9wdFNlbGVjdGVkID0gb3B0LnNlbGVjdGVkO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHQvLyBBbiBpbnB1dCBsb3NlcyBpdHMgdmFsdWUgYWZ0ZXIgYmVjb21pbmcgYSByYWRpb1xuXHRpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApO1xuXHRpbnB1dC52YWx1ZSA9IFwidFwiO1xuXHRpbnB1dC50eXBlID0gXCJyYWRpb1wiO1xuXHRzdXBwb3J0LnJhZGlvVmFsdWUgPSBpbnB1dC52YWx1ZSA9PT0gXCJ0XCI7XG59ICkoKTtcblxuXG52YXIgYm9vbEhvb2ssXG5cdGF0dHJIYW5kbGUgPSBqUXVlcnkuZXhwci5hdHRySGFuZGxlO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGF0dHI6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBqUXVlcnkuYXR0ciwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxICk7XG5cdH0sXG5cblx0cmVtb3ZlQXR0cjogZnVuY3Rpb24oIG5hbWUgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkucmVtb3ZlQXR0ciggdGhpcywgbmFtZSApO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdGF0dHI6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcblx0XHR2YXIgcmV0LCBob29rcyxcblx0XHRcdG5UeXBlID0gZWxlbS5ub2RlVHlwZTtcblxuXHRcdC8vIERvbid0IGdldC9zZXQgYXR0cmlidXRlcyBvbiB0ZXh0LCBjb21tZW50IGFuZCBhdHRyaWJ1dGUgbm9kZXNcblx0XHRpZiAoIG5UeXBlID09PSAzIHx8IG5UeXBlID09PSA4IHx8IG5UeXBlID09PSAyICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIEZhbGxiYWNrIHRvIHByb3Agd2hlbiBhdHRyaWJ1dGVzIGFyZSBub3Qgc3VwcG9ydGVkXG5cdFx0aWYgKCB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGUgPT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LnByb3AoIGVsZW0sIG5hbWUsIHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0Ly8gQXR0cmlidXRlIGhvb2tzIGFyZSBkZXRlcm1pbmVkIGJ5IHRoZSBsb3dlcmNhc2UgdmVyc2lvblxuXHRcdC8vIEdyYWIgbmVjZXNzYXJ5IGhvb2sgaWYgb25lIGlzIGRlZmluZWRcblx0XHRpZiAoIG5UeXBlICE9PSAxIHx8ICFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcblx0XHRcdGhvb2tzID0galF1ZXJ5LmF0dHJIb29rc1sgbmFtZS50b0xvd2VyQ2FzZSgpIF0gfHxcblx0XHRcdFx0KCBqUXVlcnkuZXhwci5tYXRjaC5ib29sLnRlc3QoIG5hbWUgKSA/IGJvb2xIb29rIDogdW5kZWZpbmVkICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gbnVsbCApIHtcblx0XHRcdFx0alF1ZXJ5LnJlbW92ZUF0dHIoIGVsZW0sIG5hbWUgKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGhvb2tzICYmIFwic2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0KCByZXQgPSBob29rcy5zZXQoIGVsZW0sIHZhbHVlLCBuYW1lICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggbmFtZSwgdmFsdWUgKyBcIlwiICk7XG5cdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0fVxuXG5cdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmICggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBuYW1lICkgKSAhPT0gbnVsbCApIHtcblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXG5cdFx0cmV0ID0galF1ZXJ5LmZpbmQuYXR0ciggZWxlbSwgbmFtZSApO1xuXG5cdFx0Ly8gTm9uLWV4aXN0ZW50IGF0dHJpYnV0ZXMgcmV0dXJuIG51bGwsIHdlIG5vcm1hbGl6ZSB0byB1bmRlZmluZWRcblx0XHRyZXR1cm4gcmV0ID09IG51bGwgPyB1bmRlZmluZWQgOiByZXQ7XG5cdH0sXG5cblx0YXR0ckhvb2tzOiB7XG5cdFx0dHlwZToge1xuXHRcdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHRcdGlmICggIXN1cHBvcnQucmFkaW9WYWx1ZSAmJiB2YWx1ZSA9PT0gXCJyYWRpb1wiICYmXG5cdFx0XHRcdFx0alF1ZXJ5Lm5vZGVOYW1lKCBlbGVtLCBcImlucHV0XCIgKSApIHtcblx0XHRcdFx0XHR2YXIgdmFsID0gZWxlbS52YWx1ZTtcblx0XHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggXCJ0eXBlXCIsIHZhbHVlICk7XG5cdFx0XHRcdFx0aWYgKCB2YWwgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLnZhbHVlID0gdmFsO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0cmVtb3ZlQXR0cjogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdHZhciBuYW1lLFxuXHRcdFx0aSA9IDAsXG5cblx0XHRcdC8vIEF0dHJpYnV0ZSBuYW1lcyBjYW4gY29udGFpbiBub24tSFRNTCB3aGl0ZXNwYWNlIGNoYXJhY3RlcnNcblx0XHRcdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2F0dHJpYnV0ZXMtMlxuXHRcdFx0YXR0ck5hbWVzID0gdmFsdWUgJiYgdmFsdWUubWF0Y2goIHJub3RodG1sd2hpdGUgKTtcblxuXHRcdGlmICggYXR0ck5hbWVzICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHR3aGlsZSAoICggbmFtZSA9IGF0dHJOYW1lc1sgaSsrIF0gKSApIHtcblx0XHRcdFx0ZWxlbS5yZW1vdmVBdHRyaWJ1dGUoIG5hbWUgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0gKTtcblxuLy8gSG9va3MgZm9yIGJvb2xlYW4gYXR0cmlidXRlc1xuYm9vbEhvb2sgPSB7XG5cdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlLCBuYW1lICkge1xuXHRcdGlmICggdmFsdWUgPT09IGZhbHNlICkge1xuXG5cdFx0XHQvLyBSZW1vdmUgYm9vbGVhbiBhdHRyaWJ1dGVzIHdoZW4gc2V0IHRvIGZhbHNlXG5cdFx0XHRqUXVlcnkucmVtb3ZlQXR0ciggZWxlbSwgbmFtZSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggbmFtZSwgbmFtZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gbmFtZTtcblx0fVxufTtcblxualF1ZXJ5LmVhY2goIGpRdWVyeS5leHByLm1hdGNoLmJvb2wuc291cmNlLm1hdGNoKCAvXFx3Ky9nICksIGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXHR2YXIgZ2V0dGVyID0gYXR0ckhhbmRsZVsgbmFtZSBdIHx8IGpRdWVyeS5maW5kLmF0dHI7XG5cblx0YXR0ckhhbmRsZVsgbmFtZSBdID0gZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdHZhciByZXQsIGhhbmRsZSxcblx0XHRcdGxvd2VyY2FzZU5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cblx0XHRpZiAoICFpc1hNTCApIHtcblxuXHRcdFx0Ly8gQXZvaWQgYW4gaW5maW5pdGUgbG9vcCBieSB0ZW1wb3JhcmlseSByZW1vdmluZyB0aGlzIGZ1bmN0aW9uIGZyb20gdGhlIGdldHRlclxuXHRcdFx0aGFuZGxlID0gYXR0ckhhbmRsZVsgbG93ZXJjYXNlTmFtZSBdO1xuXHRcdFx0YXR0ckhhbmRsZVsgbG93ZXJjYXNlTmFtZSBdID0gcmV0O1xuXHRcdFx0cmV0ID0gZ2V0dGVyKCBlbGVtLCBuYW1lLCBpc1hNTCApICE9IG51bGwgP1xuXHRcdFx0XHRsb3dlcmNhc2VOYW1lIDpcblx0XHRcdFx0bnVsbDtcblx0XHRcdGF0dHJIYW5kbGVbIGxvd2VyY2FzZU5hbWUgXSA9IGhhbmRsZTtcblx0XHR9XG5cdFx0cmV0dXJuIHJldDtcblx0fTtcbn0gKTtcblxuXG5cblxudmFyIHJmb2N1c2FibGUgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b24pJC9pLFxuXHRyY2xpY2thYmxlID0gL14oPzphfGFyZWEpJC9pO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHByb3A6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBqUXVlcnkucHJvcCwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxICk7XG5cdH0sXG5cblx0cmVtb3ZlUHJvcDogZnVuY3Rpb24oIG5hbWUgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRkZWxldGUgdGhpc1sgalF1ZXJ5LnByb3BGaXhbIG5hbWUgXSB8fCBuYW1lIF07XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0cHJvcDogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xuXHRcdHZhciByZXQsIGhvb2tzLFxuXHRcdFx0blR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG5cdFx0Ly8gRG9uJ3QgZ2V0L3NldCBwcm9wZXJ0aWVzIG9uIHRleHQsIGNvbW1lbnQgYW5kIGF0dHJpYnV0ZSBub2Rlc1xuXHRcdGlmICggblR5cGUgPT09IDMgfHwgblR5cGUgPT09IDggfHwgblR5cGUgPT09IDIgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCBuVHlwZSAhPT0gMSB8fCAhalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICkgKSB7XG5cblx0XHRcdC8vIEZpeCBuYW1lIGFuZCBhdHRhY2ggaG9va3Ncblx0XHRcdG5hbWUgPSBqUXVlcnkucHJvcEZpeFsgbmFtZSBdIHx8IG5hbWU7XG5cdFx0XHRob29rcyA9IGpRdWVyeS5wcm9wSG9va3NbIG5hbWUgXTtcblx0XHR9XG5cblx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRpZiAoIGhvb2tzICYmIFwic2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0KCByZXQgPSBob29rcy5zZXQoIGVsZW0sIHZhbHVlLCBuYW1lICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gKCBlbGVtWyBuYW1lIF0gPSB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJiAoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgbmFtZSApICkgIT09IG51bGwgKSB7XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH1cblxuXHRcdHJldHVybiBlbGVtWyBuYW1lIF07XG5cdH0sXG5cblx0cHJvcEhvb2tzOiB7XG5cdFx0dGFiSW5kZXg6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxuXHRcdFx0XHQvLyBlbGVtLnRhYkluZGV4IGRvZXNuJ3QgYWx3YXlzIHJldHVybiB0aGVcblx0XHRcdFx0Ly8gY29ycmVjdCB2YWx1ZSB3aGVuIGl0IGhhc24ndCBiZWVuIGV4cGxpY2l0bHkgc2V0XG5cdFx0XHRcdC8vIGh0dHBzOi8vd2ViLmFyY2hpdmUub3JnL3dlYi8yMDE0MTExNjIzMzM0Ny9odHRwOi8vZmx1aWRwcm9qZWN0Lm9yZy9ibG9nLzIwMDgvMDEvMDkvZ2V0dGluZy1zZXR0aW5nLWFuZC1yZW1vdmluZy10YWJpbmRleC12YWx1ZXMtd2l0aC1qYXZhc2NyaXB0L1xuXHRcdFx0XHQvLyBVc2UgcHJvcGVyIGF0dHJpYnV0ZSByZXRyaWV2YWwoIzEyMDcyKVxuXHRcdFx0XHR2YXIgdGFiaW5kZXggPSBqUXVlcnkuZmluZC5hdHRyKCBlbGVtLCBcInRhYmluZGV4XCIgKTtcblxuXHRcdFx0XHRpZiAoIHRhYmluZGV4ICkge1xuXHRcdFx0XHRcdHJldHVybiBwYXJzZUludCggdGFiaW5kZXgsIDEwICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0cmZvY3VzYWJsZS50ZXN0KCBlbGVtLm5vZGVOYW1lICkgfHxcblx0XHRcdFx0XHRyY2xpY2thYmxlLnRlc3QoIGVsZW0ubm9kZU5hbWUgKSAmJlxuXHRcdFx0XHRcdGVsZW0uaHJlZlxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRyZXR1cm4gMDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiAtMTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0cHJvcEZpeDoge1xuXHRcdFwiZm9yXCI6IFwiaHRtbEZvclwiLFxuXHRcdFwiY2xhc3NcIjogXCJjbGFzc05hbWVcIlxuXHR9XG59ICk7XG5cbi8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuLy8gQWNjZXNzaW5nIHRoZSBzZWxlY3RlZEluZGV4IHByb3BlcnR5XG4vLyBmb3JjZXMgdGhlIGJyb3dzZXIgdG8gcmVzcGVjdCBzZXR0aW5nIHNlbGVjdGVkXG4vLyBvbiB0aGUgb3B0aW9uXG4vLyBUaGUgZ2V0dGVyIGVuc3VyZXMgYSBkZWZhdWx0IG9wdGlvbiBpcyBzZWxlY3RlZFxuLy8gd2hlbiBpbiBhbiBvcHRncm91cFxuLy8gZXNsaW50IHJ1bGUgXCJuby11bnVzZWQtZXhwcmVzc2lvbnNcIiBpcyBkaXNhYmxlZCBmb3IgdGhpcyBjb2RlXG4vLyBzaW5jZSBpdCBjb25zaWRlcnMgc3VjaCBhY2Nlc3Npb25zIG5vb3BcbmlmICggIXN1cHBvcnQub3B0U2VsZWN0ZWQgKSB7XG5cdGpRdWVyeS5wcm9wSG9va3Muc2VsZWN0ZWQgPSB7XG5cdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0LyogZXNsaW50IG5vLXVudXNlZC1leHByZXNzaW9uczogXCJvZmZcIiAqL1xuXG5cdFx0XHR2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuXHRcdFx0aWYgKCBwYXJlbnQgJiYgcGFyZW50LnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHBhcmVudC5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9LFxuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdC8qIGVzbGludCBuby11bnVzZWQtZXhwcmVzc2lvbnM6IFwib2ZmXCIgKi9cblxuXHRcdFx0dmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcblx0XHRcdGlmICggcGFyZW50ICkge1xuXHRcdFx0XHRwYXJlbnQuc2VsZWN0ZWRJbmRleDtcblxuXHRcdFx0XHRpZiAoIHBhcmVudC5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRcdHBhcmVudC5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH07XG59XG5cbmpRdWVyeS5lYWNoKCBbXG5cdFwidGFiSW5kZXhcIixcblx0XCJyZWFkT25seVwiLFxuXHRcIm1heExlbmd0aFwiLFxuXHRcImNlbGxTcGFjaW5nXCIsXG5cdFwiY2VsbFBhZGRpbmdcIixcblx0XCJyb3dTcGFuXCIsXG5cdFwiY29sU3BhblwiLFxuXHRcInVzZU1hcFwiLFxuXHRcImZyYW1lQm9yZGVyXCIsXG5cdFwiY29udGVudEVkaXRhYmxlXCJcbl0sIGZ1bmN0aW9uKCkge1xuXHRqUXVlcnkucHJvcEZpeFsgdGhpcy50b0xvd2VyQ2FzZSgpIF0gPSB0aGlzO1xufSApO1xuXG5cblxuXG5cdC8vIFN0cmlwIGFuZCBjb2xsYXBzZSB3aGl0ZXNwYWNlIGFjY29yZGluZyB0byBIVE1MIHNwZWNcblx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW5mcmFzdHJ1Y3R1cmUuaHRtbCNzdHJpcC1hbmQtY29sbGFwc2Utd2hpdGVzcGFjZVxuXHRmdW5jdGlvbiBzdHJpcEFuZENvbGxhcHNlKCB2YWx1ZSApIHtcblx0XHR2YXIgdG9rZW5zID0gdmFsdWUubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXTtcblx0XHRyZXR1cm4gdG9rZW5zLmpvaW4oIFwiIFwiICk7XG5cdH1cblxuXG5mdW5jdGlvbiBnZXRDbGFzcyggZWxlbSApIHtcblx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlICYmIGVsZW0uZ2V0QXR0cmlidXRlKCBcImNsYXNzXCIgKSB8fCBcIlwiO1xufVxuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGFkZENsYXNzOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dmFyIGNsYXNzZXMsIGVsZW0sIGN1ciwgY3VyVmFsdWUsIGNsYXp6LCBqLCBmaW5hbFZhbHVlLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGogKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLmFkZENsYXNzKCB2YWx1ZS5jYWxsKCB0aGlzLCBqLCBnZXRDbGFzcyggdGhpcyApICkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiB2YWx1ZSApIHtcblx0XHRcdGNsYXNzZXMgPSB2YWx1ZS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdO1xuXG5cdFx0XHR3aGlsZSAoICggZWxlbSA9IHRoaXNbIGkrKyBdICkgKSB7XG5cdFx0XHRcdGN1clZhbHVlID0gZ2V0Q2xhc3MoIGVsZW0gKTtcblx0XHRcdFx0Y3VyID0gZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAoIFwiIFwiICsgc3RyaXBBbmRDb2xsYXBzZSggY3VyVmFsdWUgKSArIFwiIFwiICk7XG5cblx0XHRcdFx0aWYgKCBjdXIgKSB7XG5cdFx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdFx0d2hpbGUgKCAoIGNsYXp6ID0gY2xhc3Nlc1sgaisrIF0gKSApIHtcblx0XHRcdFx0XHRcdGlmICggY3VyLmluZGV4T2YoIFwiIFwiICsgY2xhenogKyBcIiBcIiApIDwgMCApIHtcblx0XHRcdFx0XHRcdFx0Y3VyICs9IGNsYXp6ICsgXCIgXCI7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gT25seSBhc3NpZ24gaWYgZGlmZmVyZW50IHRvIGF2b2lkIHVubmVlZGVkIHJlbmRlcmluZy5cblx0XHRcdFx0XHRmaW5hbFZhbHVlID0gc3RyaXBBbmRDb2xsYXBzZSggY3VyICk7XG5cdFx0XHRcdFx0aWYgKCBjdXJWYWx1ZSAhPT0gZmluYWxWYWx1ZSApIHtcblx0XHRcdFx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBcImNsYXNzXCIsIGZpbmFsVmFsdWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRyZW1vdmVDbGFzczogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBjbGFzc2VzLCBlbGVtLCBjdXIsIGN1clZhbHVlLCBjbGF6eiwgaiwgZmluYWxWYWx1ZSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBqICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5yZW1vdmVDbGFzcyggdmFsdWUuY2FsbCggdGhpcywgaiwgZ2V0Q2xhc3MoIHRoaXMgKSApICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0aWYgKCAhYXJndW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdHJldHVybiB0aGlzLmF0dHIoIFwiY2xhc3NcIiwgXCJcIiApO1xuXHRcdH1cblxuXHRcdGlmICggdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmIHZhbHVlICkge1xuXHRcdFx0Y2xhc3NlcyA9IHZhbHVlLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW107XG5cblx0XHRcdHdoaWxlICggKCBlbGVtID0gdGhpc1sgaSsrIF0gKSApIHtcblx0XHRcdFx0Y3VyVmFsdWUgPSBnZXRDbGFzcyggZWxlbSApO1xuXG5cdFx0XHRcdC8vIFRoaXMgZXhwcmVzc2lvbiBpcyBoZXJlIGZvciBiZXR0ZXIgY29tcHJlc3NpYmlsaXR5IChzZWUgYWRkQ2xhc3MpXG5cdFx0XHRcdGN1ciA9IGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgKCBcIiBcIiArIHN0cmlwQW5kQ29sbGFwc2UoIGN1clZhbHVlICkgKyBcIiBcIiApO1xuXG5cdFx0XHRcdGlmICggY3VyICkge1xuXHRcdFx0XHRcdGogPSAwO1xuXHRcdFx0XHRcdHdoaWxlICggKCBjbGF6eiA9IGNsYXNzZXNbIGorKyBdICkgKSB7XG5cblx0XHRcdFx0XHRcdC8vIFJlbW92ZSAqYWxsKiBpbnN0YW5jZXNcblx0XHRcdFx0XHRcdHdoaWxlICggY3VyLmluZGV4T2YoIFwiIFwiICsgY2xhenogKyBcIiBcIiApID4gLTEgKSB7XG5cdFx0XHRcdFx0XHRcdGN1ciA9IGN1ci5yZXBsYWNlKCBcIiBcIiArIGNsYXp6ICsgXCIgXCIsIFwiIFwiICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gT25seSBhc3NpZ24gaWYgZGlmZmVyZW50IHRvIGF2b2lkIHVubmVlZGVkIHJlbmRlcmluZy5cblx0XHRcdFx0XHRmaW5hbFZhbHVlID0gc3RyaXBBbmRDb2xsYXBzZSggY3VyICk7XG5cdFx0XHRcdFx0aWYgKCBjdXJWYWx1ZSAhPT0gZmluYWxWYWx1ZSApIHtcblx0XHRcdFx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBcImNsYXNzXCIsIGZpbmFsVmFsdWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHR0b2dnbGVDbGFzczogZnVuY3Rpb24oIHZhbHVlLCBzdGF0ZVZhbCApIHtcblx0XHR2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcblxuXHRcdGlmICggdHlwZW9mIHN0YXRlVmFsID09PSBcImJvb2xlYW5cIiAmJiB0eXBlID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIHN0YXRlVmFsID8gdGhpcy5hZGRDbGFzcyggdmFsdWUgKSA6IHRoaXMucmVtb3ZlQ2xhc3MoIHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS50b2dnbGVDbGFzcyhcblx0XHRcdFx0XHR2YWx1ZS5jYWxsKCB0aGlzLCBpLCBnZXRDbGFzcyggdGhpcyApLCBzdGF0ZVZhbCApLFxuXHRcdFx0XHRcdHN0YXRlVmFsXG5cdFx0XHRcdCk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgY2xhc3NOYW1lLCBpLCBzZWxmLCBjbGFzc05hbWVzO1xuXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdFx0Ly8gVG9nZ2xlIGluZGl2aWR1YWwgY2xhc3MgbmFtZXNcblx0XHRcdFx0aSA9IDA7XG5cdFx0XHRcdHNlbGYgPSBqUXVlcnkoIHRoaXMgKTtcblx0XHRcdFx0Y2xhc3NOYW1lcyA9IHZhbHVlLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW107XG5cblx0XHRcdFx0d2hpbGUgKCAoIGNsYXNzTmFtZSA9IGNsYXNzTmFtZXNbIGkrKyBdICkgKSB7XG5cblx0XHRcdFx0XHQvLyBDaGVjayBlYWNoIGNsYXNzTmFtZSBnaXZlbiwgc3BhY2Ugc2VwYXJhdGVkIGxpc3Rcblx0XHRcdFx0XHRpZiAoIHNlbGYuaGFzQ2xhc3MoIGNsYXNzTmFtZSApICkge1xuXHRcdFx0XHRcdFx0c2VsZi5yZW1vdmVDbGFzcyggY2xhc3NOYW1lICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHNlbGYuYWRkQ2xhc3MoIGNsYXNzTmFtZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBUb2dnbGUgd2hvbGUgY2xhc3MgbmFtZVxuXHRcdFx0fSBlbHNlIGlmICggdmFsdWUgPT09IHVuZGVmaW5lZCB8fCB0eXBlID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRcdFx0Y2xhc3NOYW1lID0gZ2V0Q2xhc3MoIHRoaXMgKTtcblx0XHRcdFx0aWYgKCBjbGFzc05hbWUgKSB7XG5cblx0XHRcdFx0XHQvLyBTdG9yZSBjbGFzc05hbWUgaWYgc2V0XG5cdFx0XHRcdFx0ZGF0YVByaXYuc2V0KCB0aGlzLCBcIl9fY2xhc3NOYW1lX19cIiwgY2xhc3NOYW1lICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBJZiB0aGUgZWxlbWVudCBoYXMgYSBjbGFzcyBuYW1lIG9yIGlmIHdlJ3JlIHBhc3NlZCBgZmFsc2VgLFxuXHRcdFx0XHQvLyB0aGVuIHJlbW92ZSB0aGUgd2hvbGUgY2xhc3NuYW1lIChpZiB0aGVyZSB3YXMgb25lLCB0aGUgYWJvdmUgc2F2ZWQgaXQpLlxuXHRcdFx0XHQvLyBPdGhlcndpc2UgYnJpbmcgYmFjayB3aGF0ZXZlciB3YXMgcHJldmlvdXNseSBzYXZlZCAoaWYgYW55dGhpbmcpLFxuXHRcdFx0XHQvLyBmYWxsaW5nIGJhY2sgdG8gdGhlIGVtcHR5IHN0cmluZyBpZiBub3RoaW5nIHdhcyBzdG9yZWQuXG5cdFx0XHRcdGlmICggdGhpcy5zZXRBdHRyaWJ1dGUgKSB7XG5cdFx0XHRcdFx0dGhpcy5zZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIixcblx0XHRcdFx0XHRcdGNsYXNzTmFtZSB8fCB2YWx1ZSA9PT0gZmFsc2UgP1xuXHRcdFx0XHRcdFx0XCJcIiA6XG5cdFx0XHRcdFx0XHRkYXRhUHJpdi5nZXQoIHRoaXMsIFwiX19jbGFzc05hbWVfX1wiICkgfHwgXCJcIlxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0aGFzQ2xhc3M6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR2YXIgY2xhc3NOYW1lLCBlbGVtLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRjbGFzc05hbWUgPSBcIiBcIiArIHNlbGVjdG9yICsgXCIgXCI7XG5cdFx0d2hpbGUgKCAoIGVsZW0gPSB0aGlzWyBpKysgXSApICkge1xuXHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRcdCggXCIgXCIgKyBzdHJpcEFuZENvbGxhcHNlKCBnZXRDbGFzcyggZWxlbSApICkgKyBcIiBcIiApLmluZGV4T2YoIGNsYXNzTmFtZSApID4gLTEgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59ICk7XG5cblxuXG5cbnZhciBycmV0dXJuID0gL1xcci9nO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHZhbDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBob29rcywgcmV0LCBpc0Z1bmN0aW9uLFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXTtcblxuXHRcdGlmICggIWFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHRcdGhvb2tzID0galF1ZXJ5LnZhbEhvb2tzWyBlbGVtLnR5cGUgXSB8fFxuXHRcdFx0XHRcdGpRdWVyeS52YWxIb29rc1sgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIF07XG5cblx0XHRcdFx0aWYgKCBob29rcyAmJlxuXHRcdFx0XHRcdFwiZ2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0XHQoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgXCJ2YWx1ZVwiICkgKSAhPT0gdW5kZWZpbmVkXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXQgPSBlbGVtLnZhbHVlO1xuXG5cdFx0XHRcdC8vIEhhbmRsZSBtb3N0IGNvbW1vbiBzdHJpbmcgY2FzZXNcblx0XHRcdFx0aWYgKCB0eXBlb2YgcmV0ID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0XHRcdHJldHVybiByZXQucmVwbGFjZSggcnJldHVybiwgXCJcIiApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSGFuZGxlIGNhc2VzIHdoZXJlIHZhbHVlIGlzIG51bGwvdW5kZWYgb3IgbnVtYmVyXG5cdFx0XHRcdHJldHVybiByZXQgPT0gbnVsbCA/IFwiXCIgOiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpc0Z1bmN0aW9uID0galF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICk7XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdHZhciB2YWw7XG5cblx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSAhPT0gMSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGlzRnVuY3Rpb24gKSB7XG5cdFx0XHRcdHZhbCA9IHZhbHVlLmNhbGwoIHRoaXMsIGksIGpRdWVyeSggdGhpcyApLnZhbCgpICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YWwgPSB2YWx1ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVHJlYXQgbnVsbC91bmRlZmluZWQgYXMgXCJcIjsgY29udmVydCBudW1iZXJzIHRvIHN0cmluZ1xuXHRcdFx0aWYgKCB2YWwgPT0gbnVsbCApIHtcblx0XHRcdFx0dmFsID0gXCJcIjtcblxuXHRcdFx0fSBlbHNlIGlmICggdHlwZW9mIHZhbCA9PT0gXCJudW1iZXJcIiApIHtcblx0XHRcdFx0dmFsICs9IFwiXCI7XG5cblx0XHRcdH0gZWxzZSBpZiAoIGpRdWVyeS5pc0FycmF5KCB2YWwgKSApIHtcblx0XHRcdFx0dmFsID0galF1ZXJ5Lm1hcCggdmFsLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHZhbHVlID09IG51bGwgPyBcIlwiIDogdmFsdWUgKyBcIlwiO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cblx0XHRcdGhvb2tzID0galF1ZXJ5LnZhbEhvb2tzWyB0aGlzLnR5cGUgXSB8fCBqUXVlcnkudmFsSG9va3NbIHRoaXMubm9kZU5hbWUudG9Mb3dlckNhc2UoKSBdO1xuXG5cdFx0XHQvLyBJZiBzZXQgcmV0dXJucyB1bmRlZmluZWQsIGZhbGwgYmFjayB0byBub3JtYWwgc2V0dGluZ1xuXHRcdFx0aWYgKCAhaG9va3MgfHwgISggXCJzZXRcIiBpbiBob29rcyApIHx8IGhvb2tzLnNldCggdGhpcywgdmFsLCBcInZhbHVlXCIgKSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHR0aGlzLnZhbHVlID0gdmFsO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdHZhbEhvb2tzOiB7XG5cdFx0b3B0aW9uOiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHRcdHZhciB2YWwgPSBqUXVlcnkuZmluZC5hdHRyKCBlbGVtLCBcInZhbHVlXCIgKTtcblx0XHRcdFx0cmV0dXJuIHZhbCAhPSBudWxsID9cblx0XHRcdFx0XHR2YWwgOlxuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD0xMCAtIDExIG9ubHlcblx0XHRcdFx0XHQvLyBvcHRpb24udGV4dCB0aHJvd3MgZXhjZXB0aW9ucyAoIzE0Njg2LCAjMTQ4NTgpXG5cdFx0XHRcdFx0Ly8gU3RyaXAgYW5kIGNvbGxhcHNlIHdoaXRlc3BhY2Vcblx0XHRcdFx0XHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnLyNzdHJpcC1hbmQtY29sbGFwc2Utd2hpdGVzcGFjZVxuXHRcdFx0XHRcdHN0cmlwQW5kQ29sbGFwc2UoIGpRdWVyeS50ZXh0KCBlbGVtICkgKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdHNlbGVjdDoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIHZhbHVlLCBvcHRpb24sIGksXG5cdFx0XHRcdFx0b3B0aW9ucyA9IGVsZW0ub3B0aW9ucyxcblx0XHRcdFx0XHRpbmRleCA9IGVsZW0uc2VsZWN0ZWRJbmRleCxcblx0XHRcdFx0XHRvbmUgPSBlbGVtLnR5cGUgPT09IFwic2VsZWN0LW9uZVwiLFxuXHRcdFx0XHRcdHZhbHVlcyA9IG9uZSA/IG51bGwgOiBbXSxcblx0XHRcdFx0XHRtYXggPSBvbmUgPyBpbmRleCArIDEgOiBvcHRpb25zLmxlbmd0aDtcblxuXHRcdFx0XHRpZiAoIGluZGV4IDwgMCApIHtcblx0XHRcdFx0XHRpID0gbWF4O1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aSA9IG9uZSA/IGluZGV4IDogMDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIExvb3AgdGhyb3VnaCBhbGwgdGhlIHNlbGVjdGVkIG9wdGlvbnNcblx0XHRcdFx0Zm9yICggOyBpIDwgbWF4OyBpKysgKSB7XG5cdFx0XHRcdFx0b3B0aW9uID0gb3B0aW9uc1sgaSBdO1xuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0XHRcdFx0XHQvLyBJRTgtOSBkb2Vzbid0IHVwZGF0ZSBzZWxlY3RlZCBhZnRlciBmb3JtIHJlc2V0ICgjMjU1MSlcblx0XHRcdFx0XHRpZiAoICggb3B0aW9uLnNlbGVjdGVkIHx8IGkgPT09IGluZGV4ICkgJiZcblxuXHRcdFx0XHRcdFx0XHQvLyBEb24ndCByZXR1cm4gb3B0aW9ucyB0aGF0IGFyZSBkaXNhYmxlZCBvciBpbiBhIGRpc2FibGVkIG9wdGdyb3VwXG5cdFx0XHRcdFx0XHRcdCFvcHRpb24uZGlzYWJsZWQgJiZcblx0XHRcdFx0XHRcdFx0KCAhb3B0aW9uLnBhcmVudE5vZGUuZGlzYWJsZWQgfHxcblx0XHRcdFx0XHRcdFx0XHQhalF1ZXJ5Lm5vZGVOYW1lKCBvcHRpb24ucGFyZW50Tm9kZSwgXCJvcHRncm91cFwiICkgKSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gR2V0IHRoZSBzcGVjaWZpYyB2YWx1ZSBmb3IgdGhlIG9wdGlvblxuXHRcdFx0XHRcdFx0dmFsdWUgPSBqUXVlcnkoIG9wdGlvbiApLnZhbCgpO1xuXG5cdFx0XHRcdFx0XHQvLyBXZSBkb24ndCBuZWVkIGFuIGFycmF5IGZvciBvbmUgc2VsZWN0c1xuXHRcdFx0XHRcdFx0aWYgKCBvbmUgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gTXVsdGktU2VsZWN0cyByZXR1cm4gYW4gYXJyYXlcblx0XHRcdFx0XHRcdHZhbHVlcy5wdXNoKCB2YWx1ZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB2YWx1ZXM7XG5cdFx0XHR9LFxuXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdFx0dmFyIG9wdGlvblNldCwgb3B0aW9uLFxuXHRcdFx0XHRcdG9wdGlvbnMgPSBlbGVtLm9wdGlvbnMsXG5cdFx0XHRcdFx0dmFsdWVzID0galF1ZXJ5Lm1ha2VBcnJheSggdmFsdWUgKSxcblx0XHRcdFx0XHRpID0gb3B0aW9ucy5sZW5ndGg7XG5cblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0b3B0aW9uID0gb3B0aW9uc1sgaSBdO1xuXG5cdFx0XHRcdFx0LyogZXNsaW50LWRpc2FibGUgbm8tY29uZC1hc3NpZ24gKi9cblxuXHRcdFx0XHRcdGlmICggb3B0aW9uLnNlbGVjdGVkID1cblx0XHRcdFx0XHRcdGpRdWVyeS5pbkFycmF5KCBqUXVlcnkudmFsSG9va3Mub3B0aW9uLmdldCggb3B0aW9uICksIHZhbHVlcyApID4gLTFcblx0XHRcdFx0XHQpIHtcblx0XHRcdFx0XHRcdG9wdGlvblNldCA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0LyogZXNsaW50LWVuYWJsZSBuby1jb25kLWFzc2lnbiAqL1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gRm9yY2UgYnJvd3NlcnMgdG8gYmVoYXZlIGNvbnNpc3RlbnRseSB3aGVuIG5vbi1tYXRjaGluZyB2YWx1ZSBpcyBzZXRcblx0XHRcdFx0aWYgKCAhb3B0aW9uU2V0ICkge1xuXHRcdFx0XHRcdGVsZW0uc2VsZWN0ZWRJbmRleCA9IC0xO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB2YWx1ZXM7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59ICk7XG5cbi8vIFJhZGlvcyBhbmQgY2hlY2tib3hlcyBnZXR0ZXIvc2V0dGVyXG5qUXVlcnkuZWFjaCggWyBcInJhZGlvXCIsIFwiY2hlY2tib3hcIiBdLCBmdW5jdGlvbigpIHtcblx0alF1ZXJ5LnZhbEhvb2tzWyB0aGlzIF0gPSB7XG5cdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHRpZiAoIGpRdWVyeS5pc0FycmF5KCB2YWx1ZSApICkge1xuXHRcdFx0XHRyZXR1cm4gKCBlbGVtLmNoZWNrZWQgPSBqUXVlcnkuaW5BcnJheSggalF1ZXJ5KCBlbGVtICkudmFsKCksIHZhbHVlICkgPiAtMSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblx0aWYgKCAhc3VwcG9ydC5jaGVja09uICkge1xuXHRcdGpRdWVyeS52YWxIb29rc1sgdGhpcyBdLmdldCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKCBcInZhbHVlXCIgKSA9PT0gbnVsbCA/IFwib25cIiA6IGVsZW0udmFsdWU7XG5cdFx0fTtcblx0fVxufSApO1xuXG5cblxuXG4vLyBSZXR1cm4galF1ZXJ5IGZvciBhdHRyaWJ1dGVzLW9ubHkgaW5jbHVzaW9uXG5cblxudmFyIHJmb2N1c01vcnBoID0gL14oPzpmb2N1c2luZm9jdXN8Zm9jdXNvdXRibHVyKSQvO1xuXG5qUXVlcnkuZXh0ZW5kKCBqUXVlcnkuZXZlbnQsIHtcblxuXHR0cmlnZ2VyOiBmdW5jdGlvbiggZXZlbnQsIGRhdGEsIGVsZW0sIG9ubHlIYW5kbGVycyApIHtcblxuXHRcdHZhciBpLCBjdXIsIHRtcCwgYnViYmxlVHlwZSwgb250eXBlLCBoYW5kbGUsIHNwZWNpYWwsXG5cdFx0XHRldmVudFBhdGggPSBbIGVsZW0gfHwgZG9jdW1lbnQgXSxcblx0XHRcdHR5cGUgPSBoYXNPd24uY2FsbCggZXZlbnQsIFwidHlwZVwiICkgPyBldmVudC50eXBlIDogZXZlbnQsXG5cdFx0XHRuYW1lc3BhY2VzID0gaGFzT3duLmNhbGwoIGV2ZW50LCBcIm5hbWVzcGFjZVwiICkgPyBldmVudC5uYW1lc3BhY2Uuc3BsaXQoIFwiLlwiICkgOiBbXTtcblxuXHRcdGN1ciA9IHRtcCA9IGVsZW0gPSBlbGVtIHx8IGRvY3VtZW50O1xuXG5cdFx0Ly8gRG9uJ3QgZG8gZXZlbnRzIG9uIHRleHQgYW5kIGNvbW1lbnQgbm9kZXNcblx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDMgfHwgZWxlbS5ub2RlVHlwZSA9PT0gOCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBmb2N1cy9ibHVyIG1vcnBocyB0byBmb2N1c2luL291dDsgZW5zdXJlIHdlJ3JlIG5vdCBmaXJpbmcgdGhlbSByaWdodCBub3dcblx0XHRpZiAoIHJmb2N1c01vcnBoLnRlc3QoIHR5cGUgKyBqUXVlcnkuZXZlbnQudHJpZ2dlcmVkICkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCB0eXBlLmluZGV4T2YoIFwiLlwiICkgPiAtMSApIHtcblxuXHRcdFx0Ly8gTmFtZXNwYWNlZCB0cmlnZ2VyOyBjcmVhdGUgYSByZWdleHAgdG8gbWF0Y2ggZXZlbnQgdHlwZSBpbiBoYW5kbGUoKVxuXHRcdFx0bmFtZXNwYWNlcyA9IHR5cGUuc3BsaXQoIFwiLlwiICk7XG5cdFx0XHR0eXBlID0gbmFtZXNwYWNlcy5zaGlmdCgpO1xuXHRcdFx0bmFtZXNwYWNlcy5zb3J0KCk7XG5cdFx0fVxuXHRcdG9udHlwZSA9IHR5cGUuaW5kZXhPZiggXCI6XCIgKSA8IDAgJiYgXCJvblwiICsgdHlwZTtcblxuXHRcdC8vIENhbGxlciBjYW4gcGFzcyBpbiBhIGpRdWVyeS5FdmVudCBvYmplY3QsIE9iamVjdCwgb3IganVzdCBhbiBldmVudCB0eXBlIHN0cmluZ1xuXHRcdGV2ZW50ID0gZXZlbnRbIGpRdWVyeS5leHBhbmRvIF0gP1xuXHRcdFx0ZXZlbnQgOlxuXHRcdFx0bmV3IGpRdWVyeS5FdmVudCggdHlwZSwgdHlwZW9mIGV2ZW50ID09PSBcIm9iamVjdFwiICYmIGV2ZW50ICk7XG5cblx0XHQvLyBUcmlnZ2VyIGJpdG1hc2s6ICYgMSBmb3IgbmF0aXZlIGhhbmRsZXJzOyAmIDIgZm9yIGpRdWVyeSAoYWx3YXlzIHRydWUpXG5cdFx0ZXZlbnQuaXNUcmlnZ2VyID0gb25seUhhbmRsZXJzID8gMiA6IDM7XG5cdFx0ZXZlbnQubmFtZXNwYWNlID0gbmFtZXNwYWNlcy5qb2luKCBcIi5cIiApO1xuXHRcdGV2ZW50LnJuYW1lc3BhY2UgPSBldmVudC5uYW1lc3BhY2UgP1xuXHRcdFx0bmV3IFJlZ0V4cCggXCIoXnxcXFxcLilcIiArIG5hbWVzcGFjZXMuam9pbiggXCJcXFxcLig/Oi4qXFxcXC58KVwiICkgKyBcIihcXFxcLnwkKVwiICkgOlxuXHRcdFx0bnVsbDtcblxuXHRcdC8vIENsZWFuIHVwIHRoZSBldmVudCBpbiBjYXNlIGl0IGlzIGJlaW5nIHJldXNlZFxuXHRcdGV2ZW50LnJlc3VsdCA9IHVuZGVmaW5lZDtcblx0XHRpZiAoICFldmVudC50YXJnZXQgKSB7XG5cdFx0XHRldmVudC50YXJnZXQgPSBlbGVtO1xuXHRcdH1cblxuXHRcdC8vIENsb25lIGFueSBpbmNvbWluZyBkYXRhIGFuZCBwcmVwZW5kIHRoZSBldmVudCwgY3JlYXRpbmcgdGhlIGhhbmRsZXIgYXJnIGxpc3Rcblx0XHRkYXRhID0gZGF0YSA9PSBudWxsID9cblx0XHRcdFsgZXZlbnQgXSA6XG5cdFx0XHRqUXVlcnkubWFrZUFycmF5KCBkYXRhLCBbIGV2ZW50IF0gKTtcblxuXHRcdC8vIEFsbG93IHNwZWNpYWwgZXZlbnRzIHRvIGRyYXcgb3V0c2lkZSB0aGUgbGluZXNcblx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblx0XHRpZiAoICFvbmx5SGFuZGxlcnMgJiYgc3BlY2lhbC50cmlnZ2VyICYmIHNwZWNpYWwudHJpZ2dlci5hcHBseSggZWxlbSwgZGF0YSApID09PSBmYWxzZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBEZXRlcm1pbmUgZXZlbnQgcHJvcGFnYXRpb24gcGF0aCBpbiBhZHZhbmNlLCBwZXIgVzNDIGV2ZW50cyBzcGVjICgjOTk1MSlcblx0XHQvLyBCdWJibGUgdXAgdG8gZG9jdW1lbnQsIHRoZW4gdG8gd2luZG93OyB3YXRjaCBmb3IgYSBnbG9iYWwgb3duZXJEb2N1bWVudCB2YXIgKCM5NzI0KVxuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiAhc3BlY2lhbC5ub0J1YmJsZSAmJiAhalF1ZXJ5LmlzV2luZG93KCBlbGVtICkgKSB7XG5cblx0XHRcdGJ1YmJsZVR5cGUgPSBzcGVjaWFsLmRlbGVnYXRlVHlwZSB8fCB0eXBlO1xuXHRcdFx0aWYgKCAhcmZvY3VzTW9ycGgudGVzdCggYnViYmxlVHlwZSArIHR5cGUgKSApIHtcblx0XHRcdFx0Y3VyID0gY3VyLnBhcmVudE5vZGU7XG5cdFx0XHR9XG5cdFx0XHRmb3IgKCA7IGN1cjsgY3VyID0gY3VyLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdGV2ZW50UGF0aC5wdXNoKCBjdXIgKTtcblx0XHRcdFx0dG1wID0gY3VyO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBPbmx5IGFkZCB3aW5kb3cgaWYgd2UgZ290IHRvIGRvY3VtZW50IChlLmcuLCBub3QgcGxhaW4gb2JqIG9yIGRldGFjaGVkIERPTSlcblx0XHRcdGlmICggdG1wID09PSAoIGVsZW0ub3duZXJEb2N1bWVudCB8fCBkb2N1bWVudCApICkge1xuXHRcdFx0XHRldmVudFBhdGgucHVzaCggdG1wLmRlZmF1bHRWaWV3IHx8IHRtcC5wYXJlbnRXaW5kb3cgfHwgd2luZG93ICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gRmlyZSBoYW5kbGVycyBvbiB0aGUgZXZlbnQgcGF0aFxuXHRcdGkgPSAwO1xuXHRcdHdoaWxlICggKCBjdXIgPSBldmVudFBhdGhbIGkrKyBdICkgJiYgIWV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cblx0XHRcdGV2ZW50LnR5cGUgPSBpID4gMSA/XG5cdFx0XHRcdGJ1YmJsZVR5cGUgOlxuXHRcdFx0XHRzcGVjaWFsLmJpbmRUeXBlIHx8IHR5cGU7XG5cblx0XHRcdC8vIGpRdWVyeSBoYW5kbGVyXG5cdFx0XHRoYW5kbGUgPSAoIGRhdGFQcml2LmdldCggY3VyLCBcImV2ZW50c1wiICkgfHwge30gKVsgZXZlbnQudHlwZSBdICYmXG5cdFx0XHRcdGRhdGFQcml2LmdldCggY3VyLCBcImhhbmRsZVwiICk7XG5cdFx0XHRpZiAoIGhhbmRsZSApIHtcblx0XHRcdFx0aGFuZGxlLmFwcGx5KCBjdXIsIGRhdGEgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTmF0aXZlIGhhbmRsZXJcblx0XHRcdGhhbmRsZSA9IG9udHlwZSAmJiBjdXJbIG9udHlwZSBdO1xuXHRcdFx0aWYgKCBoYW5kbGUgJiYgaGFuZGxlLmFwcGx5ICYmIGFjY2VwdERhdGEoIGN1ciApICkge1xuXHRcdFx0XHRldmVudC5yZXN1bHQgPSBoYW5kbGUuYXBwbHkoIGN1ciwgZGF0YSApO1xuXHRcdFx0XHRpZiAoIGV2ZW50LnJlc3VsdCA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRldmVudC50eXBlID0gdHlwZTtcblxuXHRcdC8vIElmIG5vYm9keSBwcmV2ZW50ZWQgdGhlIGRlZmF1bHQgYWN0aW9uLCBkbyBpdCBub3dcblx0XHRpZiAoICFvbmx5SGFuZGxlcnMgJiYgIWV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpICkge1xuXG5cdFx0XHRpZiAoICggIXNwZWNpYWwuX2RlZmF1bHQgfHxcblx0XHRcdFx0c3BlY2lhbC5fZGVmYXVsdC5hcHBseSggZXZlbnRQYXRoLnBvcCgpLCBkYXRhICkgPT09IGZhbHNlICkgJiZcblx0XHRcdFx0YWNjZXB0RGF0YSggZWxlbSApICkge1xuXG5cdFx0XHRcdC8vIENhbGwgYSBuYXRpdmUgRE9NIG1ldGhvZCBvbiB0aGUgdGFyZ2V0IHdpdGggdGhlIHNhbWUgbmFtZSBhcyB0aGUgZXZlbnQuXG5cdFx0XHRcdC8vIERvbid0IGRvIGRlZmF1bHQgYWN0aW9ucyBvbiB3aW5kb3csIHRoYXQncyB3aGVyZSBnbG9iYWwgdmFyaWFibGVzIGJlICgjNjE3MClcblx0XHRcdFx0aWYgKCBvbnR5cGUgJiYgalF1ZXJ5LmlzRnVuY3Rpb24oIGVsZW1bIHR5cGUgXSApICYmICFqUXVlcnkuaXNXaW5kb3coIGVsZW0gKSApIHtcblxuXHRcdFx0XHRcdC8vIERvbid0IHJlLXRyaWdnZXIgYW4gb25GT08gZXZlbnQgd2hlbiB3ZSBjYWxsIGl0cyBGT08oKSBtZXRob2Rcblx0XHRcdFx0XHR0bXAgPSBlbGVtWyBvbnR5cGUgXTtcblxuXHRcdFx0XHRcdGlmICggdG1wICkge1xuXHRcdFx0XHRcdFx0ZWxlbVsgb250eXBlIF0gPSBudWxsO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFByZXZlbnQgcmUtdHJpZ2dlcmluZyBvZiB0aGUgc2FtZSBldmVudCwgc2luY2Ugd2UgYWxyZWFkeSBidWJibGVkIGl0IGFib3ZlXG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCA9IHR5cGU7XG5cdFx0XHRcdFx0ZWxlbVsgdHlwZSBdKCk7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCA9IHVuZGVmaW5lZDtcblxuXHRcdFx0XHRcdGlmICggdG1wICkge1xuXHRcdFx0XHRcdFx0ZWxlbVsgb250eXBlIF0gPSB0bXA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50LnJlc3VsdDtcblx0fSxcblxuXHQvLyBQaWdneWJhY2sgb24gYSBkb25vciBldmVudCB0byBzaW11bGF0ZSBhIGRpZmZlcmVudCBvbmVcblx0Ly8gVXNlZCBvbmx5IGZvciBgZm9jdXMoaW4gfCBvdXQpYCBldmVudHNcblx0c2ltdWxhdGU6IGZ1bmN0aW9uKCB0eXBlLCBlbGVtLCBldmVudCApIHtcblx0XHR2YXIgZSA9IGpRdWVyeS5leHRlbmQoXG5cdFx0XHRuZXcgalF1ZXJ5LkV2ZW50KCksXG5cdFx0XHRldmVudCxcblx0XHRcdHtcblx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0aXNTaW11bGF0ZWQ6IHRydWVcblx0XHRcdH1cblx0XHQpO1xuXG5cdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIGUsIG51bGwsIGVsZW0gKTtcblx0fVxuXG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblxuXHR0cmlnZ2VyOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCB0eXBlLCBkYXRhLCB0aGlzICk7XG5cdFx0fSApO1xuXHR9LFxuXHR0cmlnZ2VySGFuZGxlcjogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7XG5cdFx0dmFyIGVsZW0gPSB0aGlzWyAwIF07XG5cdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5ldmVudC50cmlnZ2VyKCB0eXBlLCBkYXRhLCBlbGVtLCB0cnVlICk7XG5cdFx0fVxuXHR9XG59ICk7XG5cblxualF1ZXJ5LmVhY2goICggXCJibHVyIGZvY3VzIGZvY3VzaW4gZm9jdXNvdXQgcmVzaXplIHNjcm9sbCBjbGljayBkYmxjbGljayBcIiArXG5cdFwibW91c2Vkb3duIG1vdXNldXAgbW91c2Vtb3ZlIG1vdXNlb3ZlciBtb3VzZW91dCBtb3VzZWVudGVyIG1vdXNlbGVhdmUgXCIgK1xuXHRcImNoYW5nZSBzZWxlY3Qgc3VibWl0IGtleWRvd24ga2V5cHJlc3Mga2V5dXAgY29udGV4dG1lbnVcIiApLnNwbGl0KCBcIiBcIiApLFxuXHRmdW5jdGlvbiggaSwgbmFtZSApIHtcblxuXHQvLyBIYW5kbGUgZXZlbnQgYmluZGluZ1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDAgP1xuXHRcdFx0dGhpcy5vbiggbmFtZSwgbnVsbCwgZGF0YSwgZm4gKSA6XG5cdFx0XHR0aGlzLnRyaWdnZXIoIG5hbWUgKTtcblx0fTtcbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRob3ZlcjogZnVuY3Rpb24oIGZuT3ZlciwgZm5PdXQgKSB7XG5cdFx0cmV0dXJuIHRoaXMubW91c2VlbnRlciggZm5PdmVyICkubW91c2VsZWF2ZSggZm5PdXQgfHwgZm5PdmVyICk7XG5cdH1cbn0gKTtcblxuXG5cblxuc3VwcG9ydC5mb2N1c2luID0gXCJvbmZvY3VzaW5cIiBpbiB3aW5kb3c7XG5cblxuLy8gU3VwcG9ydDogRmlyZWZveCA8PTQ0XG4vLyBGaXJlZm94IGRvZXNuJ3QgaGF2ZSBmb2N1cyhpbiB8IG91dCkgZXZlbnRzXG4vLyBSZWxhdGVkIHRpY2tldCAtIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY4Nzc4N1xuLy9cbi8vIFN1cHBvcnQ6IENocm9tZSA8PTQ4IC0gNDksIFNhZmFyaSA8PTkuMCAtIDkuMVxuLy8gZm9jdXMoaW4gfCBvdXQpIGV2ZW50cyBmaXJlIGFmdGVyIGZvY3VzICYgYmx1ciBldmVudHMsXG4vLyB3aGljaCBpcyBzcGVjIHZpb2xhdGlvbiAtIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8jZXZlbnRzLWZvY3VzZXZlbnQtZXZlbnQtb3JkZXJcbi8vIFJlbGF0ZWQgdGlja2V0IC0gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NDQ5ODU3XG5pZiAoICFzdXBwb3J0LmZvY3VzaW4gKSB7XG5cdGpRdWVyeS5lYWNoKCB7IGZvY3VzOiBcImZvY3VzaW5cIiwgYmx1cjogXCJmb2N1c291dFwiIH0sIGZ1bmN0aW9uKCBvcmlnLCBmaXggKSB7XG5cblx0XHQvLyBBdHRhY2ggYSBzaW5nbGUgY2FwdHVyaW5nIGhhbmRsZXIgb24gdGhlIGRvY3VtZW50IHdoaWxlIHNvbWVvbmUgd2FudHMgZm9jdXNpbi9mb2N1c291dFxuXHRcdHZhciBoYW5kbGVyID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnNpbXVsYXRlKCBmaXgsIGV2ZW50LnRhcmdldCwgalF1ZXJ5LmV2ZW50LmZpeCggZXZlbnQgKSApO1xuXHRcdH07XG5cblx0XHRqUXVlcnkuZXZlbnQuc3BlY2lhbFsgZml4IF0gPSB7XG5cdFx0XHRzZXR1cDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBkb2MgPSB0aGlzLm93bmVyRG9jdW1lbnQgfHwgdGhpcyxcblx0XHRcdFx0XHRhdHRhY2hlcyA9IGRhdGFQcml2LmFjY2VzcyggZG9jLCBmaXggKTtcblxuXHRcdFx0XHRpZiAoICFhdHRhY2hlcyApIHtcblx0XHRcdFx0XHRkb2MuYWRkRXZlbnRMaXN0ZW5lciggb3JpZywgaGFuZGxlciwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRhdGFQcml2LmFjY2VzcyggZG9jLCBmaXgsICggYXR0YWNoZXMgfHwgMCApICsgMSApO1xuXHRcdFx0fSxcblx0XHRcdHRlYXJkb3duOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGRvYyA9IHRoaXMub3duZXJEb2N1bWVudCB8fCB0aGlzLFxuXHRcdFx0XHRcdGF0dGFjaGVzID0gZGF0YVByaXYuYWNjZXNzKCBkb2MsIGZpeCApIC0gMTtcblxuXHRcdFx0XHRpZiAoICFhdHRhY2hlcyApIHtcblx0XHRcdFx0XHRkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lciggb3JpZywgaGFuZGxlciwgdHJ1ZSApO1xuXHRcdFx0XHRcdGRhdGFQcml2LnJlbW92ZSggZG9jLCBmaXggKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRhdGFQcml2LmFjY2VzcyggZG9jLCBmaXgsIGF0dGFjaGVzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9ICk7XG59XG52YXIgbG9jYXRpb24gPSB3aW5kb3cubG9jYXRpb247XG5cbnZhciBub25jZSA9IGpRdWVyeS5ub3coKTtcblxudmFyIHJxdWVyeSA9ICggL1xcPy8gKTtcblxuXG5cbi8vIENyb3NzLWJyb3dzZXIgeG1sIHBhcnNpbmdcbmpRdWVyeS5wYXJzZVhNTCA9IGZ1bmN0aW9uKCBkYXRhICkge1xuXHR2YXIgeG1sO1xuXHRpZiAoICFkYXRhIHx8IHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0Ly8gU3VwcG9ydDogSUUgOSAtIDExIG9ubHlcblx0Ly8gSUUgdGhyb3dzIG9uIHBhcnNlRnJvbVN0cmluZyB3aXRoIGludmFsaWQgaW5wdXQuXG5cdHRyeSB7XG5cdFx0eG1sID0gKCBuZXcgd2luZG93LkRPTVBhcnNlcigpICkucGFyc2VGcm9tU3RyaW5nKCBkYXRhLCBcInRleHQveG1sXCIgKTtcblx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0eG1sID0gdW5kZWZpbmVkO1xuXHR9XG5cblx0aWYgKCAheG1sIHx8IHhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZSggXCJwYXJzZXJlcnJvclwiICkubGVuZ3RoICkge1xuXHRcdGpRdWVyeS5lcnJvciggXCJJbnZhbGlkIFhNTDogXCIgKyBkYXRhICk7XG5cdH1cblx0cmV0dXJuIHhtbDtcbn07XG5cblxudmFyXG5cdHJicmFja2V0ID0gL1xcW1xcXSQvLFxuXHRyQ1JMRiA9IC9cXHI/XFxuL2csXG5cdHJzdWJtaXR0ZXJUeXBlcyA9IC9eKD86c3VibWl0fGJ1dHRvbnxpbWFnZXxyZXNldHxmaWxlKSQvaSxcblx0cnN1Ym1pdHRhYmxlID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8a2V5Z2VuKS9pO1xuXG5mdW5jdGlvbiBidWlsZFBhcmFtcyggcHJlZml4LCBvYmosIHRyYWRpdGlvbmFsLCBhZGQgKSB7XG5cdHZhciBuYW1lO1xuXG5cdGlmICggalF1ZXJ5LmlzQXJyYXkoIG9iaiApICkge1xuXG5cdFx0Ly8gU2VyaWFsaXplIGFycmF5IGl0ZW0uXG5cdFx0alF1ZXJ5LmVhY2goIG9iaiwgZnVuY3Rpb24oIGksIHYgKSB7XG5cdFx0XHRpZiAoIHRyYWRpdGlvbmFsIHx8IHJicmFja2V0LnRlc3QoIHByZWZpeCApICkge1xuXG5cdFx0XHRcdC8vIFRyZWF0IGVhY2ggYXJyYXkgaXRlbSBhcyBhIHNjYWxhci5cblx0XHRcdFx0YWRkKCBwcmVmaXgsIHYgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBJdGVtIGlzIG5vbi1zY2FsYXIgKGFycmF5IG9yIG9iamVjdCksIGVuY29kZSBpdHMgbnVtZXJpYyBpbmRleC5cblx0XHRcdFx0YnVpbGRQYXJhbXMoXG5cdFx0XHRcdFx0cHJlZml4ICsgXCJbXCIgKyAoIHR5cGVvZiB2ID09PSBcIm9iamVjdFwiICYmIHYgIT0gbnVsbCA/IGkgOiBcIlwiICkgKyBcIl1cIixcblx0XHRcdFx0XHR2LFxuXHRcdFx0XHRcdHRyYWRpdGlvbmFsLFxuXHRcdFx0XHRcdGFkZFxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH0gKTtcblxuXHR9IGVsc2UgaWYgKCAhdHJhZGl0aW9uYWwgJiYgalF1ZXJ5LnR5cGUoIG9iaiApID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0Ly8gU2VyaWFsaXplIG9iamVjdCBpdGVtLlxuXHRcdGZvciAoIG5hbWUgaW4gb2JqICkge1xuXHRcdFx0YnVpbGRQYXJhbXMoIHByZWZpeCArIFwiW1wiICsgbmFtZSArIFwiXVwiLCBvYmpbIG5hbWUgXSwgdHJhZGl0aW9uYWwsIGFkZCApO1xuXHRcdH1cblxuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gU2VyaWFsaXplIHNjYWxhciBpdGVtLlxuXHRcdGFkZCggcHJlZml4LCBvYmogKTtcblx0fVxufVxuXG4vLyBTZXJpYWxpemUgYW4gYXJyYXkgb2YgZm9ybSBlbGVtZW50cyBvciBhIHNldCBvZlxuLy8ga2V5L3ZhbHVlcyBpbnRvIGEgcXVlcnkgc3RyaW5nXG5qUXVlcnkucGFyYW0gPSBmdW5jdGlvbiggYSwgdHJhZGl0aW9uYWwgKSB7XG5cdHZhciBwcmVmaXgsXG5cdFx0cyA9IFtdLFxuXHRcdGFkZCA9IGZ1bmN0aW9uKCBrZXksIHZhbHVlT3JGdW5jdGlvbiApIHtcblxuXHRcdFx0Ly8gSWYgdmFsdWUgaXMgYSBmdW5jdGlvbiwgaW52b2tlIGl0IGFuZCB1c2UgaXRzIHJldHVybiB2YWx1ZVxuXHRcdFx0dmFyIHZhbHVlID0galF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlT3JGdW5jdGlvbiApID9cblx0XHRcdFx0dmFsdWVPckZ1bmN0aW9uKCkgOlxuXHRcdFx0XHR2YWx1ZU9yRnVuY3Rpb247XG5cblx0XHRcdHNbIHMubGVuZ3RoIF0gPSBlbmNvZGVVUklDb21wb25lbnQoIGtleSApICsgXCI9XCIgK1xuXHRcdFx0XHRlbmNvZGVVUklDb21wb25lbnQoIHZhbHVlID09IG51bGwgPyBcIlwiIDogdmFsdWUgKTtcblx0XHR9O1xuXG5cdC8vIElmIGFuIGFycmF5IHdhcyBwYXNzZWQgaW4sIGFzc3VtZSB0aGF0IGl0IGlzIGFuIGFycmF5IG9mIGZvcm0gZWxlbWVudHMuXG5cdGlmICggalF1ZXJ5LmlzQXJyYXkoIGEgKSB8fCAoIGEuanF1ZXJ5ICYmICFqUXVlcnkuaXNQbGFpbk9iamVjdCggYSApICkgKSB7XG5cblx0XHQvLyBTZXJpYWxpemUgdGhlIGZvcm0gZWxlbWVudHNcblx0XHRqUXVlcnkuZWFjaCggYSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRhZGQoIHRoaXMubmFtZSwgdGhpcy52YWx1ZSApO1xuXHRcdH0gKTtcblxuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gSWYgdHJhZGl0aW9uYWwsIGVuY29kZSB0aGUgXCJvbGRcIiB3YXkgKHRoZSB3YXkgMS4zLjIgb3Igb2xkZXJcblx0XHQvLyBkaWQgaXQpLCBvdGhlcndpc2UgZW5jb2RlIHBhcmFtcyByZWN1cnNpdmVseS5cblx0XHRmb3IgKCBwcmVmaXggaW4gYSApIHtcblx0XHRcdGJ1aWxkUGFyYW1zKCBwcmVmaXgsIGFbIHByZWZpeCBdLCB0cmFkaXRpb25hbCwgYWRkICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSByZXN1bHRpbmcgc2VyaWFsaXphdGlvblxuXHRyZXR1cm4gcy5qb2luKCBcIiZcIiApO1xufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRzZXJpYWxpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBqUXVlcnkucGFyYW0oIHRoaXMuc2VyaWFsaXplQXJyYXkoKSApO1xuXHR9LFxuXHRzZXJpYWxpemVBcnJheTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gQ2FuIGFkZCBwcm9wSG9vayBmb3IgXCJlbGVtZW50c1wiIHRvIGZpbHRlciBvciBhZGQgZm9ybSBlbGVtZW50c1xuXHRcdFx0dmFyIGVsZW1lbnRzID0galF1ZXJ5LnByb3AoIHRoaXMsIFwiZWxlbWVudHNcIiApO1xuXHRcdFx0cmV0dXJuIGVsZW1lbnRzID8galF1ZXJ5Lm1ha2VBcnJheSggZWxlbWVudHMgKSA6IHRoaXM7XG5cdFx0fSApXG5cdFx0LmZpbHRlciggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgdHlwZSA9IHRoaXMudHlwZTtcblxuXHRcdFx0Ly8gVXNlIC5pcyggXCI6ZGlzYWJsZWRcIiApIHNvIHRoYXQgZmllbGRzZXRbZGlzYWJsZWRdIHdvcmtzXG5cdFx0XHRyZXR1cm4gdGhpcy5uYW1lICYmICFqUXVlcnkoIHRoaXMgKS5pcyggXCI6ZGlzYWJsZWRcIiApICYmXG5cdFx0XHRcdHJzdWJtaXR0YWJsZS50ZXN0KCB0aGlzLm5vZGVOYW1lICkgJiYgIXJzdWJtaXR0ZXJUeXBlcy50ZXN0KCB0eXBlICkgJiZcblx0XHRcdFx0KCB0aGlzLmNoZWNrZWQgfHwgIXJjaGVja2FibGVUeXBlLnRlc3QoIHR5cGUgKSApO1xuXHRcdH0gKVxuXHRcdC5tYXAoIGZ1bmN0aW9uKCBpLCBlbGVtICkge1xuXHRcdFx0dmFyIHZhbCA9IGpRdWVyeSggdGhpcyApLnZhbCgpO1xuXG5cdFx0XHRpZiAoIHZhbCA9PSBudWxsICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBqUXVlcnkuaXNBcnJheSggdmFsICkgKSB7XG5cdFx0XHRcdHJldHVybiBqUXVlcnkubWFwKCB2YWwsIGZ1bmN0aW9uKCB2YWwgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHsgbmFtZTogZWxlbS5uYW1lLCB2YWx1ZTogdmFsLnJlcGxhY2UoIHJDUkxGLCBcIlxcclxcblwiICkgfTtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4geyBuYW1lOiBlbGVtLm5hbWUsIHZhbHVlOiB2YWwucmVwbGFjZSggckNSTEYsIFwiXFxyXFxuXCIgKSB9O1xuXHRcdH0gKS5nZXQoKTtcblx0fVxufSApO1xuXG5cbnZhclxuXHRyMjAgPSAvJTIwL2csXG5cdHJoYXNoID0gLyMuKiQvLFxuXHRyYW50aUNhY2hlID0gLyhbPyZdKV89W14mXSovLFxuXHRyaGVhZGVycyA9IC9eKC4qPyk6WyBcXHRdKihbXlxcclxcbl0qKSQvbWcsXG5cblx0Ly8gIzc2NTMsICM4MTI1LCAjODE1MjogbG9jYWwgcHJvdG9jb2wgZGV0ZWN0aW9uXG5cdHJsb2NhbFByb3RvY29sID0gL14oPzphYm91dHxhcHB8YXBwLXN0b3JhZ2V8ListZXh0ZW5zaW9ufGZpbGV8cmVzfHdpZGdldCk6JC8sXG5cdHJub0NvbnRlbnQgPSAvXig/OkdFVHxIRUFEKSQvLFxuXHRycHJvdG9jb2wgPSAvXlxcL1xcLy8sXG5cblx0LyogUHJlZmlsdGVyc1xuXHQgKiAxKSBUaGV5IGFyZSB1c2VmdWwgdG8gaW50cm9kdWNlIGN1c3RvbSBkYXRhVHlwZXMgKHNlZSBhamF4L2pzb25wLmpzIGZvciBhbiBleGFtcGxlKVxuXHQgKiAyKSBUaGVzZSBhcmUgY2FsbGVkOlxuXHQgKiAgICAtIEJFRk9SRSBhc2tpbmcgZm9yIGEgdHJhbnNwb3J0XG5cdCAqICAgIC0gQUZURVIgcGFyYW0gc2VyaWFsaXphdGlvbiAocy5kYXRhIGlzIGEgc3RyaW5nIGlmIHMucHJvY2Vzc0RhdGEgaXMgdHJ1ZSlcblx0ICogMykga2V5IGlzIHRoZSBkYXRhVHlwZVxuXHQgKiA0KSB0aGUgY2F0Y2hhbGwgc3ltYm9sIFwiKlwiIGNhbiBiZSB1c2VkXG5cdCAqIDUpIGV4ZWN1dGlvbiB3aWxsIHN0YXJ0IHdpdGggdHJhbnNwb3J0IGRhdGFUeXBlIGFuZCBUSEVOIGNvbnRpbnVlIGRvd24gdG8gXCIqXCIgaWYgbmVlZGVkXG5cdCAqL1xuXHRwcmVmaWx0ZXJzID0ge30sXG5cblx0LyogVHJhbnNwb3J0cyBiaW5kaW5nc1xuXHQgKiAxKSBrZXkgaXMgdGhlIGRhdGFUeXBlXG5cdCAqIDIpIHRoZSBjYXRjaGFsbCBzeW1ib2wgXCIqXCIgY2FuIGJlIHVzZWRcblx0ICogMykgc2VsZWN0aW9uIHdpbGwgc3RhcnQgd2l0aCB0cmFuc3BvcnQgZGF0YVR5cGUgYW5kIFRIRU4gZ28gdG8gXCIqXCIgaWYgbmVlZGVkXG5cdCAqL1xuXHR0cmFuc3BvcnRzID0ge30sXG5cblx0Ly8gQXZvaWQgY29tbWVudC1wcm9sb2cgY2hhciBzZXF1ZW5jZSAoIzEwMDk4KTsgbXVzdCBhcHBlYXNlIGxpbnQgYW5kIGV2YWRlIGNvbXByZXNzaW9uXG5cdGFsbFR5cGVzID0gXCIqL1wiLmNvbmNhdCggXCIqXCIgKSxcblxuXHQvLyBBbmNob3IgdGFnIGZvciBwYXJzaW5nIHRoZSBkb2N1bWVudCBvcmlnaW5cblx0b3JpZ2luQW5jaG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJhXCIgKTtcblx0b3JpZ2luQW5jaG9yLmhyZWYgPSBsb2NhdGlvbi5ocmVmO1xuXG4vLyBCYXNlIFwiY29uc3RydWN0b3JcIiBmb3IgalF1ZXJ5LmFqYXhQcmVmaWx0ZXIgYW5kIGpRdWVyeS5hamF4VHJhbnNwb3J0XG5mdW5jdGlvbiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHN0cnVjdHVyZSApIHtcblxuXHQvLyBkYXRhVHlwZUV4cHJlc3Npb24gaXMgb3B0aW9uYWwgYW5kIGRlZmF1bHRzIHRvIFwiKlwiXG5cdHJldHVybiBmdW5jdGlvbiggZGF0YVR5cGVFeHByZXNzaW9uLCBmdW5jICkge1xuXG5cdFx0aWYgKCB0eXBlb2YgZGF0YVR5cGVFeHByZXNzaW9uICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0ZnVuYyA9IGRhdGFUeXBlRXhwcmVzc2lvbjtcblx0XHRcdGRhdGFUeXBlRXhwcmVzc2lvbiA9IFwiKlwiO1xuXHRcdH1cblxuXHRcdHZhciBkYXRhVHlwZSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0ZGF0YVR5cGVzID0gZGF0YVR5cGVFeHByZXNzaW9uLnRvTG93ZXJDYXNlKCkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXTtcblxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIGZ1bmMgKSApIHtcblxuXHRcdFx0Ly8gRm9yIGVhY2ggZGF0YVR5cGUgaW4gdGhlIGRhdGFUeXBlRXhwcmVzc2lvblxuXHRcdFx0d2hpbGUgKCAoIGRhdGFUeXBlID0gZGF0YVR5cGVzWyBpKysgXSApICkge1xuXG5cdFx0XHRcdC8vIFByZXBlbmQgaWYgcmVxdWVzdGVkXG5cdFx0XHRcdGlmICggZGF0YVR5cGVbIDAgXSA9PT0gXCIrXCIgKSB7XG5cdFx0XHRcdFx0ZGF0YVR5cGUgPSBkYXRhVHlwZS5zbGljZSggMSApIHx8IFwiKlwiO1xuXHRcdFx0XHRcdCggc3RydWN0dXJlWyBkYXRhVHlwZSBdID0gc3RydWN0dXJlWyBkYXRhVHlwZSBdIHx8IFtdICkudW5zaGlmdCggZnVuYyApO1xuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSBhcHBlbmRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQoIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSA9IHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSApLnB1c2goIGZ1bmMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn1cblxuLy8gQmFzZSBpbnNwZWN0aW9uIGZ1bmN0aW9uIGZvciBwcmVmaWx0ZXJzIGFuZCB0cmFuc3BvcnRzXG5mdW5jdGlvbiBpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggc3RydWN0dXJlLCBvcHRpb25zLCBvcmlnaW5hbE9wdGlvbnMsIGpxWEhSICkge1xuXG5cdHZhciBpbnNwZWN0ZWQgPSB7fSxcblx0XHRzZWVraW5nVHJhbnNwb3J0ID0gKCBzdHJ1Y3R1cmUgPT09IHRyYW5zcG9ydHMgKTtcblxuXHRmdW5jdGlvbiBpbnNwZWN0KCBkYXRhVHlwZSApIHtcblx0XHR2YXIgc2VsZWN0ZWQ7XG5cdFx0aW5zcGVjdGVkWyBkYXRhVHlwZSBdID0gdHJ1ZTtcblx0XHRqUXVlcnkuZWFjaCggc3RydWN0dXJlWyBkYXRhVHlwZSBdIHx8IFtdLCBmdW5jdGlvbiggXywgcHJlZmlsdGVyT3JGYWN0b3J5ICkge1xuXHRcdFx0dmFyIGRhdGFUeXBlT3JUcmFuc3BvcnQgPSBwcmVmaWx0ZXJPckZhY3RvcnkoIG9wdGlvbnMsIG9yaWdpbmFsT3B0aW9ucywganFYSFIgKTtcblx0XHRcdGlmICggdHlwZW9mIGRhdGFUeXBlT3JUcmFuc3BvcnQgPT09IFwic3RyaW5nXCIgJiZcblx0XHRcdFx0IXNlZWtpbmdUcmFuc3BvcnQgJiYgIWluc3BlY3RlZFsgZGF0YVR5cGVPclRyYW5zcG9ydCBdICkge1xuXG5cdFx0XHRcdG9wdGlvbnMuZGF0YVR5cGVzLnVuc2hpZnQoIGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcblx0XHRcdFx0aW5zcGVjdCggZGF0YVR5cGVPclRyYW5zcG9ydCApO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9IGVsc2UgaWYgKCBzZWVraW5nVHJhbnNwb3J0ICkge1xuXHRcdFx0XHRyZXR1cm4gISggc2VsZWN0ZWQgPSBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHRcdHJldHVybiBzZWxlY3RlZDtcblx0fVxuXG5cdHJldHVybiBpbnNwZWN0KCBvcHRpb25zLmRhdGFUeXBlc1sgMCBdICkgfHwgIWluc3BlY3RlZFsgXCIqXCIgXSAmJiBpbnNwZWN0KCBcIipcIiApO1xufVxuXG4vLyBBIHNwZWNpYWwgZXh0ZW5kIGZvciBhamF4IG9wdGlvbnNcbi8vIHRoYXQgdGFrZXMgXCJmbGF0XCIgb3B0aW9ucyAobm90IHRvIGJlIGRlZXAgZXh0ZW5kZWQpXG4vLyBGaXhlcyAjOTg4N1xuZnVuY3Rpb24gYWpheEV4dGVuZCggdGFyZ2V0LCBzcmMgKSB7XG5cdHZhciBrZXksIGRlZXAsXG5cdFx0ZmxhdE9wdGlvbnMgPSBqUXVlcnkuYWpheFNldHRpbmdzLmZsYXRPcHRpb25zIHx8IHt9O1xuXG5cdGZvciAoIGtleSBpbiBzcmMgKSB7XG5cdFx0aWYgKCBzcmNbIGtleSBdICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHQoIGZsYXRPcHRpb25zWyBrZXkgXSA/IHRhcmdldCA6ICggZGVlcCB8fCAoIGRlZXAgPSB7fSApICkgKVsga2V5IF0gPSBzcmNbIGtleSBdO1xuXHRcdH1cblx0fVxuXHRpZiAoIGRlZXAgKSB7XG5cdFx0alF1ZXJ5LmV4dGVuZCggdHJ1ZSwgdGFyZ2V0LCBkZWVwICk7XG5cdH1cblxuXHRyZXR1cm4gdGFyZ2V0O1xufVxuXG4vKiBIYW5kbGVzIHJlc3BvbnNlcyB0byBhbiBhamF4IHJlcXVlc3Q6XG4gKiAtIGZpbmRzIHRoZSByaWdodCBkYXRhVHlwZSAobWVkaWF0ZXMgYmV0d2VlbiBjb250ZW50LXR5cGUgYW5kIGV4cGVjdGVkIGRhdGFUeXBlKVxuICogLSByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIHJlc3BvbnNlXG4gKi9cbmZ1bmN0aW9uIGFqYXhIYW5kbGVSZXNwb25zZXMoIHMsIGpxWEhSLCByZXNwb25zZXMgKSB7XG5cblx0dmFyIGN0LCB0eXBlLCBmaW5hbERhdGFUeXBlLCBmaXJzdERhdGFUeXBlLFxuXHRcdGNvbnRlbnRzID0gcy5jb250ZW50cyxcblx0XHRkYXRhVHlwZXMgPSBzLmRhdGFUeXBlcztcblxuXHQvLyBSZW1vdmUgYXV0byBkYXRhVHlwZSBhbmQgZ2V0IGNvbnRlbnQtdHlwZSBpbiB0aGUgcHJvY2Vzc1xuXHR3aGlsZSAoIGRhdGFUeXBlc1sgMCBdID09PSBcIipcIiApIHtcblx0XHRkYXRhVHlwZXMuc2hpZnQoKTtcblx0XHRpZiAoIGN0ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRjdCA9IHMubWltZVR5cGUgfHwganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoIFwiQ29udGVudC1UeXBlXCIgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBDaGVjayBpZiB3ZSdyZSBkZWFsaW5nIHdpdGggYSBrbm93biBjb250ZW50LXR5cGVcblx0aWYgKCBjdCApIHtcblx0XHRmb3IgKCB0eXBlIGluIGNvbnRlbnRzICkge1xuXHRcdFx0aWYgKCBjb250ZW50c1sgdHlwZSBdICYmIGNvbnRlbnRzWyB0eXBlIF0udGVzdCggY3QgKSApIHtcblx0XHRcdFx0ZGF0YVR5cGVzLnVuc2hpZnQoIHR5cGUgKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2hlY2sgdG8gc2VlIGlmIHdlIGhhdmUgYSByZXNwb25zZSBmb3IgdGhlIGV4cGVjdGVkIGRhdGFUeXBlXG5cdGlmICggZGF0YVR5cGVzWyAwIF0gaW4gcmVzcG9uc2VzICkge1xuXHRcdGZpbmFsRGF0YVR5cGUgPSBkYXRhVHlwZXNbIDAgXTtcblx0fSBlbHNlIHtcblxuXHRcdC8vIFRyeSBjb252ZXJ0aWJsZSBkYXRhVHlwZXNcblx0XHRmb3IgKCB0eXBlIGluIHJlc3BvbnNlcyApIHtcblx0XHRcdGlmICggIWRhdGFUeXBlc1sgMCBdIHx8IHMuY29udmVydGVyc1sgdHlwZSArIFwiIFwiICsgZGF0YVR5cGVzWyAwIF0gXSApIHtcblx0XHRcdFx0ZmluYWxEYXRhVHlwZSA9IHR5cGU7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCAhZmlyc3REYXRhVHlwZSApIHtcblx0XHRcdFx0Zmlyc3REYXRhVHlwZSA9IHR5cGU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gT3IganVzdCB1c2UgZmlyc3Qgb25lXG5cdFx0ZmluYWxEYXRhVHlwZSA9IGZpbmFsRGF0YVR5cGUgfHwgZmlyc3REYXRhVHlwZTtcblx0fVxuXG5cdC8vIElmIHdlIGZvdW5kIGEgZGF0YVR5cGVcblx0Ly8gV2UgYWRkIHRoZSBkYXRhVHlwZSB0byB0aGUgbGlzdCBpZiBuZWVkZWRcblx0Ly8gYW5kIHJldHVybiB0aGUgY29ycmVzcG9uZGluZyByZXNwb25zZVxuXHRpZiAoIGZpbmFsRGF0YVR5cGUgKSB7XG5cdFx0aWYgKCBmaW5hbERhdGFUeXBlICE9PSBkYXRhVHlwZXNbIDAgXSApIHtcblx0XHRcdGRhdGFUeXBlcy51bnNoaWZ0KCBmaW5hbERhdGFUeXBlICk7XG5cdFx0fVxuXHRcdHJldHVybiByZXNwb25zZXNbIGZpbmFsRGF0YVR5cGUgXTtcblx0fVxufVxuXG4vKiBDaGFpbiBjb252ZXJzaW9ucyBnaXZlbiB0aGUgcmVxdWVzdCBhbmQgdGhlIG9yaWdpbmFsIHJlc3BvbnNlXG4gKiBBbHNvIHNldHMgdGhlIHJlc3BvbnNlWFhYIGZpZWxkcyBvbiB0aGUganFYSFIgaW5zdGFuY2VcbiAqL1xuZnVuY3Rpb24gYWpheENvbnZlcnQoIHMsIHJlc3BvbnNlLCBqcVhIUiwgaXNTdWNjZXNzICkge1xuXHR2YXIgY29udjIsIGN1cnJlbnQsIGNvbnYsIHRtcCwgcHJldixcblx0XHRjb252ZXJ0ZXJzID0ge30sXG5cblx0XHQvLyBXb3JrIHdpdGggYSBjb3B5IG9mIGRhdGFUeXBlcyBpbiBjYXNlIHdlIG5lZWQgdG8gbW9kaWZ5IGl0IGZvciBjb252ZXJzaW9uXG5cdFx0ZGF0YVR5cGVzID0gcy5kYXRhVHlwZXMuc2xpY2UoKTtcblxuXHQvLyBDcmVhdGUgY29udmVydGVycyBtYXAgd2l0aCBsb3dlcmNhc2VkIGtleXNcblx0aWYgKCBkYXRhVHlwZXNbIDEgXSApIHtcblx0XHRmb3IgKCBjb252IGluIHMuY29udmVydGVycyApIHtcblx0XHRcdGNvbnZlcnRlcnNbIGNvbnYudG9Mb3dlckNhc2UoKSBdID0gcy5jb252ZXJ0ZXJzWyBjb252IF07XG5cdFx0fVxuXHR9XG5cblx0Y3VycmVudCA9IGRhdGFUeXBlcy5zaGlmdCgpO1xuXG5cdC8vIENvbnZlcnQgdG8gZWFjaCBzZXF1ZW50aWFsIGRhdGFUeXBlXG5cdHdoaWxlICggY3VycmVudCApIHtcblxuXHRcdGlmICggcy5yZXNwb25zZUZpZWxkc1sgY3VycmVudCBdICkge1xuXHRcdFx0anFYSFJbIHMucmVzcG9uc2VGaWVsZHNbIGN1cnJlbnQgXSBdID0gcmVzcG9uc2U7XG5cdFx0fVxuXG5cdFx0Ly8gQXBwbHkgdGhlIGRhdGFGaWx0ZXIgaWYgcHJvdmlkZWRcblx0XHRpZiAoICFwcmV2ICYmIGlzU3VjY2VzcyAmJiBzLmRhdGFGaWx0ZXIgKSB7XG5cdFx0XHRyZXNwb25zZSA9IHMuZGF0YUZpbHRlciggcmVzcG9uc2UsIHMuZGF0YVR5cGUgKTtcblx0XHR9XG5cblx0XHRwcmV2ID0gY3VycmVudDtcblx0XHRjdXJyZW50ID0gZGF0YVR5cGVzLnNoaWZ0KCk7XG5cblx0XHRpZiAoIGN1cnJlbnQgKSB7XG5cblx0XHRcdC8vIFRoZXJlJ3Mgb25seSB3b3JrIHRvIGRvIGlmIGN1cnJlbnQgZGF0YVR5cGUgaXMgbm9uLWF1dG9cblx0XHRcdGlmICggY3VycmVudCA9PT0gXCIqXCIgKSB7XG5cblx0XHRcdFx0Y3VycmVudCA9IHByZXY7XG5cblx0XHRcdC8vIENvbnZlcnQgcmVzcG9uc2UgaWYgcHJldiBkYXRhVHlwZSBpcyBub24tYXV0byBhbmQgZGlmZmVycyBmcm9tIGN1cnJlbnRcblx0XHRcdH0gZWxzZSBpZiAoIHByZXYgIT09IFwiKlwiICYmIHByZXYgIT09IGN1cnJlbnQgKSB7XG5cblx0XHRcdFx0Ly8gU2VlayBhIGRpcmVjdCBjb252ZXJ0ZXJcblx0XHRcdFx0Y29udiA9IGNvbnZlcnRlcnNbIHByZXYgKyBcIiBcIiArIGN1cnJlbnQgXSB8fCBjb252ZXJ0ZXJzWyBcIiogXCIgKyBjdXJyZW50IF07XG5cblx0XHRcdFx0Ly8gSWYgbm9uZSBmb3VuZCwgc2VlayBhIHBhaXJcblx0XHRcdFx0aWYgKCAhY29udiApIHtcblx0XHRcdFx0XHRmb3IgKCBjb252MiBpbiBjb252ZXJ0ZXJzICkge1xuXG5cdFx0XHRcdFx0XHQvLyBJZiBjb252MiBvdXRwdXRzIGN1cnJlbnRcblx0XHRcdFx0XHRcdHRtcCA9IGNvbnYyLnNwbGl0KCBcIiBcIiApO1xuXHRcdFx0XHRcdFx0aWYgKCB0bXBbIDEgXSA9PT0gY3VycmVudCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBJZiBwcmV2IGNhbiBiZSBjb252ZXJ0ZWQgdG8gYWNjZXB0ZWQgaW5wdXRcblx0XHRcdFx0XHRcdFx0Y29udiA9IGNvbnZlcnRlcnNbIHByZXYgKyBcIiBcIiArIHRtcFsgMCBdIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRjb252ZXJ0ZXJzWyBcIiogXCIgKyB0bXBbIDAgXSBdO1xuXHRcdFx0XHRcdFx0XHRpZiAoIGNvbnYgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBDb25kZW5zZSBlcXVpdmFsZW5jZSBjb252ZXJ0ZXJzXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBjb252ID09PSB0cnVlICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29udiA9IGNvbnZlcnRlcnNbIGNvbnYyIF07XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBPdGhlcndpc2UsIGluc2VydCB0aGUgaW50ZXJtZWRpYXRlIGRhdGFUeXBlXG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICggY29udmVydGVyc1sgY29udjIgXSAhPT0gdHJ1ZSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGN1cnJlbnQgPSB0bXBbIDAgXTtcblx0XHRcdFx0XHRcdFx0XHRcdGRhdGFUeXBlcy51bnNoaWZ0KCB0bXBbIDEgXSApO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEFwcGx5IGNvbnZlcnRlciAoaWYgbm90IGFuIGVxdWl2YWxlbmNlKVxuXHRcdFx0XHRpZiAoIGNvbnYgIT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHQvLyBVbmxlc3MgZXJyb3JzIGFyZSBhbGxvd2VkIHRvIGJ1YmJsZSwgY2F0Y2ggYW5kIHJldHVybiB0aGVtXG5cdFx0XHRcdFx0aWYgKCBjb252ICYmIHMudGhyb3dzICkge1xuXHRcdFx0XHRcdFx0cmVzcG9uc2UgPSBjb252KCByZXNwb25zZSApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRyZXNwb25zZSA9IGNvbnYoIHJlc3BvbnNlICk7XG5cdFx0XHRcdFx0XHR9IGNhdGNoICggZSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdFx0XHRzdGF0ZTogXCJwYXJzZXJlcnJvclwiLFxuXHRcdFx0XHRcdFx0XHRcdGVycm9yOiBjb252ID8gZSA6IFwiTm8gY29udmVyc2lvbiBmcm9tIFwiICsgcHJldiArIFwiIHRvIFwiICsgY3VycmVudFxuXHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB7IHN0YXRlOiBcInN1Y2Nlc3NcIiwgZGF0YTogcmVzcG9uc2UgfTtcbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdC8vIENvdW50ZXIgZm9yIGhvbGRpbmcgdGhlIG51bWJlciBvZiBhY3RpdmUgcXVlcmllc1xuXHRhY3RpdmU6IDAsXG5cblx0Ly8gTGFzdC1Nb2RpZmllZCBoZWFkZXIgY2FjaGUgZm9yIG5leHQgcmVxdWVzdFxuXHRsYXN0TW9kaWZpZWQ6IHt9LFxuXHRldGFnOiB7fSxcblxuXHRhamF4U2V0dGluZ3M6IHtcblx0XHR1cmw6IGxvY2F0aW9uLmhyZWYsXG5cdFx0dHlwZTogXCJHRVRcIixcblx0XHRpc0xvY2FsOiBybG9jYWxQcm90b2NvbC50ZXN0KCBsb2NhdGlvbi5wcm90b2NvbCApLFxuXHRcdGdsb2JhbDogdHJ1ZSxcblx0XHRwcm9jZXNzRGF0YTogdHJ1ZSxcblx0XHRhc3luYzogdHJ1ZSxcblx0XHRjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7IGNoYXJzZXQ9VVRGLThcIixcblxuXHRcdC8qXG5cdFx0dGltZW91dDogMCxcblx0XHRkYXRhOiBudWxsLFxuXHRcdGRhdGFUeXBlOiBudWxsLFxuXHRcdHVzZXJuYW1lOiBudWxsLFxuXHRcdHBhc3N3b3JkOiBudWxsLFxuXHRcdGNhY2hlOiBudWxsLFxuXHRcdHRocm93czogZmFsc2UsXG5cdFx0dHJhZGl0aW9uYWw6IGZhbHNlLFxuXHRcdGhlYWRlcnM6IHt9LFxuXHRcdCovXG5cblx0XHRhY2NlcHRzOiB7XG5cdFx0XHRcIipcIjogYWxsVHlwZXMsXG5cdFx0XHR0ZXh0OiBcInRleHQvcGxhaW5cIixcblx0XHRcdGh0bWw6IFwidGV4dC9odG1sXCIsXG5cdFx0XHR4bWw6IFwiYXBwbGljYXRpb24veG1sLCB0ZXh0L3htbFwiLFxuXHRcdFx0anNvbjogXCJhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L2phdmFzY3JpcHRcIlxuXHRcdH0sXG5cblx0XHRjb250ZW50czoge1xuXHRcdFx0eG1sOiAvXFxieG1sXFxiLyxcblx0XHRcdGh0bWw6IC9cXGJodG1sLyxcblx0XHRcdGpzb246IC9cXGJqc29uXFxiL1xuXHRcdH0sXG5cblx0XHRyZXNwb25zZUZpZWxkczoge1xuXHRcdFx0eG1sOiBcInJlc3BvbnNlWE1MXCIsXG5cdFx0XHR0ZXh0OiBcInJlc3BvbnNlVGV4dFwiLFxuXHRcdFx0anNvbjogXCJyZXNwb25zZUpTT05cIlxuXHRcdH0sXG5cblx0XHQvLyBEYXRhIGNvbnZlcnRlcnNcblx0XHQvLyBLZXlzIHNlcGFyYXRlIHNvdXJjZSAob3IgY2F0Y2hhbGwgXCIqXCIpIGFuZCBkZXN0aW5hdGlvbiB0eXBlcyB3aXRoIGEgc2luZ2xlIHNwYWNlXG5cdFx0Y29udmVydGVyczoge1xuXG5cdFx0XHQvLyBDb252ZXJ0IGFueXRoaW5nIHRvIHRleHRcblx0XHRcdFwiKiB0ZXh0XCI6IFN0cmluZyxcblxuXHRcdFx0Ly8gVGV4dCB0byBodG1sICh0cnVlID0gbm8gdHJhbnNmb3JtYXRpb24pXG5cdFx0XHRcInRleHQgaHRtbFwiOiB0cnVlLFxuXG5cdFx0XHQvLyBFdmFsdWF0ZSB0ZXh0IGFzIGEganNvbiBleHByZXNzaW9uXG5cdFx0XHRcInRleHQganNvblwiOiBKU09OLnBhcnNlLFxuXG5cdFx0XHQvLyBQYXJzZSB0ZXh0IGFzIHhtbFxuXHRcdFx0XCJ0ZXh0IHhtbFwiOiBqUXVlcnkucGFyc2VYTUxcblx0XHR9LFxuXG5cdFx0Ly8gRm9yIG9wdGlvbnMgdGhhdCBzaG91bGRuJ3QgYmUgZGVlcCBleHRlbmRlZDpcblx0XHQvLyB5b3UgY2FuIGFkZCB5b3VyIG93biBjdXN0b20gb3B0aW9ucyBoZXJlIGlmXG5cdFx0Ly8gYW5kIHdoZW4geW91IGNyZWF0ZSBvbmUgdGhhdCBzaG91bGRuJ3QgYmVcblx0XHQvLyBkZWVwIGV4dGVuZGVkIChzZWUgYWpheEV4dGVuZClcblx0XHRmbGF0T3B0aW9uczoge1xuXHRcdFx0dXJsOiB0cnVlLFxuXHRcdFx0Y29udGV4dDogdHJ1ZVxuXHRcdH1cblx0fSxcblxuXHQvLyBDcmVhdGVzIGEgZnVsbCBmbGVkZ2VkIHNldHRpbmdzIG9iamVjdCBpbnRvIHRhcmdldFxuXHQvLyB3aXRoIGJvdGggYWpheFNldHRpbmdzIGFuZCBzZXR0aW5ncyBmaWVsZHMuXG5cdC8vIElmIHRhcmdldCBpcyBvbWl0dGVkLCB3cml0ZXMgaW50byBhamF4U2V0dGluZ3MuXG5cdGFqYXhTZXR1cDogZnVuY3Rpb24oIHRhcmdldCwgc2V0dGluZ3MgKSB7XG5cdFx0cmV0dXJuIHNldHRpbmdzID9cblxuXHRcdFx0Ly8gQnVpbGRpbmcgYSBzZXR0aW5ncyBvYmplY3Rcblx0XHRcdGFqYXhFeHRlbmQoIGFqYXhFeHRlbmQoIHRhcmdldCwgalF1ZXJ5LmFqYXhTZXR0aW5ncyApLCBzZXR0aW5ncyApIDpcblxuXHRcdFx0Ly8gRXh0ZW5kaW5nIGFqYXhTZXR0aW5nc1xuXHRcdFx0YWpheEV4dGVuZCggalF1ZXJ5LmFqYXhTZXR0aW5ncywgdGFyZ2V0ICk7XG5cdH0sXG5cblx0YWpheFByZWZpbHRlcjogYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBwcmVmaWx0ZXJzICksXG5cdGFqYXhUcmFuc3BvcnQ6IGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggdHJhbnNwb3J0cyApLFxuXG5cdC8vIE1haW4gbWV0aG9kXG5cdGFqYXg6IGZ1bmN0aW9uKCB1cmwsIG9wdGlvbnMgKSB7XG5cblx0XHQvLyBJZiB1cmwgaXMgYW4gb2JqZWN0LCBzaW11bGF0ZSBwcmUtMS41IHNpZ25hdHVyZVxuXHRcdGlmICggdHlwZW9mIHVybCA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRcdG9wdGlvbnMgPSB1cmw7XG5cdFx0XHR1cmwgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0Ly8gRm9yY2Ugb3B0aW9ucyB0byBiZSBhbiBvYmplY3Rcblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHRcdHZhciB0cmFuc3BvcnQsXG5cblx0XHRcdC8vIFVSTCB3aXRob3V0IGFudGktY2FjaGUgcGFyYW1cblx0XHRcdGNhY2hlVVJMLFxuXG5cdFx0XHQvLyBSZXNwb25zZSBoZWFkZXJzXG5cdFx0XHRyZXNwb25zZUhlYWRlcnNTdHJpbmcsXG5cdFx0XHRyZXNwb25zZUhlYWRlcnMsXG5cblx0XHRcdC8vIHRpbWVvdXQgaGFuZGxlXG5cdFx0XHR0aW1lb3V0VGltZXIsXG5cblx0XHRcdC8vIFVybCBjbGVhbnVwIHZhclxuXHRcdFx0dXJsQW5jaG9yLFxuXG5cdFx0XHQvLyBSZXF1ZXN0IHN0YXRlIChiZWNvbWVzIGZhbHNlIHVwb24gc2VuZCBhbmQgdHJ1ZSB1cG9uIGNvbXBsZXRpb24pXG5cdFx0XHRjb21wbGV0ZWQsXG5cblx0XHRcdC8vIFRvIGtub3cgaWYgZ2xvYmFsIGV2ZW50cyBhcmUgdG8gYmUgZGlzcGF0Y2hlZFxuXHRcdFx0ZmlyZUdsb2JhbHMsXG5cblx0XHRcdC8vIExvb3AgdmFyaWFibGVcblx0XHRcdGksXG5cblx0XHRcdC8vIHVuY2FjaGVkIHBhcnQgb2YgdGhlIHVybFxuXHRcdFx0dW5jYWNoZWQsXG5cblx0XHRcdC8vIENyZWF0ZSB0aGUgZmluYWwgb3B0aW9ucyBvYmplY3Rcblx0XHRcdHMgPSBqUXVlcnkuYWpheFNldHVwKCB7fSwgb3B0aW9ucyApLFxuXG5cdFx0XHQvLyBDYWxsYmFja3MgY29udGV4dFxuXHRcdFx0Y2FsbGJhY2tDb250ZXh0ID0gcy5jb250ZXh0IHx8IHMsXG5cblx0XHRcdC8vIENvbnRleHQgZm9yIGdsb2JhbCBldmVudHMgaXMgY2FsbGJhY2tDb250ZXh0IGlmIGl0IGlzIGEgRE9NIG5vZGUgb3IgalF1ZXJ5IGNvbGxlY3Rpb25cblx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dCA9IHMuY29udGV4dCAmJlxuXHRcdFx0XHQoIGNhbGxiYWNrQ29udGV4dC5ub2RlVHlwZSB8fCBjYWxsYmFja0NvbnRleHQuanF1ZXJ5ICkgP1xuXHRcdFx0XHRcdGpRdWVyeSggY2FsbGJhY2tDb250ZXh0ICkgOlxuXHRcdFx0XHRcdGpRdWVyeS5ldmVudCxcblxuXHRcdFx0Ly8gRGVmZXJyZWRzXG5cdFx0XHRkZWZlcnJlZCA9IGpRdWVyeS5EZWZlcnJlZCgpLFxuXHRcdFx0Y29tcGxldGVEZWZlcnJlZCA9IGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLFxuXG5cdFx0XHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuXHRcdFx0c3RhdHVzQ29kZSA9IHMuc3RhdHVzQ29kZSB8fCB7fSxcblxuXHRcdFx0Ly8gSGVhZGVycyAodGhleSBhcmUgc2VudCBhbGwgYXQgb25jZSlcblx0XHRcdHJlcXVlc3RIZWFkZXJzID0ge30sXG5cdFx0XHRyZXF1ZXN0SGVhZGVyc05hbWVzID0ge30sXG5cblx0XHRcdC8vIERlZmF1bHQgYWJvcnQgbWVzc2FnZVxuXHRcdFx0c3RyQWJvcnQgPSBcImNhbmNlbGVkXCIsXG5cblx0XHRcdC8vIEZha2UgeGhyXG5cdFx0XHRqcVhIUiA9IHtcblx0XHRcdFx0cmVhZHlTdGF0ZTogMCxcblxuXHRcdFx0XHQvLyBCdWlsZHMgaGVhZGVycyBoYXNodGFibGUgaWYgbmVlZGVkXG5cdFx0XHRcdGdldFJlc3BvbnNlSGVhZGVyOiBmdW5jdGlvbigga2V5ICkge1xuXHRcdFx0XHRcdHZhciBtYXRjaDtcblx0XHRcdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdFx0XHRcdGlmICggIXJlc3BvbnNlSGVhZGVycyApIHtcblx0XHRcdFx0XHRcdFx0cmVzcG9uc2VIZWFkZXJzID0ge307XG5cdFx0XHRcdFx0XHRcdHdoaWxlICggKCBtYXRjaCA9IHJoZWFkZXJzLmV4ZWMoIHJlc3BvbnNlSGVhZGVyc1N0cmluZyApICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmVzcG9uc2VIZWFkZXJzWyBtYXRjaFsgMSBdLnRvTG93ZXJDYXNlKCkgXSA9IG1hdGNoWyAyIF07XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdG1hdGNoID0gcmVzcG9uc2VIZWFkZXJzWyBrZXkudG9Mb3dlckNhc2UoKSBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gbWF0Y2ggPT0gbnVsbCA/IG51bGwgOiBtYXRjaDtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBSYXcgc3RyaW5nXG5cdFx0XHRcdGdldEFsbFJlc3BvbnNlSGVhZGVyczogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGNvbXBsZXRlZCA/IHJlc3BvbnNlSGVhZGVyc1N0cmluZyA6IG51bGw7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gQ2FjaGVzIHRoZSBoZWFkZXJcblx0XHRcdFx0c2V0UmVxdWVzdEhlYWRlcjogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdFx0XHRcdGlmICggY29tcGxldGVkID09IG51bGwgKSB7XG5cdFx0XHRcdFx0XHRuYW1lID0gcmVxdWVzdEhlYWRlcnNOYW1lc1sgbmFtZS50b0xvd2VyQ2FzZSgpIF0gPVxuXHRcdFx0XHRcdFx0XHRyZXF1ZXN0SGVhZGVyc05hbWVzWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSB8fCBuYW1lO1xuXHRcdFx0XHRcdFx0cmVxdWVzdEhlYWRlcnNbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBPdmVycmlkZXMgcmVzcG9uc2UgY29udGVudC10eXBlIGhlYWRlclxuXHRcdFx0XHRvdmVycmlkZU1pbWVUeXBlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRcdFx0XHRpZiAoIGNvbXBsZXRlZCA9PSBudWxsICkge1xuXHRcdFx0XHRcdFx0cy5taW1lVHlwZSA9IHR5cGU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG5cdFx0XHRcdHN0YXR1c0NvZGU6IGZ1bmN0aW9uKCBtYXAgKSB7XG5cdFx0XHRcdFx0dmFyIGNvZGU7XG5cdFx0XHRcdFx0aWYgKCBtYXAgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBFeGVjdXRlIHRoZSBhcHByb3ByaWF0ZSBjYWxsYmFja3Ncblx0XHRcdFx0XHRcdFx0anFYSFIuYWx3YXlzKCBtYXBbIGpxWEhSLnN0YXR1cyBdICk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdC8vIExhenktYWRkIHRoZSBuZXcgY2FsbGJhY2tzIGluIGEgd2F5IHRoYXQgcHJlc2VydmVzIG9sZCBvbmVzXG5cdFx0XHRcdFx0XHRcdGZvciAoIGNvZGUgaW4gbWFwICkge1xuXHRcdFx0XHRcdFx0XHRcdHN0YXR1c0NvZGVbIGNvZGUgXSA9IFsgc3RhdHVzQ29kZVsgY29kZSBdLCBtYXBbIGNvZGUgXSBdO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIENhbmNlbCB0aGUgcmVxdWVzdFxuXHRcdFx0XHRhYm9ydDogZnVuY3Rpb24oIHN0YXR1c1RleHQgKSB7XG5cdFx0XHRcdFx0dmFyIGZpbmFsVGV4dCA9IHN0YXR1c1RleHQgfHwgc3RyQWJvcnQ7XG5cdFx0XHRcdFx0aWYgKCB0cmFuc3BvcnQgKSB7XG5cdFx0XHRcdFx0XHR0cmFuc3BvcnQuYWJvcnQoIGZpbmFsVGV4dCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkb25lKCAwLCBmaW5hbFRleHQgKTtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdC8vIEF0dGFjaCBkZWZlcnJlZHNcblx0XHRkZWZlcnJlZC5wcm9taXNlKCBqcVhIUiApO1xuXG5cdFx0Ly8gQWRkIHByb3RvY29sIGlmIG5vdCBwcm92aWRlZCAocHJlZmlsdGVycyBtaWdodCBleHBlY3QgaXQpXG5cdFx0Ly8gSGFuZGxlIGZhbHN5IHVybCBpbiB0aGUgc2V0dGluZ3Mgb2JqZWN0ICgjMTAwOTM6IGNvbnNpc3RlbmN5IHdpdGggb2xkIHNpZ25hdHVyZSlcblx0XHQvLyBXZSBhbHNvIHVzZSB0aGUgdXJsIHBhcmFtZXRlciBpZiBhdmFpbGFibGVcblx0XHRzLnVybCA9ICggKCB1cmwgfHwgcy51cmwgfHwgbG9jYXRpb24uaHJlZiApICsgXCJcIiApXG5cdFx0XHQucmVwbGFjZSggcnByb3RvY29sLCBsb2NhdGlvbi5wcm90b2NvbCArIFwiLy9cIiApO1xuXG5cdFx0Ly8gQWxpYXMgbWV0aG9kIG9wdGlvbiB0byB0eXBlIGFzIHBlciB0aWNrZXQgIzEyMDA0XG5cdFx0cy50eXBlID0gb3B0aW9ucy5tZXRob2QgfHwgb3B0aW9ucy50eXBlIHx8IHMubWV0aG9kIHx8IHMudHlwZTtcblxuXHRcdC8vIEV4dHJhY3QgZGF0YVR5cGVzIGxpc3Rcblx0XHRzLmRhdGFUeXBlcyA9ICggcy5kYXRhVHlwZSB8fCBcIipcIiApLnRvTG93ZXJDYXNlKCkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbIFwiXCIgXTtcblxuXHRcdC8vIEEgY3Jvc3MtZG9tYWluIHJlcXVlc3QgaXMgaW4gb3JkZXIgd2hlbiB0aGUgb3JpZ2luIGRvZXNuJ3QgbWF0Y2ggdGhlIGN1cnJlbnQgb3JpZ2luLlxuXHRcdGlmICggcy5jcm9zc0RvbWFpbiA9PSBudWxsICkge1xuXHRcdFx0dXJsQW5jaG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJhXCIgKTtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgPD04IC0gMTEsIEVkZ2UgMTIgLSAxM1xuXHRcdFx0Ly8gSUUgdGhyb3dzIGV4Y2VwdGlvbiBvbiBhY2Nlc3NpbmcgdGhlIGhyZWYgcHJvcGVydHkgaWYgdXJsIGlzIG1hbGZvcm1lZCxcblx0XHRcdC8vIGUuZy4gaHR0cDovL2V4YW1wbGUuY29tOjgweC9cblx0XHRcdHRyeSB7XG5cdFx0XHRcdHVybEFuY2hvci5ocmVmID0gcy51cmw7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD04IC0gMTEgb25seVxuXHRcdFx0XHQvLyBBbmNob3IncyBob3N0IHByb3BlcnR5IGlzbid0IGNvcnJlY3RseSBzZXQgd2hlbiBzLnVybCBpcyByZWxhdGl2ZVxuXHRcdFx0XHR1cmxBbmNob3IuaHJlZiA9IHVybEFuY2hvci5ocmVmO1xuXHRcdFx0XHRzLmNyb3NzRG9tYWluID0gb3JpZ2luQW5jaG9yLnByb3RvY29sICsgXCIvL1wiICsgb3JpZ2luQW5jaG9yLmhvc3QgIT09XG5cdFx0XHRcdFx0dXJsQW5jaG9yLnByb3RvY29sICsgXCIvL1wiICsgdXJsQW5jaG9yLmhvc3Q7XG5cdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHQvLyBJZiB0aGVyZSBpcyBhbiBlcnJvciBwYXJzaW5nIHRoZSBVUkwsIGFzc3VtZSBpdCBpcyBjcm9zc0RvbWFpbixcblx0XHRcdFx0Ly8gaXQgY2FuIGJlIHJlamVjdGVkIGJ5IHRoZSB0cmFuc3BvcnQgaWYgaXQgaXMgaW52YWxpZFxuXHRcdFx0XHRzLmNyb3NzRG9tYWluID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDb252ZXJ0IGRhdGEgaWYgbm90IGFscmVhZHkgYSBzdHJpbmdcblx0XHRpZiAoIHMuZGF0YSAmJiBzLnByb2Nlc3NEYXRhICYmIHR5cGVvZiBzLmRhdGEgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRzLmRhdGEgPSBqUXVlcnkucGFyYW0oIHMuZGF0YSwgcy50cmFkaXRpb25hbCApO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHByZWZpbHRlcnNcblx0XHRpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggcHJlZmlsdGVycywgcywgb3B0aW9ucywganFYSFIgKTtcblxuXHRcdC8vIElmIHJlcXVlc3Qgd2FzIGFib3J0ZWQgaW5zaWRlIGEgcHJlZmlsdGVyLCBzdG9wIHRoZXJlXG5cdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRyZXR1cm4ganFYSFI7XG5cdFx0fVxuXG5cdFx0Ly8gV2UgY2FuIGZpcmUgZ2xvYmFsIGV2ZW50cyBhcyBvZiBub3cgaWYgYXNrZWQgdG9cblx0XHQvLyBEb24ndCBmaXJlIGV2ZW50cyBpZiBqUXVlcnkuZXZlbnQgaXMgdW5kZWZpbmVkIGluIGFuIEFNRC11c2FnZSBzY2VuYXJpbyAoIzE1MTE4KVxuXHRcdGZpcmVHbG9iYWxzID0galF1ZXJ5LmV2ZW50ICYmIHMuZ2xvYmFsO1xuXG5cdFx0Ly8gV2F0Y2ggZm9yIGEgbmV3IHNldCBvZiByZXF1ZXN0c1xuXHRcdGlmICggZmlyZUdsb2JhbHMgJiYgalF1ZXJ5LmFjdGl2ZSsrID09PSAwICkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIFwiYWpheFN0YXJ0XCIgKTtcblx0XHR9XG5cblx0XHQvLyBVcHBlcmNhc2UgdGhlIHR5cGVcblx0XHRzLnR5cGUgPSBzLnR5cGUudG9VcHBlckNhc2UoKTtcblxuXHRcdC8vIERldGVybWluZSBpZiByZXF1ZXN0IGhhcyBjb250ZW50XG5cdFx0cy5oYXNDb250ZW50ID0gIXJub0NvbnRlbnQudGVzdCggcy50eXBlICk7XG5cblx0XHQvLyBTYXZlIHRoZSBVUkwgaW4gY2FzZSB3ZSdyZSB0b3lpbmcgd2l0aCB0aGUgSWYtTW9kaWZpZWQtU2luY2Vcblx0XHQvLyBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIgbGF0ZXIgb25cblx0XHQvLyBSZW1vdmUgaGFzaCB0byBzaW1wbGlmeSB1cmwgbWFuaXB1bGF0aW9uXG5cdFx0Y2FjaGVVUkwgPSBzLnVybC5yZXBsYWNlKCByaGFzaCwgXCJcIiApO1xuXG5cdFx0Ly8gTW9yZSBvcHRpb25zIGhhbmRsaW5nIGZvciByZXF1ZXN0cyB3aXRoIG5vIGNvbnRlbnRcblx0XHRpZiAoICFzLmhhc0NvbnRlbnQgKSB7XG5cblx0XHRcdC8vIFJlbWVtYmVyIHRoZSBoYXNoIHNvIHdlIGNhbiBwdXQgaXQgYmFja1xuXHRcdFx0dW5jYWNoZWQgPSBzLnVybC5zbGljZSggY2FjaGVVUkwubGVuZ3RoICk7XG5cblx0XHRcdC8vIElmIGRhdGEgaXMgYXZhaWxhYmxlLCBhcHBlbmQgZGF0YSB0byB1cmxcblx0XHRcdGlmICggcy5kYXRhICkge1xuXHRcdFx0XHRjYWNoZVVSTCArPSAoIHJxdWVyeS50ZXN0KCBjYWNoZVVSTCApID8gXCImXCIgOiBcIj9cIiApICsgcy5kYXRhO1xuXG5cdFx0XHRcdC8vICM5NjgyOiByZW1vdmUgZGF0YSBzbyB0aGF0IGl0J3Mgbm90IHVzZWQgaW4gYW4gZXZlbnR1YWwgcmV0cnlcblx0XHRcdFx0ZGVsZXRlIHMuZGF0YTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIG9yIHVwZGF0ZSBhbnRpLWNhY2hlIHBhcmFtIGlmIG5lZWRlZFxuXHRcdFx0aWYgKCBzLmNhY2hlID09PSBmYWxzZSApIHtcblx0XHRcdFx0Y2FjaGVVUkwgPSBjYWNoZVVSTC5yZXBsYWNlKCByYW50aUNhY2hlLCBcIiQxXCIgKTtcblx0XHRcdFx0dW5jYWNoZWQgPSAoIHJxdWVyeS50ZXN0KCBjYWNoZVVSTCApID8gXCImXCIgOiBcIj9cIiApICsgXCJfPVwiICsgKCBub25jZSsrICkgKyB1bmNhY2hlZDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUHV0IGhhc2ggYW5kIGFudGktY2FjaGUgb24gdGhlIFVSTCB0aGF0IHdpbGwgYmUgcmVxdWVzdGVkIChnaC0xNzMyKVxuXHRcdFx0cy51cmwgPSBjYWNoZVVSTCArIHVuY2FjaGVkO1xuXG5cdFx0Ly8gQ2hhbmdlICclMjAnIHRvICcrJyBpZiB0aGlzIGlzIGVuY29kZWQgZm9ybSBib2R5IGNvbnRlbnQgKGdoLTI2NTgpXG5cdFx0fSBlbHNlIGlmICggcy5kYXRhICYmIHMucHJvY2Vzc0RhdGEgJiZcblx0XHRcdCggcy5jb250ZW50VHlwZSB8fCBcIlwiICkuaW5kZXhPZiggXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIiApID09PSAwICkge1xuXHRcdFx0cy5kYXRhID0gcy5kYXRhLnJlcGxhY2UoIHIyMCwgXCIrXCIgKTtcblx0XHR9XG5cblx0XHQvLyBTZXQgdGhlIElmLU1vZGlmaWVkLVNpbmNlIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciwgaWYgaW4gaWZNb2RpZmllZCBtb2RlLlxuXHRcdGlmICggcy5pZk1vZGlmaWVkICkge1xuXHRcdFx0aWYgKCBqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdICkge1xuXHRcdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIklmLU1vZGlmaWVkLVNpbmNlXCIsIGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gKTtcblx0XHRcdH1cblx0XHRcdGlmICggalF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gKSB7XG5cdFx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFwiSWYtTm9uZS1NYXRjaFwiLCBqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgY29ycmVjdCBoZWFkZXIsIGlmIGRhdGEgaXMgYmVpbmcgc2VudFxuXHRcdGlmICggcy5kYXRhICYmIHMuaGFzQ29udGVudCAmJiBzLmNvbnRlbnRUeXBlICE9PSBmYWxzZSB8fCBvcHRpb25zLmNvbnRlbnRUeXBlICkge1xuXHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggXCJDb250ZW50LVR5cGVcIiwgcy5jb250ZW50VHlwZSApO1xuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgQWNjZXB0cyBoZWFkZXIgZm9yIHRoZSBzZXJ2ZXIsIGRlcGVuZGluZyBvbiB0aGUgZGF0YVR5cGVcblx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKFxuXHRcdFx0XCJBY2NlcHRcIixcblx0XHRcdHMuZGF0YVR5cGVzWyAwIF0gJiYgcy5hY2NlcHRzWyBzLmRhdGFUeXBlc1sgMCBdIF0gP1xuXHRcdFx0XHRzLmFjY2VwdHNbIHMuZGF0YVR5cGVzWyAwIF0gXSArXG5cdFx0XHRcdFx0KCBzLmRhdGFUeXBlc1sgMCBdICE9PSBcIipcIiA/IFwiLCBcIiArIGFsbFR5cGVzICsgXCI7IHE9MC4wMVwiIDogXCJcIiApIDpcblx0XHRcdFx0cy5hY2NlcHRzWyBcIipcIiBdXG5cdFx0KTtcblxuXHRcdC8vIENoZWNrIGZvciBoZWFkZXJzIG9wdGlvblxuXHRcdGZvciAoIGkgaW4gcy5oZWFkZXJzICkge1xuXHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggaSwgcy5oZWFkZXJzWyBpIF0gKTtcblx0XHR9XG5cblx0XHQvLyBBbGxvdyBjdXN0b20gaGVhZGVycy9taW1ldHlwZXMgYW5kIGVhcmx5IGFib3J0XG5cdFx0aWYgKCBzLmJlZm9yZVNlbmQgJiZcblx0XHRcdCggcy5iZWZvcmVTZW5kLmNhbGwoIGNhbGxiYWNrQ29udGV4dCwganFYSFIsIHMgKSA9PT0gZmFsc2UgfHwgY29tcGxldGVkICkgKSB7XG5cblx0XHRcdC8vIEFib3J0IGlmIG5vdCBkb25lIGFscmVhZHkgYW5kIHJldHVyblxuXHRcdFx0cmV0dXJuIGpxWEhSLmFib3J0KCk7XG5cdFx0fVxuXG5cdFx0Ly8gQWJvcnRpbmcgaXMgbm8gbG9uZ2VyIGEgY2FuY2VsbGF0aW9uXG5cdFx0c3RyQWJvcnQgPSBcImFib3J0XCI7XG5cblx0XHQvLyBJbnN0YWxsIGNhbGxiYWNrcyBvbiBkZWZlcnJlZHNcblx0XHRjb21wbGV0ZURlZmVycmVkLmFkZCggcy5jb21wbGV0ZSApO1xuXHRcdGpxWEhSLmRvbmUoIHMuc3VjY2VzcyApO1xuXHRcdGpxWEhSLmZhaWwoIHMuZXJyb3IgKTtcblxuXHRcdC8vIEdldCB0cmFuc3BvcnRcblx0XHR0cmFuc3BvcnQgPSBpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggdHJhbnNwb3J0cywgcywgb3B0aW9ucywganFYSFIgKTtcblxuXHRcdC8vIElmIG5vIHRyYW5zcG9ydCwgd2UgYXV0by1hYm9ydFxuXHRcdGlmICggIXRyYW5zcG9ydCApIHtcblx0XHRcdGRvbmUoIC0xLCBcIk5vIFRyYW5zcG9ydFwiICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGpxWEhSLnJlYWR5U3RhdGUgPSAxO1xuXG5cdFx0XHQvLyBTZW5kIGdsb2JhbCBldmVudFxuXHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIFwiYWpheFNlbmRcIiwgWyBqcVhIUiwgcyBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIHJlcXVlc3Qgd2FzIGFib3J0ZWQgaW5zaWRlIGFqYXhTZW5kLCBzdG9wIHRoZXJlXG5cdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdFx0cmV0dXJuIGpxWEhSO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUaW1lb3V0XG5cdFx0XHRpZiAoIHMuYXN5bmMgJiYgcy50aW1lb3V0ID4gMCApIHtcblx0XHRcdFx0dGltZW91dFRpbWVyID0gd2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGpxWEhSLmFib3J0KCBcInRpbWVvdXRcIiApO1xuXHRcdFx0XHR9LCBzLnRpbWVvdXQgKTtcblx0XHRcdH1cblxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Y29tcGxldGVkID0gZmFsc2U7XG5cdFx0XHRcdHRyYW5zcG9ydC5zZW5kKCByZXF1ZXN0SGVhZGVycywgZG9uZSApO1xuXHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0Ly8gUmV0aHJvdyBwb3N0LWNvbXBsZXRpb24gZXhjZXB0aW9uc1xuXHRcdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdFx0XHR0aHJvdyBlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUHJvcGFnYXRlIG90aGVycyBhcyByZXN1bHRzXG5cdFx0XHRcdGRvbmUoIC0xLCBlICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsbGJhY2sgZm9yIHdoZW4gZXZlcnl0aGluZyBpcyBkb25lXG5cdFx0ZnVuY3Rpb24gZG9uZSggc3RhdHVzLCBuYXRpdmVTdGF0dXNUZXh0LCByZXNwb25zZXMsIGhlYWRlcnMgKSB7XG5cdFx0XHR2YXIgaXNTdWNjZXNzLCBzdWNjZXNzLCBlcnJvciwgcmVzcG9uc2UsIG1vZGlmaWVkLFxuXHRcdFx0XHRzdGF0dXNUZXh0ID0gbmF0aXZlU3RhdHVzVGV4dDtcblxuXHRcdFx0Ly8gSWdub3JlIHJlcGVhdCBpbnZvY2F0aW9uc1xuXHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Y29tcGxldGVkID0gdHJ1ZTtcblxuXHRcdFx0Ly8gQ2xlYXIgdGltZW91dCBpZiBpdCBleGlzdHNcblx0XHRcdGlmICggdGltZW91dFRpbWVyICkge1xuXHRcdFx0XHR3aW5kb3cuY2xlYXJUaW1lb3V0KCB0aW1lb3V0VGltZXIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRGVyZWZlcmVuY2UgdHJhbnNwb3J0IGZvciBlYXJseSBnYXJiYWdlIGNvbGxlY3Rpb25cblx0XHRcdC8vIChubyBtYXR0ZXIgaG93IGxvbmcgdGhlIGpxWEhSIG9iamVjdCB3aWxsIGJlIHVzZWQpXG5cdFx0XHR0cmFuc3BvcnQgPSB1bmRlZmluZWQ7XG5cblx0XHRcdC8vIENhY2hlIHJlc3BvbnNlIGhlYWRlcnNcblx0XHRcdHJlc3BvbnNlSGVhZGVyc1N0cmluZyA9IGhlYWRlcnMgfHwgXCJcIjtcblxuXHRcdFx0Ly8gU2V0IHJlYWR5U3RhdGVcblx0XHRcdGpxWEhSLnJlYWR5U3RhdGUgPSBzdGF0dXMgPiAwID8gNCA6IDA7XG5cblx0XHRcdC8vIERldGVybWluZSBpZiBzdWNjZXNzZnVsXG5cdFx0XHRpc1N1Y2Nlc3MgPSBzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMCB8fCBzdGF0dXMgPT09IDMwNDtcblxuXHRcdFx0Ly8gR2V0IHJlc3BvbnNlIGRhdGFcblx0XHRcdGlmICggcmVzcG9uc2VzICkge1xuXHRcdFx0XHRyZXNwb25zZSA9IGFqYXhIYW5kbGVSZXNwb25zZXMoIHMsIGpxWEhSLCByZXNwb25zZXMgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29udmVydCBubyBtYXR0ZXIgd2hhdCAodGhhdCB3YXkgcmVzcG9uc2VYWFggZmllbGRzIGFyZSBhbHdheXMgc2V0KVxuXHRcdFx0cmVzcG9uc2UgPSBhamF4Q29udmVydCggcywgcmVzcG9uc2UsIGpxWEhSLCBpc1N1Y2Nlc3MgKTtcblxuXHRcdFx0Ly8gSWYgc3VjY2Vzc2Z1bCwgaGFuZGxlIHR5cGUgY2hhaW5pbmdcblx0XHRcdGlmICggaXNTdWNjZXNzICkge1xuXG5cdFx0XHRcdC8vIFNldCB0aGUgSWYtTW9kaWZpZWQtU2luY2UgYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyLCBpZiBpbiBpZk1vZGlmaWVkIG1vZGUuXG5cdFx0XHRcdGlmICggcy5pZk1vZGlmaWVkICkge1xuXHRcdFx0XHRcdG1vZGlmaWVkID0ganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoIFwiTGFzdC1Nb2RpZmllZFwiICk7XG5cdFx0XHRcdFx0aWYgKCBtb2RpZmllZCApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gPSBtb2RpZmllZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bW9kaWZpZWQgPSBqcVhIUi5nZXRSZXNwb25zZUhlYWRlciggXCJldGFnXCIgKTtcblx0XHRcdFx0XHRpZiAoIG1vZGlmaWVkICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gPSBtb2RpZmllZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBpZiBubyBjb250ZW50XG5cdFx0XHRcdGlmICggc3RhdHVzID09PSAyMDQgfHwgcy50eXBlID09PSBcIkhFQURcIiApIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJub2NvbnRlbnRcIjtcblxuXHRcdFx0XHQvLyBpZiBub3QgbW9kaWZpZWRcblx0XHRcdFx0fSBlbHNlIGlmICggc3RhdHVzID09PSAzMDQgKSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwibm90bW9kaWZpZWRcIjtcblxuXHRcdFx0XHQvLyBJZiB3ZSBoYXZlIGRhdGEsIGxldCdzIGNvbnZlcnQgaXRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gcmVzcG9uc2Uuc3RhdGU7XG5cdFx0XHRcdFx0c3VjY2VzcyA9IHJlc3BvbnNlLmRhdGE7XG5cdFx0XHRcdFx0ZXJyb3IgPSByZXNwb25zZS5lcnJvcjtcblx0XHRcdFx0XHRpc1N1Y2Nlc3MgPSAhZXJyb3I7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gRXh0cmFjdCBlcnJvciBmcm9tIHN0YXR1c1RleHQgYW5kIG5vcm1hbGl6ZSBmb3Igbm9uLWFib3J0c1xuXHRcdFx0XHRlcnJvciA9IHN0YXR1c1RleHQ7XG5cdFx0XHRcdGlmICggc3RhdHVzIHx8ICFzdGF0dXNUZXh0ICkge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcImVycm9yXCI7XG5cdFx0XHRcdFx0aWYgKCBzdGF0dXMgPCAwICkge1xuXHRcdFx0XHRcdFx0c3RhdHVzID0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gU2V0IGRhdGEgZm9yIHRoZSBmYWtlIHhociBvYmplY3Rcblx0XHRcdGpxWEhSLnN0YXR1cyA9IHN0YXR1cztcblx0XHRcdGpxWEhSLnN0YXR1c1RleHQgPSAoIG5hdGl2ZVN0YXR1c1RleHQgfHwgc3RhdHVzVGV4dCApICsgXCJcIjtcblxuXHRcdFx0Ly8gU3VjY2Vzcy9FcnJvclxuXHRcdFx0aWYgKCBpc1N1Y2Nlc3MgKSB7XG5cdFx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsgc3VjY2Vzcywgc3RhdHVzVGV4dCwganFYSFIgXSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0V2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIGpxWEhSLCBzdGF0dXNUZXh0LCBlcnJvciBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG5cdFx0XHRqcVhIUi5zdGF0dXNDb2RlKCBzdGF0dXNDb2RlICk7XG5cdFx0XHRzdGF0dXNDb2RlID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRpZiAoIGZpcmVHbG9iYWxzICkge1xuXHRcdFx0XHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggaXNTdWNjZXNzID8gXCJhamF4U3VjY2Vzc1wiIDogXCJhamF4RXJyb3JcIixcblx0XHRcdFx0XHRbIGpxWEhSLCBzLCBpc1N1Y2Nlc3MgPyBzdWNjZXNzIDogZXJyb3IgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb21wbGV0ZVxuXHRcdFx0Y29tcGxldGVEZWZlcnJlZC5maXJlV2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIGpxWEhSLCBzdGF0dXNUZXh0IF0gKTtcblxuXHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIFwiYWpheENvbXBsZXRlXCIsIFsganFYSFIsIHMgXSApO1xuXG5cdFx0XHRcdC8vIEhhbmRsZSB0aGUgZ2xvYmFsIEFKQVggY291bnRlclxuXHRcdFx0XHRpZiAoICEoIC0talF1ZXJ5LmFjdGl2ZSApICkge1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBcImFqYXhTdG9wXCIgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBqcVhIUjtcblx0fSxcblxuXHRnZXRKU09OOiBmdW5jdGlvbiggdXJsLCBkYXRhLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdldCggdXJsLCBkYXRhLCBjYWxsYmFjaywgXCJqc29uXCIgKTtcblx0fSxcblxuXHRnZXRTY3JpcHQ6IGZ1bmN0aW9uKCB1cmwsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ2V0KCB1cmwsIHVuZGVmaW5lZCwgY2FsbGJhY2ssIFwic2NyaXB0XCIgKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCggWyBcImdldFwiLCBcInBvc3RcIiBdLCBmdW5jdGlvbiggaSwgbWV0aG9kICkge1xuXHRqUXVlcnlbIG1ldGhvZCBdID0gZnVuY3Rpb24oIHVybCwgZGF0YSwgY2FsbGJhY2ssIHR5cGUgKSB7XG5cblx0XHQvLyBTaGlmdCBhcmd1bWVudHMgaWYgZGF0YSBhcmd1bWVudCB3YXMgb21pdHRlZFxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIGRhdGEgKSApIHtcblx0XHRcdHR5cGUgPSB0eXBlIHx8IGNhbGxiYWNrO1xuXHRcdFx0Y2FsbGJhY2sgPSBkYXRhO1xuXHRcdFx0ZGF0YSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHQvLyBUaGUgdXJsIGNhbiBiZSBhbiBvcHRpb25zIG9iamVjdCAod2hpY2ggdGhlbiBtdXN0IGhhdmUgLnVybClcblx0XHRyZXR1cm4galF1ZXJ5LmFqYXgoIGpRdWVyeS5leHRlbmQoIHtcblx0XHRcdHVybDogdXJsLFxuXHRcdFx0dHlwZTogbWV0aG9kLFxuXHRcdFx0ZGF0YVR5cGU6IHR5cGUsXG5cdFx0XHRkYXRhOiBkYXRhLFxuXHRcdFx0c3VjY2VzczogY2FsbGJhY2tcblx0XHR9LCBqUXVlcnkuaXNQbGFpbk9iamVjdCggdXJsICkgJiYgdXJsICkgKTtcblx0fTtcbn0gKTtcblxuXG5qUXVlcnkuX2V2YWxVcmwgPSBmdW5jdGlvbiggdXJsICkge1xuXHRyZXR1cm4galF1ZXJ5LmFqYXgoIHtcblx0XHR1cmw6IHVybCxcblxuXHRcdC8vIE1ha2UgdGhpcyBleHBsaWNpdCwgc2luY2UgdXNlciBjYW4gb3ZlcnJpZGUgdGhpcyB0aHJvdWdoIGFqYXhTZXR1cCAoIzExMjY0KVxuXHRcdHR5cGU6IFwiR0VUXCIsXG5cdFx0ZGF0YVR5cGU6IFwic2NyaXB0XCIsXG5cdFx0Y2FjaGU6IHRydWUsXG5cdFx0YXN5bmM6IGZhbHNlLFxuXHRcdGdsb2JhbDogZmFsc2UsXG5cdFx0XCJ0aHJvd3NcIjogdHJ1ZVxuXHR9ICk7XG59O1xuXG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0d3JhcEFsbDogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0dmFyIHdyYXA7XG5cblx0XHRpZiAoIHRoaXNbIDAgXSApIHtcblx0XHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIGh0bWwgKSApIHtcblx0XHRcdFx0aHRtbCA9IGh0bWwuY2FsbCggdGhpc1sgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRoZSBlbGVtZW50cyB0byB3cmFwIHRoZSB0YXJnZXQgYXJvdW5kXG5cdFx0XHR3cmFwID0galF1ZXJ5KCBodG1sLCB0aGlzWyAwIF0ub3duZXJEb2N1bWVudCApLmVxKCAwICkuY2xvbmUoIHRydWUgKTtcblxuXHRcdFx0aWYgKCB0aGlzWyAwIF0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0d3JhcC5pbnNlcnRCZWZvcmUoIHRoaXNbIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHR3cmFwLm1hcCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBlbGVtID0gdGhpcztcblxuXHRcdFx0XHR3aGlsZSAoIGVsZW0uZmlyc3RFbGVtZW50Q2hpbGQgKSB7XG5cdFx0XHRcdFx0ZWxlbSA9IGVsZW0uZmlyc3RFbGVtZW50Q2hpbGQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gZWxlbTtcblx0XHRcdH0gKS5hcHBlbmQoIHRoaXMgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHR3cmFwSW5uZXI6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIGh0bWwgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS53cmFwSW5uZXIoIGh0bWwuY2FsbCggdGhpcywgaSApICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgc2VsZiA9IGpRdWVyeSggdGhpcyApLFxuXHRcdFx0XHRjb250ZW50cyA9IHNlbGYuY29udGVudHMoKTtcblxuXHRcdFx0aWYgKCBjb250ZW50cy5sZW5ndGggKSB7XG5cdFx0XHRcdGNvbnRlbnRzLndyYXBBbGwoIGh0bWwgKTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c2VsZi5hcHBlbmQoIGh0bWwgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0d3JhcDogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0dmFyIGlzRnVuY3Rpb24gPSBqUXVlcnkuaXNGdW5jdGlvbiggaHRtbCApO1xuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRqUXVlcnkoIHRoaXMgKS53cmFwQWxsKCBpc0Z1bmN0aW9uID8gaHRtbC5jYWxsKCB0aGlzLCBpICkgOiBodG1sICk7XG5cdFx0fSApO1xuXHR9LFxuXG5cdHVud3JhcDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHRoaXMucGFyZW50KCBzZWxlY3RvciApLm5vdCggXCJib2R5XCIgKS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeSggdGhpcyApLnJlcGxhY2VXaXRoKCB0aGlzLmNoaWxkTm9kZXMgKTtcblx0XHR9ICk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn0gKTtcblxuXG5qUXVlcnkuZXhwci5wc2V1ZG9zLmhpZGRlbiA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRyZXR1cm4gIWpRdWVyeS5leHByLnBzZXVkb3MudmlzaWJsZSggZWxlbSApO1xufTtcbmpRdWVyeS5leHByLnBzZXVkb3MudmlzaWJsZSA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRyZXR1cm4gISEoIGVsZW0ub2Zmc2V0V2lkdGggfHwgZWxlbS5vZmZzZXRIZWlnaHQgfHwgZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCApO1xufTtcblxuXG5cblxualF1ZXJ5LmFqYXhTZXR0aW5ncy54aHIgPSBmdW5jdGlvbigpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gbmV3IHdpbmRvdy5YTUxIdHRwUmVxdWVzdCgpO1xuXHR9IGNhdGNoICggZSApIHt9XG59O1xuXG52YXIgeGhyU3VjY2Vzc1N0YXR1cyA9IHtcblxuXHRcdC8vIEZpbGUgcHJvdG9jb2wgYWx3YXlzIHlpZWxkcyBzdGF0dXMgY29kZSAwLCBhc3N1bWUgMjAwXG5cdFx0MDogMjAwLFxuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0XHQvLyAjMTQ1MDogc29tZXRpbWVzIElFIHJldHVybnMgMTIyMyB3aGVuIGl0IHNob3VsZCBiZSAyMDRcblx0XHQxMjIzOiAyMDRcblx0fSxcblx0eGhyU3VwcG9ydGVkID0galF1ZXJ5LmFqYXhTZXR0aW5ncy54aHIoKTtcblxuc3VwcG9ydC5jb3JzID0gISF4aHJTdXBwb3J0ZWQgJiYgKCBcIndpdGhDcmVkZW50aWFsc1wiIGluIHhoclN1cHBvcnRlZCApO1xuc3VwcG9ydC5hamF4ID0geGhyU3VwcG9ydGVkID0gISF4aHJTdXBwb3J0ZWQ7XG5cbmpRdWVyeS5hamF4VHJhbnNwb3J0KCBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0dmFyIGNhbGxiYWNrLCBlcnJvckNhbGxiYWNrO1xuXG5cdC8vIENyb3NzIGRvbWFpbiBvbmx5IGFsbG93ZWQgaWYgc3VwcG9ydGVkIHRocm91Z2ggWE1MSHR0cFJlcXVlc3Rcblx0aWYgKCBzdXBwb3J0LmNvcnMgfHwgeGhyU3VwcG9ydGVkICYmICFvcHRpb25zLmNyb3NzRG9tYWluICkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRzZW5kOiBmdW5jdGlvbiggaGVhZGVycywgY29tcGxldGUgKSB7XG5cdFx0XHRcdHZhciBpLFxuXHRcdFx0XHRcdHhociA9IG9wdGlvbnMueGhyKCk7XG5cblx0XHRcdFx0eGhyLm9wZW4oXG5cdFx0XHRcdFx0b3B0aW9ucy50eXBlLFxuXHRcdFx0XHRcdG9wdGlvbnMudXJsLFxuXHRcdFx0XHRcdG9wdGlvbnMuYXN5bmMsXG5cdFx0XHRcdFx0b3B0aW9ucy51c2VybmFtZSxcblx0XHRcdFx0XHRvcHRpb25zLnBhc3N3b3JkXG5cdFx0XHRcdCk7XG5cblx0XHRcdFx0Ly8gQXBwbHkgY3VzdG9tIGZpZWxkcyBpZiBwcm92aWRlZFxuXHRcdFx0XHRpZiAoIG9wdGlvbnMueGhyRmllbGRzICkge1xuXHRcdFx0XHRcdGZvciAoIGkgaW4gb3B0aW9ucy54aHJGaWVsZHMgKSB7XG5cdFx0XHRcdFx0XHR4aHJbIGkgXSA9IG9wdGlvbnMueGhyRmllbGRzWyBpIF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gT3ZlcnJpZGUgbWltZSB0eXBlIGlmIG5lZWRlZFxuXHRcdFx0XHRpZiAoIG9wdGlvbnMubWltZVR5cGUgJiYgeGhyLm92ZXJyaWRlTWltZVR5cGUgKSB7XG5cdFx0XHRcdFx0eGhyLm92ZXJyaWRlTWltZVR5cGUoIG9wdGlvbnMubWltZVR5cGUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFgtUmVxdWVzdGVkLVdpdGggaGVhZGVyXG5cdFx0XHRcdC8vIEZvciBjcm9zcy1kb21haW4gcmVxdWVzdHMsIHNlZWluZyBhcyBjb25kaXRpb25zIGZvciBhIHByZWZsaWdodCBhcmVcblx0XHRcdFx0Ly8gYWtpbiB0byBhIGppZ3NhdyBwdXp6bGUsIHdlIHNpbXBseSBuZXZlciBzZXQgaXQgdG8gYmUgc3VyZS5cblx0XHRcdFx0Ly8gKGl0IGNhbiBhbHdheXMgYmUgc2V0IG9uIGEgcGVyLXJlcXVlc3QgYmFzaXMgb3IgZXZlbiB1c2luZyBhamF4U2V0dXApXG5cdFx0XHRcdC8vIEZvciBzYW1lLWRvbWFpbiByZXF1ZXN0cywgd29uJ3QgY2hhbmdlIGhlYWRlciBpZiBhbHJlYWR5IHByb3ZpZGVkLlxuXHRcdFx0XHRpZiAoICFvcHRpb25zLmNyb3NzRG9tYWluICYmICFoZWFkZXJzWyBcIlgtUmVxdWVzdGVkLVdpdGhcIiBdICkge1xuXHRcdFx0XHRcdGhlYWRlcnNbIFwiWC1SZXF1ZXN0ZWQtV2l0aFwiIF0gPSBcIlhNTEh0dHBSZXF1ZXN0XCI7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTZXQgaGVhZGVyc1xuXHRcdFx0XHRmb3IgKCBpIGluIGhlYWRlcnMgKSB7XG5cdFx0XHRcdFx0eGhyLnNldFJlcXVlc3RIZWFkZXIoIGksIGhlYWRlcnNbIGkgXSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQ2FsbGJhY2tcblx0XHRcdFx0Y2FsbGJhY2sgPSBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdFx0XHRjYWxsYmFjayA9IGVycm9yQ2FsbGJhY2sgPSB4aHIub25sb2FkID1cblx0XHRcdFx0XHRcdFx0XHR4aHIub25lcnJvciA9IHhoci5vbmFib3J0ID0geGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCB0eXBlID09PSBcImFib3J0XCIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0eGhyLmFib3J0KCk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIHR5cGUgPT09IFwiZXJyb3JcIiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdFx0XHRcdFx0XHRcdFx0Ly8gT24gYSBtYW51YWwgbmF0aXZlIGFib3J0LCBJRTkgdGhyb3dzXG5cdFx0XHRcdFx0XHRcdFx0Ly8gZXJyb3JzIG9uIGFueSBwcm9wZXJ0eSBhY2Nlc3MgdGhhdCBpcyBub3QgcmVhZHlTdGF0ZVxuXHRcdFx0XHRcdFx0XHRcdGlmICggdHlwZW9mIHhoci5zdGF0dXMgIT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb21wbGV0ZSggMCwgXCJlcnJvclwiICk7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbXBsZXRlKFxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIEZpbGU6IHByb3RvY29sIGFsd2F5cyB5aWVsZHMgc3RhdHVzIDA7IHNlZSAjODYwNSwgIzE0MjA3XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHhoci5zdGF0dXMsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHhoci5zdGF0dXNUZXh0XG5cdFx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRjb21wbGV0ZShcblx0XHRcdFx0XHRcdFx0XHRcdHhoclN1Y2Nlc3NTdGF0dXNbIHhoci5zdGF0dXMgXSB8fCB4aHIuc3RhdHVzLFxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyLnN0YXR1c1RleHQsXG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBJRTkgaGFzIG5vIFhIUjIgYnV0IHRocm93cyBvbiBiaW5hcnkgKHRyYWMtMTE0MjYpXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBGb3IgWEhSMiBub24tdGV4dCwgbGV0IHRoZSBjYWxsZXIgaGFuZGxlIGl0IChnaC0yNDk4KVxuXHRcdFx0XHRcdFx0XHRcdFx0KCB4aHIucmVzcG9uc2VUeXBlIHx8IFwidGV4dFwiICkgIT09IFwidGV4dFwiICB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0dHlwZW9mIHhoci5yZXNwb25zZVRleHQgIT09IFwic3RyaW5nXCIgP1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR7IGJpbmFyeTogeGhyLnJlc3BvbnNlIH0gOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR7IHRleHQ6IHhoci5yZXNwb25zZVRleHQgfSxcblx0XHRcdFx0XHRcdFx0XHRcdHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKVxuXHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdC8vIExpc3RlbiB0byBldmVudHNcblx0XHRcdFx0eGhyLm9ubG9hZCA9IGNhbGxiYWNrKCk7XG5cdFx0XHRcdGVycm9yQ2FsbGJhY2sgPSB4aHIub25lcnJvciA9IGNhbGxiYWNrKCBcImVycm9yXCIgKTtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA5IG9ubHlcblx0XHRcdFx0Ly8gVXNlIG9ucmVhZHlzdGF0ZWNoYW5nZSB0byByZXBsYWNlIG9uYWJvcnRcblx0XHRcdFx0Ly8gdG8gaGFuZGxlIHVuY2F1Z2h0IGFib3J0c1xuXHRcdFx0XHRpZiAoIHhoci5vbmFib3J0ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0eGhyLm9uYWJvcnQgPSBlcnJvckNhbGxiYWNrO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHRcdFx0Ly8gQ2hlY2sgcmVhZHlTdGF0ZSBiZWZvcmUgdGltZW91dCBhcyBpdCBjaGFuZ2VzXG5cdFx0XHRcdFx0XHRpZiAoIHhoci5yZWFkeVN0YXRlID09PSA0ICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIEFsbG93IG9uZXJyb3IgdG8gYmUgY2FsbGVkIGZpcnN0LFxuXHRcdFx0XHRcdFx0XHQvLyBidXQgdGhhdCB3aWxsIG5vdCBoYW5kbGUgYSBuYXRpdmUgYWJvcnRcblx0XHRcdFx0XHRcdFx0Ly8gQWxzbywgc2F2ZSBlcnJvckNhbGxiYWNrIHRvIGEgdmFyaWFibGVcblx0XHRcdFx0XHRcdFx0Ly8gYXMgeGhyLm9uZXJyb3IgY2Fubm90IGJlIGFjY2Vzc2VkXG5cdFx0XHRcdFx0XHRcdHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZXJyb3JDYWxsYmFjaygpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBDcmVhdGUgdGhlIGFib3J0IGNhbGxiYWNrXG5cdFx0XHRcdGNhbGxiYWNrID0gY2FsbGJhY2soIFwiYWJvcnRcIiApO1xuXG5cdFx0XHRcdHRyeSB7XG5cblx0XHRcdFx0XHQvLyBEbyBzZW5kIHRoZSByZXF1ZXN0ICh0aGlzIG1heSByYWlzZSBhbiBleGNlcHRpb24pXG5cdFx0XHRcdFx0eGhyLnNlbmQoIG9wdGlvbnMuaGFzQ29udGVudCAmJiBvcHRpb25zLmRhdGEgfHwgbnVsbCApO1xuXHRcdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHRcdC8vICMxNDY4MzogT25seSByZXRocm93IGlmIHRoaXMgaGFzbid0IGJlZW4gbm90aWZpZWQgYXMgYW4gZXJyb3IgeWV0XG5cdFx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRcdHRocm93IGU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHRhYm9ydDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH1cbn0gKTtcblxuXG5cblxuLy8gUHJldmVudCBhdXRvLWV4ZWN1dGlvbiBvZiBzY3JpcHRzIHdoZW4gbm8gZXhwbGljaXQgZGF0YVR5cGUgd2FzIHByb3ZpZGVkIChTZWUgZ2gtMjQzMilcbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBmdW5jdGlvbiggcyApIHtcblx0aWYgKCBzLmNyb3NzRG9tYWluICkge1xuXHRcdHMuY29udGVudHMuc2NyaXB0ID0gZmFsc2U7XG5cdH1cbn0gKTtcblxuLy8gSW5zdGFsbCBzY3JpcHQgZGF0YVR5cGVcbmpRdWVyeS5hamF4U2V0dXAoIHtcblx0YWNjZXB0czoge1xuXHRcdHNjcmlwdDogXCJ0ZXh0L2phdmFzY3JpcHQsIGFwcGxpY2F0aW9uL2phdmFzY3JpcHQsIFwiICtcblx0XHRcdFwiYXBwbGljYXRpb24vZWNtYXNjcmlwdCwgYXBwbGljYXRpb24veC1lY21hc2NyaXB0XCJcblx0fSxcblx0Y29udGVudHM6IHtcblx0XHRzY3JpcHQ6IC9cXGIoPzpqYXZhfGVjbWEpc2NyaXB0XFxiL1xuXHR9LFxuXHRjb252ZXJ0ZXJzOiB7XG5cdFx0XCJ0ZXh0IHNjcmlwdFwiOiBmdW5jdGlvbiggdGV4dCApIHtcblx0XHRcdGpRdWVyeS5nbG9iYWxFdmFsKCB0ZXh0ICk7XG5cdFx0XHRyZXR1cm4gdGV4dDtcblx0XHR9XG5cdH1cbn0gKTtcblxuLy8gSGFuZGxlIGNhY2hlJ3Mgc3BlY2lhbCBjYXNlIGFuZCBjcm9zc0RvbWFpblxualF1ZXJ5LmFqYXhQcmVmaWx0ZXIoIFwic2NyaXB0XCIsIGZ1bmN0aW9uKCBzICkge1xuXHRpZiAoIHMuY2FjaGUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRzLmNhY2hlID0gZmFsc2U7XG5cdH1cblx0aWYgKCBzLmNyb3NzRG9tYWluICkge1xuXHRcdHMudHlwZSA9IFwiR0VUXCI7XG5cdH1cbn0gKTtcblxuLy8gQmluZCBzY3JpcHQgdGFnIGhhY2sgdHJhbnNwb3J0XG5qUXVlcnkuYWpheFRyYW5zcG9ydCggXCJzY3JpcHRcIiwgZnVuY3Rpb24oIHMgKSB7XG5cblx0Ly8gVGhpcyB0cmFuc3BvcnQgb25seSBkZWFscyB3aXRoIGNyb3NzIGRvbWFpbiByZXF1ZXN0c1xuXHRpZiAoIHMuY3Jvc3NEb21haW4gKSB7XG5cdFx0dmFyIHNjcmlwdCwgY2FsbGJhY2s7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHNlbmQ6IGZ1bmN0aW9uKCBfLCBjb21wbGV0ZSApIHtcblx0XHRcdFx0c2NyaXB0ID0galF1ZXJ5KCBcIjxzY3JpcHQ+XCIgKS5wcm9wKCB7XG5cdFx0XHRcdFx0Y2hhcnNldDogcy5zY3JpcHRDaGFyc2V0LFxuXHRcdFx0XHRcdHNyYzogcy51cmxcblx0XHRcdFx0fSApLm9uKFxuXHRcdFx0XHRcdFwibG9hZCBlcnJvclwiLFxuXHRcdFx0XHRcdGNhbGxiYWNrID0gZnVuY3Rpb24oIGV2dCApIHtcblx0XHRcdFx0XHRcdHNjcmlwdC5yZW1vdmUoKTtcblx0XHRcdFx0XHRcdGNhbGxiYWNrID0gbnVsbDtcblx0XHRcdFx0XHRcdGlmICggZXZ0ICkge1xuXHRcdFx0XHRcdFx0XHRjb21wbGV0ZSggZXZ0LnR5cGUgPT09IFwiZXJyb3JcIiA/IDQwNCA6IDIwMCwgZXZ0LnR5cGUgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdCk7XG5cblx0XHRcdFx0Ly8gVXNlIG5hdGl2ZSBET00gbWFuaXB1bGF0aW9uIHRvIGF2b2lkIG91ciBkb21NYW5pcCBBSkFYIHRyaWNrZXJ5XG5cdFx0XHRcdGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoIHNjcmlwdFsgMCBdICk7XG5cdFx0XHR9LFxuXHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9XG59ICk7XG5cblxuXG5cbnZhciBvbGRDYWxsYmFja3MgPSBbXSxcblx0cmpzb25wID0gLyg9KVxcPyg/PSZ8JCl8XFw/XFw/LztcblxuLy8gRGVmYXVsdCBqc29ucCBzZXR0aW5nc1xualF1ZXJ5LmFqYXhTZXR1cCgge1xuXHRqc29ucDogXCJjYWxsYmFja1wiLFxuXHRqc29ucENhbGxiYWNrOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY2FsbGJhY2sgPSBvbGRDYWxsYmFja3MucG9wKCkgfHwgKCBqUXVlcnkuZXhwYW5kbyArIFwiX1wiICsgKCBub25jZSsrICkgKTtcblx0XHR0aGlzWyBjYWxsYmFjayBdID0gdHJ1ZTtcblx0XHRyZXR1cm4gY2FsbGJhY2s7XG5cdH1cbn0gKTtcblxuLy8gRGV0ZWN0LCBub3JtYWxpemUgb3B0aW9ucyBhbmQgaW5zdGFsbCBjYWxsYmFja3MgZm9yIGpzb25wIHJlcXVlc3RzXG5qUXVlcnkuYWpheFByZWZpbHRlciggXCJqc29uIGpzb25wXCIsIGZ1bmN0aW9uKCBzLCBvcmlnaW5hbFNldHRpbmdzLCBqcVhIUiApIHtcblxuXHR2YXIgY2FsbGJhY2tOYW1lLCBvdmVyd3JpdHRlbiwgcmVzcG9uc2VDb250YWluZXIsXG5cdFx0anNvblByb3AgPSBzLmpzb25wICE9PSBmYWxzZSAmJiAoIHJqc29ucC50ZXN0KCBzLnVybCApID9cblx0XHRcdFwidXJsXCIgOlxuXHRcdFx0dHlwZW9mIHMuZGF0YSA9PT0gXCJzdHJpbmdcIiAmJlxuXHRcdFx0XHQoIHMuY29udGVudFR5cGUgfHwgXCJcIiApXG5cdFx0XHRcdFx0LmluZGV4T2YoIFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIgKSA9PT0gMCAmJlxuXHRcdFx0XHRyanNvbnAudGVzdCggcy5kYXRhICkgJiYgXCJkYXRhXCJcblx0XHQpO1xuXG5cdC8vIEhhbmRsZSBpZmYgdGhlIGV4cGVjdGVkIGRhdGEgdHlwZSBpcyBcImpzb25wXCIgb3Igd2UgaGF2ZSBhIHBhcmFtZXRlciB0byBzZXRcblx0aWYgKCBqc29uUHJvcCB8fCBzLmRhdGFUeXBlc1sgMCBdID09PSBcImpzb25wXCIgKSB7XG5cblx0XHQvLyBHZXQgY2FsbGJhY2sgbmFtZSwgcmVtZW1iZXJpbmcgcHJlZXhpc3RpbmcgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIGl0XG5cdFx0Y2FsbGJhY2tOYW1lID0gcy5qc29ucENhbGxiYWNrID0galF1ZXJ5LmlzRnVuY3Rpb24oIHMuanNvbnBDYWxsYmFjayApID9cblx0XHRcdHMuanNvbnBDYWxsYmFjaygpIDpcblx0XHRcdHMuanNvbnBDYWxsYmFjaztcblxuXHRcdC8vIEluc2VydCBjYWxsYmFjayBpbnRvIHVybCBvciBmb3JtIGRhdGFcblx0XHRpZiAoIGpzb25Qcm9wICkge1xuXHRcdFx0c1sganNvblByb3AgXSA9IHNbIGpzb25Qcm9wIF0ucmVwbGFjZSggcmpzb25wLCBcIiQxXCIgKyBjYWxsYmFja05hbWUgKTtcblx0XHR9IGVsc2UgaWYgKCBzLmpzb25wICE9PSBmYWxzZSApIHtcblx0XHRcdHMudXJsICs9ICggcnF1ZXJ5LnRlc3QoIHMudXJsICkgPyBcIiZcIiA6IFwiP1wiICkgKyBzLmpzb25wICsgXCI9XCIgKyBjYWxsYmFja05hbWU7XG5cdFx0fVxuXG5cdFx0Ly8gVXNlIGRhdGEgY29udmVydGVyIHRvIHJldHJpZXZlIGpzb24gYWZ0ZXIgc2NyaXB0IGV4ZWN1dGlvblxuXHRcdHMuY29udmVydGVyc1sgXCJzY3JpcHQganNvblwiIF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggIXJlc3BvbnNlQ29udGFpbmVyICkge1xuXHRcdFx0XHRqUXVlcnkuZXJyb3IoIGNhbGxiYWNrTmFtZSArIFwiIHdhcyBub3QgY2FsbGVkXCIgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXNwb25zZUNvbnRhaW5lclsgMCBdO1xuXHRcdH07XG5cblx0XHQvLyBGb3JjZSBqc29uIGRhdGFUeXBlXG5cdFx0cy5kYXRhVHlwZXNbIDAgXSA9IFwianNvblwiO1xuXG5cdFx0Ly8gSW5zdGFsbCBjYWxsYmFja1xuXHRcdG92ZXJ3cml0dGVuID0gd2luZG93WyBjYWxsYmFja05hbWUgXTtcblx0XHR3aW5kb3dbIGNhbGxiYWNrTmFtZSBdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXNwb25zZUNvbnRhaW5lciA9IGFyZ3VtZW50cztcblx0XHR9O1xuXG5cdFx0Ly8gQ2xlYW4tdXAgZnVuY3Rpb24gKGZpcmVzIGFmdGVyIGNvbnZlcnRlcnMpXG5cdFx0anFYSFIuYWx3YXlzKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gSWYgcHJldmlvdXMgdmFsdWUgZGlkbid0IGV4aXN0IC0gcmVtb3ZlIGl0XG5cdFx0XHRpZiAoIG92ZXJ3cml0dGVuID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdGpRdWVyeSggd2luZG93ICkucmVtb3ZlUHJvcCggY2FsbGJhY2tOYW1lICk7XG5cblx0XHRcdC8vIE90aGVyd2lzZSByZXN0b3JlIHByZWV4aXN0aW5nIHZhbHVlXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR3aW5kb3dbIGNhbGxiYWNrTmFtZSBdID0gb3ZlcndyaXR0ZW47XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNhdmUgYmFjayBhcyBmcmVlXG5cdFx0XHRpZiAoIHNbIGNhbGxiYWNrTmFtZSBdICkge1xuXG5cdFx0XHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHJlLXVzaW5nIHRoZSBvcHRpb25zIGRvZXNuJ3Qgc2NyZXcgdGhpbmdzIGFyb3VuZFxuXHRcdFx0XHRzLmpzb25wQ2FsbGJhY2sgPSBvcmlnaW5hbFNldHRpbmdzLmpzb25wQ2FsbGJhY2s7XG5cblx0XHRcdFx0Ly8gU2F2ZSB0aGUgY2FsbGJhY2sgbmFtZSBmb3IgZnV0dXJlIHVzZVxuXHRcdFx0XHRvbGRDYWxsYmFja3MucHVzaCggY2FsbGJhY2tOYW1lICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENhbGwgaWYgaXQgd2FzIGEgZnVuY3Rpb24gYW5kIHdlIGhhdmUgYSByZXNwb25zZVxuXHRcdFx0aWYgKCByZXNwb25zZUNvbnRhaW5lciAmJiBqUXVlcnkuaXNGdW5jdGlvbiggb3ZlcndyaXR0ZW4gKSApIHtcblx0XHRcdFx0b3ZlcndyaXR0ZW4oIHJlc3BvbnNlQ29udGFpbmVyWyAwIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0cmVzcG9uc2VDb250YWluZXIgPSBvdmVyd3JpdHRlbiA9IHVuZGVmaW5lZDtcblx0XHR9ICk7XG5cblx0XHQvLyBEZWxlZ2F0ZSB0byBzY3JpcHRcblx0XHRyZXR1cm4gXCJzY3JpcHRcIjtcblx0fVxufSApO1xuXG5cblxuXG4vLyBTdXBwb3J0OiBTYWZhcmkgOCBvbmx5XG4vLyBJbiBTYWZhcmkgOCBkb2N1bWVudHMgY3JlYXRlZCB2aWEgZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50XG4vLyBjb2xsYXBzZSBzaWJsaW5nIGZvcm1zOiB0aGUgc2Vjb25kIG9uZSBiZWNvbWVzIGEgY2hpbGQgb2YgdGhlIGZpcnN0IG9uZS5cbi8vIEJlY2F1c2Ugb2YgdGhhdCwgdGhpcyBzZWN1cml0eSBtZWFzdXJlIGhhcyB0byBiZSBkaXNhYmxlZCBpbiBTYWZhcmkgOC5cbi8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzczMzdcbnN1cHBvcnQuY3JlYXRlSFRNTERvY3VtZW50ID0gKCBmdW5jdGlvbigpIHtcblx0dmFyIGJvZHkgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoIFwiXCIgKS5ib2R5O1xuXHRib2R5LmlubmVySFRNTCA9IFwiPGZvcm0+PC9mb3JtPjxmb3JtPjwvZm9ybT5cIjtcblx0cmV0dXJuIGJvZHkuY2hpbGROb2Rlcy5sZW5ndGggPT09IDI7XG59ICkoKTtcblxuXG4vLyBBcmd1bWVudCBcImRhdGFcIiBzaG91bGQgYmUgc3RyaW5nIG9mIGh0bWxcbi8vIGNvbnRleHQgKG9wdGlvbmFsKTogSWYgc3BlY2lmaWVkLCB0aGUgZnJhZ21lbnQgd2lsbCBiZSBjcmVhdGVkIGluIHRoaXMgY29udGV4dCxcbi8vIGRlZmF1bHRzIHRvIGRvY3VtZW50XG4vLyBrZWVwU2NyaXB0cyAob3B0aW9uYWwpOiBJZiB0cnVlLCB3aWxsIGluY2x1ZGUgc2NyaXB0cyBwYXNzZWQgaW4gdGhlIGh0bWwgc3RyaW5nXG5qUXVlcnkucGFyc2VIVE1MID0gZnVuY3Rpb24oIGRhdGEsIGNvbnRleHQsIGtlZXBTY3JpcHRzICkge1xuXHRpZiAoIHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdHJldHVybiBbXTtcblx0fVxuXHRpZiAoIHR5cGVvZiBjb250ZXh0ID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRrZWVwU2NyaXB0cyA9IGNvbnRleHQ7XG5cdFx0Y29udGV4dCA9IGZhbHNlO1xuXHR9XG5cblx0dmFyIGJhc2UsIHBhcnNlZCwgc2NyaXB0cztcblxuXHRpZiAoICFjb250ZXh0ICkge1xuXG5cdFx0Ly8gU3RvcCBzY3JpcHRzIG9yIGlubGluZSBldmVudCBoYW5kbGVycyBmcm9tIGJlaW5nIGV4ZWN1dGVkIGltbWVkaWF0ZWx5XG5cdFx0Ly8gYnkgdXNpbmcgZG9jdW1lbnQuaW1wbGVtZW50YXRpb25cblx0XHRpZiAoIHN1cHBvcnQuY3JlYXRlSFRNTERvY3VtZW50ICkge1xuXHRcdFx0Y29udGV4dCA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudCggXCJcIiApO1xuXG5cdFx0XHQvLyBTZXQgdGhlIGJhc2UgaHJlZiBmb3IgdGhlIGNyZWF0ZWQgZG9jdW1lbnRcblx0XHRcdC8vIHNvIGFueSBwYXJzZWQgZWxlbWVudHMgd2l0aCBVUkxzXG5cdFx0XHQvLyBhcmUgYmFzZWQgb24gdGhlIGRvY3VtZW50J3MgVVJMIChnaC0yOTY1KVxuXHRcdFx0YmFzZSA9IGNvbnRleHQuY3JlYXRlRWxlbWVudCggXCJiYXNlXCIgKTtcblx0XHRcdGJhc2UuaHJlZiA9IGRvY3VtZW50LmxvY2F0aW9uLmhyZWY7XG5cdFx0XHRjb250ZXh0LmhlYWQuYXBwZW5kQ2hpbGQoIGJhc2UgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29udGV4dCA9IGRvY3VtZW50O1xuXHRcdH1cblx0fVxuXG5cdHBhcnNlZCA9IHJzaW5nbGVUYWcuZXhlYyggZGF0YSApO1xuXHRzY3JpcHRzID0gIWtlZXBTY3JpcHRzICYmIFtdO1xuXG5cdC8vIFNpbmdsZSB0YWdcblx0aWYgKCBwYXJzZWQgKSB7XG5cdFx0cmV0dXJuIFsgY29udGV4dC5jcmVhdGVFbGVtZW50KCBwYXJzZWRbIDEgXSApIF07XG5cdH1cblxuXHRwYXJzZWQgPSBidWlsZEZyYWdtZW50KCBbIGRhdGEgXSwgY29udGV4dCwgc2NyaXB0cyApO1xuXG5cdGlmICggc2NyaXB0cyAmJiBzY3JpcHRzLmxlbmd0aCApIHtcblx0XHRqUXVlcnkoIHNjcmlwdHMgKS5yZW1vdmUoKTtcblx0fVxuXG5cdHJldHVybiBqUXVlcnkubWVyZ2UoIFtdLCBwYXJzZWQuY2hpbGROb2RlcyApO1xufTtcblxuXG4vKipcbiAqIExvYWQgYSB1cmwgaW50byBhIHBhZ2VcbiAqL1xualF1ZXJ5LmZuLmxvYWQgPSBmdW5jdGlvbiggdXJsLCBwYXJhbXMsIGNhbGxiYWNrICkge1xuXHR2YXIgc2VsZWN0b3IsIHR5cGUsIHJlc3BvbnNlLFxuXHRcdHNlbGYgPSB0aGlzLFxuXHRcdG9mZiA9IHVybC5pbmRleE9mKCBcIiBcIiApO1xuXG5cdGlmICggb2ZmID4gLTEgKSB7XG5cdFx0c2VsZWN0b3IgPSBzdHJpcEFuZENvbGxhcHNlKCB1cmwuc2xpY2UoIG9mZiApICk7XG5cdFx0dXJsID0gdXJsLnNsaWNlKCAwLCBvZmYgKTtcblx0fVxuXG5cdC8vIElmIGl0J3MgYSBmdW5jdGlvblxuXHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBwYXJhbXMgKSApIHtcblxuXHRcdC8vIFdlIGFzc3VtZSB0aGF0IGl0J3MgdGhlIGNhbGxiYWNrXG5cdFx0Y2FsbGJhY2sgPSBwYXJhbXM7XG5cdFx0cGFyYW1zID0gdW5kZWZpbmVkO1xuXG5cdC8vIE90aGVyd2lzZSwgYnVpbGQgYSBwYXJhbSBzdHJpbmdcblx0fSBlbHNlIGlmICggcGFyYW1zICYmIHR5cGVvZiBwYXJhbXMgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0dHlwZSA9IFwiUE9TVFwiO1xuXHR9XG5cblx0Ly8gSWYgd2UgaGF2ZSBlbGVtZW50cyB0byBtb2RpZnksIG1ha2UgdGhlIHJlcXVlc3Rcblx0aWYgKCBzZWxmLmxlbmd0aCA+IDAgKSB7XG5cdFx0alF1ZXJ5LmFqYXgoIHtcblx0XHRcdHVybDogdXJsLFxuXG5cdFx0XHQvLyBJZiBcInR5cGVcIiB2YXJpYWJsZSBpcyB1bmRlZmluZWQsIHRoZW4gXCJHRVRcIiBtZXRob2Qgd2lsbCBiZSB1c2VkLlxuXHRcdFx0Ly8gTWFrZSB2YWx1ZSBvZiB0aGlzIGZpZWxkIGV4cGxpY2l0IHNpbmNlXG5cdFx0XHQvLyB1c2VyIGNhbiBvdmVycmlkZSBpdCB0aHJvdWdoIGFqYXhTZXR1cCBtZXRob2Rcblx0XHRcdHR5cGU6IHR5cGUgfHwgXCJHRVRcIixcblx0XHRcdGRhdGFUeXBlOiBcImh0bWxcIixcblx0XHRcdGRhdGE6IHBhcmFtc1xuXHRcdH0gKS5kb25lKCBmdW5jdGlvbiggcmVzcG9uc2VUZXh0ICkge1xuXG5cdFx0XHQvLyBTYXZlIHJlc3BvbnNlIGZvciB1c2UgaW4gY29tcGxldGUgY2FsbGJhY2tcblx0XHRcdHJlc3BvbnNlID0gYXJndW1lbnRzO1xuXG5cdFx0XHRzZWxmLmh0bWwoIHNlbGVjdG9yID9cblxuXHRcdFx0XHQvLyBJZiBhIHNlbGVjdG9yIHdhcyBzcGVjaWZpZWQsIGxvY2F0ZSB0aGUgcmlnaHQgZWxlbWVudHMgaW4gYSBkdW1teSBkaXZcblx0XHRcdFx0Ly8gRXhjbHVkZSBzY3JpcHRzIHRvIGF2b2lkIElFICdQZXJtaXNzaW9uIERlbmllZCcgZXJyb3JzXG5cdFx0XHRcdGpRdWVyeSggXCI8ZGl2PlwiICkuYXBwZW5kKCBqUXVlcnkucGFyc2VIVE1MKCByZXNwb25zZVRleHQgKSApLmZpbmQoIHNlbGVjdG9yICkgOlxuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSB1c2UgdGhlIGZ1bGwgcmVzdWx0XG5cdFx0XHRcdHJlc3BvbnNlVGV4dCApO1xuXG5cdFx0Ly8gSWYgdGhlIHJlcXVlc3Qgc3VjY2VlZHMsIHRoaXMgZnVuY3Rpb24gZ2V0cyBcImRhdGFcIiwgXCJzdGF0dXNcIiwgXCJqcVhIUlwiXG5cdFx0Ly8gYnV0IHRoZXkgYXJlIGlnbm9yZWQgYmVjYXVzZSByZXNwb25zZSB3YXMgc2V0IGFib3ZlLlxuXHRcdC8vIElmIGl0IGZhaWxzLCB0aGlzIGZ1bmN0aW9uIGdldHMgXCJqcVhIUlwiLCBcInN0YXR1c1wiLCBcImVycm9yXCJcblx0XHR9ICkuYWx3YXlzKCBjYWxsYmFjayAmJiBmdW5jdGlvbigganFYSFIsIHN0YXR1cyApIHtcblx0XHRcdHNlbGYuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGNhbGxiYWNrLmFwcGx5KCB0aGlzLCByZXNwb25zZSB8fCBbIGpxWEhSLnJlc3BvbnNlVGV4dCwgc3RhdHVzLCBqcVhIUiBdICk7XG5cdFx0XHR9ICk7XG5cdFx0fSApO1xuXHR9XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG5cblxuXG4vLyBBdHRhY2ggYSBidW5jaCBvZiBmdW5jdGlvbnMgZm9yIGhhbmRsaW5nIGNvbW1vbiBBSkFYIGV2ZW50c1xualF1ZXJ5LmVhY2goIFtcblx0XCJhamF4U3RhcnRcIixcblx0XCJhamF4U3RvcFwiLFxuXHRcImFqYXhDb21wbGV0ZVwiLFxuXHRcImFqYXhFcnJvclwiLFxuXHRcImFqYXhTdWNjZXNzXCIsXG5cdFwiYWpheFNlbmRcIlxuXSwgZnVuY3Rpb24oIGksIHR5cGUgKSB7XG5cdGpRdWVyeS5mblsgdHlwZSBdID0gZnVuY3Rpb24oIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9uKCB0eXBlLCBmbiApO1xuXHR9O1xufSApO1xuXG5cblxuXG5qUXVlcnkuZXhwci5wc2V1ZG9zLmFuaW1hdGVkID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHJldHVybiBqUXVlcnkuZ3JlcCggalF1ZXJ5LnRpbWVycywgZnVuY3Rpb24oIGZuICkge1xuXHRcdHJldHVybiBlbGVtID09PSBmbi5lbGVtO1xuXHR9ICkubGVuZ3RoO1xufTtcblxuXG5cblxuLyoqXG4gKiBHZXRzIGEgd2luZG93IGZyb20gYW4gZWxlbWVudFxuICovXG5mdW5jdGlvbiBnZXRXaW5kb3coIGVsZW0gKSB7XG5cdHJldHVybiBqUXVlcnkuaXNXaW5kb3coIGVsZW0gKSA/IGVsZW0gOiBlbGVtLm5vZGVUeXBlID09PSA5ICYmIGVsZW0uZGVmYXVsdFZpZXc7XG59XG5cbmpRdWVyeS5vZmZzZXQgPSB7XG5cdHNldE9mZnNldDogZnVuY3Rpb24oIGVsZW0sIG9wdGlvbnMsIGkgKSB7XG5cdFx0dmFyIGN1clBvc2l0aW9uLCBjdXJMZWZ0LCBjdXJDU1NUb3AsIGN1clRvcCwgY3VyT2Zmc2V0LCBjdXJDU1NMZWZ0LCBjYWxjdWxhdGVQb3NpdGlvbixcblx0XHRcdHBvc2l0aW9uID0galF1ZXJ5LmNzcyggZWxlbSwgXCJwb3NpdGlvblwiICksXG5cdFx0XHRjdXJFbGVtID0galF1ZXJ5KCBlbGVtICksXG5cdFx0XHRwcm9wcyA9IHt9O1xuXG5cdFx0Ly8gU2V0IHBvc2l0aW9uIGZpcnN0LCBpbi1jYXNlIHRvcC9sZWZ0IGFyZSBzZXQgZXZlbiBvbiBzdGF0aWMgZWxlbVxuXHRcdGlmICggcG9zaXRpb24gPT09IFwic3RhdGljXCIgKSB7XG5cdFx0XHRlbGVtLnN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xuXHRcdH1cblxuXHRcdGN1ck9mZnNldCA9IGN1ckVsZW0ub2Zmc2V0KCk7XG5cdFx0Y3VyQ1NTVG9wID0galF1ZXJ5LmNzcyggZWxlbSwgXCJ0b3BcIiApO1xuXHRcdGN1ckNTU0xlZnQgPSBqUXVlcnkuY3NzKCBlbGVtLCBcImxlZnRcIiApO1xuXHRcdGNhbGN1bGF0ZVBvc2l0aW9uID0gKCBwb3NpdGlvbiA9PT0gXCJhYnNvbHV0ZVwiIHx8IHBvc2l0aW9uID09PSBcImZpeGVkXCIgKSAmJlxuXHRcdFx0KCBjdXJDU1NUb3AgKyBjdXJDU1NMZWZ0ICkuaW5kZXhPZiggXCJhdXRvXCIgKSA+IC0xO1xuXG5cdFx0Ly8gTmVlZCB0byBiZSBhYmxlIHRvIGNhbGN1bGF0ZSBwb3NpdGlvbiBpZiBlaXRoZXJcblx0XHQvLyB0b3Agb3IgbGVmdCBpcyBhdXRvIGFuZCBwb3NpdGlvbiBpcyBlaXRoZXIgYWJzb2x1dGUgb3IgZml4ZWRcblx0XHRpZiAoIGNhbGN1bGF0ZVBvc2l0aW9uICkge1xuXHRcdFx0Y3VyUG9zaXRpb24gPSBjdXJFbGVtLnBvc2l0aW9uKCk7XG5cdFx0XHRjdXJUb3AgPSBjdXJQb3NpdGlvbi50b3A7XG5cdFx0XHRjdXJMZWZ0ID0gY3VyUG9zaXRpb24ubGVmdDtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRjdXJUb3AgPSBwYXJzZUZsb2F0KCBjdXJDU1NUb3AgKSB8fCAwO1xuXHRcdFx0Y3VyTGVmdCA9IHBhcnNlRmxvYXQoIGN1ckNTU0xlZnQgKSB8fCAwO1xuXHRcdH1cblxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIG9wdGlvbnMgKSApIHtcblxuXHRcdFx0Ly8gVXNlIGpRdWVyeS5leHRlbmQgaGVyZSB0byBhbGxvdyBtb2RpZmljYXRpb24gb2YgY29vcmRpbmF0ZXMgYXJndW1lbnQgKGdoLTE4NDgpXG5cdFx0XHRvcHRpb25zID0gb3B0aW9ucy5jYWxsKCBlbGVtLCBpLCBqUXVlcnkuZXh0ZW5kKCB7fSwgY3VyT2Zmc2V0ICkgKTtcblx0XHR9XG5cblx0XHRpZiAoIG9wdGlvbnMudG9wICE9IG51bGwgKSB7XG5cdFx0XHRwcm9wcy50b3AgPSAoIG9wdGlvbnMudG9wIC0gY3VyT2Zmc2V0LnRvcCApICsgY3VyVG9wO1xuXHRcdH1cblx0XHRpZiAoIG9wdGlvbnMubGVmdCAhPSBudWxsICkge1xuXHRcdFx0cHJvcHMubGVmdCA9ICggb3B0aW9ucy5sZWZ0IC0gY3VyT2Zmc2V0LmxlZnQgKSArIGN1ckxlZnQ7XG5cdFx0fVxuXG5cdFx0aWYgKCBcInVzaW5nXCIgaW4gb3B0aW9ucyApIHtcblx0XHRcdG9wdGlvbnMudXNpbmcuY2FsbCggZWxlbSwgcHJvcHMgKTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRjdXJFbGVtLmNzcyggcHJvcHMgKTtcblx0XHR9XG5cdH1cbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0b2Zmc2V0OiBmdW5jdGlvbiggb3B0aW9ucyApIHtcblxuXHRcdC8vIFByZXNlcnZlIGNoYWluaW5nIGZvciBzZXR0ZXJcblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4gb3B0aW9ucyA9PT0gdW5kZWZpbmVkID9cblx0XHRcdFx0dGhpcyA6XG5cdFx0XHRcdHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5Lm9mZnNldC5zZXRPZmZzZXQoIHRoaXMsIG9wdGlvbnMsIGkgKTtcblx0XHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHZhciBkb2NFbGVtLCB3aW4sIHJlY3QsIGRvYyxcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF07XG5cblx0XHRpZiAoICFlbGVtICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHRcdC8vIFJ1bm5pbmcgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IG9uIGFcblx0XHQvLyBkaXNjb25uZWN0ZWQgbm9kZSBpbiBJRSB0aHJvd3MgYW4gZXJyb3Jcblx0XHRpZiAoICFlbGVtLmdldENsaWVudFJlY3RzKCkubGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIHsgdG9wOiAwLCBsZWZ0OiAwIH07XG5cdFx0fVxuXG5cdFx0cmVjdCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cblx0XHQvLyBNYWtlIHN1cmUgZWxlbWVudCBpcyBub3QgaGlkZGVuIChkaXNwbGF5OiBub25lKVxuXHRcdGlmICggcmVjdC53aWR0aCB8fCByZWN0LmhlaWdodCApIHtcblx0XHRcdGRvYyA9IGVsZW0ub3duZXJEb2N1bWVudDtcblx0XHRcdHdpbiA9IGdldFdpbmRvdyggZG9jICk7XG5cdFx0XHRkb2NFbGVtID0gZG9jLmRvY3VtZW50RWxlbWVudDtcblxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0dG9wOiByZWN0LnRvcCArIHdpbi5wYWdlWU9mZnNldCAtIGRvY0VsZW0uY2xpZW50VG9wLFxuXHRcdFx0XHRsZWZ0OiByZWN0LmxlZnQgKyB3aW4ucGFnZVhPZmZzZXQgLSBkb2NFbGVtLmNsaWVudExlZnRcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0Ly8gUmV0dXJuIHplcm9zIGZvciBkaXNjb25uZWN0ZWQgYW5kIGhpZGRlbiBlbGVtZW50cyAoZ2gtMjMxMClcblx0XHRyZXR1cm4gcmVjdDtcblx0fSxcblxuXHRwb3NpdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCAhdGhpc1sgMCBdICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBvZmZzZXRQYXJlbnQsIG9mZnNldCxcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF0sXG5cdFx0XHRwYXJlbnRPZmZzZXQgPSB7IHRvcDogMCwgbGVmdDogMCB9O1xuXG5cdFx0Ly8gRml4ZWQgZWxlbWVudHMgYXJlIG9mZnNldCBmcm9tIHdpbmRvdyAocGFyZW50T2Zmc2V0ID0ge3RvcDowLCBsZWZ0OiAwfSxcblx0XHQvLyBiZWNhdXNlIGl0IGlzIGl0cyBvbmx5IG9mZnNldCBwYXJlbnRcblx0XHRpZiAoIGpRdWVyeS5jc3MoIGVsZW0sIFwicG9zaXRpb25cIiApID09PSBcImZpeGVkXCIgKSB7XG5cblx0XHRcdC8vIEFzc3VtZSBnZXRCb3VuZGluZ0NsaWVudFJlY3QgaXMgdGhlcmUgd2hlbiBjb21wdXRlZCBwb3NpdGlvbiBpcyBmaXhlZFxuXHRcdFx0b2Zmc2V0ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIEdldCAqcmVhbCogb2Zmc2V0UGFyZW50XG5cdFx0XHRvZmZzZXRQYXJlbnQgPSB0aGlzLm9mZnNldFBhcmVudCgpO1xuXG5cdFx0XHQvLyBHZXQgY29ycmVjdCBvZmZzZXRzXG5cdFx0XHRvZmZzZXQgPSB0aGlzLm9mZnNldCgpO1xuXHRcdFx0aWYgKCAhalF1ZXJ5Lm5vZGVOYW1lKCBvZmZzZXRQYXJlbnRbIDAgXSwgXCJodG1sXCIgKSApIHtcblx0XHRcdFx0cGFyZW50T2Zmc2V0ID0gb2Zmc2V0UGFyZW50Lm9mZnNldCgpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgb2Zmc2V0UGFyZW50IGJvcmRlcnNcblx0XHRcdHBhcmVudE9mZnNldCA9IHtcblx0XHRcdFx0dG9wOiBwYXJlbnRPZmZzZXQudG9wICsgalF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50WyAwIF0sIFwiYm9yZGVyVG9wV2lkdGhcIiwgdHJ1ZSApLFxuXHRcdFx0XHRsZWZ0OiBwYXJlbnRPZmZzZXQubGVmdCArIGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudFsgMCBdLCBcImJvcmRlckxlZnRXaWR0aFwiLCB0cnVlIClcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0Ly8gU3VidHJhY3QgcGFyZW50IG9mZnNldHMgYW5kIGVsZW1lbnQgbWFyZ2luc1xuXHRcdHJldHVybiB7XG5cdFx0XHR0b3A6IG9mZnNldC50b3AgLSBwYXJlbnRPZmZzZXQudG9wIC0galF1ZXJ5LmNzcyggZWxlbSwgXCJtYXJnaW5Ub3BcIiwgdHJ1ZSApLFxuXHRcdFx0bGVmdDogb2Zmc2V0LmxlZnQgLSBwYXJlbnRPZmZzZXQubGVmdCAtIGpRdWVyeS5jc3MoIGVsZW0sIFwibWFyZ2luTGVmdFwiLCB0cnVlIClcblx0XHR9O1xuXHR9LFxuXG5cdC8vIFRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuIGRvY3VtZW50RWxlbWVudCBpbiB0aGUgZm9sbG93aW5nIGNhc2VzOlxuXHQvLyAxKSBGb3IgdGhlIGVsZW1lbnQgaW5zaWRlIHRoZSBpZnJhbWUgd2l0aG91dCBvZmZzZXRQYXJlbnQsIHRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuXG5cdC8vICAgIGRvY3VtZW50RWxlbWVudCBvZiB0aGUgcGFyZW50IHdpbmRvd1xuXHQvLyAyKSBGb3IgdGhlIGhpZGRlbiBvciBkZXRhY2hlZCBlbGVtZW50XG5cdC8vIDMpIEZvciBib2R5IG9yIGh0bWwgZWxlbWVudCwgaS5lLiBpbiBjYXNlIG9mIHRoZSBodG1sIG5vZGUgLSBpdCB3aWxsIHJldHVybiBpdHNlbGZcblx0Ly9cblx0Ly8gYnV0IHRob3NlIGV4Y2VwdGlvbnMgd2VyZSBuZXZlciBwcmVzZW50ZWQgYXMgYSByZWFsIGxpZmUgdXNlLWNhc2VzXG5cdC8vIGFuZCBtaWdodCBiZSBjb25zaWRlcmVkIGFzIG1vcmUgcHJlZmVyYWJsZSByZXN1bHRzLlxuXHQvL1xuXHQvLyBUaGlzIGxvZ2ljLCBob3dldmVyLCBpcyBub3QgZ3VhcmFudGVlZCBhbmQgY2FuIGNoYW5nZSBhdCBhbnkgcG9pbnQgaW4gdGhlIGZ1dHVyZVxuXHRvZmZzZXRQYXJlbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgb2Zmc2V0UGFyZW50ID0gdGhpcy5vZmZzZXRQYXJlbnQ7XG5cblx0XHRcdHdoaWxlICggb2Zmc2V0UGFyZW50ICYmIGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudCwgXCJwb3NpdGlvblwiICkgPT09IFwic3RhdGljXCIgKSB7XG5cdFx0XHRcdG9mZnNldFBhcmVudCA9IG9mZnNldFBhcmVudC5vZmZzZXRQYXJlbnQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBvZmZzZXRQYXJlbnQgfHwgZG9jdW1lbnRFbGVtZW50O1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG4vLyBDcmVhdGUgc2Nyb2xsTGVmdCBhbmQgc2Nyb2xsVG9wIG1ldGhvZHNcbmpRdWVyeS5lYWNoKCB7IHNjcm9sbExlZnQ6IFwicGFnZVhPZmZzZXRcIiwgc2Nyb2xsVG9wOiBcInBhZ2VZT2Zmc2V0XCIgfSwgZnVuY3Rpb24oIG1ldGhvZCwgcHJvcCApIHtcblx0dmFyIHRvcCA9IFwicGFnZVlPZmZzZXRcIiA9PT0gcHJvcDtcblxuXHRqUXVlcnkuZm5bIG1ldGhvZCBdID0gZnVuY3Rpb24oIHZhbCApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgbWV0aG9kLCB2YWwgKSB7XG5cdFx0XHR2YXIgd2luID0gZ2V0V2luZG93KCBlbGVtICk7XG5cblx0XHRcdGlmICggdmFsID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiB3aW4gPyB3aW5bIHByb3AgXSA6IGVsZW1bIG1ldGhvZCBdO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHdpbiApIHtcblx0XHRcdFx0d2luLnNjcm9sbFRvKFxuXHRcdFx0XHRcdCF0b3AgPyB2YWwgOiB3aW4ucGFnZVhPZmZzZXQsXG5cdFx0XHRcdFx0dG9wID8gdmFsIDogd2luLnBhZ2VZT2Zmc2V0XG5cdFx0XHRcdCk7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsZW1bIG1ldGhvZCBdID0gdmFsO1xuXHRcdFx0fVxuXHRcdH0sIG1ldGhvZCwgdmFsLCBhcmd1bWVudHMubGVuZ3RoICk7XG5cdH07XG59ICk7XG5cbi8vIFN1cHBvcnQ6IFNhZmFyaSA8PTcgLSA5LjEsIENocm9tZSA8PTM3IC0gNDlcbi8vIEFkZCB0aGUgdG9wL2xlZnQgY3NzSG9va3MgdXNpbmcgalF1ZXJ5LmZuLnBvc2l0aW9uXG4vLyBXZWJraXQgYnVnOiBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjkwODRcbi8vIEJsaW5rIGJ1ZzogaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NTg5MzQ3XG4vLyBnZXRDb21wdXRlZFN0eWxlIHJldHVybnMgcGVyY2VudCB3aGVuIHNwZWNpZmllZCBmb3IgdG9wL2xlZnQvYm90dG9tL3JpZ2h0O1xuLy8gcmF0aGVyIHRoYW4gbWFrZSB0aGUgY3NzIG1vZHVsZSBkZXBlbmQgb24gdGhlIG9mZnNldCBtb2R1bGUsIGp1c3QgY2hlY2sgZm9yIGl0IGhlcmVcbmpRdWVyeS5lYWNoKCBbIFwidG9wXCIsIFwibGVmdFwiIF0sIGZ1bmN0aW9uKCBpLCBwcm9wICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIHByb3AgXSA9IGFkZEdldEhvb2tJZiggc3VwcG9ydC5waXhlbFBvc2l0aW9uLFxuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRcdGlmICggY29tcHV0ZWQgKSB7XG5cdFx0XHRcdGNvbXB1dGVkID0gY3VyQ1NTKCBlbGVtLCBwcm9wICk7XG5cblx0XHRcdFx0Ly8gSWYgY3VyQ1NTIHJldHVybnMgcGVyY2VudGFnZSwgZmFsbGJhY2sgdG8gb2Zmc2V0XG5cdFx0XHRcdHJldHVybiBybnVtbm9ucHgudGVzdCggY29tcHV0ZWQgKSA/XG5cdFx0XHRcdFx0alF1ZXJ5KCBlbGVtICkucG9zaXRpb24oKVsgcHJvcCBdICsgXCJweFwiIDpcblx0XHRcdFx0XHRjb21wdXRlZDtcblx0XHRcdH1cblx0XHR9XG5cdCk7XG59ICk7XG5cblxuLy8gQ3JlYXRlIGlubmVySGVpZ2h0LCBpbm5lcldpZHRoLCBoZWlnaHQsIHdpZHRoLCBvdXRlckhlaWdodCBhbmQgb3V0ZXJXaWR0aCBtZXRob2RzXG5qUXVlcnkuZWFjaCggeyBIZWlnaHQ6IFwiaGVpZ2h0XCIsIFdpZHRoOiBcIndpZHRoXCIgfSwgZnVuY3Rpb24oIG5hbWUsIHR5cGUgKSB7XG5cdGpRdWVyeS5lYWNoKCB7IHBhZGRpbmc6IFwiaW5uZXJcIiArIG5hbWUsIGNvbnRlbnQ6IHR5cGUsIFwiXCI6IFwib3V0ZXJcIiArIG5hbWUgfSxcblx0XHRmdW5jdGlvbiggZGVmYXVsdEV4dHJhLCBmdW5jTmFtZSApIHtcblxuXHRcdC8vIE1hcmdpbiBpcyBvbmx5IGZvciBvdXRlckhlaWdodCwgb3V0ZXJXaWR0aFxuXHRcdGpRdWVyeS5mblsgZnVuY05hbWUgXSA9IGZ1bmN0aW9uKCBtYXJnaW4sIHZhbHVlICkge1xuXHRcdFx0dmFyIGNoYWluYWJsZSA9IGFyZ3VtZW50cy5sZW5ndGggJiYgKCBkZWZhdWx0RXh0cmEgfHwgdHlwZW9mIG1hcmdpbiAhPT0gXCJib29sZWFuXCIgKSxcblx0XHRcdFx0ZXh0cmEgPSBkZWZhdWx0RXh0cmEgfHwgKCBtYXJnaW4gPT09IHRydWUgfHwgdmFsdWUgPT09IHRydWUgPyBcIm1hcmdpblwiIDogXCJib3JkZXJcIiApO1xuXG5cdFx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgdHlwZSwgdmFsdWUgKSB7XG5cdFx0XHRcdHZhciBkb2M7XG5cblx0XHRcdFx0aWYgKCBqUXVlcnkuaXNXaW5kb3coIGVsZW0gKSApIHtcblxuXHRcdFx0XHRcdC8vICQoIHdpbmRvdyApLm91dGVyV2lkdGgvSGVpZ2h0IHJldHVybiB3L2ggaW5jbHVkaW5nIHNjcm9sbGJhcnMgKGdoLTE3MjkpXG5cdFx0XHRcdFx0cmV0dXJuIGZ1bmNOYW1lLmluZGV4T2YoIFwib3V0ZXJcIiApID09PSAwID9cblx0XHRcdFx0XHRcdGVsZW1bIFwiaW5uZXJcIiArIG5hbWUgXSA6XG5cdFx0XHRcdFx0XHRlbGVtLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudFsgXCJjbGllbnRcIiArIG5hbWUgXTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEdldCBkb2N1bWVudCB3aWR0aCBvciBoZWlnaHRcblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHRcdGRvYyA9IGVsZW0uZG9jdW1lbnRFbGVtZW50O1xuXG5cdFx0XHRcdFx0Ly8gRWl0aGVyIHNjcm9sbFtXaWR0aC9IZWlnaHRdIG9yIG9mZnNldFtXaWR0aC9IZWlnaHRdIG9yIGNsaWVudFtXaWR0aC9IZWlnaHRdLFxuXHRcdFx0XHRcdC8vIHdoaWNoZXZlciBpcyBncmVhdGVzdFxuXHRcdFx0XHRcdHJldHVybiBNYXRoLm1heChcblx0XHRcdFx0XHRcdGVsZW0uYm9keVsgXCJzY3JvbGxcIiArIG5hbWUgXSwgZG9jWyBcInNjcm9sbFwiICsgbmFtZSBdLFxuXHRcdFx0XHRcdFx0ZWxlbS5ib2R5WyBcIm9mZnNldFwiICsgbmFtZSBdLCBkb2NbIFwib2Zmc2V0XCIgKyBuYW1lIF0sXG5cdFx0XHRcdFx0XHRkb2NbIFwiY2xpZW50XCIgKyBuYW1lIF1cblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgP1xuXG5cdFx0XHRcdFx0Ly8gR2V0IHdpZHRoIG9yIGhlaWdodCBvbiB0aGUgZWxlbWVudCwgcmVxdWVzdGluZyBidXQgbm90IGZvcmNpbmcgcGFyc2VGbG9hdFxuXHRcdFx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIHR5cGUsIGV4dHJhICkgOlxuXG5cdFx0XHRcdFx0Ly8gU2V0IHdpZHRoIG9yIGhlaWdodCBvbiB0aGUgZWxlbWVudFxuXHRcdFx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgdHlwZSwgdmFsdWUsIGV4dHJhICk7XG5cdFx0XHR9LCB0eXBlLCBjaGFpbmFibGUgPyBtYXJnaW4gOiB1bmRlZmluZWQsIGNoYWluYWJsZSApO1xuXHRcdH07XG5cdH0gKTtcbn0gKTtcblxuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cblx0YmluZDogZnVuY3Rpb24oIHR5cGVzLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vbiggdHlwZXMsIG51bGwsIGRhdGEsIGZuICk7XG5cdH0sXG5cdHVuYmluZDogZnVuY3Rpb24oIHR5cGVzLCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vZmYoIHR5cGVzLCBudWxsLCBmbiApO1xuXHR9LFxuXG5cdGRlbGVnYXRlOiBmdW5jdGlvbiggc2VsZWN0b3IsIHR5cGVzLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApO1xuXHR9LFxuXHR1bmRlbGVnYXRlOiBmdW5jdGlvbiggc2VsZWN0b3IsIHR5cGVzLCBmbiApIHtcblxuXHRcdC8vICggbmFtZXNwYWNlICkgb3IgKCBzZWxlY3RvciwgdHlwZXMgWywgZm5dIClcblx0XHRyZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/XG5cdFx0XHR0aGlzLm9mZiggc2VsZWN0b3IsIFwiKipcIiApIDpcblx0XHRcdHRoaXMub2ZmKCB0eXBlcywgc2VsZWN0b3IgfHwgXCIqKlwiLCBmbiApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5wYXJzZUpTT04gPSBKU09OLnBhcnNlO1xuXG5cblxuXG4vLyBSZWdpc3RlciBhcyBhIG5hbWVkIEFNRCBtb2R1bGUsIHNpbmNlIGpRdWVyeSBjYW4gYmUgY29uY2F0ZW5hdGVkIHdpdGggb3RoZXJcbi8vIGZpbGVzIHRoYXQgbWF5IHVzZSBkZWZpbmUsIGJ1dCBub3QgdmlhIGEgcHJvcGVyIGNvbmNhdGVuYXRpb24gc2NyaXB0IHRoYXRcbi8vIHVuZGVyc3RhbmRzIGFub255bW91cyBBTUQgbW9kdWxlcy4gQSBuYW1lZCBBTUQgaXMgc2FmZXN0IGFuZCBtb3N0IHJvYnVzdFxuLy8gd2F5IHRvIHJlZ2lzdGVyLiBMb3dlcmNhc2UganF1ZXJ5IGlzIHVzZWQgYmVjYXVzZSBBTUQgbW9kdWxlIG5hbWVzIGFyZVxuLy8gZGVyaXZlZCBmcm9tIGZpbGUgbmFtZXMsIGFuZCBqUXVlcnkgaXMgbm9ybWFsbHkgZGVsaXZlcmVkIGluIGEgbG93ZXJjYXNlXG4vLyBmaWxlIG5hbWUuIERvIHRoaXMgYWZ0ZXIgY3JlYXRpbmcgdGhlIGdsb2JhbCBzbyB0aGF0IGlmIGFuIEFNRCBtb2R1bGUgd2FudHNcbi8vIHRvIGNhbGwgbm9Db25mbGljdCB0byBoaWRlIHRoaXMgdmVyc2lvbiBvZiBqUXVlcnksIGl0IHdpbGwgd29yay5cblxuLy8gTm90ZSB0aGF0IGZvciBtYXhpbXVtIHBvcnRhYmlsaXR5LCBsaWJyYXJpZXMgdGhhdCBhcmUgbm90IGpRdWVyeSBzaG91bGRcbi8vIGRlY2xhcmUgdGhlbXNlbHZlcyBhcyBhbm9ueW1vdXMgbW9kdWxlcywgYW5kIGF2b2lkIHNldHRpbmcgYSBnbG9iYWwgaWYgYW5cbi8vIEFNRCBsb2FkZXIgaXMgcHJlc2VudC4galF1ZXJ5IGlzIGEgc3BlY2lhbCBjYXNlLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlXG4vLyBodHRwczovL2dpdGh1Yi5jb20vanJidXJrZS9yZXF1aXJlanMvd2lraS9VcGRhdGluZy1leGlzdGluZy1saWJyYXJpZXMjd2lraS1hbm9uXG5cbmlmICggdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQgKSB7XG5cdGRlZmluZSggXCJqcXVlcnlcIiwgW10sIGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBqUXVlcnk7XG5cdH0gKTtcbn1cblxuXG5cblxudmFyXG5cblx0Ly8gTWFwIG92ZXIgalF1ZXJ5IGluIGNhc2Ugb2Ygb3ZlcndyaXRlXG5cdF9qUXVlcnkgPSB3aW5kb3cualF1ZXJ5LFxuXG5cdC8vIE1hcCBvdmVyIHRoZSAkIGluIGNhc2Ugb2Ygb3ZlcndyaXRlXG5cdF8kID0gd2luZG93LiQ7XG5cbmpRdWVyeS5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oIGRlZXAgKSB7XG5cdGlmICggd2luZG93LiQgPT09IGpRdWVyeSApIHtcblx0XHR3aW5kb3cuJCA9IF8kO1xuXHR9XG5cblx0aWYgKCBkZWVwICYmIHdpbmRvdy5qUXVlcnkgPT09IGpRdWVyeSApIHtcblx0XHR3aW5kb3cualF1ZXJ5ID0gX2pRdWVyeTtcblx0fVxuXG5cdHJldHVybiBqUXVlcnk7XG59O1xuXG4vLyBFeHBvc2UgalF1ZXJ5IGFuZCAkIGlkZW50aWZpZXJzLCBldmVuIGluIEFNRFxuLy8gKCM3MTAyI2NvbW1lbnQ6MTAsIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvanF1ZXJ5L3B1bGwvNTU3KVxuLy8gYW5kIENvbW1vbkpTIGZvciBicm93c2VyIGVtdWxhdG9ycyAoIzEzNTY2KVxuaWYgKCAhbm9HbG9iYWwgKSB7XG5cdHdpbmRvdy5qUXVlcnkgPSB3aW5kb3cuJCA9IGpRdWVyeTtcbn1cblxuXG5cblxuXG5yZXR1cm4galF1ZXJ5O1xufSApO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9qcXVlcnkvZGlzdC9qcXVlcnkuanMiLCJ2YXIgUHJlc2VudGVyID0gcmVxdWlyZSgnLi9wcmVzZW50ZXJzJylcblxudmFyIEFwcCA9IHsgUHJlc2VudGVyIH1cblxuQXBwLmluaXQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5QcmVzZW50ZXIuaW5pdCgpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gQXBwXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9qcy9hcHAuanMiLCJ2YXIgT3JkZXJNb2RlbCA9IHJlcXVpcmUoJy4uL21vZGVscy9tX29yZGVyJyk7XG5cbnZhciBPcmRlckNvbGxlY3Rpb24gPSBCYWNrYm9uZS5Db2xsZWN0aW9uLmV4dGVuZCh7XG4gIG1vZGVsOiBPcmRlck1vZGVsLFxuICB1cmw6IFwiL2FwaS91c2Vycy9zZWxmL29yZGVyc1wiXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBPcmRlckNvbGxlY3Rpb247XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9qcy9jb2xsZWN0aW9ucy9jX29yZGVycy5qcyIsInZhciBPcmRlck1vZGVsID0gQmFja2JvbmUuTW9kZWwuZXh0ZW5kKHtcbiAgdXJsUm9vdDogXCIvYXBpL29yZGVyc1wiXG59KTtcbi8vIFJldHVybiB0aGUgbW9kZWwgZm9yIHRoZSBtb2R1bGVcbm1vZHVsZS5leHBvcnRzID0gT3JkZXJNb2RlbDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2pzL21vZGVscy9tX29yZGVyLmpzIiwidmFyIGxvY2FsU3RvcmFnZSA9IHJlcXVpcmUoJy4uL2xvY2FsU3RvcmFnZScpXG52YXIgRXZlbnRCdXMgPSByZXF1aXJlKCcuLi9ldmVudEJ1cycpXG5cbnZhciBBcGkgPSB7fTtcblxuQXBpLmxvZ2luID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgcmV0dXJuICQuYWpheCh7XG4gICAgdXJsOiAnL2FwaS91c2Vycy9sb2dpbicsXG4gICAgZGF0YVR5cGU6ICdqc29uJyxcbiAgICB0eXBlOiAncG9zdCcsXG4gICAgY29udGVudFR5cGU6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICBkYXRhOiBKU09OLnN0cmluZ2lmeShkYXRhKSxcbiAgICBwcm9jZXNzRGF0YTogZmFsc2UsXG4gIH0pXG59O1xuXG5BcGkuc2lnbnVwID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgcmV0dXJuICQuYWpheCh7XG4gICAgdXJsOiAnL2FwaS91c2VycycsXG4gICAgZGF0YVR5cGU6ICdqc29uJyxcbiAgICB0eXBlOiAncG9zdCcsXG4gICAgY29udGVudFR5cGU6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICBkYXRhOiBKU09OLnN0cmluZ2lmeShkYXRhKSxcbiAgICBwcm9jZXNzRGF0YTogZmFsc2UsXG4gIH0pO1xufTtcblxuQXBpLmluaXQgPSBmdW5jdGlvbiAoKSB7XG5cbi8vIExvZ2luXG5cbiAgRXZlbnRCdXMub24oJ2FwaTpsb2dpbicsIGZ1bmN0aW9uICh1c2VybmFtZSwgcGFzc3dvcmQpIHtcbiAgICBBcGkubG9naW4oe3VzZXJuYW1lOiB1c2VybmFtZSwgcGFzc3dvcmQ6IHBhc3N3b3JkfSlcbiAgICAgIC50aGVuKEV2ZW50QnVzLnRyaWdnZXIuYmluZChFdmVudEJ1cywgJ2FwaTpsb2dpbjpzdWNjZXNzZnVsJykpXG4gICAgICAuY2F0Y2goRXZlbnRCdXMudHJpZ2dlci5iaW5kKEV2ZW50QnVzLCAnYXBpOmxvZ2luOmVycm9yJykpXG4gICAgICAuZG9uZSgpXG4gIH0pXG5cbiAgRXZlbnRCdXMub24oJ2FwaTpsb2dpbjpzdWNjZXNzZnVsJywgZnVuY3Rpb24gKHVzZXIpIHtcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgndXNlcicsIHVzZXIpO1xuICAgIEV2ZW50QnVzLnRyaWdnZXIoJ3VpOnNob3dIb21lJylcbiAgfSlcblxuICBFdmVudEJ1cy5vbignYXBpOmxvZ2luOmVycm9yJywgRXZlbnRCdXMudHJpZ2dlci5iaW5kKEV2ZW50QnVzLCAndWk6c2hvd0Vycm9yJykpXG5cbi8vIFNpZ251cFxuXG4gIEV2ZW50QnVzLm9uKCdhcGk6c2lnbnVwJywgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBBcGkuc2lnbnVwKGRhdGEpXG4gICAgICAudGhlbihFdmVudEJ1cy50cmlnZ2VyLmJpbmQoRXZlbnRCdXMsICdhcGk6c2lnbnVwOnN1Y2Nlc3NmdWwnKSlcbiAgICAgIC5jYXRjaChFdmVudEJ1cy50cmlnZ2VyLmJpbmQoRXZlbnRCdXMsICdhcGk6c2lnbnVwOmVycm9yJykpXG4gICAgICAuZG9uZSgpXG4gIH0pXG5cbiAgRXZlbnRCdXMub24oJ2FwaTpzaWdudXA6c3VjY2Vzc2Z1bCcsIGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgRXZlbnRCdXMudHJpZ2dlcigndWk6c2hvd0hvbWUnKVxuICB9KVxuXG4gIEV2ZW50QnVzLm9uKCdhcGk6c2lnbnVwOmVycm9yJywgRXZlbnRCdXMudHJpZ2dlci5iaW5kKEV2ZW50QnVzLCAndWk6c2hvd0Vycm9yJykpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gQXBpXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vanMvcHJlc2VudGVycy9hcGkuanMiLCJcbnZhciBQcmVzZW50ZXJzID0ge31cblxudmFyIFVpID0gcmVxdWlyZSgnLi91aScpXG52YXIgUm91dGVyID0gcmVxdWlyZSgnLi9yb3V0ZXInKVxudmFyIExvZ2luID0gcmVxdWlyZSgnLi9sb2dpbicpXG52YXIgQXBpID0gcmVxdWlyZSgnLi9hcGknKVxuXG5QcmVzZW50ZXJzLmluaXQgPSBmdW5jdGlvbigpIHtcbiAgVWkuaW5pdCgpXG4gIExvZ2luLmluaXQoKVxuICBBcGkuaW5pdCgpXG4gIFJvdXRlci5pbml0KClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBQcmVzZW50ZXJzXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vanMvcHJlc2VudGVycy9pbmRleC5qcyIsInZhciBFdmVudEJ1cyA9IHJlcXVpcmUoJy4uL2V2ZW50QnVzJylcblxuXG52YXIgTG9naW4gPSB7fVxuXG5Mb2dpbi5pbml0ID0gZnVuY3Rpb24gKCkge1xuXG4gIEV2ZW50QnVzLm9uKCd2aWV3OmxvZ2luOnJlcXVlc3QnLCBFdmVudEJ1cy50cmlnZ2VyLmJpbmQoRXZlbnRCdXMsICdhcGk6bG9naW4nKSk7XG5cbiAgRXZlbnRCdXMub24oJ3ZpZXc6c2lnbnVwOnJlcXVlc3QnLCBFdmVudEJ1cy50cmlnZ2VyLmJpbmQoRXZlbnRCdXMsICdhcGk6c2lnbnVwJykpO1xuXG59XG5cbm1vZHVsZS5leHBvcnRzID0gTG9naW5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9qcy9wcmVzZW50ZXJzL2xvZ2luLmpzIiwidmFyIEV2ZW50QnVzID0gcmVxdWlyZSgnLi4vZXZlbnRCdXMnKVxudmFyIGxvY2FsU3RvcmFnZSA9IHJlcXVpcmUoJy4uL2xvY2FsU3RvcmFnZScpXG5cbnZhciBSb3V0ZXIgPSB7fVxuXG5Sb3V0ZXIuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIEFwcFJvdXRlciA9IEJhY2tib25lLlJvdXRlci5leHRlbmQoe1xuICAgIHJvdXRlczoge1xuICAgICAgLy8gRGVmaW5lIHNvbWUgVVJMIHJvdXRlc1xuICAgICAgJyc6ICdob21lJyxcbiAgICAgICdzaWdudXAnOiAnc2lnbnVwJyxcbiAgICAgICdsb2dpbic6ICdob21lJyxcbiAgICAgICdvcmRlcnMnOiAnc2hvd09yZGVycycsXG5cbiAgICAgIC8vIERlZmF1bHRcbiAgICAgICcqYWN0aW9ucyc6ICdkZWZhdWx0QWN0aW9uJ1xuICAgIH0sXG5cbiAgICBob21lOiBmdW5jdGlvbiAoKSB7XG4gICAgICBFdmVudEJ1cy50cmlnZ2VyKCd1aTpzaG93SG9tZScpXG4gICAgfSxcblxuICAgIHNpZ251cDogZnVuY3Rpb24gKCkge1xuICAgICAgRXZlbnRCdXMudHJpZ2dlcigndWk6c3dpdGNoOnNpZ251cCcpXG4gICAgfSxcblxuICAgIHNob3dPcmRlcnM6IGZ1bmN0aW9uICgpIHtcbiAgICAgIEV2ZW50QnVzLnRyaWdnZXIoJ3VpOnN3aXRjaDpvcmRlcnMnKVxuICAgIH1cbiAgfSlcblxuICBuZXcgQXBwUm91dGVyKClcblxuICBCYWNrYm9uZS5oaXN0b3J5LnN0YXJ0KClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSb3V0ZXJcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9qcy9wcmVzZW50ZXJzL3JvdXRlci5qcyIsInZhciBFdmVudEJ1cyA9IHJlcXVpcmUoJy4uL2V2ZW50QnVzJylcbnZhciBsb2NhbFN0b3JhZ2UgPSByZXF1aXJlKCcuLi9sb2NhbFN0b3JhZ2UnKVxudmFyIENvbGxlY3Rpb25PcmRlciA9IHJlcXVpcmUoXCIuLi9jb2xsZWN0aW9ucy9jX29yZGVyc1wiKVxudmFyIFVzZXJMb2dpbiA9IHJlcXVpcmUoXCIuLi92aWV3cy91c2VyL3ZfbG9naW5cIilcbnZhciBVc2VyU2lnbnVwID0gcmVxdWlyZShcIi4uL3ZpZXdzL3VzZXIvdl9zaWdudXBcIilcbnZhciBIZWFkZXJWaWV3ID0gcmVxdWlyZShcIi4uL3ZpZXdzL2hlYWRlclwiKVxudmFyIE9yZGVyc1ZpZXcgPSByZXF1aXJlKFwiLi4vdmlld3Mvb3JkZXIvdmxfb3JkZXJzXCIpXG5cbnZhciBVaSA9IHt9XG5cbi8vIFZpZXdzIHRoYXQgY2FuIGJlIHJlbmRlcmVkIGF0ICNjb250ZW50XG52YXIgbG9naW5WaWV3ID0gbmV3IFVzZXJMb2dpbih7ZXZlbnRCdXM6IEV2ZW50QnVzfSlcbnZhciBzaWdudXBWaWV3ID0gbmV3IFVzZXJTaWdudXAoe2V2ZW50QnVzOiBFdmVudEJ1c30pXG5cbnZhciBvcmRlckxpc3QgPSBuZXcgQ29sbGVjdGlvbk9yZGVyKHtldmVudEJ1czogRXZlbnRCdXN9KVxudmFyIG9yZGVyc1ZpZXcgPSBuZXcgT3JkZXJzVmlldyh7Y29sbGVjdGlvbjogb3JkZXJMaXN0LCBldmVudEJ1czogRXZlbnRCdXN9KVxuXG52YXIgJGNvbnRlbnQgPSAkKCcjY29udGVudCcpXG5cbnZhciBoZWFkZXJWaWV3ID0gbmV3IEhlYWRlclZpZXcoe2VsOiAnI2hlYWRlcicsIGV2ZW50QnVzOiBFdmVudEJ1c30pXG5cblVpLnN3aXRjaENvbnRlbnQgPSBmdW5jdGlvbiAod2lkZ2V0KSB7XG5cbiAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpXG4gIGFyZ3Muc2hpZnQoKVxuICBzd2l0Y2ggKHdpZGdldCkge1xuICAgIGNhc2UgJ2xvZ2luJzoge1xuICAgICAgJGNvbnRlbnQuaHRtbChsb2dpblZpZXcucmVuZGVyLmFwcGx5KGxvZ2luVmlldywgYXJncykuZWwpXG4gICAgICBsb2dpblZpZXcuZGVsZWdhdGVFdmVudHMoKVxuICAgICAgYnJlYWtcbiAgICB9XG4gICAgY2FzZSAnc2lnbnVwJzoge1xuICAgICAgJGNvbnRlbnQuaHRtbChzaWdudXBWaWV3LnJlbmRlci5hcHBseShzaWdudXBWaWV3LCBhcmdzKS5lbClcbiAgICAgIHNpZ251cFZpZXcuZGVsZWdhdGVFdmVudHMoKVxuICAgICAgYnJlYWtcbiAgICB9XG4gICAgY2FzZSAnb3JkZXJzJzoge1xuICAgICAgb3JkZXJMaXN0LmZldGNoKHtcbiAgICAgICAgc3VjY2VzczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICRjb250ZW50Lmh0bWwob3JkZXJzVmlldy5yZW5kZXIuYXBwbHkob3JkZXJzVmlldywgYXJncykuZWwpXG4gICAgICAgICAgb3JkZXJzVmlldy5kZWxlZ2F0ZUV2ZW50cygpXG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yOiBVaS5lcnJvclxuICAgICAgfSk7XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxufVxuXG5VaS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICBoZWFkZXJWaWV3LnNldFVzZXJEYXRhKGxvY2FsU3RvcmFnZS5nZXRJdGVtKCd1c2VyJykpXG4gIFVpLnNob3dIb21lKCk7XG59XG5cblVpLnNob3dIb21lID0gZnVuY3Rpb24gKCkge1xuICBpZiAobG9jYWxTdG9yYWdlLmhhc0l0ZW0oJ3VzZXInKSkge1xuICAgIFVpLnN3aXRjaENvbnRlbnQoJ29yZGVycycpXG4gIH0gZWxzZSB7XG4gICAgVWkuc3dpdGNoQ29udGVudCgnbG9naW4nKVxuICB9XG59XG5cblVpLnNob3dTaWdudXAgPSBmdW5jdGlvbiAoKSB7XG4gIFVpLnN3aXRjaENvbnRlbnQoJ3NpZ251cCcpXG59XG5cblVpLnNob3dPcmRlcnMgPSBmdW5jdGlvbiAoKSB7XG4gIG9yZGVyTGlzdC5mZXRjaCh7XG4gICAgc3VjY2VzczogVWkuc3dpdGNoQ29udGVudC5iaW5kKFVpLCAnb3JkZXJzJyksXG4gICAgZXJyb3I6IFVpLmVycm9yXG4gIH0pO1xufVxuXG4vLyBUaGlzIGFsd2F5cyByZWNlaXZlIGEgSlNPTiBvYmplY3Qgd2l0aCBhIHN0YW5kYXJkIEFQSSBlcnJvclxuVWkuZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gIGlmIChlcnIubWVzc2FnZSlcbiAgICBhbGVydChcIkVycm9yOiBcIiArIGVyci5tZXNzYWdlKVxuICBlbHNlIGlmIChlcnIucmVzcG9uc2VKU09OKSB7XG4gICAgaWYgKGVyci5yZXNwb25zZUpTT04ubWVzc2FnZSlcbiAgICAgIGFsZXJ0KFwiRXJyb3I6IFwiICsgZXJyLnJlc3BvbnNlSlNPTi5tZXNzYWdlKVxuICAgIGVsc2UgaWYgKGVyci5yZXNwb25zZUpTT04uZXJyb3IpXG4gICAgICBhbGVydChcIkVycm9yOiBcIiArIGVyci5yZXNwb25zZUpTT04uZXJyb3IubWVzc2FnZSlcbiAgfVxufVxuXG5FdmVudEJ1cy5vbigndWk6c2hvd0hvbWUnLCBVaS5zaG93SG9tZSlcbkV2ZW50QnVzLm9uKCd1aTpzaG93RXJyb3InLCBVaS5lcnJvcilcbkV2ZW50QnVzLm9uKCd1aTpzd2l0Y2g6c2lnbnVwJywgVWkuc2hvd1NpZ251cClcbkV2ZW50QnVzLm9uKCd1aTpzd2l0Y2g6b3JkZXJzJywgVWkuc2hvd09yZGVycylcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFVpXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vanMvcHJlc2VudGVycy91aS5qcyIsInZhciB0X2hlYWRlciA9IHJlcXVpcmUoXCJyYXctbG9hZGVyIS4uLy4uL3RlbXBsYXRlcy9oZWFkZXIuaHRtbFwiKTtcblxudmFyIHVzZXJEYXRhID0ge31cblxudmFyIEhlYWRlciA9IEJhY2tib25lLlZpZXcuZXh0ZW5kKHtcblxuICBpbml0aWFsaXplOiBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgdGhpcy50ZW1wbGF0ZSA9IF8udGVtcGxhdGUodF9oZWFkZXIpXG4gICAgcGFyYW1zLmV2ZW50QnVzLm9uKCdsb2NhbHN0b3JhZ2U6c2V0OnVzZXInLCB0aGlzLnNldFVzZXJEYXRhLmJpbmQodGhpcykpXG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy4kZWwuaHRtbCh0aGlzLnRlbXBsYXRlKHt1c2VyOiB1c2VyRGF0YX0pKVxuICAgIHJldHVybiB0aGlzXG4gIH0sXG5cbiAgc2V0VXNlckRhdGE6IGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgdXNlckRhdGEgPSB1c2VyXG4gICAgdGhpcy5yZW5kZXIoKVxuICB9XG5cbn0pXG5cbm1vZHVsZS5leHBvcnRzID0gSGVhZGVyXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vanMvdmlld3MvaGVhZGVyLmpzIiwidmFyIHRsX29yZGVyID0gcmVxdWlyZShcInJhdy1sb2FkZXIhLi4vLi4vLi4vdGVtcGxhdGVzL29yZGVyL3RsX29yZGVyLmh0bWxcIilcblxudmFyIE9yZGVyTGlzdFZpZXcgPSBCYWNrYm9uZS5WaWV3LmV4dGVuZCh7XG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oZXZlbnRCdXMpIHtcbiAgICB0aGlzLmV2ZW50QnVzID0gZXZlbnRCdXM7XG4gICAgdGhpcy50ZW1wbGF0ZSA9IF8udGVtcGxhdGUodGxfb3JkZXIpO1xuICB9LFxuXG4gIGNsYXNzTmFtZTogJ2NvbnRhaW5lcicsXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy4kZWwuaHRtbCh0aGlzLnRlbXBsYXRlKHtvcmRlcnM6IHRoaXMuY29sbGVjdGlvbn0pKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gT3JkZXJMaXN0Vmlld1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vanMvdmlld3Mvb3JkZXIvdmxfb3JkZXJzLmpzIiwidmFyIHRfbG9naW4gPSByZXF1aXJlKFwicmF3LWxvYWRlciEuLi8uLi8uLi90ZW1wbGF0ZXMvdXNlci9sb2dpbi5odG1sXCIpXG5cblxudmFyIFVzZXJMb2dpbiA9IEJhY2tib25lLlZpZXcuZXh0ZW5kKHtcblxuICBpbml0aWFsaXplOiBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICB0aGlzLmV2ZW50QnVzID0gcGFyYW1zLmV2ZW50QnVzO1xuICB9LFxuXG4gIHRlbXBsYXRlOiBfLnRlbXBsYXRlKHRfbG9naW4pLFxuXG4gIGNsYXNzTmFtZTogJ2NvbnRhaW5lcicsXG5cbiAgZXZlbnRzOiB7XG4gICAgJ2NsaWNrICNidG4tbG9naW4nOiAnc3VibWl0J1xuICB9LFxuXG4gIHN1Ym1pdDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZXZlbnRCdXMudHJpZ2dlcigndmlldzpsb2dpbjpyZXF1ZXN0JywgdGhpcy4kKCcjbG9naW4tdXNlcm5hbWUnKS52YWwoKSwgdGhpcy4kKCcjbG9naW4tcGFzc3dvcmQnKS52YWwoKSlcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLiRlbC5odG1sKHRoaXMudGVtcGxhdGUoKSlcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbn0pXG5cbm1vZHVsZS5leHBvcnRzID0gVXNlckxvZ2luXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vanMvdmlld3MvdXNlci92X2xvZ2luLmpzIiwidmFyIHRfc2lnbnVwID0gcmVxdWlyZShcInJhdy1sb2FkZXIhLi4vLi4vLi4vdGVtcGxhdGVzL3VzZXIvc2lnbnVwLmh0bWxcIilcblxuXG52YXIgVXNlclNpZ251cCA9IEJhY2tib25lLlZpZXcuZXh0ZW5kKHtcblxuICBjbGFzc05hbWU6ICdjb250YWluZXInLFxuXG4gIHRlbXBsYXRlOiBfLnRlbXBsYXRlKHRfc2lnbnVwKSxcblxuICBpbml0aWFsaXplOiBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICB0aGlzLmV2ZW50QnVzID0gcGFyYW1zLmV2ZW50QnVzO1xuICB9LFxuXG4gIGV2ZW50czoge1xuICAgICdjbGljayAjYnRuLXNpZ251cCc6ICdzdWJtaXQnXG4gIH0sXG5cbiAgc3VibWl0OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRhdGEgPSB7XG4gICAgICB1c2VybmFtZTogdGhpcy4kKCdbbmFtZT11c2VybmFtZV0nKS52YWwoKSxcbiAgICAgIGVtYWlsOiB0aGlzLiQoJ1tuYW1lPWVtYWlsXScpLnZhbCgpLFxuICAgICAgcGFzc3dvcmQ6IHRoaXMuJCgnW25hbWU9cGFzc3dkXScpLnZhbCgpXG4gICAgfVxuICAgIHRoaXMuZXZlbnRCdXMudHJpZ2dlcigndmlldzpzaWdudXA6cmVxdWVzdCcsIGRhdGEpXG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy4kZWwuaHRtbCh0aGlzLnRlbXBsYXRlKCkpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxufSlcblxubW9kdWxlLmV4cG9ydHMgPSBVc2VyU2lnbnVwXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vanMvdmlld3MvdXNlci92X3NpZ251cC5qcyIsInZhciBnO1xyXG5cclxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcclxuZyA9IChmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcztcclxufSkoKTtcclxuXHJcbnRyeSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXHJcblx0ZyA9IGcgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpIHx8ICgxLGV2YWwpKFwidGhpc1wiKTtcclxufSBjYXRjaChlKSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcclxuXHRpZih0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKVxyXG5cdFx0ZyA9IHdpbmRvdztcclxufVxyXG5cclxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxyXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xyXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGc7XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAod2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanMiLCJtb2R1bGUuZXhwb3J0cyA9IFwiPGRpdiBjbGFzcz1cXFwibmF2YmFyLWhlYWRlclxcXCI+XFxuICAgIDxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwibmF2YmFyLXRvZ2dsZVxcXCIgZGF0YS10b2dnbGU9XFxcImNvbGxhcHNlXFxcIiBkYXRhLXRhcmdldD1cXFwiLm5hdmJhci1jb2xsYXBzZVxcXCI+XFxuICAgICAgICA8c3BhbiBjbGFzcz1cXFwic3Itb25seVxcXCI+VG9nZ2xlIG5hdmlnYXRpb248L3NwYW4+XFxuICAgICAgICA8c3BhbiBjbGFzcz1cXFwiaWNvbi1iYXJcXFwiPjwvc3Bhbj5cXG4gICAgICAgIDxzcGFuIGNsYXNzPVxcXCJpY29uLWJhclxcXCI+PC9zcGFuPlxcbiAgICAgICAgPHNwYW4gY2xhc3M9XFxcImljb24tYmFyXFxcIj48L3NwYW4+XFxuICAgIDwvYnV0dG9uPlxcbjwvZGl2PlxcbjxkaXYgY2xhc3M9XFxcIm5hdmJhci1jb2xsYXBzZSBjb2xsYXBzZVxcXCI+XFxuICAgIDx1bCBjbGFzcz1cXFwibmF2IG5hdmJhci1uYXZcXFwiPlxcbiAgICAgICAgPGxpIGNsYXNzPVxcXCJhY3RpdmVcXFwiPjxhIGhyZWY9XFxcIiNcXFwiPkhvbWU8L2E+PC9saT5cXG4gICAgICAgIDwlIGlmICh1c2VyICYmIHVzZXIudXNlcm5hbWUpIHsgJT5cXG4gICAgICAgIDxsaT48YSBocmVmPVxcXCIjb3JkZXJzXFxcIj5PcmRlcnM8L2E+PC9saT5cXG4gICAgICAgIDwlIH0gJT5cXG4gICAgPC91bD5cXG4gICAgPHVsIGNsYXNzPVxcXCJuYXYgbmF2YmFyLW5hdiBuYXZiYXItcmlnaHRcXFwiPlxcbiAgICAgICAgPCUgaWYgKHVzZXIgJiYgdXNlci51c2VybmFtZSkgeyAlPlxcbiAgICAgICAgPGxpPjxhIGhyZWY9JyNwcm9maWxlJz48JT0gdXNlci51c2VybmFtZSAlPjwvYT48L2xpPlxcbiAgICAgICAgPCUgfSAlPlxcbiAgICA8L3VsPlxcbjwvZGl2PlwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Jhdy1sb2FkZXIhLi90ZW1wbGF0ZXMvaGVhZGVyLmh0bWxcbi8vIG1vZHVsZSBpZCA9IDE4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gXCI8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJjb2wtbWQtNlxcXCI+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJwYW5lbCBwYW5lbC1wcmltYXJ5XFxcIj5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJwYW5lbC1oZWFkaW5nXFxcIj5cXG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcImdseXBoaWNvbiBnbHlwaGljb24tbGlzdFxcXCI+PC9zcGFuPlNvcnRhYmxlIExpc3RzXFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInB1bGwtcmlnaHQgYWN0aW9uLWJ1dHRvbnNcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiYnRuLWdyb3VwIHB1bGwtcmlnaHRcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1kZWZhdWx0IGJ0bi14cyBkcm9wZG93bi10b2dnbGVcXFwiIGRhdGEtdG9nZ2xlPVxcXCJkcm9wZG93blxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJnbHlwaGljb24gZ2x5cGhpY29uLWNvZ1xcXCIgc3R5bGU9XFxcIm1hcmdpbi1yaWdodDogMHB4O1xcXCI+PC9zcGFuPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDx1bCBjbGFzcz1cXFwiZHJvcGRvd24tbWVudSBzbGlkZWRvd25cXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGk+PGEgaHJlZj1cXFwiaHR0cDovL3d3dy5qcXVlcnkyZG90bmV0LmNvbVxcXCI+PHNwYW4gY2xhc3M9XFxcImdseXBoaWNvbiBnbHlwaGljb24tcGVuY2lsXFxcIj48L3NwYW4+RWRpdDwvYT5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9saT5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxpPjxhIGhyZWY9XFxcImh0dHA6Ly93d3cuanF1ZXJ5MmRvdG5ldC5jb21cXFwiPjxzcGFuIGNsYXNzPVxcXCJnbHlwaGljb24gZ2x5cGhpY29uLXRyYXNoXFxcIj48L3NwYW4+RGVsZXRlPC9hPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2xpPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGk+PGEgaHJlZj1cXFwiaHR0cDovL3d3dy5qcXVlcnkyZG90bmV0LmNvbVxcXCI+PHNwYW4gY2xhc3M9XFxcImdseXBoaWNvbiBnbHlwaGljb24tZmxhZ1xcXCI+PC9zcGFuPkZsYWc8L2E+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvbGk+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPC91bD5cXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJwYW5lbC1ib2R5XFxcIj5cXG4gICAgICAgICAgICAgICAgPHVsIGNsYXNzPVxcXCJsaXN0LWdyb3VwXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgIDwlIG9yZGVycy5lYWNoKGZ1bmN0aW9uKG8pIHsgJT5cXG4gICAgICAgICAgICAgICAgICAgIDxsaSBjbGFzcz1cXFwibGlzdC1ncm91cC1pdGVtXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8c3Bhbj5JZDogPCU9IG8uZ2V0KCdpZCcpICU+LCBkZXNjcmlwdGlvbjogPCU9IG8uZ2V0KCdkZXNjcmlwdGlvbicpICU+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9zcGFuPlxcbiAgICAgICAgICAgICAgICAgICAgPC9saT5cXG4gICAgICAgICAgICAgICAgICAgIDwlIH0pOyAlPlxcbiAgICAgICAgICAgICAgICA8L3VsPlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInBhbmVsLWZvb3RlclxcXCI+XFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInJvd1xcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wtbWQtNlxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGg2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBUb3RhbCBDb3VudCA8c3BhbiBjbGFzcz1cXFwibGFiZWwgbGFiZWwtaW5mb1xcXCI+PCU9IG9yZGVycy5sZW5ndGggJT48L3NwYW4+PC9oNj5cXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG48L2Rpdj5cXG5cIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yYXctbG9hZGVyIS4vdGVtcGxhdGVzL29yZGVyL3RsX29yZGVyLmh0bWxcbi8vIG1vZHVsZSBpZCA9IDE5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gXCIgICAgPGRpdiBpZD1cXFwibG9naW5ib3hcXFwiIHN0eWxlPVxcXCJtYXJnaW4tdG9wOjUwcHg7XFxcIiBjbGFzcz1cXFwibWFpbmJveCBjb2wtbWQtNiBjb2wtbWQtb2Zmc2V0LTMgY29sLXNtLTggY29sLXNtLW9mZnNldC0yXFxcIj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInBhbmVsIHBhbmVsLWluZm9cXFwiID5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJwYW5lbC1oZWFkaW5nXFxcIj5cXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwicGFuZWwtdGl0bGVcXFwiPlNpZ24gSW48L2Rpdj5cXG4gICAgICAgICAgICAgICAgPGRpdiBzdHlsZT1cXFwiZmxvYXQ6cmlnaHQ7IGZvbnQtc2l6ZTogODAlOyBwb3NpdGlvbjogcmVsYXRpdmU7IHRvcDotMTBweFxcXCI+PGEgaHJlZj1cXFwiI1xcXCI+Rm9yZ290IHBhc3N3b3JkPzwvYT48L2Rpdj5cXG4gICAgICAgICAgICA8L2Rpdj5cXG5cXG4gICAgICAgICAgICA8ZGl2IHN0eWxlPVxcXCJwYWRkaW5nLXRvcDozMHB4XFxcIiBjbGFzcz1cXFwicGFuZWwtYm9keVxcXCIgPlxcblxcbiAgICAgICAgICAgICAgICA8ZGl2IHN0eWxlPVxcXCJkaXNwbGF5Om5vbmVcXFwiIGlkPVxcXCJsb2dpbi1hbGVydFxcXCIgY2xhc3M9XFxcImFsZXJ0IGFsZXJ0LWRhbmdlciBjb2wtc20tMTJcXFwiPjwvZGl2PlxcblxcbiAgICAgICAgICAgICAgICA8ZGl2IGlkPVxcXCJsb2dpbmZvcm1cXFwiIGNsYXNzPVxcXCJmb3JtLWhvcml6b250YWxcXFwiIHJvbGU9XFxcImZvcm1cXFwiPlxcblxcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBzdHlsZT1cXFwibWFyZ2luLWJvdHRvbTogMjVweFxcXCIgY2xhc3M9XFxcImlucHV0LWdyb3VwXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwiaW5wdXQtZ3JvdXAtYWRkb25cXFwiPjxpIGNsYXNzPVxcXCJnbHlwaGljb24gZ2x5cGhpY29uLXVzZXJcXFwiPjwvaT48L3NwYW4+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0IGlkPVxcXCJsb2dpbi11c2VybmFtZVxcXCIgdHlwZT1cXFwidGV4dFxcXCIgY2xhc3M9XFxcImZvcm0tY29udHJvbFxcXCIgbmFtZT1cXFwidXNlcm5hbWVcXFwiIHZhbHVlPVxcXCJcXFwiIHBsYWNlaG9sZGVyPVxcXCJ1c2VybmFtZSBvciBlbWFpbFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG5cXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgc3R5bGU9XFxcIm1hcmdpbi1ib3R0b206IDI1cHhcXFwiIGNsYXNzPVxcXCJpbnB1dC1ncm91cFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcImlucHV0LWdyb3VwLWFkZG9uXFxcIj48aSBjbGFzcz1cXFwiZ2x5cGhpY29uIGdseXBoaWNvbi1sb2NrXFxcIj48L2k+PC9zcGFuPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCBpZD1cXFwibG9naW4tcGFzc3dvcmRcXFwiIHR5cGU9XFxcInBhc3N3b3JkXFxcIiBjbGFzcz1cXFwiZm9ybS1jb250cm9sXFxcIiBuYW1lPVxcXCJwYXNzd29yZFxcXCIgcGxhY2Vob2xkZXI9XFxcInBhc3N3b3JkXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcblxcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiaW5wdXQtZ3JvdXBcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNoZWNrYm94XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxhYmVsPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0IGlkPVxcXCJsb2dpbi1yZW1lbWJlclxcXCIgdHlwZT1cXFwiY2hlY2tib3hcXFwiIG5hbWU9XFxcInJlbWVtYmVyXFxcIiB2YWx1ZT1cXFwiMVxcXCI+IFJlbWVtYmVyIG1lXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvbGFiZWw+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG5cXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgc3R5bGU9XFxcIm1hcmdpbi10b3A6MTBweFxcXCIgY2xhc3M9XFxcImZvcm0tZ3JvdXBcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwhLS0gQnV0dG9uIC0tPlxcblxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbC1zbS0xMiBjb250cm9sc1xcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gaWQ9XFxcImJ0bi1sb2dpblxcXCIgY2xhc3M9XFxcImJ0biBidG4tc3VjY2Vzc1xcXCI+TG9naW4gIDwvYnV0dG9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGlkPVxcXCJidG4tZmJsb2dpblxcXCIgY2xhc3M9XFxcImJ0biBidG4tcHJpbWFyeVxcXCI+TG9naW4gd2l0aCBGYWNlYm9vazwvYnV0dG9uPlxcblxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuXFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJmb3JtLWdyb3VwXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wtbWQtMTIgY29udHJvbFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgc3R5bGU9XFxcImJvcmRlci10b3A6IDFweCBzb2xpZCM4ODg7IHBhZGRpbmctdG9wOjE1cHg7IGZvbnQtc2l6ZTo4NSVcXFwiID5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERvbid0IGhhdmUgYW4gYWNjb3VudCFcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxhIGhyZWY9XFxcIiNzaWdudXBcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNpZ24gVXAgSGVyZVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9hPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICA8L2Rpdj5cXG5cXG5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG5cIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yYXctbG9hZGVyIS4vdGVtcGxhdGVzL3VzZXIvbG9naW4uaHRtbFxuLy8gbW9kdWxlIGlkID0gMjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxkaXYgaWQ9XFxcInNpZ251cGJveFxcXCIgbWFyZ2luLXRvcDo1MHB4XFxcIlxcbiAgICAgY2xhc3M9XFxcIm1haW5ib3ggY29sLW1kLTYgY29sLW1kLW9mZnNldC0zIGNvbC1zbS04IGNvbC1zbS1vZmZzZXQtMlxcXCI+XFxuICAgIDxkaXYgY2xhc3M9XFxcInBhbmVsIHBhbmVsLWluZm9cXFwiPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwicGFuZWwtaGVhZGluZ1xcXCI+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwicGFuZWwtdGl0bGVcXFwiPlNpZ24gVXA8L2Rpdj5cXG4gICAgICAgICAgICA8ZGl2IHN0eWxlPVxcXCJmbG9hdDpyaWdodDsgZm9udC1zaXplOiA4NSU7IHBvc2l0aW9uOiByZWxhdGl2ZTsgdG9wOi0xMHB4XFxcIj48YSBpZD1cXFwic2lnbmlubGlua1xcXCIgaHJlZj1cXFwiI2xvZ2luXFxcIj5TaWduXFxuICAgICAgICAgICAgICAgIEluPC9hPjwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJwYW5lbC1ib2R5XFxcIj5cXG4gICAgICAgICAgICA8ZGl2IGlkPVxcXCJzaWdudXBmb3JtXFxcIiBjbGFzcz1cXFwiZm9ybS1ob3Jpem9udGFsXFxcIiByb2xlPVxcXCJmb3JtXFxcIj5cXG5cXG4gICAgICAgICAgICAgICAgPGRpdiBpZD1cXFwic2lnbnVwYWxlcnRcXFwiIHN0eWxlPVxcXCJkaXNwbGF5Om5vbmVcXFwiIGNsYXNzPVxcXCJhbGVydCBhbGVydC1kYW5nZXJcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgPHA+RXJyb3I6PC9wPlxcbiAgICAgICAgICAgICAgICAgICAgPHNwYW4+PC9zcGFuPlxcbiAgICAgICAgICAgICAgICA8L2Rpdj5cXG5cXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiZm9ybS1ncm91cFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8bGFiZWwgZm9yPVxcXCJ1c2VybmFtZVxcXCIgY2xhc3M9XFxcImNvbC1tZC0zIGNvbnRyb2wtbGFiZWxcXFwiPlVzZXJuYW1lPC9sYWJlbD5cXG5cXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbC1tZC05XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cXFwidGV4dFxcXCIgY2xhc3M9XFxcImZvcm0tY29udHJvbFxcXCIgbmFtZT1cXFwidXNlcm5hbWVcXFwiIHBsYWNlaG9sZGVyPVxcXCJGaXJzdCBOYW1lXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICA8L2Rpdj5cXG5cXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiZm9ybS1ncm91cFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8bGFiZWwgZm9yPVxcXCJlbWFpbFxcXCIgY2xhc3M9XFxcImNvbC1tZC0zIGNvbnRyb2wtbGFiZWxcXFwiPkVtYWlsPC9sYWJlbD5cXG5cXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbC1tZC05XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cXFwidGV4dFxcXCIgY2xhc3M9XFxcImZvcm0tY29udHJvbFxcXCIgbmFtZT1cXFwiZW1haWxcXFwiIHBsYWNlaG9sZGVyPVxcXCJFbWFpbCBBZGRyZXNzXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICA8L2Rpdj5cXG5cXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiZm9ybS1ncm91cFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8bGFiZWwgZm9yPVxcXCJwYXNzd29yZFxcXCIgY2xhc3M9XFxcImNvbC1tZC0zIGNvbnRyb2wtbGFiZWxcXFwiPlBhc3N3b3JkPC9sYWJlbD5cXG5cXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbC1tZC05XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cXFwicGFzc3dvcmRcXFwiIGNsYXNzPVxcXCJmb3JtLWNvbnRyb2xcXFwiIG5hbWU9XFxcInBhc3N3ZFxcXCIgcGxhY2Vob2xkZXI9XFxcIlBhc3N3b3JkXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICA8L2Rpdj5cXG5cXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiZm9ybS1ncm91cFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8IS0tIEJ1dHRvbiAtLT5cXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbC1tZC1vZmZzZXQtMyBjb2wtbWQtOVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBpZD1cXFwiYnRuLXNpZ251cFxcXCIgdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1pbmZvXFxcIj48aSBjbGFzcz1cXFwiaWNvbi1oYW5kLXJpZ2h0XFxcIj48L2k+ICZuYnNwXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNpZ24gVXBcXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBzdHlsZT1cXFwibWFyZ2luLWxlZnQ6OHB4O1xcXCI+b3I8L3NwYW4+XFxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgPC9kaXY+XFxuXFxuICAgICAgICAgICAgICAgIDxkaXYgc3R5bGU9XFxcImJvcmRlci10b3A6IDFweCBzb2xpZCAjOTk5OyBwYWRkaW5nLXRvcDoyMHB4XFxcIiBjbGFzcz1cXFwiZm9ybS1ncm91cFxcXCI+XFxuXFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wtbWQtb2Zmc2V0LTMgY29sLW1kLTlcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gaWQ9XFxcImJ0bi1mYnNpZ251cFxcXCIgdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1wcmltYXJ5XFxcIj48aSBjbGFzcz1cXFwiaWNvbi1mYWNlYm9va1xcXCI+PC9pPiDCoFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBTaWduIFVwIHdpdGggRmFjZWJvb2tcXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj5cXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcblxcbiAgICAgICAgICAgICAgICA8L2Rpdj5cXG5cXG5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG5cXG5cXG48L2Rpdj5cXG5cIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yYXctbG9hZGVyIS4vdGVtcGxhdGVzL3VzZXIvc2lnbnVwLmh0bWxcbi8vIG1vZHVsZSBpZCA9IDIxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBsb2NhbFN0b3JhZ2UgPSByZXF1aXJlKCcuL2xvY2FsU3RvcmFnZScpXG52YXIgQXBwID0gcmVxdWlyZSgnLi9hcHAnKVxuXG4vLyBXQVJOSU5HOiB0aGlzIGRlbGV0ZXMgYW55IHByZXZpb3VzbHkgdXNlclxuLy8gVEhJUyBTSE9VTEQgTk9UIEdPIElOVE8gUFJPRFVDVElPTlxubG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ3VzZXInKVxuXG5BcHAuaW5pdCgpXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vanMvbWFpbi5qcyJdLCJzb3VyY2VSb290IjoiIn0=